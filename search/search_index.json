{"config":{"lang":["en","ja"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Wandas Documentation","text":"<p>Welcome to the Wandas documentation.</p> <ul> <li>English Documentation</li> <li>\u65e5\u672c\u8a9e\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8</li> </ul>"},{"location":"frame_dataset_spec/","title":"FrameDataset\u306e\u4ed5\u69d8","text":""},{"location":"frame_dataset_spec/#_1","title":"\u6982\u8981","text":"<p><code>FrameDataset</code>\u306f\u3001\u30d5\u30a9\u30eb\u30c0\u5185\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u52b9\u7387\u7684\u306b\u51e6\u7406\u3059\u308b\u305f\u3081\u306e\u62bd\u8c61\u57fa\u5e95\u30af\u30e9\u30b9\u3067\u3059\u3002\u4e3b\u306a\u7279\u5fb4\u3068\u3057\u3066\u4ee5\u4e0b\u306e\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\uff1a</p> <ul> <li>\u9045\u5ef6\u30ed\u30fc\u30c9: \u5927\u898f\u6a21\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3067\u3082\u52b9\u7387\u7684\u306b\u6271\u3048\u308b\u3088\u3046\u3001\u5fc5\u8981\u306b\u306a\u3063\u305f\u6642\u70b9\u3067\u30c7\u30fc\u30bf\u3092\u30ed\u30fc\u30c9\u3057\u307e\u3059</li> <li>\u5909\u63db\u30c1\u30a7\u30fc\u30f3: \u30c7\u30fc\u30bf\u306b\u5bfe\u3059\u308b\u5909\u63db\u3092\u9023\u9396\u7684\u306b\u9069\u7528\u3067\u304d\u307e\u3059</li> <li>\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0: \u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u304b\u3089\u6307\u5b9a\u6570\u307e\u305f\u306f\u5272\u5408\u306e\u30b5\u30f3\u30d7\u30eb\u3092\u53d6\u5f97\u3067\u304d\u307e\u3059</li> <li>\u30d5\u30a1\u30a4\u30eb\u51fa\u529b: \u51e6\u7406\u6e08\u307f\u306e\u30c7\u30fc\u30bf\u3092\u4fdd\u5b58\u3067\u304d\u307e\u3059</li> </ul>"},{"location":"frame_dataset_spec/#_2","title":"\u30af\u30e9\u30b9\u968e\u5c64","text":"<pre><code>FrameDataset[F] (ABC)\n\u251c\u2500\u2500 _SampledFrameDataset[F] (\u5185\u90e8\u30af\u30e9\u30b9)\n\u251c\u2500\u2500 ChannelFrameDataset\n\u2514\u2500\u2500 SpectrogramFrameDataset\n</code></pre>"},{"location":"frame_dataset_spec/#_3","title":"\u30af\u30e9\u30b9\u306e\u8a73\u7d30","text":""},{"location":"frame_dataset_spec/#framedatasetf","title":"FrameDataset[F]","text":"<p>\u62bd\u8c61\u57fa\u5e95\u30af\u30e9\u30b9\u3067\u3001\u30b8\u30a7\u30cd\u30ea\u30c3\u30af\u578b\u30d1\u30e9\u30e1\u30fc\u30bf<code>F</code>\u306f\u6271\u3046\u30d5\u30ec\u30fc\u30e0\u306e\u578b\uff08<code>ChannelFrame</code>\u307e\u305f\u306f<code>SpectrogramFrame</code>\uff09\u3092\u8868\u3057\u307e\u3059\u3002</p>"},{"location":"frame_dataset_spec/#_4","title":"\u4e3b\u306a\u30e1\u30bd\u30c3\u30c9","text":"<ul> <li><code>__init__</code>: \u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u306e\u521d\u671f\u5316</li> <li><code>_discover_files</code>: \u5bfe\u8c61\u3068\u306a\u308b\u30d5\u30a1\u30a4\u30eb\u3092\u691c\u7d22</li> <li><code>_load_all_files</code>: \u3059\u3079\u3066\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u30ed\u30fc\u30c9\uff08\u975e\u9045\u5ef6\u30e2\u30fc\u30c9\uff09</li> <li><code>_load_file</code>: \u5177\u4f53\u7684\u306a\u30d5\u30a1\u30a4\u30eb\u30ed\u30fc\u30c9\u51e6\u7406\uff08\u62bd\u8c61\u30e1\u30bd\u30c3\u30c9\u3001\u30b5\u30d6\u30af\u30e9\u30b9\u3067\u5b9f\u88c5\uff09</li> <li><code>_ensure_loaded</code>: \u6307\u5b9a\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u30d5\u30ec\u30fc\u30e0\u304c\u30ed\u30fc\u30c9\u3055\u308c\u3066\u3044\u308b\u304b\u78ba\u8a8d\u3057\u3001\u5fc5\u8981\u3067\u3042\u308c\u3070\u30ed\u30fc\u30c9</li> <li><code>__len__</code>: \u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u5185\u306e\u30d5\u30a1\u30a4\u30eb\u6570\u3092\u8fd4\u3059</li> <li><code>__getitem__</code>: \u6307\u5b9a\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u30d5\u30ec\u30fc\u30e0\u3092\u53d6\u5f97</li> <li><code>apply</code>: \u95a2\u6570\u3092\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u5168\u4f53\u306b\u9069\u7528\u3057\u3066\u65b0\u3057\u3044\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3092\u4f5c\u6210</li> <li><code>save</code>: \u51e6\u7406\u6e08\u307f\u30d5\u30ec\u30fc\u30e0\u3092\u30d5\u30a1\u30a4\u30eb\u306b\u4fdd\u5b58</li> <li><code>sample</code>: \u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u304b\u3089\u30b5\u30f3\u30d7\u30eb\u3092\u53d6\u5f97</li> <li><code>get_metadata</code>: \u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u306e\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u53d6\u5f97</li> </ul>"},{"location":"frame_dataset_spec/#_sampledframedatasetf","title":"_SampledFrameDataset[F]","text":"<p><code>FrameDataset</code>\u304b\u3089\u6d3e\u751f\u3057\u305f\u5185\u90e8\u30af\u30e9\u30b9\u3067\u3001\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u3055\u308c\u305f\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3092\u8868\u73fe\u3057\u307e\u3059\u3002\u5143\u306e\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3078\u306e\u53c2\u7167\u3068\u5909\u63db\u30c1\u30a7\u30fc\u30f3\u3092\u4fdd\u6301\u3057\u307e\u3059\u3002</p>"},{"location":"frame_dataset_spec/#_5","title":"\u7279\u5fb4","text":"<ul> <li>\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u3055\u308c\u305f\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u30de\u30c3\u30d7\u3092\u4fdd\u6301</li> <li>\u5909\u63db\u30c1\u30a7\u30fc\u30f3\u3092\u9069\u7528\u3059\u308b\u6d17\u7df4\u3055\u308c\u305f\u5185\u90e8\u5b9f\u88c5</li> <li>\u5143\u306e\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u306e\u69cb\u9020\u3092\u4fdd\u6301\u3057\u3064\u3064\u3001\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u3055\u308c\u305f\u30c7\u30fc\u30bf\u306e\u307f\u3092\u51e6\u7406</li> </ul>"},{"location":"frame_dataset_spec/#channelframedataset","title":"ChannelFrameDataset","text":"<p>\u97f3\u58f0\u30fb\u4fe1\u53f7\u30d5\u30a1\u30a4\u30eb\u3092<code>ChannelFrame</code>\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3068\u3057\u3066\u6271\u3046\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3067\u3059\u3002</p>"},{"location":"frame_dataset_spec/#_6","title":"\u5bfe\u5fdc\u30d5\u30a1\u30a4\u30eb\u5f62\u5f0f","text":"<ul> <li><code>.wav</code></li> <li><code>.mp3</code></li> <li><code>.flac</code></li> <li><code>.csv</code></li> </ul>"},{"location":"frame_dataset_spec/#_7","title":"\u7279\u5fb4\u7684\u306a\u30e1\u30bd\u30c3\u30c9","text":"<ul> <li><code>_load_file</code>: \u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u307e\u305f\u306fCSV\u304b\u3089<code>ChannelFrame</code>\u3092\u4f5c\u6210</li> <li><code>resample</code>: \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u3092\u5909\u66f4</li> <li><code>trim</code>: \u6307\u5b9a\u3057\u305f\u6642\u9593\u7bc4\u56f2\u3067\u30c8\u30ea\u30df\u30f3\u30b0</li> <li><code>normalize</code>: \u97f3\u58f0\u4fe1\u53f7\u3092\u6b63\u898f\u5316</li> <li><code>stft</code>: \u77ed\u6642\u9593\u30d5\u30fc\u30ea\u30a8\u5909\u63db\u3092\u9069\u7528\u3057\u3001<code>SpectrogramFrameDataset</code>\u3092\u4f5c\u6210</li> <li><code>from_folder</code>: \u30d5\u30a1\u30a4\u30eb\u304b\u3089\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3092\u4f5c\u6210\u3059\u308b\u30af\u30e9\u30b9\u30e1\u30bd\u30c3\u30c9</li> </ul>"},{"location":"frame_dataset_spec/#spectrogramframedataset","title":"SpectrogramFrameDataset","text":"<p>\u30b9\u30da\u30af\u30c8\u30ed\u30b0\u30e9\u30e0\u30c7\u30fc\u30bf\u3092<code>SpectrogramFrame</code>\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3068\u3057\u3066\u6271\u3046\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3067\u3059\u3002\u4e3b\u306b<code>ChannelFrameDataset.stft()</code>\u306e\u7d50\u679c\u3068\u3057\u3066\u751f\u6210\u3055\u308c\u308b\u3053\u3068\u3092\u60f3\u5b9a\u3057\u3066\u3044\u307e\u3059\u3002</p>"},{"location":"frame_dataset_spec/#_8","title":"\u7279\u5fb4\u7684\u306a\u30e1\u30bd\u30c3\u30c9","text":"<ul> <li><code>_load_file</code>: \u73fe\u5728\u306f\u76f4\u63a5\u30d5\u30a1\u30a4\u30eb\u304b\u3089\u306e\u30ed\u30fc\u30c9\u3092\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u307e\u305b\u3093</li> <li><code>plot</code>: \u30b9\u30da\u30af\u30c8\u30ed\u30b0\u30e9\u30e0\u3092\u30d7\u30ed\u30c3\u30c8</li> </ul>"},{"location":"frame_dataset_spec/#_9","title":"\u4f7f\u7528\u4f8b","text":""},{"location":"frame_dataset_spec/#_10","title":"\u57fa\u672c\u7684\u306a\u4f7f\u7528\u65b9\u6cd5","text":"<pre><code># \u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u306e\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3092\u4f5c\u6210\ndataset = ChannelFrameDataset.from_folder(\n    \"path/to/audio/files\",\n    sampling_rate=16000,\n    lazy_loading=True\n)\n\n# \u6700\u521d\u306e10\u30d5\u30a1\u30a4\u30eb\u3092\u51e6\u7406\nfor i in range(min(10, len(dataset))):\n    frame = dataset[i]\n    # frame\u3092\u4f7f\u3063\u305f\u51e6\u7406\n    print(f\"File {i}: {frame.label}, SR: {frame.sampling_rate}, Duration: {frame.duration}s\")\n</code></pre>"},{"location":"frame_dataset_spec/#_11","title":"\u5909\u63db\u30c1\u30a7\u30fc\u30f3\u306e\u4f8b","text":"<pre><code># \u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u306e\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3092\u4f5c\u6210\ndataset = ChannelFrameDataset.from_folder(\"path/to/audio/files\")\n\n# \u5909\u63db\u30c1\u30a7\u30fc\u30f3\u3092\u9069\u7528\nprocessed_dataset = (\n    dataset\n    .resample(target_sr=16000)  # \u30ea\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\n    .trim(start=0.5, end=3.5)   # \u30c8\u30ea\u30df\u30f3\u30b0\n    .normalize()                # \u6b63\u898f\u5316\n)\n\n# STFT\u3092\u9069\u7528\u3057\u3066\u30b9\u30da\u30af\u30c8\u30ed\u30b0\u30e9\u30e0\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3092\u4f5c\u6210\nspec_dataset = processed_dataset.stft(n_fft=2048, hop_length=512)\n\n# \u7d50\u679c\u3092\u4fdd\u5b58\nprocessed_dataset.save(\"output/processed_audio\")\nspec_dataset.save(\"output/spectrograms\")\n</code></pre>"},{"location":"frame_dataset_spec/#_12","title":"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u306e\u4f8b","text":"<pre><code># \u5143\u306e\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u304b\u3089\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\nsampled_dataset = dataset.sample(n=10, seed=42)\n\n# \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u3057\u305f\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u306b\u5909\u63db\u3092\u9069\u7528\nprocessed_sampled = (\n    sampled_dataset\n    .resample(target_sr=16000)\n    .normalize()\n)\n</code></pre>"},{"location":"frame_dataset_spec/#_13","title":"\u9ad8\u5ea6\u306a\u6a5f\u80fd","text":""},{"location":"frame_dataset_spec/#_14","title":"\u9045\u5ef6\u30ed\u30fc\u30c9","text":"<p>\u5927\u898f\u6a21\u306a\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3092\u52b9\u7387\u7684\u306b\u6271\u3046\u305f\u3081\u3001<code>lazy_loading=True</code>\uff08\u30c7\u30d5\u30a9\u30eb\u30c8\uff09\u306e\u5834\u5408\u3001\u30c7\u30fc\u30bf\u306f\u5fc5\u8981\u306b\u306a\u3063\u305f\u6642\u70b9\u3067\u30ed\u30fc\u30c9\u3055\u308c\u307e\u3059\u3002\u3053\u308c\u306b\u3088\u308a\u3001\u30e1\u30e2\u30ea\u4f7f\u7528\u91cf\u3092\u6291\u3048\u3064\u3064\u3001\u5927\u91cf\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u6271\u3046\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002</p>"},{"location":"frame_dataset_spec/#_15","title":"\u5909\u63db\u30c1\u30a7\u30fc\u30f3","text":"<p><code>apply()</code>\u30e1\u30bd\u30c3\u30c9\u3092\u4f7f\u7528\u3057\u3066\u95a2\u6570\u3092\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u5168\u4f53\u306b\u9069\u7528\u3067\u304d\u307e\u3059\u3002\u5909\u63db\u306f\u9023\u9396\u7684\u306b\u9069\u7528\u3067\u304d\u3001\u5404\u5909\u63db\u306f\u524d\u306e\u5909\u63db\u306e\u7d50\u679c\u3092\u5165\u529b\u3068\u3057\u3066\u4f7f\u7528\u3057\u307e\u3059\u3002\u7d50\u679c\u306f\u65b0\u3057\u3044\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3068\u3057\u3066\u8fd4\u3055\u308c\u307e\u3059\u3002</p>"},{"location":"frame_dataset_spec/#_16","title":"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0","text":"<p><code>sample()</code>\u30e1\u30bd\u30c3\u30c9\u3092\u4f7f\u7528\u3057\u3066\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u304b\u3089\u6307\u5b9a\u6570\u307e\u305f\u306f\u5272\u5408\u306e\u30b5\u30f3\u30d7\u30eb\u3092\u53d6\u5f97\u3067\u304d\u307e\u3059\u3002\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u3055\u308c\u305f\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3082\u5143\u306e\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3068\u540c\u69d8\u306b\u64cd\u4f5c\u3067\u304d\u3001\u5909\u63db\u30c1\u30a7\u30fc\u30f3\u3082\u9069\u7528\u3067\u304d\u307e\u3059\u3002</p>"},{"location":"en/","title":"Wandas: Waveform Analysis Data Structures","text":"<p>Wandas is an open-source library for efficient signal analysis in Python. Wandas provides comprehensive functionality for signal processing and seamless integration with Matplotlib.</p>"},{"location":"en/#features","title":"Features","text":"<ul> <li>Comprehensive Signal Processing Functions: Easily perform basic signal processing operations including filtering, Fourier transforms, and STFT</li> <li>Integration with Visualization Libraries: Seamlessly integrate with Matplotlib for easy data visualization</li> <li>Lazy Evaluation: Efficiently process large data using dask</li> <li>Various Analysis Tools: Frequency analysis, octave band analysis, time-frequency analysis, and more</li> </ul>"},{"location":"en/#usage-examples","title":"Usage Examples","text":""},{"location":"en/#loading-and-visualizing-audio-files","title":"Loading and Visualizing Audio Files","text":"<pre><code>import wandas as wd\n\ncf = wd.read_wav(\"data/sample.wav\")\ncf.describe()\n</code></pre>"},{"location":"en/#filtering","title":"Filtering","text":"<pre><code>signal = wd.generate_sin(freqs=[5000, 1000], duration=1)\n# Apply low pass filter\nsignal.low_pass_filter(cutoff=1000).fft().plot()\n</code></pre> <p>For detailed documentation and usage examples, see the Tutorial and Cookbook.</p>"},{"location":"en/#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Tutorial - 5-minute getting started guide</li> <li>Cookbook - Recipe collection for common tasks</li> <li>API Reference - Detailed API specifications</li> <li>Theory &amp; Architecture - Design philosophy and algorithm explanations</li> <li>Contributing Guide - Rules and methods for contribution</li> </ul>"},{"location":"en/#license","title":"License","text":"<p>This project is released under the MIT License.</p>"},{"location":"en/contributing/","title":"Contributing Guide","text":"<p>Thank you for your interest in contributing to the Wandas project. This guide explains how to contribute to the project.</p>"},{"location":"en/contributing/#types-of-contributions","title":"Types of Contributions","text":"<p>You can contribute to the Wandas project in the following ways:</p> <ul> <li>Bug reports and feature requests</li> <li>Documentation improvements</li> <li>Bug fixes</li> <li>New feature implementations</li> <li>Test additions and improvements</li> <li>Performance optimizations</li> </ul>"},{"location":"en/contributing/#setting-up-the-development-environment","title":"Setting Up the Development Environment","text":""},{"location":"en/contributing/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/yourusername/wandas.git\ncd wandas\n</code></pre>"},{"location":"en/contributing/#2-set-up-a-virtual-environment-and-install-dependencies","title":"2. Set Up a Virtual Environment and Install Dependencies","text":"<pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip install -e \".[dev]\"\n</code></pre>"},{"location":"en/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"en/contributing/#1-create-a-new-branch","title":"1. Create a New Branch","text":"<p>Create a new branch for new features or bug fixes:</p> <pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/issue-description\n</code></pre>"},{"location":"en/contributing/#2-code-style","title":"2. Code Style","text":"<p>Follow the PEP 8 style guide for code. We use the following tools to ensure code quality:</p> <ul> <li>Ruff: Code linter and formatter</li> <li>mypy: Static type checking</li> </ul> <p>Before committing your code, run the following commands to check your code style:</p> <pre><code># Linting\nruff check wandas tests\n\n# Type checking\nmypy wandas tests\n</code></pre>"},{"location":"en/contributing/#3-testing","title":"3. Testing","text":"<p>Always add tests for new features or bug fixes. Tests are run using <code>pytest</code>:</p> <pre><code>pytest\n</code></pre> <p>To generate a coverage report:</p> <pre><code>pytest --cov=wandas tests/\n</code></pre>"},{"location":"en/contributing/#4-documentation","title":"4. Documentation","text":"<p>Code changes require documentation updates:</p> <ul> <li>Write NumPy-style docstrings for functions and classes</li> <li>Update or add appropriate documentation pages (tutorials, how-tos, API reference) for new features</li> <li>Add sample code to the <code>examples/</code> directory as needed</li> </ul> <p>To build and check the documentation:</p> <pre><code>cd docs\nmkdocs serve\n</code></pre> <p>Then visit http://localhost:8000 in your browser to check.</p>"},{"location":"en/contributing/#5-creating-a-pull-request","title":"5. Creating a Pull Request","text":"<p>Once your changes are complete, create a pull request (PR):</p> <ol> <li>Commit your changes and push to the remote repository</li> </ol> <pre><code>git add .\ngit commit -m \"Descriptive commit message\"\ngit push origin your-branch-name\n</code></pre> <ol> <li>Create a pull request on the GitHub repository page</li> <li>In the PR description, include what was changed, what issues were resolved, and how to test it</li> </ol>"},{"location":"en/contributing/#review-process","title":"Review Process","text":"<p>All PRs are reviewed through the following process:</p> <ol> <li>Automated CI tests must pass</li> <li>Code review by at least one maintainer</li> <li>Requested changes and responses as needed</li> <li>Merge approval</li> </ol>"},{"location":"en/contributing/#communication","title":"Communication","text":"<p>You can communicate for questions or discussions through:</p> <ul> <li>GitHub Issues: Bug reports and feature requests</li> <li>GitHub Discussions: General questions and discussions</li> <li>Project mailing list (if available)</li> </ul>"},{"location":"en/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>All participants in the project are expected to follow the Code of Conduct. Treat other contributors with respect and engage in cooperative and constructive communication.</p>"},{"location":"en/api/","title":"API Reference","text":"<p>This section provides detailed references for all modules, classes, and methods in the Wandas library. It includes documentation automatically generated from the library's source code.</p>"},{"location":"en/api/#core-components","title":"Core Components","text":""},{"location":"en/api/#baseframe","title":"BaseFrame","text":"<p>The <code>BaseFrame</code> class is the basic data structure unit of Wandas.</p> <pre><code>from wandas.core.base_frame import BaseFrame\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for all signal frame types.</p> <p>This class provides the common interface and functionality for all frame types used in signal processing. It implements basic operations like indexing, iteration, and data manipulation that are shared across all frame types.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The signal data to process. Must be a dask array. sampling_rate : float     The sampling rate of the signal in Hz. label : str, optional     A label for the frame. If not provided, defaults to \"unnamed_frame\". metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame--attributes","title":"Attributes","text":"<p>sampling_rate : float     The sampling rate of the signal in Hz. label : str     The label of the frame. metadata : dict     Additional metadata for the frame. operation_history : list[dict]     History of operations performed on this frame.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>class BaseFrame(ABC, Generic[T]):\n    \"\"\"\n    Abstract base class for all signal frame types.\n\n    This class provides the common interface and functionality for all frame types\n    used in signal processing. It implements basic operations like indexing, iteration,\n    and data manipulation that are shared across all frame types.\n\n    Parameters\n    ----------\n    data : DaArray\n        The signal data to process. Must be a dask array.\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str, optional\n        A label for the frame. If not provided, defaults to \"unnamed_frame\".\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str\n        The label of the frame.\n    metadata : dict\n        Additional metadata for the frame.\n    operation_history : list[dict]\n        History of operations performed on this frame.\n    \"\"\"\n\n    _data: DaArray\n    sampling_rate: float\n    label: str\n    metadata: dict[str, Any]\n    operation_history: list[dict[str, Any]]\n    _channel_metadata: list[ChannelMetadata]\n    _previous: Optional[\"BaseFrame[Any]\"]\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ):\n        self._data = data.rechunk(chunks=-1)  # type: ignore [unused-ignore]\n        if self._data.ndim == 1:\n            self._data = self._data.reshape((1, -1))\n        self.sampling_rate = sampling_rate\n        self.label = label or \"unnamed_frame\"\n        self.metadata = metadata or {}\n        self.operation_history = operation_history or []\n        self._previous = previous\n\n        if channel_metadata:\n            self._channel_metadata = copy.deepcopy(channel_metadata)\n        else:\n            self._channel_metadata = [\n                ChannelMetadata(label=f\"ch{i}\", unit=\"\", extra={})\n                for i in range(self._n_channels)\n            ]\n\n        try:\n            # Display information for newer dask versions\n            logger.debug(f\"Dask graph layers: {list(self._data.dask.layers.keys())}\")\n            logger.debug(\n                f\"Dask graph dependencies: {len(self._data.dask.dependencies)}\"\n            )\n        except Exception as e:\n            logger.debug(f\"Dask graph visualization details unavailable: {e}\")\n\n    @property\n    @abstractmethod\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n\n    @property\n    def n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return len(self)\n\n    @property\n    def channels(self) -&gt; list[ChannelMetadata]:\n        \"\"\"Property to access channel metadata.\"\"\"\n        return self._channel_metadata\n\n    @property\n    def previous(self) -&gt; Optional[\"BaseFrame[Any]\"]:\n        \"\"\"\n        Returns the previous frame.\n        \"\"\"\n        return self._previous\n\n    def get_channel(self: S, channel_idx: int) -&gt; S:\n        n_channels = len(self)\n        if channel_idx &lt; 0 or channel_idx &gt;= n_channels:\n            range_max = n_channels - 1\n            raise ValueError(\n                f\"Channel index out of range: {channel_idx} \"\n                f\"(valid range: 0-{range_max})\"\n            )\n        logger.debug(f\"Extracting channel index={channel_idx} (lazy operation).\")\n        channel_data = self._data[channel_idx : channel_idx + 1]\n\n        return self._create_new_instance(\n            data=channel_data,\n            operation_history=self.operation_history,\n            channel_metadata=[self._channel_metadata[channel_idx]],\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Returns the number of channels.\n        \"\"\"\n        return len(self._channel_metadata)\n\n    def __iter__(self: S) -&gt; Iterator[S]:\n        for idx in range(len(self)):\n            yield self[idx]\n\n    def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n        \"\"\"\n        Method to get a channel by name or index.\n\n        Parameters\n        ----------\n        key : str, int, slice, or tuple of slices\n            Channel name (label) or index number.\n\n        Returns\n        -------\n        BaseFrame\n            The corresponding channel.\n\n        Raises\n        ------\n        ValueError\n            If the key length is invalid for the shape.\n        IndexError\n            If the channel index is out of range.\n        TypeError\n            If the key type is invalid.\n        \"\"\"\n        if isinstance(key, str):\n            index = self.label2index(key)\n            return self.get_channel(index)\n\n        elif isinstance(key, tuple):\n            # When key is a tuple, treat the first element as an index\n            if len(key) &gt; len(self.shape):\n                raise ValueError(\n                    f\"Invalid key length: {len(key)} for shape {self.shape}\"\n                )\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key[0]]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, slice):\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, numbers.Integral):\n            # Access by index number\n            if key &lt; 0 or key &gt;= len(self):\n                raise IndexError(f\"Channel index {key} out of range.\")\n            return self.get_channel(key)\n        else:\n            raise TypeError(\n                f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n            )\n\n    def label2index(self, label: str) -&gt; int:\n        \"\"\"\n        Get the index from a channel label.\n\n        Parameters\n        ----------\n        label : str\n            Channel label.\n\n        Returns\n        -------\n        int\n            Corresponding index.\n\n        Raises\n        ------\n        KeyError\n            If the channel label is not found.\n        \"\"\"\n        for idx, ch in enumerate(self._channel_metadata):\n            if ch.label == label:\n                return idx\n        raise KeyError(f\"Channel label '{label}' not found.\")\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        _shape: tuple[int, ...] = self._data.shape\n        return _shape\n\n    @property\n    def data(self) -&gt; T:\n        \"\"\"\n        Returns the computed data.\n        Calculation is executed the first time this is accessed.\n        \"\"\"\n        return self.compute()\n\n    @property\n    def labels(self) -&gt; list[str]:\n        \"\"\"Get a list of all channel labels.\"\"\"\n        return [ch.label for ch in self._channel_metadata]\n\n    def compute(self) -&gt; T:\n        \"\"\"\n        Compute and return the data.\n        This method materializes lazily computed data into a concrete NumPy array.\n\n        Returns\n        -------\n        NDArrayReal\n            The computed data.\n\n        Raises\n        ------\n        ValueError\n            If the computed result is not a NumPy array.\n        \"\"\"\n        logger.debug(\n            \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n        )\n        result = self._data.compute()\n\n        if not isinstance(result, np.ndarray):\n            raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n        logger.debug(f\"Computation complete, result shape: {result.shape}\")\n        return cast(T, result)\n\n    @abstractmethod\n    def plot(\n        self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n    ) -&gt; Union[Axes, Iterator[Axes]]:\n        \"\"\"Plot the data\"\"\"\n        pass\n\n    def persist(self: S) -&gt; S:\n        \"\"\"Persist the data in memory\"\"\"\n        persisted_data = self._data.persist()\n        return self._create_new_instance(data=persisted_data)\n\n    @abstractmethod\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Abstract method for derived classes to provide\n        additional initialization arguments.\n        \"\"\"\n        pass\n\n    def _create_new_instance(self: S, data: DaArray, **kwargs: Any) -&gt; S:\n        \"\"\"\n        Create a new channel instance based on an existing channel.\n        Keyword arguments can override or extend the original attributes.\n        \"\"\"\n\n        sampling_rate = kwargs.pop(\"sampling_rate\", self.sampling_rate)\n        # if not isinstance(sampling_rate, int):\n        #     raise TypeError(\"Sampling rate must be an integer\")\n\n        label = kwargs.pop(\"label\", self.label)\n        if not isinstance(label, str):\n            raise TypeError(\"Label must be a string\")\n\n        metadata = kwargs.pop(\"metadata\", copy.deepcopy(self.metadata))\n        if not isinstance(metadata, dict):\n            raise TypeError(\"Metadata must be a dictionary\")\n\n        # Get additional initialization arguments from derived classes\n        additional_kwargs = self._get_additional_init_kwargs()\n        kwargs.update(additional_kwargs)\n\n        return type(self)(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            previous=self,\n            **kwargs,\n        )\n\n    def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n        \"\"\"Implicit conversion to NumPy array\"\"\"\n        result = self.compute()\n        if dtype is not None:\n            return result.astype(dtype)\n        return result\n\n    def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n        \"\"\"Visualize the computation graph and save it to a file\"\"\"\n        try:\n            filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n            self._data.visualize(filename=filename)\n            return filename\n        except Exception as e:\n            logger.warning(f\"Failed to visualize the graph: {e}\")\n            return None\n\n    @abstractmethod\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"Basic implementation of binary operations\"\"\"\n        # Basic logic\n        # Actual implementation is left to derived classes\n        pass\n\n    def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Addition operator\"\"\"\n        return self._binary_op(other, lambda x, y: x + y, \"+\")\n\n    def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Subtraction operator\"\"\"\n        return self._binary_op(other, lambda x, y: x - y, \"-\")\n\n    def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Multiplication operator\"\"\"\n        return self._binary_op(other, lambda x, y: x * y, \"*\")\n\n    def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Division operator\"\"\"\n        return self._binary_op(other, lambda x, y: x / y, \"/\")\n\n    def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Apply a named operation.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters to pass to the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        # Apply the operation through abstract method\n        return self._apply_operation_impl(operation_name, **params)\n\n    @abstractmethod\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"Implementation of operation application\"\"\"\n        pass\n\n    def debug_info(self) -&gt; None:\n        \"\"\"Output detailed debug information\"\"\"\n        logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n        logger.debug(f\"Label: {self.label}\")\n        logger.debug(f\"Shape: {self.shape}\")\n        logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n        logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n        self._debug_info_impl()\n        logger.debug(\"=== End Debug Info ===\")\n\n    def _debug_info_impl(self) -&gt; None:\n        \"\"\"Implement derived class-specific debug information\"\"\"\n        pass\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.channels","title":"<code>channels</code>  <code>property</code>","text":"<p>Property to access channel metadata.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.data","title":"<code>data</code>  <code>property</code>","text":"<p>Returns the computed data. Calculation is executed the first time this is accessed.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>Get a list of all channel labels.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.n_channels","title":"<code>n_channels</code>  <code>property</code>","text":"<p>Returns the number of channels.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.previous","title":"<code>previous</code>  <code>property</code>","text":"<p>Returns the previous frame.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__add__","title":"<code>__add__(other)</code>","text":"<p>Addition operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Addition operator\"\"\"\n    return self._binary_op(other, lambda x, y: x + y, \"+\")\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__array__","title":"<code>__array__(dtype=None)</code>","text":"<p>Implicit conversion to NumPy array</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n    \"\"\"Implicit conversion to NumPy array\"\"\"\n    result = self.compute()\n    if dtype is not None:\n        return result.astype(dtype)\n    return result\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Method to get a channel by name or index.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__getitem__--parameters","title":"Parameters","text":"<p>key : str, int, slice, or tuple of slices     Channel name (label) or index number.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__getitem__--returns","title":"Returns","text":"<p>BaseFrame     The corresponding channel.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__getitem__--raises","title":"Raises","text":"<p>ValueError     If the key length is invalid for the shape. IndexError     If the channel index is out of range. TypeError     If the key type is invalid.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n    \"\"\"\n    Method to get a channel by name or index.\n\n    Parameters\n    ----------\n    key : str, int, slice, or tuple of slices\n        Channel name (label) or index number.\n\n    Returns\n    -------\n    BaseFrame\n        The corresponding channel.\n\n    Raises\n    ------\n    ValueError\n        If the key length is invalid for the shape.\n    IndexError\n        If the channel index is out of range.\n    TypeError\n        If the key type is invalid.\n    \"\"\"\n    if isinstance(key, str):\n        index = self.label2index(key)\n        return self.get_channel(index)\n\n    elif isinstance(key, tuple):\n        # When key is a tuple, treat the first element as an index\n        if len(key) &gt; len(self.shape):\n            raise ValueError(\n                f\"Invalid key length: {len(key)} for shape {self.shape}\"\n            )\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key[0]]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, slice):\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, numbers.Integral):\n        # Access by index number\n        if key &lt; 0 or key &gt;= len(self):\n            raise IndexError(f\"Channel index {key} out of range.\")\n        return self.get_channel(key)\n    else:\n        raise TypeError(\n            f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n        )\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of channels.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of channels.\n    \"\"\"\n    return len(self._channel_metadata)\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplication operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Multiplication operator\"\"\"\n    return self._binary_op(other, lambda x, y: x * y, \"*\")\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtraction operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Subtraction operator\"\"\"\n    return self._binary_op(other, lambda x, y: x - y, \"-\")\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Division operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Division operator\"\"\"\n    return self._binary_op(other, lambda x, y: x / y, \"/\")\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.apply_operation","title":"<code>apply_operation(operation_name, **params)</code>","text":"<p>Apply a named operation.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.apply_operation--parameters","title":"Parameters","text":"<p>operation_name : str     Name of the operation to apply. **params : Any     Parameters to pass to the operation.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.apply_operation--returns","title":"Returns","text":"<p>S     A new instance with the operation applied.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n    \"\"\"\n    Apply a named operation.\n\n    Parameters\n    ----------\n    operation_name : str\n        Name of the operation to apply.\n    **params : Any\n        Parameters to pass to the operation.\n\n    Returns\n    -------\n    S\n        A new instance with the operation applied.\n    \"\"\"\n    # Apply the operation through abstract method\n    return self._apply_operation_impl(operation_name, **params)\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.compute","title":"<code>compute()</code>","text":"<p>Compute and return the data. This method materializes lazily computed data into a concrete NumPy array.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.compute--returns","title":"Returns","text":"<p>NDArrayReal     The computed data.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.compute--raises","title":"Raises","text":"<p>ValueError     If the computed result is not a NumPy array.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def compute(self) -&gt; T:\n    \"\"\"\n    Compute and return the data.\n    This method materializes lazily computed data into a concrete NumPy array.\n\n    Returns\n    -------\n    NDArrayReal\n        The computed data.\n\n    Raises\n    ------\n    ValueError\n        If the computed result is not a NumPy array.\n    \"\"\"\n    logger.debug(\n        \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n    )\n    result = self._data.compute()\n\n    if not isinstance(result, np.ndarray):\n        raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n    logger.debug(f\"Computation complete, result shape: {result.shape}\")\n    return cast(T, result)\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.debug_info","title":"<code>debug_info()</code>","text":"<p>Output detailed debug information</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def debug_info(self) -&gt; None:\n    \"\"\"Output detailed debug information\"\"\"\n    logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n    logger.debug(f\"Label: {self.label}\")\n    logger.debug(f\"Shape: {self.shape}\")\n    logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n    logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n    self._debug_info_impl()\n    logger.debug(\"=== End Debug Info ===\")\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.label2index","title":"<code>label2index(label)</code>","text":"<p>Get the index from a channel label.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.label2index--parameters","title":"Parameters","text":"<p>label : str     Channel label.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.label2index--returns","title":"Returns","text":"<p>int     Corresponding index.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.label2index--raises","title":"Raises","text":"<p>KeyError     If the channel label is not found.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def label2index(self, label: str) -&gt; int:\n    \"\"\"\n    Get the index from a channel label.\n\n    Parameters\n    ----------\n    label : str\n        Channel label.\n\n    Returns\n    -------\n    int\n        Corresponding index.\n\n    Raises\n    ------\n    KeyError\n        If the channel label is not found.\n    \"\"\"\n    for idx, ch in enumerate(self._channel_metadata):\n        if ch.label == label:\n            return idx\n    raise KeyError(f\"Channel label '{label}' not found.\")\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.persist","title":"<code>persist()</code>","text":"<p>Persist the data in memory</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def persist(self: S) -&gt; S:\n    \"\"\"Persist the data in memory\"\"\"\n    persisted_data = self._data.persist()\n    return self._create_new_instance(data=persisted_data)\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.plot","title":"<code>plot(plot_type='default', ax=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Plot the data</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>@abstractmethod\ndef plot(\n    self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n) -&gt; Union[Axes, Iterator[Axes]]:\n    \"\"\"Plot the data\"\"\"\n    pass\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.visualize_graph","title":"<code>visualize_graph(filename=None)</code>","text":"<p>Visualize the computation graph and save it to a file</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"Visualize the computation graph and save it to a file\"\"\"\n    try:\n        filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n        self._data.visualize(filename=filename)\n        return filename\n    except Exception as e:\n        logger.warning(f\"Failed to visualize the graph: {e}\")\n        return None\n</code></pre>"},{"location":"en/api/#frame-module","title":"Frame Module","text":""},{"location":"en/api/#channelframe","title":"ChannelFrame","text":"<p><code>ChannelFrame</code> is a class that handles time-domain signal data.</p> <pre><code>from wandas.frames.channel import ChannelFrame\n</code></pre> <p>You can also import it directly:</p> <pre><code>import wandas\n# Use it as follows\nframe = wandas.read_wav(\"audio.wav\")\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Channel-based data frame for handling audio signals and time series data.</p> <p>This frame represents channel-based data such as audio signals and time series data, with each channel containing data samples in the time domain.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>class ChannelFrame(BaseFrame[NDArrayReal]):\n    \"\"\"Channel-based data frame for handling audio signals and time series data.\n\n    This frame represents channel-based data such as audio signals and time series data,\n    with each channel containing data samples in the time domain.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"Initialize a ChannelFrame.\n\n        Args:\n            data: Dask array containing channel data.\n            Shape should be (n_channels, n_samples).\n            sampling_rate: The sampling rate of the data in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            operation_history: History of operations applied to the frame.\n            channel_metadata: Metadata for each channel.\n            previous: Reference to the previous frame in the processing chain.\n\n        Raises:\n            ValueError: If data has more than 2 dimensions.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return self.shape[-2]\n\n    @property\n    def time(self) -&gt; NDArrayReal:\n        \"\"\"Get time array for the signal.\n\n        Returns:\n            Array of time points in seconds.\n        \"\"\"\n        return np.arange(self.n_samples) / self.sampling_rate\n\n    @property\n    def n_samples(self) -&gt; int:\n        \"\"\"Returns the number of samples.\"\"\"\n        n: int = self._data.shape[-1]\n        return n\n\n    @property\n    def duration(self) -&gt; float:\n        \"\"\"Returns the duration in seconds.\"\"\"\n        return self.n_samples / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # Apply processing to data\n        processed_data = operation.process(self._data)\n\n        # Update metadata\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        if operation_name == \"resampling\":\n            # For resampling, update sampling rate\n            return self._create_new_instance(\n                sampling_rate=params[\"target_sr\"],\n                data=processed_data,\n                metadata=new_metadata,\n                operation_history=new_history,\n            )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Common implementation for binary operations\n        - utilizing dask's lazy evaluation.\n\n        Args:\n            other: Right operand for the operation.\n            op: Function to execute the operation (e.g., lambda a, b: a + b).\n            symbol: Symbolic representation of the operation (e.g., '+').\n\n        Returns:\n            A new channel containing the operation result (lazy execution).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, ChannelFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Perform operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other._data)\n\n            # Merge channel metadata\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # Perform operation with scalar, NumPy array, or other types\n        else:\n            # Apply operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other)\n\n            # Operand display string\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # Check for dask.array.Array\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # Update channel metadata\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n                previous=self,\n            )\n\n    def add(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        snr: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Add another signal or value to the current signal.\n\n        If SNR is specified, performs addition with consideration for\n        signal-to-noise ratio.\n\n        Args:\n            other: Signal or value to add.\n            snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n                other signal based on this SNR.\n                self is treated as the signal, and other as the noise.\n\n        Returns:\n            A new channel frame containing the addition result (lazy execution).\n        \"\"\"\n        logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n        # Special processing when SNR is specified\n        if snr is not None:\n            # First convert other to ChannelFrame if it's not\n            if not isinstance(other, ChannelFrame):\n                if isinstance(other, np.ndarray):\n                    other = ChannelFrame.from_numpy(\n                        other, self.sampling_rate, label=\"array_data\"\n                    )\n                elif isinstance(other, (int, float)):\n                    # For scalar values, simply add (ignore SNR)\n                    return self + other\n                else:\n                    raise TypeError(\n                        \"Addition target with SNR must be a ChannelFrame or \"\n                        f\"NumPy array: {type(other)}\"\n                    )\n\n            # Check if sampling rates match\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Apply addition operation with SNR adjustment\n            return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n        # Execute normal addition if SNR is not specified\n        return self + other\n\n    def plot(\n        self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Plot the frame data.\n\n        Args:\n            plot_type: Type of plot. Default is \"waveform\".\n            ax: Optional matplotlib axes for plotting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        plot_strategy = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def rms_plot(\n        self,\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = True,\n        Aw: bool = False,  # noqa: N803\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Generate an RMS plot.\n\n        Args:\n            ax: Optional matplotlib axes for plotting.\n            title: Title for the plot.\n            overlay: Whether to overlay the plot on the existing axis.\n            Aw: Apply A-weighting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        kwargs = kwargs or {}\n        ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n        rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n        return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n\n    def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n        \"\"\"Display visual and audio representation of the frame.\n\n        Args:\n            normalize: Whether to normalize the audio data for playback.\n            **kwargs: Additional parameters for visualization.\n        \"\"\"\n        if \"axis_config\" in kwargs:\n            logger.warning(\n                \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            axis_config = kwargs[\"axis_config\"]\n            if \"time_plot\" in axis_config:\n                kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n            if \"freq_plot\" in axis_config:\n                if \"xlim\" in axis_config[\"freq_plot\"]:\n                    vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                    kwargs[\"vmin\"] = vlim[0]\n                    kwargs[\"vmax\"] = vlim[1]\n                if \"ylim\" in axis_config[\"freq_plot\"]:\n                    ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                    kwargs[\"ylim\"] = ylim\n\n        if \"cbar_config\" in kwargs:\n            logger.warning(\n                \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            cbar_config = kwargs[\"cbar_config\"]\n            if \"vmin\" in cbar_config:\n                kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n            if \"vmax\" in cbar_config:\n                kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n        for ch in self:\n            ax: Axes\n            _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n            if isinstance(_ax, Iterator):\n                ax = next(iter(_ax))\n            elif isinstance(_ax, Axes):\n                ax = _ax\n            else:\n                raise TypeError(\n                    f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n                )\n            # Ignore type checks for display and Audio\n            display(ax.figure)  # type: ignore\n            plt.close(ax.figure)  # type: ignore\n            display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n\n    @classmethod\n    def from_numpy(\n        cls,\n        data: NDArrayReal,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        ch_labels: Optional[list[str]] = None,\n        ch_units: Optional[Union[list[str], str]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        Args:\n            data: NumPy array containing channel data.\n            sampling_rate: The sampling rate in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            ch_labels: Labels for each channel.\n            ch_units: Units for each channel.\n\n        Returns:\n            A new ChannelFrame containing the NumPy data.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n\n        # Convert NumPy array to dask array\n        dask_data = da_from_array(data)\n        cf = ChannelFrame(\n            data=dask_data,\n            sampling_rate=sampling_rate,\n            label=label or \"numpy_data\",\n        )\n        if metadata is not None:\n            cf.metadata = metadata\n        if ch_labels is not None:\n            if len(ch_labels) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel labels does not match the number of channels\"\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        if ch_units is not None:\n            if isinstance(ch_units, str):\n                ch_units = [ch_units] * cf.n_channels\n\n            if len(ch_units) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel units does not match the number of channels\"\n                )\n            for i in range(len(ch_units)):\n                cf._channel_metadata[i].unit = ch_units[i]\n\n        return cf\n\n    @classmethod\n    def from_ndarray(\n        cls,\n        array: NDArrayReal,\n        sampling_rate: float,\n        labels: Optional[list[str]] = None,\n        unit: Optional[Union[list[str], str]] = None,\n        frame_label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        This method is deprecated. Use from_numpy instead.\n\n        Args:\n            array: Signal data. Each row corresponds to a channel.\n            sampling_rate: Sampling rate (Hz).\n            labels: Labels for each channel.\n            unit: Unit of the signal.\n            frame_label: Label for the frame.\n            metadata: Optional metadata dictionary.\n\n        Returns:\n            A new ChannelFrame containing the data.\n        \"\"\"\n        # Redirect to from_numpy for compatibility\n        # However, from_ndarray is deprecated\n        logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n        return cls.from_numpy(\n            data=array,\n            sampling_rate=sampling_rate,\n            label=frame_label,\n            metadata=metadata,\n            ch_labels=labels,\n            ch_units=unit,\n        )\n\n    @classmethod\n    def from_file(\n        cls,\n        path: Union[str, Path],\n        channel: Optional[Union[int, list[int]]] = None,\n        start: Optional[float] = None,\n        end: Optional[float] = None,\n        chunk_size: Optional[int] = None,\n        ch_labels: Optional[list[str]] = None,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from an audio file.\n\n        Args:\n            path: Path to the audio file.\n            channel: Channel(s) to load.\n            start: Start time in seconds.\n            end: End time in seconds.\n            chunk_size: Chunk size for processing.\n            Specifies the splitting size for lazy processing.\n            ch_labels: Labels for each channel.\n            **kwargs: Additional arguments passed to the file reader.\n\n        Returns:\n            A new ChannelFrame containing the loaded audio data.\n\n        Raises:\n            ValueError: If channel selection is invalid.\n            TypeError: If channel parameter type is invalid.\n            FileNotFoundError: If the file doesn't exist.\n        \"\"\"\n        from .channel import ChannelFrame\n\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"File not found: {path}\")\n\n        # Get file reader\n        reader = get_file_reader(path)\n\n        # Get file info\n        info = reader.get_file_info(path, **kwargs)\n        sr = info[\"samplerate\"]\n        n_channels = info[\"channels\"]\n        n_frames = info[\"frames\"]\n        ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n        logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n        # Channel selection processing\n        all_channels = list(range(n_channels))\n\n        if channel is None:\n            channels_to_load = all_channels\n            logger.debug(f\"Will load all channels: {channels_to_load}\")\n        elif isinstance(channel, int):\n            if channel &lt; 0 or channel &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n            channels_to_load = [channel]\n            logger.debug(f\"Will load single channel: {channel}\")\n        elif isinstance(channel, (list, tuple)):\n            for ch in channel:\n                if ch &lt; 0 or ch &gt;= n_channels:\n                    raise ValueError(\n                        f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                    )\n            channels_to_load = list(channel)\n            logger.debug(f\"Will load specific channels: {channels_to_load}\")\n        else:\n            raise TypeError(\"channel must be int, list, or None\")\n\n        # Index calculation\n        start_idx = 0 if start is None else max(0, int(start * sr))\n        end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n        frames_to_read = end_idx - start_idx\n\n        logger.debug(\n            f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n            f\"start_idx={start_idx}, end_idx={end_idx}\"\n        )\n\n        # Settings for lazy loading\n        expected_shape = (len(channels_to_load), frames_to_read)\n\n        # Define the loading function using the file reader\n        def _load_audio() -&gt; NDArrayReal:\n            logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n            # Use the reader to get audio data with parameters\n            out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n            if not isinstance(out, np.ndarray):\n                raise ValueError(\"Unexpected data type after reading file\")\n            return out\n\n        logger.debug(\n            f\"Creating delayed dask task with expected shape: {expected_shape}\"\n        )\n\n        # Create delayed operation\n        delayed_data = dask_delayed(_load_audio)()\n        logger.debug(\"Wrapping delayed function in dask array\")\n\n        # Create dask array from delayed computation\n        dask_array = da_from_delayed(\n            delayed_data, shape=expected_shape, dtype=np.float32\n        )\n\n        if chunk_size is not None:\n            if chunk_size &lt;= 0:\n                raise ValueError(\"Chunk size must be a positive integer\")\n            logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n            dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n        logger.debug(\n            \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n        )\n\n        cf = ChannelFrame(\n            data=dask_array,\n            sampling_rate=sr,\n            label=path.stem,\n            metadata={\n                \"filename\": str(path),\n            },\n        )\n        if ch_labels is not None:\n            if len(ch_labels) != len(cf):\n                raise ValueError(\n                    \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        return cf\n\n    @classmethod\n    def read_wav(\n        cls, filename: str, labels: Optional[list[str]] = None\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a WAV file.\n\n        Args:\n            filename: Path to the WAV file.\n            labels: Labels to set for each channel.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(filename, ch_labels=labels)\n        return cf\n\n    @classmethod\n    def read_csv(\n        cls,\n        filename: str,\n        time_column: Union[int, str] = 0,\n        labels: Optional[list[str]] = None,\n        delimiter: str = \",\",\n        header: Optional[int] = 0,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a CSV file.\n\n        Args:\n            filename: Path to the CSV file.\n            time_column: Index or name of the time column.\n            labels: Labels to set for each channel.\n            delimiter: Delimiter character.\n            header: Row number to use as header.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(\n            filename,\n            ch_labels=labels,\n            time_column=time_column,\n            delimiter=delimiter,\n            header=header,\n        )\n        return cf\n\n    def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n        \"\"\"Save the audio data to a file.\n\n        Args:\n            path: Path to save the file.\n            format: File format. If None, determined from file extension.\n        \"\"\"\n        logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n        data = self.compute()\n        data = data.T\n        if data.shape[1] == 1:\n            data = data.squeeze(axis=1)\n        sf.write(str(path), data, int(self.sampling_rate), format=format)\n        logger.debug(f\"Save complete: {path}\")\n\n    def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a high-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n\n    def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a low-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n\n    def normalize(\n        self, target_level: float = -20, channel_wise: bool = True\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Normalize the signal level.\n\n        This method adjusts the signal amplitude to reach a target RMS level.\n\n        Args:\n            target_level: Target RMS level in dB. Default is -20.\n            channel_wise: If True, normalize each channel independently.\n                If False, apply the same scaling to all channels.\n\n        Returns:\n            A new ChannelFrame containing the normalized signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n        )\n        return self.apply_operation(\n            \"normalize\", target_level=target_level, channel_wise=channel_wise\n        )\n\n    def a_weighting(self) -&gt; \"ChannelFrame\":\n        \"\"\"Apply A-weighting filter to the signal.\n\n        A-weighting adjusts the frequency response to approximate human hearing\n        perception, following IEC 61672-1:2013 standard.\n\n        Returns:\n            A new ChannelFrame with A-weighted signal.\n        \"\"\"\n        return self.apply_operation(\"a_weighting\")\n\n    def hpss_harmonic(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract harmonic components using HPSS\n         (Harmonic-Percussive Source Separation).\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_harmonic\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def hpss_percussive(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract percussive components using HPSS\n        (Harmonic-Percussive Source Separation).\n\n        This method separates the percussive (tonal) components from the signal.\n\n        Args:\n            kernel_size: Median filter size for HPSS.\n            power: Exponent for the Weiner filter used in HPSS.\n            margin: Margin size for the separation.\n\n        Returns:\n            A new ChannelFrame containing the harmonic components.\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_percussive\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def resampling(\n        self,\n        target_sr: float,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Resample audio data.\n\n        Parameters\n        ----------\n        target_sr : float\n            Target sampling rate (Hz)\n        resample_type : str, optional\n            Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n        **kwargs : dict\n            Additional resampling parameters\n\n        Returns\n        -------\n        ChannelFrame\n            Resampled channel frame\n        \"\"\"\n        return self.apply_operation(\n            \"resampling\",\n            target_sr=target_sr,\n            **kwargs,\n        )\n\n    def abs(self) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the absolute value of the signal.\n\n        Returns:\n            A new ChannelFrame containing the absolute values.\n        \"\"\"\n        return self.apply_operation(\"abs\")\n\n    def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the power of the signal.\n\n        Args:\n            exponent: The exponent to raise the signal to. Default is 2.0.\n\n        Returns:\n            A new ChannelFrame containing the signal raised to the power.\n        \"\"\"\n        return self.apply_operation(\"power\", exponent=exponent)\n\n    def trim(\n        self,\n        start: float = 0,\n        end: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Trim the signal to specified time range.\n\n        Args:\n            start: Start time in seconds.\n            end: End time in seconds.\n\n        Returns:\n            A new ChannelFrame with trimmed signal.\n\n        Raises:\n            ValueError: If end time is before start time.\n        \"\"\"\n        if end is None:\n            end = self.duration\n        if start &gt; end:\n            raise ValueError(\"start must be less than end\")\n        # Apply trim operation\n        return self.apply_operation(\"trim\", start=start, end=end)\n\n    def rms_trend(\n        self,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the RMS trend of the signal.\n\n        This method computes the root mean square value over sliding windows.\n\n        Args:\n            frame_length: The size of the sliding window in samples. Default is 2048.\n            hop_length: The hop length between windows in samples. Default is 512.\n            dB: Whether to return the RMS values in decibels. Default is False.\n            Aw: Whether to apply A-weighting. Default is False.\n\n        Returns:\n            A new ChannelFrame containing the RMS trend.\n        \"\"\"\n        cf = self.apply_operation(\n            \"rms_trend\",\n            frame_length=frame_length,\n            hop_length=hop_length,\n            ref=[ch.ref for ch in self._channel_metadata],\n            dB=dB,\n            Aw=Aw,\n        )\n        cf.sampling_rate = self.sampling_rate / hop_length\n        return cf\n\n    def sum(self) -&gt; \"ChannelFrame\":\n        \"\"\"Sum all channels.\n\n        Returns:\n            A new ChannelFrame with summed signal.\n        \"\"\"\n        return self.apply_operation(\"sum\")\n\n    def mean(self) -&gt; \"ChannelFrame\":\n        \"\"\"Average all channels.\n\n        Returns:\n            A new ChannelFrame with averaged signal.\n        \"\"\"\n        return self.apply_operation(\"mean\")\n\n    def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate channel differences relative to a reference channel.\n\n        Args:\n            other_channel: Reference channel index or label. Default is 0.\n\n        Returns:\n            A new ChannelFrame with channel differences.\n        \"\"\"\n        if isinstance(other_channel, str):\n            return self.apply_operation(\n                \"channel_difference\", other_channel=self.label2index(other_channel)\n            )\n        return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n\n    def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n        \"\"\"Compute Fast Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is next power of 2 of data length.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectralFrame containing the FFT results.\n        \"\"\"\n        from ..processing.time_series import FFT\n        from .spectral import SpectralFrame\n\n        params = {\"n_fft\": n_fft, \"window\": window}\n        operation_name = \"fft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"FFT\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        if n_fft is None:\n            is_even = spectrum_data.shape[-1] % 2 == 0\n            _n_fft = (\n                spectrum_data.shape[-1] * 2 - 2\n                if is_even\n                else spectrum_data.shape[-1] * 2 - 1\n            )\n        else:\n            _n_fft = n_fft\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=_n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def welch(\n        self,\n        n_fft: Optional[int] = None,\n        hop_length: Optional[int] = None,\n        win_length: int = 2048,\n        window: str = \"hann\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute power spectral density using Welch's method.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the power spectral density.\n        \"\"\"\n        from ..processing.time_series import Welch\n        from .spectral import SpectralFrame\n\n        params = dict(\n            n_fft=n_fft or win_length,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            average=average,\n        )\n        operation_name = \"welch\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Welch\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"welch\", \"params\": params},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def noct_spectrum(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"Compute N-octave band spectrum.\n\n        Args:\n            fmin: Minimum center frequency in Hz. Default is 20 Hz.\n            fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n            n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n            G: Reference gain in dB. Default is 10 dB.\n            fr: Reference frequency in Hz. Default is 1000 Hz.\n\n        Returns:\n            A NOctFrame containing the N-octave band spectrum.\n        \"\"\"\n        from ..processing.time_series import NOctSpectrum\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_spectrum\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSpectrum\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_spectrum\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def stft(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"Compute Short-Time Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectrogramFrame containing the STFT results.\n        \"\"\"\n        from ..processing.time_series import STFT, create_operation\n        from .spectrogram import SpectrogramFrame\n\n        # Set hop length and window length\n        _hop_length = hop_length if hop_length is not None else n_fft // 4\n        _win_length = win_length if win_length is not None else n_fft\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": _hop_length,\n            \"win_length\": _win_length,\n            \"window\": window,\n        }\n        operation_name = \"stft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"STFT\", operation)\n\n        # Apply processing to data\n        spectrogram_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n\n        # Create new instance\n        return SpectrogramFrame(\n            data=spectrogram_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=n_fft,\n            hop_length=_hop_length,\n            win_length=_win_length,\n            window=window,\n            label=f\"stft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def coherence(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute magnitude squared coherence.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n        Returns:\n            A SpectralFrame containing the magnitude squared coherence.\n        \"\"\"\n        from ..processing.time_series import Coherence, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n        }\n        operation_name = \"coherence\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Coherence\", operation)\n\n        # Apply processing to data\n        coherence_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=coherence_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Coherence of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def csd(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute cross-spectral density matrix.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the cross-spectral density matrix.\n        \"\"\"\n        from ..processing.time_series import CSD, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"csd\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"CSD\", operation)\n\n        # Apply processing to data\n        csd_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=csd_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def transfer_function(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute transfer function matrix.\n\n        The transfer function characterizes the signal transmission properties\n        between channels in the frequency domain, representing the input-output\n        relationship of a system.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the transfer function matrix.\n        \"\"\"\n        from ..processing.time_series import TransferFunction, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"transfer_function\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"TransferFunction\", operation)\n\n        # Apply processing to data\n        tf_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=tf_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Transfer function of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"Provide additional initialization arguments required for ChannelFrame.\"\"\"\n        return {}\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Returns the duration in seconds.</p>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>Returns the number of samples.</p>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.time","title":"<code>time</code>  <code>property</code>","text":"<p>Get time array for the signal.</p> <p>Returns:</p> Type Description <code>NDArrayReal</code> <p>Array of time points in seconds.</p>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.__init__","title":"<code>__init__(data, sampling_rate, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a ChannelFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>Dask array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate of the data in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>operation_history</code> <code>Optional[list[dict[str, Any]]]</code> <p>History of operations applied to the frame.</p> <code>None</code> <code>channel_metadata</code> <code>Optional[list[ChannelMetadata]]</code> <p>Metadata for each channel.</p> <code>None</code> <code>previous</code> <code>Optional[BaseFrame[Any]]</code> <p>Reference to the previous frame in the processing chain.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has more than 2 dimensions.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"Initialize a ChannelFrame.\n\n    Args:\n        data: Dask array containing channel data.\n        Shape should be (n_channels, n_samples).\n        sampling_rate: The sampling rate of the data in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        operation_history: History of operations applied to the frame.\n        channel_metadata: Metadata for each channel.\n        previous: Reference to the previous frame in the processing chain.\n\n    Raises:\n        ValueError: If data has more than 2 dimensions.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.a_weighting","title":"<code>a_weighting()</code>","text":"<p>Apply A-weighting filter to the signal.</p> <p>A-weighting adjusts the frequency response to approximate human hearing perception, following IEC 61672-1:2013 standard.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with A-weighted signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def a_weighting(self) -&gt; \"ChannelFrame\":\n    \"\"\"Apply A-weighting filter to the signal.\n\n    A-weighting adjusts the frequency response to approximate human hearing\n    perception, following IEC 61672-1:2013 standard.\n\n    Returns:\n        A new ChannelFrame with A-weighted signal.\n    \"\"\"\n    return self.apply_operation(\"a_weighting\")\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.abs","title":"<code>abs()</code>","text":"<p>Calculate the absolute value of the signal.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the absolute values.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def abs(self) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the absolute value of the signal.\n\n    Returns:\n        A new ChannelFrame containing the absolute values.\n    \"\"\"\n    return self.apply_operation(\"abs\")\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.add","title":"<code>add(other, snr=None)</code>","text":"<p>Add another signal or value to the current signal.</p> <p>If SNR is specified, performs addition with consideration for signal-to-noise ratio.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[ChannelFrame, int, float, NDArrayReal, Array]</code> <p>Signal or value to add.</p> required <code>snr</code> <code>Optional[float]</code> <p>Signal-to-noise ratio (dB). If specified, adjusts the scale of the other signal based on this SNR. self is treated as the signal, and other as the noise.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new channel frame containing the addition result (lazy execution).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def add(\n    self,\n    other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n    snr: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Add another signal or value to the current signal.\n\n    If SNR is specified, performs addition with consideration for\n    signal-to-noise ratio.\n\n    Args:\n        other: Signal or value to add.\n        snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n            other signal based on this SNR.\n            self is treated as the signal, and other as the noise.\n\n    Returns:\n        A new channel frame containing the addition result (lazy execution).\n    \"\"\"\n    logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n    # Special processing when SNR is specified\n    if snr is not None:\n        # First convert other to ChannelFrame if it's not\n        if not isinstance(other, ChannelFrame):\n            if isinstance(other, np.ndarray):\n                other = ChannelFrame.from_numpy(\n                    other, self.sampling_rate, label=\"array_data\"\n                )\n            elif isinstance(other, (int, float)):\n                # For scalar values, simply add (ignore SNR)\n                return self + other\n            else:\n                raise TypeError(\n                    \"Addition target with SNR must be a ChannelFrame or \"\n                    f\"NumPy array: {type(other)}\"\n                )\n\n        # Check if sampling rates match\n        if self.sampling_rate != other.sampling_rate:\n            raise ValueError(\n                \"Sampling rates do not match. Cannot perform operation.\"\n            )\n\n        # Apply addition operation with SNR adjustment\n        return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n    # Execute normal addition if SNR is not specified\n    return self + other\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.channel_difference","title":"<code>channel_difference(other_channel=0)</code>","text":"<p>Calculate channel differences relative to a reference channel.</p> <p>Parameters:</p> Name Type Description Default <code>other_channel</code> <code>Union[int, str]</code> <p>Reference channel index or label. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with channel differences.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate channel differences relative to a reference channel.\n\n    Args:\n        other_channel: Reference channel index or label. Default is 0.\n\n    Returns:\n        A new ChannelFrame with channel differences.\n    \"\"\"\n    if isinstance(other_channel, str):\n        return self.apply_operation(\n            \"channel_difference\", other_channel=self.label2index(other_channel)\n        )\n    return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.coherence","title":"<code>coherence(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant')</code>","text":"<p>Compute magnitude squared coherence.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the magnitude squared coherence.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def coherence(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute magnitude squared coherence.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n    Returns:\n        A SpectralFrame containing the magnitude squared coherence.\n    \"\"\"\n    from ..processing.time_series import Coherence, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n    }\n    operation_name = \"coherence\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Coherence\", operation)\n\n    # Apply processing to data\n    coherence_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=coherence_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Coherence of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.csd","title":"<code>csd(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute cross-spectral density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the cross-spectral density matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def csd(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute cross-spectral density matrix.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the cross-spectral density matrix.\n    \"\"\"\n    from ..processing.time_series import CSD, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"csd\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"CSD\", operation)\n\n    # Apply processing to data\n    csd_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=csd_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.describe","title":"<code>describe(normalize=True, **kwargs)</code>","text":"<p>Display visual and audio representation of the frame.</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>Whether to normalize the audio data for playback.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for visualization.</p> <code>{}</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n    \"\"\"Display visual and audio representation of the frame.\n\n    Args:\n        normalize: Whether to normalize the audio data for playback.\n        **kwargs: Additional parameters for visualization.\n    \"\"\"\n    if \"axis_config\" in kwargs:\n        logger.warning(\n            \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        axis_config = kwargs[\"axis_config\"]\n        if \"time_plot\" in axis_config:\n            kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n        if \"freq_plot\" in axis_config:\n            if \"xlim\" in axis_config[\"freq_plot\"]:\n                vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                kwargs[\"vmin\"] = vlim[0]\n                kwargs[\"vmax\"] = vlim[1]\n            if \"ylim\" in axis_config[\"freq_plot\"]:\n                ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                kwargs[\"ylim\"] = ylim\n\n    if \"cbar_config\" in kwargs:\n        logger.warning(\n            \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        cbar_config = kwargs[\"cbar_config\"]\n        if \"vmin\" in cbar_config:\n            kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n        if \"vmax\" in cbar_config:\n            kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n    for ch in self:\n        ax: Axes\n        _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n        if isinstance(_ax, Iterator):\n            ax = next(iter(_ax))\n        elif isinstance(_ax, Axes):\n            ax = _ax\n        else:\n            raise TypeError(\n                f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n            )\n        # Ignore type checks for display and Audio\n        display(ax.figure)  # type: ignore\n        plt.close(ax.figure)  # type: ignore\n        display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.fft","title":"<code>fft(n_fft=None, window='hann')</code>","text":"<p>Compute Fast Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is next power of 2 of data length.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the FFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n    \"\"\"Compute Fast Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is next power of 2 of data length.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectralFrame containing the FFT results.\n    \"\"\"\n    from ..processing.time_series import FFT\n    from .spectral import SpectralFrame\n\n    params = {\"n_fft\": n_fft, \"window\": window}\n    operation_name = \"fft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"FFT\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    if n_fft is None:\n        is_even = spectrum_data.shape[-1] % 2 == 0\n        _n_fft = (\n            spectrum_data.shape[-1] * 2 - 2\n            if is_even\n            else spectrum_data.shape[-1] * 2 - 1\n        )\n    else:\n        _n_fft = n_fft\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=_n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.from_file","title":"<code>from_file(path, channel=None, start=None, end=None, chunk_size=None, ch_labels=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from an audio file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the audio file.</p> required <code>channel</code> <code>Optional[Union[int, list[int]]]</code> <p>Channel(s) to load.</p> <code>None</code> <code>start</code> <code>Optional[float]</code> <p>Start time in seconds.</p> <code>None</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <code>chunk_size</code> <code>Optional[int]</code> <p>Chunk size for processing.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the file reader.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the loaded audio data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If channel selection is invalid.</p> <code>TypeError</code> <p>If channel parameter type is invalid.</p> <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    path: Union[str, Path],\n    channel: Optional[Union[int, list[int]]] = None,\n    start: Optional[float] = None,\n    end: Optional[float] = None,\n    chunk_size: Optional[int] = None,\n    ch_labels: Optional[list[str]] = None,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from an audio file.\n\n    Args:\n        path: Path to the audio file.\n        channel: Channel(s) to load.\n        start: Start time in seconds.\n        end: End time in seconds.\n        chunk_size: Chunk size for processing.\n        Specifies the splitting size for lazy processing.\n        ch_labels: Labels for each channel.\n        **kwargs: Additional arguments passed to the file reader.\n\n    Returns:\n        A new ChannelFrame containing the loaded audio data.\n\n    Raises:\n        ValueError: If channel selection is invalid.\n        TypeError: If channel parameter type is invalid.\n        FileNotFoundError: If the file doesn't exist.\n    \"\"\"\n    from .channel import ChannelFrame\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    # Get file reader\n    reader = get_file_reader(path)\n\n    # Get file info\n    info = reader.get_file_info(path, **kwargs)\n    sr = info[\"samplerate\"]\n    n_channels = info[\"channels\"]\n    n_frames = info[\"frames\"]\n    ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n    logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n    # Channel selection processing\n    all_channels = list(range(n_channels))\n\n    if channel is None:\n        channels_to_load = all_channels\n        logger.debug(f\"Will load all channels: {channels_to_load}\")\n    elif isinstance(channel, int):\n        if channel &lt; 0 or channel &gt;= n_channels:\n            raise ValueError(\n                f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n            )\n        channels_to_load = [channel]\n        logger.debug(f\"Will load single channel: {channel}\")\n    elif isinstance(channel, (list, tuple)):\n        for ch in channel:\n            if ch &lt; 0 or ch &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n        channels_to_load = list(channel)\n        logger.debug(f\"Will load specific channels: {channels_to_load}\")\n    else:\n        raise TypeError(\"channel must be int, list, or None\")\n\n    # Index calculation\n    start_idx = 0 if start is None else max(0, int(start * sr))\n    end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n    frames_to_read = end_idx - start_idx\n\n    logger.debug(\n        f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n        f\"start_idx={start_idx}, end_idx={end_idx}\"\n    )\n\n    # Settings for lazy loading\n    expected_shape = (len(channels_to_load), frames_to_read)\n\n    # Define the loading function using the file reader\n    def _load_audio() -&gt; NDArrayReal:\n        logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n        # Use the reader to get audio data with parameters\n        out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n        if not isinstance(out, np.ndarray):\n            raise ValueError(\"Unexpected data type after reading file\")\n        return out\n\n    logger.debug(\n        f\"Creating delayed dask task with expected shape: {expected_shape}\"\n    )\n\n    # Create delayed operation\n    delayed_data = dask_delayed(_load_audio)()\n    logger.debug(\"Wrapping delayed function in dask array\")\n\n    # Create dask array from delayed computation\n    dask_array = da_from_delayed(\n        delayed_data, shape=expected_shape, dtype=np.float32\n    )\n\n    if chunk_size is not None:\n        if chunk_size &lt;= 0:\n            raise ValueError(\"Chunk size must be a positive integer\")\n        logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n        dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n    logger.debug(\n        \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n    )\n\n    cf = ChannelFrame(\n        data=dask_array,\n        sampling_rate=sr,\n        label=path.stem,\n        metadata={\n            \"filename\": str(path),\n        },\n    )\n    if ch_labels is not None:\n        if len(ch_labels) != len(cf):\n            raise ValueError(\n                \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    return cf\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.from_ndarray","title":"<code>from_ndarray(array, sampling_rate, labels=None, unit=None, frame_label=None, metadata=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>This method is deprecated. Use from_numpy instead.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>NDArrayReal</code> <p>Signal data. Each row corresponds to a channel.</p> required <code>sampling_rate</code> <code>float</code> <p>Sampling rate (Hz).</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>unit</code> <code>Optional[Union[list[str], str]]</code> <p>Unit of the signal.</p> <code>None</code> <code>frame_label</code> <code>Optional[str]</code> <p>Label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_ndarray(\n    cls,\n    array: NDArrayReal,\n    sampling_rate: float,\n    labels: Optional[list[str]] = None,\n    unit: Optional[Union[list[str], str]] = None,\n    frame_label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    This method is deprecated. Use from_numpy instead.\n\n    Args:\n        array: Signal data. Each row corresponds to a channel.\n        sampling_rate: Sampling rate (Hz).\n        labels: Labels for each channel.\n        unit: Unit of the signal.\n        frame_label: Label for the frame.\n        metadata: Optional metadata dictionary.\n\n    Returns:\n        A new ChannelFrame containing the data.\n    \"\"\"\n    # Redirect to from_numpy for compatibility\n    # However, from_ndarray is deprecated\n    logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n    return cls.from_numpy(\n        data=array,\n        sampling_rate=sampling_rate,\n        label=frame_label,\n        metadata=metadata,\n        ch_labels=labels,\n        ch_units=unit,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.from_numpy","title":"<code>from_numpy(data, sampling_rate, label=None, metadata=None, ch_labels=None, ch_units=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArrayReal</code> <p>NumPy array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>ch_units</code> <code>Optional[Union[list[str], str]]</code> <p>Units for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the NumPy data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_numpy(\n    cls,\n    data: NDArrayReal,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    ch_labels: Optional[list[str]] = None,\n    ch_units: Optional[Union[list[str], str]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    Args:\n        data: NumPy array containing channel data.\n        sampling_rate: The sampling rate in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        ch_labels: Labels for each channel.\n        ch_units: Units for each channel.\n\n    Returns:\n        A new ChannelFrame containing the NumPy data.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n\n    # Convert NumPy array to dask array\n    dask_data = da_from_array(data)\n    cf = ChannelFrame(\n        data=dask_data,\n        sampling_rate=sampling_rate,\n        label=label or \"numpy_data\",\n    )\n    if metadata is not None:\n        cf.metadata = metadata\n    if ch_labels is not None:\n        if len(ch_labels) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel labels does not match the number of channels\"\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    if ch_units is not None:\n        if isinstance(ch_units, str):\n            ch_units = [ch_units] * cf.n_channels\n\n        if len(ch_units) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel units does not match the number of channels\"\n            )\n        for i in range(len(ch_units)):\n            cf._channel_metadata[i].unit = ch_units[i]\n\n    return cf\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.high_pass_filter","title":"<code>high_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a high-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a high-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.hpss_harmonic","title":"<code>hpss_harmonic(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract harmonic components using HPSS  (Harmonic-Percussive Source Separation).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_harmonic(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract harmonic components using HPSS\n     (Harmonic-Percussive Source Separation).\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_harmonic\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.hpss_percussive","title":"<code>hpss_percussive(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract percussive components using HPSS (Harmonic-Percussive Source Separation).</p> <p>This method separates the percussive (tonal) components from the signal.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Union[_IntLike_co, tuple[_IntLike_co, _IntLike_co], list[_IntLike_co]]</code> <p>Median filter size for HPSS.</p> <code>31</code> <code>power</code> <code>float</code> <p>Exponent for the Weiner filter used in HPSS.</p> <code>2</code> <code>margin</code> <code>Union[_FloatLike_co, tuple[_FloatLike_co, _FloatLike_co], list[_FloatLike_co]]</code> <p>Margin size for the separation.</p> <code>1</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the harmonic components.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_percussive(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract percussive components using HPSS\n    (Harmonic-Percussive Source Separation).\n\n    This method separates the percussive (tonal) components from the signal.\n\n    Args:\n        kernel_size: Median filter size for HPSS.\n        power: Exponent for the Weiner filter used in HPSS.\n        margin: Margin size for the separation.\n\n    Returns:\n        A new ChannelFrame containing the harmonic components.\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_percussive\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.low_pass_filter","title":"<code>low_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a low-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a low-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.mean","title":"<code>mean()</code>","text":"<p>Average all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with averaged signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def mean(self) -&gt; \"ChannelFrame\":\n    \"\"\"Average all channels.\n\n    Returns:\n        A new ChannelFrame with averaged signal.\n    \"\"\"\n    return self.apply_operation(\"mean\")\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.noct_spectrum","title":"<code>noct_spectrum(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Compute N-octave band spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>fmin</code> <code>float</code> <p>Minimum center frequency in Hz. Default is 20 Hz.</p> required <code>fmax</code> <code>float</code> <p>Maximum center frequency in Hz. Default is 20000 Hz.</p> required <code>n</code> <code>int</code> <p>Band division (1 for octave, 3 for 1/3 octave). Default is 3.</p> <code>3</code> <code>G</code> <code>int</code> <p>Reference gain in dB. Default is 10 dB.</p> <code>10</code> <code>fr</code> <code>int</code> <p>Reference frequency in Hz. Default is 1000 Hz.</p> <code>1000</code> <p>Returns:</p> Type Description <code>NOctFrame</code> <p>A NOctFrame containing the N-octave band spectrum.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def noct_spectrum(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"Compute N-octave band spectrum.\n\n    Args:\n        fmin: Minimum center frequency in Hz. Default is 20 Hz.\n        fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n        n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n        G: Reference gain in dB. Default is 10 dB.\n        fr: Reference frequency in Hz. Default is 1000 Hz.\n\n    Returns:\n        A NOctFrame containing the N-octave band spectrum.\n    \"\"\"\n    from ..processing.time_series import NOctSpectrum\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_spectrum\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSpectrum\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_spectrum\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.normalize","title":"<code>normalize(target_level=-20, channel_wise=True)</code>","text":"<p>Normalize the signal level.</p> <p>This method adjusts the signal amplitude to reach a target RMS level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target RMS level in dB. Default is -20.</p> <code>-20</code> <code>channel_wise</code> <code>bool</code> <p>If True, normalize each channel independently. If False, apply the same scaling to all channels.</p> <code>True</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the normalized signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def normalize(\n    self, target_level: float = -20, channel_wise: bool = True\n) -&gt; \"ChannelFrame\":\n    \"\"\"Normalize the signal level.\n\n    This method adjusts the signal amplitude to reach a target RMS level.\n\n    Args:\n        target_level: Target RMS level in dB. Default is -20.\n        channel_wise: If True, normalize each channel independently.\n            If False, apply the same scaling to all channels.\n\n    Returns:\n        A new ChannelFrame containing the normalized signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n    )\n    return self.apply_operation(\n        \"normalize\", target_level=target_level, channel_wise=channel_wise\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.plot","title":"<code>plot(plot_type='waveform', ax=None, **kwargs)</code>","text":"<p>Plot the frame data.</p> <p>Parameters:</p> Name Type Description Default <code>plot_type</code> <code>str</code> <p>Type of plot. Default is \"waveform\".</p> <code>'waveform'</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def plot(\n    self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Plot the frame data.\n\n    Args:\n        plot_type: Type of plot. Default is \"waveform\".\n        ax: Optional matplotlib axes for plotting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    plot_strategy = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.power","title":"<code>power(exponent=2.0)</code>","text":"<p>Calculate the power of the signal.</p> <p>Parameters:</p> Name Type Description Default <code>exponent</code> <code>float</code> <p>The exponent to raise the signal to. Default is 2.0.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the signal raised to the power.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the power of the signal.\n\n    Args:\n        exponent: The exponent to raise the signal to. Default is 2.0.\n\n    Returns:\n        A new ChannelFrame containing the signal raised to the power.\n    \"\"\"\n    return self.apply_operation(\"power\", exponent=exponent)\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.read_csv","title":"<code>read_csv(filename, time_column=0, labels=None, delimiter=',', header=0)</code>  <code>classmethod</code>","text":"<p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.read_wav","title":"<code>read_wav(filename, labels=None)</code>  <code>classmethod</code>","text":"<p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.resampling","title":"<code>resampling(target_sr, **kwargs)</code>","text":"<p>Resample audio data.</p>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.resampling--parameters","title":"Parameters","text":"<p>target_sr : float     Target sampling rate (Hz) resample_type : str, optional     Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.) **kwargs : dict     Additional resampling parameters</p>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.resampling--returns","title":"Returns","text":"<p>ChannelFrame     Resampled channel frame</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def resampling(\n    self,\n    target_sr: float,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Resample audio data.\n\n    Parameters\n    ----------\n    target_sr : float\n        Target sampling rate (Hz)\n    resample_type : str, optional\n        Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n    **kwargs : dict\n        Additional resampling parameters\n\n    Returns\n    -------\n    ChannelFrame\n        Resampled channel frame\n    \"\"\"\n    return self.apply_operation(\n        \"resampling\",\n        target_sr=target_sr,\n        **kwargs,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.rms_plot","title":"<code>rms_plot(ax=None, title=None, overlay=True, Aw=False, **kwargs)</code>","text":"<p>Generate an RMS plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title for the plot.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay the plot on the existing axis.</p> <code>True</code> <code>Aw</code> <code>bool</code> <p>Apply A-weighting.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_plot(\n    self,\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = True,\n    Aw: bool = False,  # noqa: N803\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Generate an RMS plot.\n\n    Args:\n        ax: Optional matplotlib axes for plotting.\n        title: Title for the plot.\n        overlay: Whether to overlay the plot on the existing axis.\n        Aw: Apply A-weighting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    kwargs = kwargs or {}\n    ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n    rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n    return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.rms_trend","title":"<code>rms_trend(frame_length=2048, hop_length=512, dB=False, Aw=False)</code>","text":"<p>Calculate the RMS trend of the signal.</p> <p>This method computes the root mean square value over sliding windows.</p> <p>Parameters:</p> Name Type Description Default <code>frame_length</code> <code>int</code> <p>The size of the sliding window in samples. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>int</code> <p>The hop length between windows in samples. Default is 512.</p> <code>512</code> <code>dB</code> <code>bool</code> <p>Whether to return the RMS values in decibels. Default is False.</p> <code>False</code> <code>Aw</code> <code>bool</code> <p>Whether to apply A-weighting. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the RMS trend.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_trend(\n    self,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the RMS trend of the signal.\n\n    This method computes the root mean square value over sliding windows.\n\n    Args:\n        frame_length: The size of the sliding window in samples. Default is 2048.\n        hop_length: The hop length between windows in samples. Default is 512.\n        dB: Whether to return the RMS values in decibels. Default is False.\n        Aw: Whether to apply A-weighting. Default is False.\n\n    Returns:\n        A new ChannelFrame containing the RMS trend.\n    \"\"\"\n    cf = self.apply_operation(\n        \"rms_trend\",\n        frame_length=frame_length,\n        hop_length=hop_length,\n        ref=[ch.ref for ch in self._channel_metadata],\n        dB=dB,\n        Aw=Aw,\n    )\n    cf.sampling_rate = self.sampling_rate / hop_length\n    return cf\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.save","title":"<code>save(path, format=None)</code>","text":"<p>Save the audio data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n    data = self.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    sf.write(str(path), data, int(self.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {path}\")\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.stft","title":"<code>stft(n_fft=2048, hop_length=None, win_length=None, window='hann')</code>","text":"<p>Compute Short-Time Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectrogramFrame</code> <p>A SpectrogramFrame containing the STFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def stft(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n) -&gt; \"SpectrogramFrame\":\n    \"\"\"Compute Short-Time Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectrogramFrame containing the STFT results.\n    \"\"\"\n    from ..processing.time_series import STFT, create_operation\n    from .spectrogram import SpectrogramFrame\n\n    # Set hop length and window length\n    _hop_length = hop_length if hop_length is not None else n_fft // 4\n    _win_length = win_length if win_length is not None else n_fft\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": _hop_length,\n        \"win_length\": _win_length,\n        \"window\": window,\n    }\n    operation_name = \"stft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"STFT\", operation)\n\n    # Apply processing to data\n    spectrogram_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n\n    # Create new instance\n    return SpectrogramFrame(\n        data=spectrogram_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=n_fft,\n        hop_length=_hop_length,\n        win_length=_win_length,\n        window=window,\n        label=f\"stft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.sum","title":"<code>sum()</code>","text":"<p>Sum all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with summed signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def sum(self) -&gt; \"ChannelFrame\":\n    \"\"\"Sum all channels.\n\n    Returns:\n        A new ChannelFrame with summed signal.\n    \"\"\"\n    return self.apply_operation(\"sum\")\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.transfer_function","title":"<code>transfer_function(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute transfer function matrix.</p> <p>The transfer function characterizes the signal transmission properties between channels in the frequency domain, representing the input-output relationship of a system.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the transfer function matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def transfer_function(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute transfer function matrix.\n\n    The transfer function characterizes the signal transmission properties\n    between channels in the frequency domain, representing the input-output\n    relationship of a system.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the transfer function matrix.\n    \"\"\"\n    from ..processing.time_series import TransferFunction, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"transfer_function\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"TransferFunction\", operation)\n\n    # Apply processing to data\n    tf_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=tf_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Transfer function of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.trim","title":"<code>trim(start=0, end=None)</code>","text":"<p>Trim the signal to specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>Start time in seconds.</p> <code>0</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with trimmed signal.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If end time is before start time.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def trim(\n    self,\n    start: float = 0,\n    end: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Trim the signal to specified time range.\n\n    Args:\n        start: Start time in seconds.\n        end: End time in seconds.\n\n    Returns:\n        A new ChannelFrame with trimmed signal.\n\n    Raises:\n        ValueError: If end time is before start time.\n    \"\"\"\n    if end is None:\n        end = self.duration\n    if start &gt; end:\n        raise ValueError(\"start must be less than end\")\n    # Apply trim operation\n    return self.apply_operation(\"trim\", start=start, end=end)\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.welch","title":"<code>welch(n_fft=None, hop_length=None, win_length=2048, window='hann', average='mean')</code>","text":"<p>Compute power spectral density using Welch's method.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is 2048.</p> <code>None</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>int</code> <p>Length of window. Default is n_fft.</p> <code>2048</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the power spectral density.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def welch(\n    self,\n    n_fft: Optional[int] = None,\n    hop_length: Optional[int] = None,\n    win_length: int = 2048,\n    window: str = \"hann\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute power spectral density using Welch's method.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the power spectral density.\n    \"\"\"\n    from ..processing.time_series import Welch\n    from .spectral import SpectralFrame\n\n    params = dict(\n        n_fft=n_fft or win_length,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        average=average,\n    )\n    operation_name = \"welch\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Welch\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"welch\", \"params\": params},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/#inputoutput-io","title":"Input/Output (I/O)","text":"<p>Wandas provides various methods to read audio files and CSV files.</p>"},{"location":"en/api/#wav-file-operations","title":"WAV File Operations","text":"<pre><code># Reading WAV files\nfrom wandas.frames.channel import ChannelFrame\nframe = ChannelFrame.read_wav(\"audio.wav\")\n\n# Or using direct import\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")\n\n# Writing WAV files\nframe.save(\"output.wav\")\n</code></pre> <p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre> <p>Save the audio data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n    data = self.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    sf.write(str(path), data, int(self.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {path}\")\n</code></pre>"},{"location":"en/api/#csv-file-operations","title":"CSV File Operations","text":"<pre><code># Reading CSV files\nfrom wandas.frames.channel import ChannelFrame\nframe = ChannelFrame.read_csv(\"data.csv\")\n\n# Or using direct import\nimport wandas\nframe = wandas.read_csv(\"data.csv\")\n</code></pre> <p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"en/api/#signal-processing","title":"Signal Processing","text":"<p>Wandas provides various signal processing functions.</p>"},{"location":"en/api/#wandas.processing.time_series.ABS","title":"<code>ABS</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Absolute value operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ABS(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Absolute value operation\"\"\"\n\n    name = \"abs\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize absolute value operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        return da.abs(data)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.ABS.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize absolute value operation</p>"},{"location":"en/api/#wandas.processing.time_series.ABS.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize absolute value operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AWeighting","title":"<code>AWeighting</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>A-weighting filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AWeighting(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"A-weighting filter operation\"\"\"\n\n    name = \"a_weighting\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize A-weighting filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for A-weighting filter\"\"\"\n        logger.debug(f\"Applying A-weighting to array with shape: {x.shape}\")\n        result = A_weight(x, self.sampling_rate)\n\n        # Handle case where A_weight returns a tuple\n        if isinstance(result, tuple):\n            # Use the first element of the tuple\n            result = result[0]\n\n        logger.debug(\n            f\"A-weighting applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AWeighting.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize A-weighting filter</p>"},{"location":"en/api/#wandas.processing.time_series.AWeighting.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize A-weighting filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AddWithSNR","title":"<code>AddWithSNR</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Addition operation considering SNR</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AddWithSNR(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Addition operation considering SNR\"\"\"\n\n    name = \"add_with_snr\"\n\n    def __init__(self, sampling_rate: float, other: DaArray, snr: float):\n        \"\"\"\n        Initialize addition operation considering SNR\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        other : DaArray\n            Noise signal to add (channel-frame format)\n        snr : float\n            Signal-to-noise ratio (dB)\n        \"\"\"\n        super().__init__(sampling_rate, other=other, snr=snr)\n\n        self.other = other\n        self.snr = snr\n        logger.debug(f\"Initialized AddWithSNR operation with SNR: {snr} dB\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape (same as input)\n        \"\"\"\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Perform addition processing considering SNR\"\"\"\n        logger.debug(f\"Applying SNR-based addition with shape: {x.shape}\")\n        other: NDArrayReal = self.other.compute()\n\n        # Use multi-channel versions of calculate_rms and calculate_desired_noise_rms\n        clean_rms = util.calculate_rms(x)\n        other_rms = util.calculate_rms(other)\n\n        # Adjust noise gain based on specified SNR (apply per channel)\n        desired_noise_rms = util.calculate_desired_noise_rms(clean_rms, self.snr)\n\n        # Apply gain per channel using broadcasting\n        gain = desired_noise_rms / other_rms\n        # Add adjusted noise to signal\n        result: NDArrayReal = x + other * gain\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AddWithSNR.__init__","title":"<code>__init__(sampling_rate, other, snr)</code>","text":"<p>Initialize addition operation considering SNR</p>"},{"location":"en/api/#wandas.processing.time_series.AddWithSNR.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) other : DaArray     Noise signal to add (channel-frame format) snr : float     Signal-to-noise ratio (dB)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, other: DaArray, snr: float):\n    \"\"\"\n    Initialize addition operation considering SNR\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    other : DaArray\n        Noise signal to add (channel-frame format)\n    snr : float\n        Signal-to-noise ratio (dB)\n    \"\"\"\n    super().__init__(sampling_rate, other=other, snr=snr)\n\n    self.other = other\n    self.snr = snr\n    logger.debug(f\"Initialized AddWithSNR operation with SNR: {snr} dB\")\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AddWithSNR.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.AddWithSNR.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/api/#wandas.processing.time_series.AddWithSNR.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (same as input)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape (same as input)\n    \"\"\"\n    return input_shape\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AudioOperation","title":"<code>AudioOperation</code>","text":"<p>               Bases: <code>Generic[InputArrayType, OutputArrayType]</code></p> <p>Abstract base class for audio processing operations.</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AudioOperation(Generic[InputArrayType, OutputArrayType]):\n    \"\"\"Abstract base class for audio processing operations.\"\"\"\n\n    # Class variable: operation name\n    name: ClassVar[str]\n\n    def __init__(self, sampling_rate: float, **params: Any):\n        \"\"\"\n        Initialize AudioOperation.\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        **params : Any\n            Operation-specific parameters\n        \"\"\"\n        self.sampling_rate = sampling_rate\n        self.params = params\n\n        # Validate parameters during initialization\n        self.validate_params()\n\n        # Create processor function (lazy initialization possible)\n        self._setup_processor()\n\n        logger.debug(\n            f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n        )\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n        pass\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up processor function (implemented by subclasses)\"\"\"\n        pass\n\n    def _process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function (implemented by subclasses)\"\"\"\n        # Default is no-op function\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    @dask.delayed  # type: ignore [misc, unused-ignore]\n    def process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n        # Default is no-op function\n        logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n        return self._process_array(x)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation (implemented by subclasses)\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        \"\"\"\n        Execute operation and return result\n        data shape is (channels, samples)\n        \"\"\"\n        # Add task as delayed processing\n        logger.debug(\"Adding delayed operation to computation graph\")\n        delayed_result = self.process_array(data)\n        # Convert delayed result to dask array and return\n        output_shape = self.calculate_output_shape(data.shape)\n        return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AudioOperation.__init__","title":"<code>__init__(sampling_rate, **params)</code>","text":"<p>Initialize AudioOperation.</p>"},{"location":"en/api/#wandas.processing.time_series.AudioOperation.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) **params : Any     Operation-specific parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, **params: Any):\n    \"\"\"\n    Initialize AudioOperation.\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    **params : Any\n        Operation-specific parameters\n    \"\"\"\n    self.sampling_rate = sampling_rate\n    self.params = params\n\n    # Validate parameters during initialization\n    self.validate_params()\n\n    # Create processor function (lazy initialization possible)\n    self._setup_processor()\n\n    logger.debug(\n        f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n    )\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AudioOperation.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation (implemented by subclasses)</p>"},{"location":"en/api/#wandas.processing.time_series.AudioOperation.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/api/#wandas.processing.time_series.AudioOperation.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation (implemented by subclasses)\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AudioOperation.process","title":"<code>process(data)</code>","text":"<p>Execute operation and return result data shape is (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    \"\"\"\n    Execute operation and return result\n    data shape is (channels, samples)\n    \"\"\"\n    # Add task as delayed processing\n    logger.debug(\"Adding delayed operation to computation graph\")\n    delayed_result = self.process_array(data)\n    # Convert delayed result to dask array and return\n    output_shape = self.calculate_output_shape(data.shape)\n    return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AudioOperation.process_array","title":"<code>process_array(x)</code>","text":"<p>Processing function wrapped with @dask.delayed</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>@dask.delayed  # type: ignore [misc, unused-ignore]\ndef process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n    \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n    # Default is no-op function\n    logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n    return self._process_array(x)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AudioOperation.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters (raises exception if invalid)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n    pass\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.CSD","title":"<code>CSD</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Cross-spectral density estimation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class CSD(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Cross-spectral density estimation operation\"\"\"\n\n    name = \"csd\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n        scaling: str,\n        average: str,\n    ):\n        \"\"\"\n        Initialize cross-spectral density estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        scaling : str\n            Type of scaling\n        average : str\n            Method of averaging\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        self.scaling = scaling\n        self.average = average\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n            scaling=scaling,\n            average=average,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Processor function for cross-spectral density estimation operation\"\"\"\n        logger.debug(f\"Applying CSD estimation to array with shape: {x.shape}\")\n        from scipy import signal as ss\n\n        # Calculate all combinations using scipy's csd function\n        _, csd_result = ss.csd(\n            x=x[:, np.newaxis],\n            y=x[np.newaxis, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n        )\n\n        # Reshape result to (n_channels * n_channels, n_freqs)\n        result: NDArrayComplex = csd_result.transpose(1, 0, 2).reshape(\n            -1, csd_result.shape[-1]\n        )\n\n        logger.debug(f\"CSD estimation applied, result shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.CSD.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend, scaling, average)</code>","text":"<p>Initialize cross-spectral density estimation operation</p>"},{"location":"en/api/#wandas.processing.time_series.CSD.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend scaling : str     Type of scaling average : str     Method of averaging</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n    scaling: str,\n    average: str,\n):\n    \"\"\"\n    Initialize cross-spectral density estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    scaling : str\n        Type of scaling\n    average : str\n        Method of averaging\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    self.scaling = scaling\n    self.average = average\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n        scaling=scaling,\n        average=average,\n    )\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.CSD.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.CSD.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/api/#wandas.processing.time_series.CSD.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.ChannelDifference","title":"<code>ChannelDifference</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Channel difference calculation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ChannelDifference(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Channel difference calculation operation\"\"\"\n\n    name = \"channel_difference\"\n    other_channel: int\n\n    def __init__(self, sampling_rate: float, other_channel: int = 0):\n        \"\"\"\n        Initialize channel difference calculation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        other_channel : int\n            Channel to calculate difference with, default is 0\n        \"\"\"\n        self.other_channel = other_channel\n        super().__init__(sampling_rate, other_channel=other_channel)\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        result = data - data[self.other_channel]\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.ChannelDifference.__init__","title":"<code>__init__(sampling_rate, other_channel=0)</code>","text":"<p>Initialize channel difference calculation</p>"},{"location":"en/api/#wandas.processing.time_series.ChannelDifference.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) other_channel : int     Channel to calculate difference with, default is 0</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, other_channel: int = 0):\n    \"\"\"\n    Initialize channel difference calculation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    other_channel : int\n        Channel to calculate difference with, default is 0\n    \"\"\"\n    self.other_channel = other_channel\n    super().__init__(sampling_rate, other_channel=other_channel)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Coherence","title":"<code>Coherence</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Coherence estimation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Coherence(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Coherence estimation operation\"\"\"\n\n    name = \"coherence\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n    ):\n        \"\"\"\n        Initialize coherence estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Processor function for coherence estimation operation\"\"\"\n        logger.debug(f\"Applying coherence estimation to array with shape: {x.shape}\")\n        from scipy import signal as ss\n\n        _, coh = ss.coherence(\n            x=x[:, np.newaxis],\n            y=x[np.newaxis, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n        )\n\n        # Reshape result to (n_channels * n_channels, n_freqs)\n        result: NDArrayReal = coh.transpose(1, 0, 2).reshape(-1, coh.shape[-1])\n\n        logger.debug(f\"Coherence estimation applied, result shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Coherence.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend)</code>","text":"<p>Initialize coherence estimation operation</p>"},{"location":"en/api/#wandas.processing.time_series.Coherence.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n):\n    \"\"\"\n    Initialize coherence estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n    )\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Coherence.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.Coherence.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/api/#wandas.processing.time_series.Coherence.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.FFT","title":"<code>FFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>FFT (Fast Fourier Transform) operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class FFT(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"FFT (Fast Fourier Transform) operation\"\"\"\n\n    name = \"fft\"\n    n_fft: Optional[int]\n    window: str\n\n    def __init__(\n        self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n    ):\n        \"\"\"\n        Initialize FFT operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int, optional\n            FFT size, default is None (determined by input size)\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(sampling_rate, n_fft=n_fft, window=window)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        \u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059\n\n        Parameters\n        ----------\n        input_shape : tuple\n            \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)\n\n        Returns\n        -------\n        tuple\n            \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)\n        \"\"\"\n        n_freqs = self.n_fft // 2 + 1 if self.n_fft else input_shape[-1] // 2 + 1\n        return (*input_shape[:-1], n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"FFT\u64cd\u4f5c\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u95a2\u6570\u3092\u4f5c\u6210\"\"\"\n        from scipy.signal import get_window\n\n        win = get_window(self.window, x.shape[-1])\n        x = x * win\n        result: NDArrayComplex = np.fft.rfft(x, n=self.n_fft, axis=-1)\n        result[..., 1:-1] *= 2.0\n        # \u7a93\u95a2\u6570\u88dc\u6b63\n        scaling_factor = np.sum(win)\n        result = result / scaling_factor\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.FFT.__init__","title":"<code>__init__(sampling_rate, n_fft=None, window='hann')</code>","text":"<p>Initialize FFT operation</p>"},{"location":"en/api/#wandas.processing.time_series.FFT.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int, optional     FFT size, default is None (determined by input size) window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n):\n    \"\"\"\n    Initialize FFT operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int, optional\n        FFT size, default is None (determined by input size)\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(sampling_rate, n_fft=n_fft, window=window)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.FFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>\u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059</p>"},{"location":"en/api/#wandas.processing.time_series.FFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)</p>"},{"location":"en/api/#wandas.processing.time_series.FFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    \u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059\n\n    Parameters\n    ----------\n    input_shape : tuple\n        \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)\n\n    Returns\n    -------\n    tuple\n        \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)\n    \"\"\"\n    n_freqs = self.n_fft // 2 + 1 if self.n_fft else input_shape[-1] // 2 + 1\n    return (*input_shape[:-1], n_freqs)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.HighPassFilter","title":"<code>HighPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>High-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HighPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"High-pass filter operation\"\"\"\n\n    name = \"highpass_filter\"\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize high-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            limit = self.sampling_rate / 2\n            raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up high-pass filter processor\"\"\"\n        # Calculate filter coefficients (once) - safely retrieve from instance variables\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"high\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Highpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying highpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.HighPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize high-pass filter</p>"},{"location":"en/api/#wandas.processing.time_series.HighPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize high-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.HighPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        limit = self.sampling_rate / 2\n        raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.HpssHarmonic","title":"<code>HpssHarmonic</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>HPSS Harmonic operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HpssHarmonic(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"HPSS Harmonic operation\"\"\"\n\n    name = \"hpss_harmonic\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize HPSS Harmonic\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        self.kwargs = kwargs\n        super().__init__(sampling_rate, **kwargs)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for HPSS Harmonic\"\"\"\n        logger.debug(f\"Applying HPSS Harmonic to array with shape: {x.shape}\")\n        result = librosa.effects.harmonic(x, **self.kwargs)\n        logger.debug(\n            f\"HPSS Harmonic applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.HpssHarmonic.__init__","title":"<code>__init__(sampling_rate, **kwargs)</code>","text":"<p>Initialize HPSS Harmonic</p>"},{"location":"en/api/#wandas.processing.time_series.HpssHarmonic.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize HPSS Harmonic\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    self.kwargs = kwargs\n    super().__init__(sampling_rate, **kwargs)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.HpssPercussive","title":"<code>HpssPercussive</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>HPSS Percussive operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HpssPercussive(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"HPSS Percussive operation\"\"\"\n\n    name = \"hpss_percussive\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize HPSS Percussive\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        self.kwargs = kwargs\n        super().__init__(sampling_rate, **kwargs)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for HPSS Percussive\"\"\"\n        logger.debug(f\"Applying HPSS Percussive to array with shape: {x.shape}\")\n        result = librosa.effects.percussive(x, **self.kwargs)\n        logger.debug(\n            f\"HPSS Percussive applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.HpssPercussive.__init__","title":"<code>__init__(sampling_rate, **kwargs)</code>","text":"<p>Initialize HPSS Percussive</p>"},{"location":"en/api/#wandas.processing.time_series.HpssPercussive.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize HPSS Percussive\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    self.kwargs = kwargs\n    super().__init__(sampling_rate, **kwargs)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.IFFT","title":"<code>IFFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayComplex, NDArrayReal]</code></p> <p>IFFT (Inverse Fast Fourier Transform) operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class IFFT(AudioOperation[NDArrayComplex, NDArrayReal]):\n    \"\"\"IFFT (Inverse Fast Fourier Transform) operation\"\"\"\n\n    name = \"ifft\"\n    n_fft: Optional[int]\n    window: str\n\n    def __init__(\n        self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n    ):\n        \"\"\"\n        Initialize IFFT operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : Optional[int], optional\n            IFFT size, default is None (determined based on input size)\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(sampling_rate, n_fft=n_fft, window=window)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, freqs)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, samples)\n        \"\"\"\n        n_samples = 2 * (input_shape[-1] - 1) if self.n_fft is None else self.n_fft\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayComplex) -&gt; NDArrayReal:\n        \"\"\"Create processor function for IFFT operation\"\"\"\n        logger.debug(f\"Applying IFFT to array with shape: {x.shape}\")\n\n        # Restore frequency component scaling (remove the 2.0 multiplier applied in FFT)\n        _x = x.copy()\n        _x[..., 1:-1] /= 2.0\n\n        # Execute IFFT\n        result: NDArrayReal = np.fft.irfft(_x, n=self.n_fft, axis=-1)\n\n        # Window function correction (inverse of FFT operation)\n        from scipy.signal import get_window\n\n        win = get_window(self.window, result.shape[-1])\n\n        # Correct the FFT window function scaling\n        scaling_factor = np.sum(win) / result.shape[-1]\n        result = result / scaling_factor\n\n        logger.debug(f\"IFFT applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.IFFT.__init__","title":"<code>__init__(sampling_rate, n_fft=None, window='hann')</code>","text":"<p>Initialize IFFT operation</p>"},{"location":"en/api/#wandas.processing.time_series.IFFT.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : Optional[int], optional     IFFT size, default is None (determined based on input size) window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n):\n    \"\"\"\n    Initialize IFFT operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : Optional[int], optional\n        IFFT size, default is None (determined based on input size)\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(sampling_rate, n_fft=n_fft, window=window)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.IFFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.IFFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, freqs)</p>"},{"location":"en/api/#wandas.processing.time_series.IFFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, freqs)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, samples)\n    \"\"\"\n    n_samples = 2 * (input_shape[-1] - 1) if self.n_fft is None else self.n_fft\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.ISTFT","title":"<code>ISTFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayComplex, NDArrayReal]</code></p> <p>Inverse Short-Time Fourier Transform operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ISTFT(AudioOperation[NDArrayComplex, NDArrayReal]):\n    \"\"\"Inverse Short-Time Fourier Transform operation\"\"\"\n\n    name = \"istft\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        length: Optional[int] = None,\n    ):\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.length = length\n\n        # Instantiate ShortTimeFFT for ISTFT calculation\n        self.SFT = ShortTimeFFT(\n            win=get_window(window, self.win_length),\n            hop=self.hop_length,\n            fs=sampling_rate,\n            mfft=self.n_fft,\n            scale_to=\"magnitude\",  # Consistent scaling with STFT\n        )\n\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n            length=length,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, freqs, time_frames)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, samples)\n        \"\"\"\n        k0: int = 0\n        q_max = input_shape[-1] + self.SFT.p_min\n        k_max = (q_max - 1) * self.SFT.hop + self.SFT.m_num - self.SFT.m_num_mid\n        k_q0, k_q1 = self.SFT.nearest_k_p(k0), self.SFT.nearest_k_p(k_max, left=False)\n        n_pts = k_q1 - k_q0 + self.SFT.m_num - self.SFT.m_num_mid\n\n        return input_shape[:-2] + (n_pts,)\n\n    def _process_array(self, x: NDArrayComplex) -&gt; NDArrayReal:\n        \"\"\"\n        Apply SciPy ISTFT processing to multiple channels at once using ShortTimeFFT\"\"\"\n        logger.debug(\n            f\"Applying SciPy ISTFT (ShortTimeFFT) to array with shape: {x.shape}\"\n        )\n\n        # Convert 2D input to 3D (assume single channel)\n        if x.ndim == 2:\n            x = x.reshape(1, *x.shape)\n\n        # Adjust scaling back if STFT applied factor of 2\n        _x = np.copy(x)\n        _x[..., 1:-1, :] /= 2.0\n\n        # Apply ISTFT using the ShortTimeFFT instance\n        result: NDArrayReal = self.SFT.istft(_x)\n\n        # Trim to desired length if specified\n        if self.length is not None:\n            result = result[..., : self.length]\n\n        logger.debug(\n            f\"ShortTimeFFT applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.ISTFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.ISTFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, freqs, time_frames)</p>"},{"location":"en/api/#wandas.processing.time_series.ISTFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, freqs, time_frames)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, samples)\n    \"\"\"\n    k0: int = 0\n    q_max = input_shape[-1] + self.SFT.p_min\n    k_max = (q_max - 1) * self.SFT.hop + self.SFT.m_num - self.SFT.m_num_mid\n    k_q0, k_q1 = self.SFT.nearest_k_p(k0), self.SFT.nearest_k_p(k_max, left=False)\n    n_pts = k_q1 - k_q0 + self.SFT.m_num - self.SFT.m_num_mid\n\n    return input_shape[:-2] + (n_pts,)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.LowPassFilter","title":"<code>LowPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Low-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class LowPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Low-pass filter operation\"\"\"\n\n    name = \"lowpass_filter\"\n    a: NDArrayReal\n    b: NDArrayReal\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize low-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            raise ValueError(\n                f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n            )\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up low-pass filter processor\"\"\"\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"low\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Lowpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying lowpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.LowPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize low-pass filter</p>"},{"location":"en/api/#wandas.processing.time_series.LowPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize low-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.LowPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        raise ValueError(\n            f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n        )\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Mean","title":"<code>Mean</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Mean calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Mean(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Mean calculation\"\"\"\n\n    name = \"mean\"\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # Use Dask's aggregate function directly without map_blocks\n        return data.mean(axis=0, keepdims=True)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.NOctSpectrum","title":"<code>NOctSpectrum</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>N-octave spectrum operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class NOctSpectrum(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"N-octave spectrum operation\"\"\"\n\n    name = \"noct_spectrum\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ):\n        \"\"\"\n        Initialize N-octave spectrum\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        fmin : float\n            Minimum frequency (Hz)\n        fmax : float\n            Maximum frequency (Hz)\n        n : int, optional\n            Number of octave divisions, default is 3\n        G : int, optional\n            Reference level, default is 10\n        fr : int, optional\n            Reference frequency, default is 1000\n        \"\"\"\n        super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n        self.fmin = fmin\n        self.fmax = fmax\n        self.n = n\n        self.G = G\n        self.fr = fr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate output shape for octave spectrum\n        _, fpref = _center_freq(\n            fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n        )\n        return (input_shape[0], fpref.shape[0])\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for octave spectrum\"\"\"\n        logger.debug(f\"Applying NoctSpectrum to array with shape: {x.shape}\")\n        spec, _ = noct_spectrum(\n            sig=x.T,\n            fs=self.sampling_rate,\n            fmin=self.fmin,\n            fmax=self.fmax,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        if spec.ndim == 1:\n            # Add channel dimension for 1D\n            spec = np.expand_dims(spec, axis=0)\n        else:\n            spec = spec.T\n        logger.debug(f\"NoctSpectrum applied, returning result with shape: {spec.shape}\")\n        return np.array(spec)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.NOctSpectrum.__init__","title":"<code>__init__(sampling_rate, fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Initialize N-octave spectrum</p>"},{"location":"en/api/#wandas.processing.time_series.NOctSpectrum.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) fmin : float     Minimum frequency (Hz) fmax : float     Maximum frequency (Hz) n : int, optional     Number of octave divisions, default is 3 G : int, optional     Reference level, default is 10 fr : int, optional     Reference frequency, default is 1000</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n):\n    \"\"\"\n    Initialize N-octave spectrum\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    fmin : float\n        Minimum frequency (Hz)\n    fmax : float\n        Maximum frequency (Hz)\n    n : int, optional\n        Number of octave divisions, default is 3\n    G : int, optional\n        Reference level, default is 10\n    fr : int, optional\n        Reference frequency, default is 1000\n    \"\"\"\n    super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n    self.fmin = fmin\n    self.fmax = fmax\n    self.n = n\n    self.G = G\n    self.fr = fr\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.NOctSpectrum.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.NOctSpectrum.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/api/#wandas.processing.time_series.NOctSpectrum.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate output shape for octave spectrum\n    _, fpref = _center_freq(\n        fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n    )\n    return (input_shape[0], fpref.shape[0])\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.NOctSynthesis","title":"<code>NOctSynthesis</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Octave synthesis operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class NOctSynthesis(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Octave synthesis operation\"\"\"\n\n    name = \"noct_synthesis\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ):\n        \"\"\"\n        Initialize octave synthesis\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        fmin : float\n            Minimum frequency (Hz)\n        fmax : float\n            Maximum frequency (Hz)\n        n : int, optional\n            Number of octave divisions, default is 3\n        G : int, optional\n            Reference level, default is 10\n        fr : int, optional\n            Reference frequency, default is 1000\n        \"\"\"\n        super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n\n        self.fmin = fmin\n        self.fmax = fmax\n        self.n = n\n        self.G = G\n        self.fr = fr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate output shape for octave spectrum\n        _, fpref = _center_freq(\n            fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n        )\n        return (input_shape[0], fpref.shape[0])\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for octave synthesis\"\"\"\n        logger.debug(f\"Applying NoctSynthesis to array with shape: {x.shape}\")\n        # Calculate n from shape[-1]\n        n = x.shape[-1]  # Calculate n from shape[-1]\n        if n % 2 == 0:\n            n = n * 2 - 1\n        else:\n            n = (n - 1) * 2\n        freqs = np.fft.rfftfreq(n, d=1 / self.sampling_rate)\n        result, _ = noct_synthesis(\n            spectrum=np.abs(x).T,\n            freqs=freqs,\n            fmin=self.fmin,\n            fmax=self.fmax,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        result = result.T\n        logger.debug(\n            f\"NoctSynthesis applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.NOctSynthesis.__init__","title":"<code>__init__(sampling_rate, fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Initialize octave synthesis</p>"},{"location":"en/api/#wandas.processing.time_series.NOctSynthesis.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) fmin : float     Minimum frequency (Hz) fmax : float     Maximum frequency (Hz) n : int, optional     Number of octave divisions, default is 3 G : int, optional     Reference level, default is 10 fr : int, optional     Reference frequency, default is 1000</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n):\n    \"\"\"\n    Initialize octave synthesis\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    fmin : float\n        Minimum frequency (Hz)\n    fmax : float\n        Maximum frequency (Hz)\n    n : int, optional\n        Number of octave divisions, default is 3\n    G : int, optional\n        Reference level, default is 10\n    fr : int, optional\n        Reference frequency, default is 1000\n    \"\"\"\n    super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n\n    self.fmin = fmin\n    self.fmax = fmax\n    self.n = n\n    self.G = G\n    self.fr = fr\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.NOctSynthesis.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.NOctSynthesis.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/api/#wandas.processing.time_series.NOctSynthesis.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate output shape for octave spectrum\n    _, fpref = _center_freq(\n        fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n    )\n    return (input_shape[0], fpref.shape[0])\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Power","title":"<code>Power</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Power operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Power(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Power operation\"\"\"\n\n    name = \"power\"\n\n    def __init__(self, sampling_rate: float, exponent: float):\n        \"\"\"\n        Initialize power operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        exponent : float\n            Power exponent\n        \"\"\"\n        super().__init__(sampling_rate)\n        self.exp = exponent\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        return da.power(data, self.exp)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Power.__init__","title":"<code>__init__(sampling_rate, exponent)</code>","text":"<p>Initialize power operation</p>"},{"location":"en/api/#wandas.processing.time_series.Power.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) exponent : float     Power exponent</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, exponent: float):\n    \"\"\"\n    Initialize power operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    exponent : float\n        Power exponent\n    \"\"\"\n    super().__init__(sampling_rate)\n    self.exp = exponent\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.ReSampling","title":"<code>ReSampling</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Resampling operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ReSampling(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Resampling operation\"\"\"\n\n    name = \"resampling\"\n\n    def __init__(self, sampling_rate: float, target_sr: float):\n        \"\"\"\n        Initialize resampling operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        target_sampling_rate : float\n            Target sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate, target_sr=target_sr)\n        self.target_sr = target_sr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after resampling\n        ratio = float(self.target_sr) / float(self.sampling_rate)\n        n_samples = int(np.ceil(input_shape[-1] * ratio))\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for resampling operation\"\"\"\n        logger.debug(f\"Applying resampling to array with shape: {x.shape}\")\n        result = librosa.resample(\n            x, orig_sr=self.sampling_rate, target_sr=self.target_sr\n        )\n        logger.debug(f\"Resampling applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.ReSampling.__init__","title":"<code>__init__(sampling_rate, target_sr)</code>","text":"<p>Initialize resampling operation</p>"},{"location":"en/api/#wandas.processing.time_series.ReSampling.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) target_sampling_rate : float     Target sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, target_sr: float):\n    \"\"\"\n    Initialize resampling operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    target_sampling_rate : float\n        Target sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate, target_sr=target_sr)\n    self.target_sr = target_sr\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.ReSampling.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.ReSampling.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/api/#wandas.processing.time_series.ReSampling.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after resampling\n    ratio = float(self.target_sr) / float(self.sampling_rate)\n    n_samples = int(np.ceil(input_shape[-1] * ratio))\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.RmsTrend","title":"<code>RmsTrend</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>RMS calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class RmsTrend(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"RMS calculation\"\"\"\n\n    name = \"rms_trend\"\n    frame_length: int\n    hop_length: int\n    Aw: bool\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        ref: Union[list[float], float] = 1.0,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; None:\n        \"\"\"\n        Initialize RMS calculation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        frame_length : int\n            Frame length, default is 2048\n        hop_length : int\n            Hop length, default is 512\n        ref : Union[list[float], float]\n            Reference value(s) for dB calculation\n        dB : bool\n            Whether to convert to decibels\n        Aw : bool\n            Whether to apply A-weighting before RMS calculation\n        \"\"\"\n        self.frame_length = frame_length\n        self.hop_length = hop_length\n        self.dB = dB\n        self.Aw = Aw\n        self.ref = np.array(ref if isinstance(ref, list) else [ref])\n        super().__init__(\n            sampling_rate,\n            frame_length=frame_length,\n            hop_length=hop_length,\n            dB=dB,\n            Aw=Aw,\n            ref=self.ref,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, frames)\n        \"\"\"\n        n_frames = librosa.feature.rms(\n            y=np.ones((1, input_shape[-1])),\n            frame_length=self.frame_length,\n            hop_length=self.hop_length,\n        ).shape[-1]\n        return (*input_shape[:-1], n_frames)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for RMS calculation\"\"\"\n        logger.debug(f\"Applying RMS to array with shape: {x.shape}\")\n\n        if self.Aw:\n            # Apply A-weighting\n            _x = A_weight(x, self.sampling_rate)\n            if isinstance(_x, np.ndarray):\n                # A_weight\u304c\u30bf\u30d7\u30eb\u3092\u8fd4\u3059\u5834\u5408\u3001\u6700\u521d\u306e\u8981\u7d20\u3092\u4f7f\u7528\n                x = _x\n            elif isinstance(_x, tuple):\n                # Use the first element if A_weight returns a tuple\n                x = _x[0]\n            else:\n                raise ValueError(\"A_weighting returned an unexpected type.\")\n\n        # Calculate RMS\n        result = librosa.feature.rms(\n            y=x, frame_length=self.frame_length, hop_length=self.hop_length\n        )[..., 0, :]\n\n        if self.dB:\n            # Convert to dB\n            result = 20 * np.log10(\n                np.maximum(result / self.ref[..., np.newaxis], 1e-12)\n            )\n        #\n        logger.debug(f\"RMS applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.RmsTrend.__init__","title":"<code>__init__(sampling_rate, frame_length=2048, hop_length=512, ref=1.0, dB=False, Aw=False)</code>","text":"<p>Initialize RMS calculation</p>"},{"location":"en/api/#wandas.processing.time_series.RmsTrend.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) frame_length : int     Frame length, default is 2048 hop_length : int     Hop length, default is 512 ref : Union[list[float], float]     Reference value(s) for dB calculation dB : bool     Whether to convert to decibels Aw : bool     Whether to apply A-weighting before RMS calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    ref: Union[list[float], float] = 1.0,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; None:\n    \"\"\"\n    Initialize RMS calculation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    frame_length : int\n        Frame length, default is 2048\n    hop_length : int\n        Hop length, default is 512\n    ref : Union[list[float], float]\n        Reference value(s) for dB calculation\n    dB : bool\n        Whether to convert to decibels\n    Aw : bool\n        Whether to apply A-weighting before RMS calculation\n    \"\"\"\n    self.frame_length = frame_length\n    self.hop_length = hop_length\n    self.dB = dB\n    self.Aw = Aw\n    self.ref = np.array(ref if isinstance(ref, list) else [ref])\n    super().__init__(\n        sampling_rate,\n        frame_length=frame_length,\n        hop_length=hop_length,\n        dB=dB,\n        Aw=Aw,\n        ref=self.ref,\n    )\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.RmsTrend.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.RmsTrend.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/api/#wandas.processing.time_series.RmsTrend.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, frames)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, frames)\n    \"\"\"\n    n_frames = librosa.feature.rms(\n        y=np.ones((1, input_shape[-1])),\n        frame_length=self.frame_length,\n        hop_length=self.hop_length,\n    ).shape[-1]\n    return (*input_shape[:-1], n_frames)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.STFT","title":"<code>STFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Short-Time Fourier Transform operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class STFT(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Short-Time Fourier Transform operation\"\"\"\n\n    name = \"stft\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ):\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.noverlap = (\n            self.win_length - self.hop_length if hop_length is not None else None\n        )\n        self.window = window\n\n        self.SFT = ShortTimeFFT(\n            win=get_window(window, self.win_length),\n            hop=self.hop_length,\n            fs=sampling_rate,\n            mfft=self.n_fft,\n            scale_to=\"magnitude\",\n        )\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        n_samples = input_shape[-1]\n        n_f = len(self.SFT.f)\n        n_t = len(self.SFT.t(n_samples))\n        return (input_shape[0], n_f, n_t)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Apply SciPy STFT processing to multiple channels at once\"\"\"\n        logger.debug(f\"Applying SciPy STFT to array with shape: {x.shape}\")\n\n        # Convert 1D input to 2D\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n\n        # Apply STFT to all channels at once\n        result: NDArrayComplex = self.SFT.stft(x)\n        result[..., 1:-1, :] *= 2.0\n        logger.debug(f\"SciPy STFT applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.STFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.STFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/api/#wandas.processing.time_series.STFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    n_samples = input_shape[-1]\n    n_f = len(self.SFT.f)\n    n_t = len(self.SFT.t(n_samples))\n    return (input_shape[0], n_f, n_t)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Sum","title":"<code>Sum</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Sum calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Sum(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Sum calculation\"\"\"\n\n    name = \"sum\"\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # Use Dask's aggregate function directly without map_blocks\n        return data.sum(axis=0, keepdims=True)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.TransferFunction","title":"<code>TransferFunction</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Transfer function estimation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class TransferFunction(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Transfer function estimation operation\"\"\"\n\n    name = \"transfer_function\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ):\n        \"\"\"\n        Initialize transfer function estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        scaling : str\n            Type of scaling\n        average : str\n            Method of averaging\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        self.scaling = scaling\n        self.average = average\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n            scaling=scaling,\n            average=average,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Processor function for transfer function estimation operation\"\"\"\n        logger.debug(\n            f\"Applying transfer function estimation to array with shape: {x.shape}\"\n        )\n        from scipy import signal as ss\n\n        # Calculate cross-spectral density between all channels\n        f, p_yx = ss.csd(\n            x=x[:, np.newaxis, :],\n            y=x[np.newaxis, :, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n            axis=-1,\n        )\n        # p_yx shape: (num_channels, num_channels, num_frequencies)\n\n        # Calculate power spectral density for each channel\n        f, p_xx = ss.welch(\n            x=x,\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n            axis=-1,\n        )\n        # p_xx shape: (num_channels, num_frequencies)\n\n        # Calculate transfer function H(f) = P_yx / P_xx\n        h_f = p_yx / p_xx[np.newaxis, :, :]\n        result: NDArrayComplex = h_f.transpose(1, 0, 2).reshape(-1, h_f.shape[-1])\n\n        logger.debug(\n            f\"Transfer function estimation applied, result shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.TransferFunction.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend, scaling='spectrum', average='mean')</code>","text":"<p>Initialize transfer function estimation operation</p>"},{"location":"en/api/#wandas.processing.time_series.TransferFunction.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend scaling : str     Type of scaling average : str     Method of averaging</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n):\n    \"\"\"\n    Initialize transfer function estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    scaling : str\n        Type of scaling\n    average : str\n        Method of averaging\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    self.scaling = scaling\n    self.average = average\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n        scaling=scaling,\n        average=average,\n    )\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.TransferFunction.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.TransferFunction.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/api/#wandas.processing.time_series.TransferFunction.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Trim","title":"<code>Trim</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Trimming operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Trim(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Trimming operation\"\"\"\n\n    name = \"trim\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        start: float,\n        end: float,\n    ):\n        \"\"\"\n        Initialize trimming operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        start : float\n            Start time for trimming (seconds)\n        end : float\n            End time for trimming (seconds)\n        \"\"\"\n        super().__init__(sampling_rate, start=start, end=end)\n        self.start = start\n        self.end = end\n        self.start_sample = int(start * sampling_rate)\n        self.end_sample = int(end * sampling_rate)\n        logger.debug(\n            f\"Initialized Trim operation with start: {self.start}, end: {self.end}\"\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after trimming\n        # Exclude parts where there is no signal\n        end_sample = min(self.end_sample, input_shape[-1])\n        n_samples = end_sample - self.start_sample\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for trimming operation\"\"\"\n        logger.debug(f\"Applying trim to array with shape: {x.shape}\")\n        # Apply trimming\n        result = x[..., self.start_sample : self.end_sample]\n        logger.debug(f\"Trim applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Trim.__init__","title":"<code>__init__(sampling_rate, start, end)</code>","text":"<p>Initialize trimming operation</p>"},{"location":"en/api/#wandas.processing.time_series.Trim.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) start : float     Start time for trimming (seconds) end : float     End time for trimming (seconds)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    start: float,\n    end: float,\n):\n    \"\"\"\n    Initialize trimming operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    start : float\n        Start time for trimming (seconds)\n    end : float\n        End time for trimming (seconds)\n    \"\"\"\n    super().__init__(sampling_rate, start=start, end=end)\n    self.start = start\n    self.end = end\n    self.start_sample = int(start * sampling_rate)\n    self.end_sample = int(end * sampling_rate)\n    logger.debug(\n        f\"Initialized Trim operation with start: {self.start}, end: {self.end}\"\n    )\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Trim.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.Trim.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/api/#wandas.processing.time_series.Trim.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after trimming\n    # Exclude parts where there is no signal\n    end_sample = min(self.end_sample, input_shape[-1])\n    n_samples = end_sample - self.start_sample\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Welch","title":"<code>Welch</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Welch</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Welch(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Welch\"\"\"\n\n    name = \"welch\"\n    n_fft: int\n    window: str\n    hop_length: Optional[int]\n    win_length: Optional[int]\n    average: str\n    detrend: str\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        average: str = \"mean\",\n        detrend: str = \"constant\",\n    ):\n        \"\"\"\n        Initialize Welch operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int, optional\n            FFT size, default is 2048\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.noverlap = (\n            self.win_length - self.hop_length if hop_length is not None else None\n        )\n        self.window = window\n        self.average = average\n        self.detrend = detrend\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n            average=average,\n            detrend=detrend,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, freqs)\n        \"\"\"\n        n_freqs = self.n_fft // 2 + 1\n        return (*input_shape[:-1], n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for Welch operation\"\"\"\n        from scipy import signal as ss\n\n        _, result = ss.welch(\n            x,\n            nperseg=self.win_length,\n            noverlap=self.noverlap,\n            nfft=self.n_fft,\n            window=self.window,\n            average=self.average,\n            detrend=self.detrend,\n            scaling=\"spectrum\",\n        )\n\n        if not isinstance(x, np.ndarray):\n            # Trigger computation for Dask array\n            raise ValueError(\n                \"Welch operation requires a Dask array, but received a non-ndarray.\"\n            )\n        return np.array(result)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Welch.__init__","title":"<code>__init__(sampling_rate, n_fft=2048, hop_length=None, win_length=None, window='hann', average='mean', detrend='constant')</code>","text":"<p>Initialize Welch operation</p>"},{"location":"en/api/#wandas.processing.time_series.Welch.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int, optional     FFT size, default is 2048 window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    average: str = \"mean\",\n    detrend: str = \"constant\",\n):\n    \"\"\"\n    Initialize Welch operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int, optional\n        FFT size, default is 2048\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.noverlap = (\n        self.win_length - self.hop_length if hop_length is not None else None\n    )\n    self.window = window\n    self.average = average\n    self.detrend = detrend\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        win_length=self.win_length,\n        hop_length=self.hop_length,\n        window=window,\n        average=average,\n        detrend=detrend,\n    )\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Welch.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.Welch.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/api/#wandas.processing.time_series.Welch.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, freqs)\n    \"\"\"\n    n_freqs = self.n_fft // 2 + 1\n    return (*input_shape[:-1], n_freqs)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.create_operation","title":"<code>create_operation(name, sampling_rate, **params)</code>","text":"<p>Create operation instance from name and parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def create_operation(\n    name: str, sampling_rate: float, **params: Any\n) -&gt; AudioOperation[Any, Any]:\n    \"\"\"Create operation instance from name and parameters\"\"\"\n    operation_class = get_operation(name)\n    return operation_class(sampling_rate, **params)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.get_operation","title":"<code>get_operation(name)</code>","text":"<p>Get operation class by name</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def get_operation(name: str) -&gt; type[AudioOperation[Any, Any]]:\n    \"\"\"Get operation class by name\"\"\"\n    if name not in _OPERATION_REGISTRY:\n        raise ValueError(f\"Unknown operation type: {name}\")\n    return _OPERATION_REGISTRY[name]\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.register_operation","title":"<code>register_operation(operation_class)</code>","text":"<p>Register a new operation type</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def register_operation(operation_class: type) -&gt; None:\n    \"\"\"Register a new operation type\"\"\"\n\n    if not issubclass(operation_class, AudioOperation):\n        raise TypeError(\"Strategy class must inherit from AudioOperation.\")\n    if inspect.isabstract(operation_class):\n        raise TypeError(\"Cannot register abstract AudioOperation class.\")\n\n    _OPERATION_REGISTRY[operation_class.name] = operation_class\n</code></pre>"},{"location":"en/api/#utilities","title":"Utilities","text":""},{"location":"en/api/core/","title":"Core Module","text":"<p>This page explains the core module of Wandas. The core module provides the basic data structures and functionality of Wandas.</p>"},{"location":"en/api/core/#baseframe","title":"BaseFrame","text":"<p><code>BaseFrame</code> is the base class for all frame classes in Wandas. You don't instantiate this class directly but use it through derived classes (like ChannelFrame).</p> <pre><code>from wandas.core.base_frame import BaseFrame\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for all signal frame types.</p> <p>This class provides the common interface and functionality for all frame types used in signal processing. It implements basic operations like indexing, iteration, and data manipulation that are shared across all frame types.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The signal data to process. Must be a dask array. sampling_rate : float     The sampling rate of the signal in Hz. label : str, optional     A label for the frame. If not provided, defaults to \"unnamed_frame\". metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame--attributes","title":"Attributes","text":"<p>sampling_rate : float     The sampling rate of the signal in Hz. label : str     The label of the frame. metadata : dict     Additional metadata for the frame. operation_history : list[dict]     History of operations performed on this frame.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>class BaseFrame(ABC, Generic[T]):\n    \"\"\"\n    Abstract base class for all signal frame types.\n\n    This class provides the common interface and functionality for all frame types\n    used in signal processing. It implements basic operations like indexing, iteration,\n    and data manipulation that are shared across all frame types.\n\n    Parameters\n    ----------\n    data : DaArray\n        The signal data to process. Must be a dask array.\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str, optional\n        A label for the frame. If not provided, defaults to \"unnamed_frame\".\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str\n        The label of the frame.\n    metadata : dict\n        Additional metadata for the frame.\n    operation_history : list[dict]\n        History of operations performed on this frame.\n    \"\"\"\n\n    _data: DaArray\n    sampling_rate: float\n    label: str\n    metadata: dict[str, Any]\n    operation_history: list[dict[str, Any]]\n    _channel_metadata: list[ChannelMetadata]\n    _previous: Optional[\"BaseFrame[Any]\"]\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ):\n        self._data = data.rechunk(chunks=-1)  # type: ignore [unused-ignore]\n        if self._data.ndim == 1:\n            self._data = self._data.reshape((1, -1))\n        self.sampling_rate = sampling_rate\n        self.label = label or \"unnamed_frame\"\n        self.metadata = metadata or {}\n        self.operation_history = operation_history or []\n        self._previous = previous\n\n        if channel_metadata:\n            self._channel_metadata = copy.deepcopy(channel_metadata)\n        else:\n            self._channel_metadata = [\n                ChannelMetadata(label=f\"ch{i}\", unit=\"\", extra={})\n                for i in range(self._n_channels)\n            ]\n\n        try:\n            # Display information for newer dask versions\n            logger.debug(f\"Dask graph layers: {list(self._data.dask.layers.keys())}\")\n            logger.debug(\n                f\"Dask graph dependencies: {len(self._data.dask.dependencies)}\"\n            )\n        except Exception as e:\n            logger.debug(f\"Dask graph visualization details unavailable: {e}\")\n\n    @property\n    @abstractmethod\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n\n    @property\n    def n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return len(self)\n\n    @property\n    def channels(self) -&gt; list[ChannelMetadata]:\n        \"\"\"Property to access channel metadata.\"\"\"\n        return self._channel_metadata\n\n    @property\n    def previous(self) -&gt; Optional[\"BaseFrame[Any]\"]:\n        \"\"\"\n        Returns the previous frame.\n        \"\"\"\n        return self._previous\n\n    def get_channel(self: S, channel_idx: int) -&gt; S:\n        n_channels = len(self)\n        if channel_idx &lt; 0 or channel_idx &gt;= n_channels:\n            range_max = n_channels - 1\n            raise ValueError(\n                f\"Channel index out of range: {channel_idx} \"\n                f\"(valid range: 0-{range_max})\"\n            )\n        logger.debug(f\"Extracting channel index={channel_idx} (lazy operation).\")\n        channel_data = self._data[channel_idx : channel_idx + 1]\n\n        return self._create_new_instance(\n            data=channel_data,\n            operation_history=self.operation_history,\n            channel_metadata=[self._channel_metadata[channel_idx]],\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Returns the number of channels.\n        \"\"\"\n        return len(self._channel_metadata)\n\n    def __iter__(self: S) -&gt; Iterator[S]:\n        for idx in range(len(self)):\n            yield self[idx]\n\n    def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n        \"\"\"\n        Method to get a channel by name or index.\n\n        Parameters\n        ----------\n        key : str, int, slice, or tuple of slices\n            Channel name (label) or index number.\n\n        Returns\n        -------\n        BaseFrame\n            The corresponding channel.\n\n        Raises\n        ------\n        ValueError\n            If the key length is invalid for the shape.\n        IndexError\n            If the channel index is out of range.\n        TypeError\n            If the key type is invalid.\n        \"\"\"\n        if isinstance(key, str):\n            index = self.label2index(key)\n            return self.get_channel(index)\n\n        elif isinstance(key, tuple):\n            # When key is a tuple, treat the first element as an index\n            if len(key) &gt; len(self.shape):\n                raise ValueError(\n                    f\"Invalid key length: {len(key)} for shape {self.shape}\"\n                )\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key[0]]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, slice):\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, numbers.Integral):\n            # Access by index number\n            if key &lt; 0 or key &gt;= len(self):\n                raise IndexError(f\"Channel index {key} out of range.\")\n            return self.get_channel(key)\n        else:\n            raise TypeError(\n                f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n            )\n\n    def label2index(self, label: str) -&gt; int:\n        \"\"\"\n        Get the index from a channel label.\n\n        Parameters\n        ----------\n        label : str\n            Channel label.\n\n        Returns\n        -------\n        int\n            Corresponding index.\n\n        Raises\n        ------\n        KeyError\n            If the channel label is not found.\n        \"\"\"\n        for idx, ch in enumerate(self._channel_metadata):\n            if ch.label == label:\n                return idx\n        raise KeyError(f\"Channel label '{label}' not found.\")\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        _shape: tuple[int, ...] = self._data.shape\n        return _shape\n\n    @property\n    def data(self) -&gt; T:\n        \"\"\"\n        Returns the computed data.\n        Calculation is executed the first time this is accessed.\n        \"\"\"\n        return self.compute()\n\n    @property\n    def labels(self) -&gt; list[str]:\n        \"\"\"Get a list of all channel labels.\"\"\"\n        return [ch.label for ch in self._channel_metadata]\n\n    def compute(self) -&gt; T:\n        \"\"\"\n        Compute and return the data.\n        This method materializes lazily computed data into a concrete NumPy array.\n\n        Returns\n        -------\n        NDArrayReal\n            The computed data.\n\n        Raises\n        ------\n        ValueError\n            If the computed result is not a NumPy array.\n        \"\"\"\n        logger.debug(\n            \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n        )\n        result = self._data.compute()\n\n        if not isinstance(result, np.ndarray):\n            raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n        logger.debug(f\"Computation complete, result shape: {result.shape}\")\n        return cast(T, result)\n\n    @abstractmethod\n    def plot(\n        self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n    ) -&gt; Union[Axes, Iterator[Axes]]:\n        \"\"\"Plot the data\"\"\"\n        pass\n\n    def persist(self: S) -&gt; S:\n        \"\"\"Persist the data in memory\"\"\"\n        persisted_data = self._data.persist()\n        return self._create_new_instance(data=persisted_data)\n\n    @abstractmethod\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Abstract method for derived classes to provide\n        additional initialization arguments.\n        \"\"\"\n        pass\n\n    def _create_new_instance(self: S, data: DaArray, **kwargs: Any) -&gt; S:\n        \"\"\"\n        Create a new channel instance based on an existing channel.\n        Keyword arguments can override or extend the original attributes.\n        \"\"\"\n\n        sampling_rate = kwargs.pop(\"sampling_rate\", self.sampling_rate)\n        # if not isinstance(sampling_rate, int):\n        #     raise TypeError(\"Sampling rate must be an integer\")\n\n        label = kwargs.pop(\"label\", self.label)\n        if not isinstance(label, str):\n            raise TypeError(\"Label must be a string\")\n\n        metadata = kwargs.pop(\"metadata\", copy.deepcopy(self.metadata))\n        if not isinstance(metadata, dict):\n            raise TypeError(\"Metadata must be a dictionary\")\n\n        # Get additional initialization arguments from derived classes\n        additional_kwargs = self._get_additional_init_kwargs()\n        kwargs.update(additional_kwargs)\n\n        return type(self)(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            previous=self,\n            **kwargs,\n        )\n\n    def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n        \"\"\"Implicit conversion to NumPy array\"\"\"\n        result = self.compute()\n        if dtype is not None:\n            return result.astype(dtype)\n        return result\n\n    def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n        \"\"\"Visualize the computation graph and save it to a file\"\"\"\n        try:\n            filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n            self._data.visualize(filename=filename)\n            return filename\n        except Exception as e:\n            logger.warning(f\"Failed to visualize the graph: {e}\")\n            return None\n\n    @abstractmethod\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"Basic implementation of binary operations\"\"\"\n        # Basic logic\n        # Actual implementation is left to derived classes\n        pass\n\n    def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Addition operator\"\"\"\n        return self._binary_op(other, lambda x, y: x + y, \"+\")\n\n    def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Subtraction operator\"\"\"\n        return self._binary_op(other, lambda x, y: x - y, \"-\")\n\n    def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Multiplication operator\"\"\"\n        return self._binary_op(other, lambda x, y: x * y, \"*\")\n\n    def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Division operator\"\"\"\n        return self._binary_op(other, lambda x, y: x / y, \"/\")\n\n    def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Apply a named operation.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters to pass to the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        # Apply the operation through abstract method\n        return self._apply_operation_impl(operation_name, **params)\n\n    @abstractmethod\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"Implementation of operation application\"\"\"\n        pass\n\n    def debug_info(self) -&gt; None:\n        \"\"\"Output detailed debug information\"\"\"\n        logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n        logger.debug(f\"Label: {self.label}\")\n        logger.debug(f\"Shape: {self.shape}\")\n        logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n        logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n        self._debug_info_impl()\n        logger.debug(\"=== End Debug Info ===\")\n\n    def _debug_info_impl(self) -&gt; None:\n        \"\"\"Implement derived class-specific debug information\"\"\"\n        pass\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.channels","title":"<code>channels</code>  <code>property</code>","text":"<p>Property to access channel metadata.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.data","title":"<code>data</code>  <code>property</code>","text":"<p>Returns the computed data. Calculation is executed the first time this is accessed.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>Get a list of all channel labels.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.n_channels","title":"<code>n_channels</code>  <code>property</code>","text":"<p>Returns the number of channels.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.previous","title":"<code>previous</code>  <code>property</code>","text":"<p>Returns the previous frame.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__add__","title":"<code>__add__(other)</code>","text":"<p>Addition operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Addition operator\"\"\"\n    return self._binary_op(other, lambda x, y: x + y, \"+\")\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__array__","title":"<code>__array__(dtype=None)</code>","text":"<p>Implicit conversion to NumPy array</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n    \"\"\"Implicit conversion to NumPy array\"\"\"\n    result = self.compute()\n    if dtype is not None:\n        return result.astype(dtype)\n    return result\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Method to get a channel by name or index.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__getitem__--parameters","title":"Parameters","text":"<p>key : str, int, slice, or tuple of slices     Channel name (label) or index number.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__getitem__--returns","title":"Returns","text":"<p>BaseFrame     The corresponding channel.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__getitem__--raises","title":"Raises","text":"<p>ValueError     If the key length is invalid for the shape. IndexError     If the channel index is out of range. TypeError     If the key type is invalid.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n    \"\"\"\n    Method to get a channel by name or index.\n\n    Parameters\n    ----------\n    key : str, int, slice, or tuple of slices\n        Channel name (label) or index number.\n\n    Returns\n    -------\n    BaseFrame\n        The corresponding channel.\n\n    Raises\n    ------\n    ValueError\n        If the key length is invalid for the shape.\n    IndexError\n        If the channel index is out of range.\n    TypeError\n        If the key type is invalid.\n    \"\"\"\n    if isinstance(key, str):\n        index = self.label2index(key)\n        return self.get_channel(index)\n\n    elif isinstance(key, tuple):\n        # When key is a tuple, treat the first element as an index\n        if len(key) &gt; len(self.shape):\n            raise ValueError(\n                f\"Invalid key length: {len(key)} for shape {self.shape}\"\n            )\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key[0]]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, slice):\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, numbers.Integral):\n        # Access by index number\n        if key &lt; 0 or key &gt;= len(self):\n            raise IndexError(f\"Channel index {key} out of range.\")\n        return self.get_channel(key)\n    else:\n        raise TypeError(\n            f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n        )\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of channels.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of channels.\n    \"\"\"\n    return len(self._channel_metadata)\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplication operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Multiplication operator\"\"\"\n    return self._binary_op(other, lambda x, y: x * y, \"*\")\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtraction operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Subtraction operator\"\"\"\n    return self._binary_op(other, lambda x, y: x - y, \"-\")\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Division operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Division operator\"\"\"\n    return self._binary_op(other, lambda x, y: x / y, \"/\")\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.apply_operation","title":"<code>apply_operation(operation_name, **params)</code>","text":"<p>Apply a named operation.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.apply_operation--parameters","title":"Parameters","text":"<p>operation_name : str     Name of the operation to apply. **params : Any     Parameters to pass to the operation.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.apply_operation--returns","title":"Returns","text":"<p>S     A new instance with the operation applied.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n    \"\"\"\n    Apply a named operation.\n\n    Parameters\n    ----------\n    operation_name : str\n        Name of the operation to apply.\n    **params : Any\n        Parameters to pass to the operation.\n\n    Returns\n    -------\n    S\n        A new instance with the operation applied.\n    \"\"\"\n    # Apply the operation through abstract method\n    return self._apply_operation_impl(operation_name, **params)\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.compute","title":"<code>compute()</code>","text":"<p>Compute and return the data. This method materializes lazily computed data into a concrete NumPy array.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.compute--returns","title":"Returns","text":"<p>NDArrayReal     The computed data.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.compute--raises","title":"Raises","text":"<p>ValueError     If the computed result is not a NumPy array.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def compute(self) -&gt; T:\n    \"\"\"\n    Compute and return the data.\n    This method materializes lazily computed data into a concrete NumPy array.\n\n    Returns\n    -------\n    NDArrayReal\n        The computed data.\n\n    Raises\n    ------\n    ValueError\n        If the computed result is not a NumPy array.\n    \"\"\"\n    logger.debug(\n        \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n    )\n    result = self._data.compute()\n\n    if not isinstance(result, np.ndarray):\n        raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n    logger.debug(f\"Computation complete, result shape: {result.shape}\")\n    return cast(T, result)\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.debug_info","title":"<code>debug_info()</code>","text":"<p>Output detailed debug information</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def debug_info(self) -&gt; None:\n    \"\"\"Output detailed debug information\"\"\"\n    logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n    logger.debug(f\"Label: {self.label}\")\n    logger.debug(f\"Shape: {self.shape}\")\n    logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n    logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n    self._debug_info_impl()\n    logger.debug(\"=== End Debug Info ===\")\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.label2index","title":"<code>label2index(label)</code>","text":"<p>Get the index from a channel label.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.label2index--parameters","title":"Parameters","text":"<p>label : str     Channel label.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.label2index--returns","title":"Returns","text":"<p>int     Corresponding index.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.label2index--raises","title":"Raises","text":"<p>KeyError     If the channel label is not found.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def label2index(self, label: str) -&gt; int:\n    \"\"\"\n    Get the index from a channel label.\n\n    Parameters\n    ----------\n    label : str\n        Channel label.\n\n    Returns\n    -------\n    int\n        Corresponding index.\n\n    Raises\n    ------\n    KeyError\n        If the channel label is not found.\n    \"\"\"\n    for idx, ch in enumerate(self._channel_metadata):\n        if ch.label == label:\n            return idx\n    raise KeyError(f\"Channel label '{label}' not found.\")\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.persist","title":"<code>persist()</code>","text":"<p>Persist the data in memory</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def persist(self: S) -&gt; S:\n    \"\"\"Persist the data in memory\"\"\"\n    persisted_data = self._data.persist()\n    return self._create_new_instance(data=persisted_data)\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.plot","title":"<code>plot(plot_type='default', ax=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Plot the data</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>@abstractmethod\ndef plot(\n    self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n) -&gt; Union[Axes, Iterator[Axes]]:\n    \"\"\"Plot the data\"\"\"\n    pass\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.visualize_graph","title":"<code>visualize_graph(filename=None)</code>","text":"<p>Visualize the computation graph and save it to a file</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"Visualize the computation graph and save it to a file\"\"\"\n    try:\n        filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n        self._data.visualize(filename=filename)\n        return filename\n    except Exception as e:\n        logger.warning(f\"Failed to visualize the graph: {e}\")\n        return None\n</code></pre>"},{"location":"en/api/core/#channelmetadata","title":"ChannelMetadata","text":"<p><code>ChannelMetadata</code> is a class for managing metadata for each channel. It holds channel names, units, and other additional information.</p> <pre><code>from wandas.core.metadata import ChannelMetadata\n\n# Usage example\nmetadata = ChannelMetadata(label=\"Left Channel\", unit=\"dB\", extra={\"device\": \"Microphone\"})\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>Data class for storing channel metadata</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>class ChannelMetadata(BaseModel):\n    \"\"\"\n    Data class for storing channel metadata\n    \"\"\"\n\n    label: str = \"\"\n    unit: str = \"\"\n    ref: float = 1.0\n    # Additional metadata for extensibility\n    extra: dict[str, Any] = Field(default_factory=dict)\n\n    def __getitem__(self, key: str) -&gt; Any:\n        \"\"\"Provide dictionary-like behavior\"\"\"\n        if key == \"label\":\n            return self.label\n        elif key == \"unit\":\n            return self.unit\n        elif key == \"ref\":\n            return self.ref\n        else:\n            return self.extra.get(key)\n\n    def __setitem__(self, key: str, value: Any) -&gt; None:\n        \"\"\"Provide dictionary-like behavior\"\"\"\n        if key == \"label\":\n            self.label = value\n        elif key == \"unit\":\n            self.unit = value\n        elif key == \"ref\":\n            self.ref = value\n        else:\n            self.extra[key] = value\n\n    def to_json(self) -&gt; str:\n        \"\"\"Convert to JSON format\"\"\"\n        json_data: str = self.model_dump_json(indent=4)\n        return json_data\n\n    @classmethod\n    def from_json(cls, json_data: str) -&gt; \"ChannelMetadata\":\n        \"\"\"Convert from JSON format\"\"\"\n        root_model: ChannelMetadata = ChannelMetadata.model_validate_json(json_data)\n\n        return root_model\n</code></pre>"},{"location":"en/api/core/#wandas.core.metadata.ChannelMetadata.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Provide dictionary-like behavior</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Any:\n    \"\"\"Provide dictionary-like behavior\"\"\"\n    if key == \"label\":\n        return self.label\n    elif key == \"unit\":\n        return self.unit\n    elif key == \"ref\":\n        return self.ref\n    else:\n        return self.extra.get(key)\n</code></pre>"},{"location":"en/api/core/#wandas.core.metadata.ChannelMetadata.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Provide dictionary-like behavior</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def __setitem__(self, key: str, value: Any) -&gt; None:\n    \"\"\"Provide dictionary-like behavior\"\"\"\n    if key == \"label\":\n        self.label = value\n    elif key == \"unit\":\n        self.unit = value\n    elif key == \"ref\":\n        self.ref = value\n    else:\n        self.extra[key] = value\n</code></pre>"},{"location":"en/api/core/#wandas.core.metadata.ChannelMetadata.from_json","title":"<code>from_json(json_data)</code>  <code>classmethod</code>","text":"<p>Convert from JSON format</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>@classmethod\ndef from_json(cls, json_data: str) -&gt; \"ChannelMetadata\":\n    \"\"\"Convert from JSON format\"\"\"\n    root_model: ChannelMetadata = ChannelMetadata.model_validate_json(json_data)\n\n    return root_model\n</code></pre>"},{"location":"en/api/core/#wandas.core.metadata.ChannelMetadata.to_json","title":"<code>to_json()</code>","text":"<p>Convert to JSON format</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Convert to JSON format\"\"\"\n    json_data: str = self.model_dump_json(indent=4)\n    return json_data\n</code></pre>"},{"location":"en/api/frames/","title":"Frame Module","text":"<p>This page explains the frame modules in Wandas. The frame module includes various types of data frames.</p>"},{"location":"en/api/frames/#channelframe","title":"ChannelFrame","text":"<p><code>ChannelFrame</code> is a frame that handles time-domain signal data.</p> <pre><code>from wandas.frames.channel import ChannelFrame\n\n# Or\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")  # Returns a ChannelFrame instance\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Channel-based data frame for handling audio signals and time series data.</p> <p>This frame represents channel-based data such as audio signals and time series data, with each channel containing data samples in the time domain.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>class ChannelFrame(BaseFrame[NDArrayReal]):\n    \"\"\"Channel-based data frame for handling audio signals and time series data.\n\n    This frame represents channel-based data such as audio signals and time series data,\n    with each channel containing data samples in the time domain.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"Initialize a ChannelFrame.\n\n        Args:\n            data: Dask array containing channel data.\n            Shape should be (n_channels, n_samples).\n            sampling_rate: The sampling rate of the data in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            operation_history: History of operations applied to the frame.\n            channel_metadata: Metadata for each channel.\n            previous: Reference to the previous frame in the processing chain.\n\n        Raises:\n            ValueError: If data has more than 2 dimensions.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return self.shape[-2]\n\n    @property\n    def time(self) -&gt; NDArrayReal:\n        \"\"\"Get time array for the signal.\n\n        Returns:\n            Array of time points in seconds.\n        \"\"\"\n        return np.arange(self.n_samples) / self.sampling_rate\n\n    @property\n    def n_samples(self) -&gt; int:\n        \"\"\"Returns the number of samples.\"\"\"\n        n: int = self._data.shape[-1]\n        return n\n\n    @property\n    def duration(self) -&gt; float:\n        \"\"\"Returns the duration in seconds.\"\"\"\n        return self.n_samples / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # Apply processing to data\n        processed_data = operation.process(self._data)\n\n        # Update metadata\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        if operation_name == \"resampling\":\n            # For resampling, update sampling rate\n            return self._create_new_instance(\n                sampling_rate=params[\"target_sr\"],\n                data=processed_data,\n                metadata=new_metadata,\n                operation_history=new_history,\n            )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Common implementation for binary operations\n        - utilizing dask's lazy evaluation.\n\n        Args:\n            other: Right operand for the operation.\n            op: Function to execute the operation (e.g., lambda a, b: a + b).\n            symbol: Symbolic representation of the operation (e.g., '+').\n\n        Returns:\n            A new channel containing the operation result (lazy execution).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, ChannelFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Perform operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other._data)\n\n            # Merge channel metadata\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # Perform operation with scalar, NumPy array, or other types\n        else:\n            # Apply operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other)\n\n            # Operand display string\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # Check for dask.array.Array\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # Update channel metadata\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n                previous=self,\n            )\n\n    def add(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        snr: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Add another signal or value to the current signal.\n\n        If SNR is specified, performs addition with consideration for\n        signal-to-noise ratio.\n\n        Args:\n            other: Signal or value to add.\n            snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n                other signal based on this SNR.\n                self is treated as the signal, and other as the noise.\n\n        Returns:\n            A new channel frame containing the addition result (lazy execution).\n        \"\"\"\n        logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n        # Special processing when SNR is specified\n        if snr is not None:\n            # First convert other to ChannelFrame if it's not\n            if not isinstance(other, ChannelFrame):\n                if isinstance(other, np.ndarray):\n                    other = ChannelFrame.from_numpy(\n                        other, self.sampling_rate, label=\"array_data\"\n                    )\n                elif isinstance(other, (int, float)):\n                    # For scalar values, simply add (ignore SNR)\n                    return self + other\n                else:\n                    raise TypeError(\n                        \"Addition target with SNR must be a ChannelFrame or \"\n                        f\"NumPy array: {type(other)}\"\n                    )\n\n            # Check if sampling rates match\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Apply addition operation with SNR adjustment\n            return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n        # Execute normal addition if SNR is not specified\n        return self + other\n\n    def plot(\n        self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Plot the frame data.\n\n        Args:\n            plot_type: Type of plot. Default is \"waveform\".\n            ax: Optional matplotlib axes for plotting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        plot_strategy = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def rms_plot(\n        self,\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = True,\n        Aw: bool = False,  # noqa: N803\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Generate an RMS plot.\n\n        Args:\n            ax: Optional matplotlib axes for plotting.\n            title: Title for the plot.\n            overlay: Whether to overlay the plot on the existing axis.\n            Aw: Apply A-weighting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        kwargs = kwargs or {}\n        ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n        rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n        return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n\n    def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n        \"\"\"Display visual and audio representation of the frame.\n\n        Args:\n            normalize: Whether to normalize the audio data for playback.\n            **kwargs: Additional parameters for visualization.\n        \"\"\"\n        if \"axis_config\" in kwargs:\n            logger.warning(\n                \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            axis_config = kwargs[\"axis_config\"]\n            if \"time_plot\" in axis_config:\n                kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n            if \"freq_plot\" in axis_config:\n                if \"xlim\" in axis_config[\"freq_plot\"]:\n                    vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                    kwargs[\"vmin\"] = vlim[0]\n                    kwargs[\"vmax\"] = vlim[1]\n                if \"ylim\" in axis_config[\"freq_plot\"]:\n                    ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                    kwargs[\"ylim\"] = ylim\n\n        if \"cbar_config\" in kwargs:\n            logger.warning(\n                \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            cbar_config = kwargs[\"cbar_config\"]\n            if \"vmin\" in cbar_config:\n                kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n            if \"vmax\" in cbar_config:\n                kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n        for ch in self:\n            ax: Axes\n            _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n            if isinstance(_ax, Iterator):\n                ax = next(iter(_ax))\n            elif isinstance(_ax, Axes):\n                ax = _ax\n            else:\n                raise TypeError(\n                    f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n                )\n            # Ignore type checks for display and Audio\n            display(ax.figure)  # type: ignore\n            plt.close(ax.figure)  # type: ignore\n            display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n\n    @classmethod\n    def from_numpy(\n        cls,\n        data: NDArrayReal,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        ch_labels: Optional[list[str]] = None,\n        ch_units: Optional[Union[list[str], str]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        Args:\n            data: NumPy array containing channel data.\n            sampling_rate: The sampling rate in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            ch_labels: Labels for each channel.\n            ch_units: Units for each channel.\n\n        Returns:\n            A new ChannelFrame containing the NumPy data.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n\n        # Convert NumPy array to dask array\n        dask_data = da_from_array(data)\n        cf = ChannelFrame(\n            data=dask_data,\n            sampling_rate=sampling_rate,\n            label=label or \"numpy_data\",\n        )\n        if metadata is not None:\n            cf.metadata = metadata\n        if ch_labels is not None:\n            if len(ch_labels) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel labels does not match the number of channels\"\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        if ch_units is not None:\n            if isinstance(ch_units, str):\n                ch_units = [ch_units] * cf.n_channels\n\n            if len(ch_units) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel units does not match the number of channels\"\n                )\n            for i in range(len(ch_units)):\n                cf._channel_metadata[i].unit = ch_units[i]\n\n        return cf\n\n    @classmethod\n    def from_ndarray(\n        cls,\n        array: NDArrayReal,\n        sampling_rate: float,\n        labels: Optional[list[str]] = None,\n        unit: Optional[Union[list[str], str]] = None,\n        frame_label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        This method is deprecated. Use from_numpy instead.\n\n        Args:\n            array: Signal data. Each row corresponds to a channel.\n            sampling_rate: Sampling rate (Hz).\n            labels: Labels for each channel.\n            unit: Unit of the signal.\n            frame_label: Label for the frame.\n            metadata: Optional metadata dictionary.\n\n        Returns:\n            A new ChannelFrame containing the data.\n        \"\"\"\n        # Redirect to from_numpy for compatibility\n        # However, from_ndarray is deprecated\n        logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n        return cls.from_numpy(\n            data=array,\n            sampling_rate=sampling_rate,\n            label=frame_label,\n            metadata=metadata,\n            ch_labels=labels,\n            ch_units=unit,\n        )\n\n    @classmethod\n    def from_file(\n        cls,\n        path: Union[str, Path],\n        channel: Optional[Union[int, list[int]]] = None,\n        start: Optional[float] = None,\n        end: Optional[float] = None,\n        chunk_size: Optional[int] = None,\n        ch_labels: Optional[list[str]] = None,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from an audio file.\n\n        Args:\n            path: Path to the audio file.\n            channel: Channel(s) to load.\n            start: Start time in seconds.\n            end: End time in seconds.\n            chunk_size: Chunk size for processing.\n            Specifies the splitting size for lazy processing.\n            ch_labels: Labels for each channel.\n            **kwargs: Additional arguments passed to the file reader.\n\n        Returns:\n            A new ChannelFrame containing the loaded audio data.\n\n        Raises:\n            ValueError: If channel selection is invalid.\n            TypeError: If channel parameter type is invalid.\n            FileNotFoundError: If the file doesn't exist.\n        \"\"\"\n        from .channel import ChannelFrame\n\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"File not found: {path}\")\n\n        # Get file reader\n        reader = get_file_reader(path)\n\n        # Get file info\n        info = reader.get_file_info(path, **kwargs)\n        sr = info[\"samplerate\"]\n        n_channels = info[\"channels\"]\n        n_frames = info[\"frames\"]\n        ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n        logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n        # Channel selection processing\n        all_channels = list(range(n_channels))\n\n        if channel is None:\n            channels_to_load = all_channels\n            logger.debug(f\"Will load all channels: {channels_to_load}\")\n        elif isinstance(channel, int):\n            if channel &lt; 0 or channel &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n            channels_to_load = [channel]\n            logger.debug(f\"Will load single channel: {channel}\")\n        elif isinstance(channel, (list, tuple)):\n            for ch in channel:\n                if ch &lt; 0 or ch &gt;= n_channels:\n                    raise ValueError(\n                        f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                    )\n            channels_to_load = list(channel)\n            logger.debug(f\"Will load specific channels: {channels_to_load}\")\n        else:\n            raise TypeError(\"channel must be int, list, or None\")\n\n        # Index calculation\n        start_idx = 0 if start is None else max(0, int(start * sr))\n        end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n        frames_to_read = end_idx - start_idx\n\n        logger.debug(\n            f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n            f\"start_idx={start_idx}, end_idx={end_idx}\"\n        )\n\n        # Settings for lazy loading\n        expected_shape = (len(channels_to_load), frames_to_read)\n\n        # Define the loading function using the file reader\n        def _load_audio() -&gt; NDArrayReal:\n            logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n            # Use the reader to get audio data with parameters\n            out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n            if not isinstance(out, np.ndarray):\n                raise ValueError(\"Unexpected data type after reading file\")\n            return out\n\n        logger.debug(\n            f\"Creating delayed dask task with expected shape: {expected_shape}\"\n        )\n\n        # Create delayed operation\n        delayed_data = dask_delayed(_load_audio)()\n        logger.debug(\"Wrapping delayed function in dask array\")\n\n        # Create dask array from delayed computation\n        dask_array = da_from_delayed(\n            delayed_data, shape=expected_shape, dtype=np.float32\n        )\n\n        if chunk_size is not None:\n            if chunk_size &lt;= 0:\n                raise ValueError(\"Chunk size must be a positive integer\")\n            logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n            dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n        logger.debug(\n            \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n        )\n\n        cf = ChannelFrame(\n            data=dask_array,\n            sampling_rate=sr,\n            label=path.stem,\n            metadata={\n                \"filename\": str(path),\n            },\n        )\n        if ch_labels is not None:\n            if len(ch_labels) != len(cf):\n                raise ValueError(\n                    \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        return cf\n\n    @classmethod\n    def read_wav(\n        cls, filename: str, labels: Optional[list[str]] = None\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a WAV file.\n\n        Args:\n            filename: Path to the WAV file.\n            labels: Labels to set for each channel.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(filename, ch_labels=labels)\n        return cf\n\n    @classmethod\n    def read_csv(\n        cls,\n        filename: str,\n        time_column: Union[int, str] = 0,\n        labels: Optional[list[str]] = None,\n        delimiter: str = \",\",\n        header: Optional[int] = 0,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a CSV file.\n\n        Args:\n            filename: Path to the CSV file.\n            time_column: Index or name of the time column.\n            labels: Labels to set for each channel.\n            delimiter: Delimiter character.\n            header: Row number to use as header.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(\n            filename,\n            ch_labels=labels,\n            time_column=time_column,\n            delimiter=delimiter,\n            header=header,\n        )\n        return cf\n\n    def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n        \"\"\"Save the audio data to a file.\n\n        Args:\n            path: Path to save the file.\n            format: File format. If None, determined from file extension.\n        \"\"\"\n        logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n        data = self.compute()\n        data = data.T\n        if data.shape[1] == 1:\n            data = data.squeeze(axis=1)\n        sf.write(str(path), data, int(self.sampling_rate), format=format)\n        logger.debug(f\"Save complete: {path}\")\n\n    def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a high-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n\n    def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a low-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n\n    def normalize(\n        self, target_level: float = -20, channel_wise: bool = True\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Normalize the signal level.\n\n        This method adjusts the signal amplitude to reach a target RMS level.\n\n        Args:\n            target_level: Target RMS level in dB. Default is -20.\n            channel_wise: If True, normalize each channel independently.\n                If False, apply the same scaling to all channels.\n\n        Returns:\n            A new ChannelFrame containing the normalized signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n        )\n        return self.apply_operation(\n            \"normalize\", target_level=target_level, channel_wise=channel_wise\n        )\n\n    def a_weighting(self) -&gt; \"ChannelFrame\":\n        \"\"\"Apply A-weighting filter to the signal.\n\n        A-weighting adjusts the frequency response to approximate human hearing\n        perception, following IEC 61672-1:2013 standard.\n\n        Returns:\n            A new ChannelFrame with A-weighted signal.\n        \"\"\"\n        return self.apply_operation(\"a_weighting\")\n\n    def hpss_harmonic(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract harmonic components using HPSS\n         (Harmonic-Percussive Source Separation).\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_harmonic\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def hpss_percussive(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract percussive components using HPSS\n        (Harmonic-Percussive Source Separation).\n\n        This method separates the percussive (tonal) components from the signal.\n\n        Args:\n            kernel_size: Median filter size for HPSS.\n            power: Exponent for the Weiner filter used in HPSS.\n            margin: Margin size for the separation.\n\n        Returns:\n            A new ChannelFrame containing the harmonic components.\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_percussive\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def resampling(\n        self,\n        target_sr: float,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Resample audio data.\n\n        Parameters\n        ----------\n        target_sr : float\n            Target sampling rate (Hz)\n        resample_type : str, optional\n            Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n        **kwargs : dict\n            Additional resampling parameters\n\n        Returns\n        -------\n        ChannelFrame\n            Resampled channel frame\n        \"\"\"\n        return self.apply_operation(\n            \"resampling\",\n            target_sr=target_sr,\n            **kwargs,\n        )\n\n    def abs(self) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the absolute value of the signal.\n\n        Returns:\n            A new ChannelFrame containing the absolute values.\n        \"\"\"\n        return self.apply_operation(\"abs\")\n\n    def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the power of the signal.\n\n        Args:\n            exponent: The exponent to raise the signal to. Default is 2.0.\n\n        Returns:\n            A new ChannelFrame containing the signal raised to the power.\n        \"\"\"\n        return self.apply_operation(\"power\", exponent=exponent)\n\n    def trim(\n        self,\n        start: float = 0,\n        end: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Trim the signal to specified time range.\n\n        Args:\n            start: Start time in seconds.\n            end: End time in seconds.\n\n        Returns:\n            A new ChannelFrame with trimmed signal.\n\n        Raises:\n            ValueError: If end time is before start time.\n        \"\"\"\n        if end is None:\n            end = self.duration\n        if start &gt; end:\n            raise ValueError(\"start must be less than end\")\n        # Apply trim operation\n        return self.apply_operation(\"trim\", start=start, end=end)\n\n    def rms_trend(\n        self,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the RMS trend of the signal.\n\n        This method computes the root mean square value over sliding windows.\n\n        Args:\n            frame_length: The size of the sliding window in samples. Default is 2048.\n            hop_length: The hop length between windows in samples. Default is 512.\n            dB: Whether to return the RMS values in decibels. Default is False.\n            Aw: Whether to apply A-weighting. Default is False.\n\n        Returns:\n            A new ChannelFrame containing the RMS trend.\n        \"\"\"\n        cf = self.apply_operation(\n            \"rms_trend\",\n            frame_length=frame_length,\n            hop_length=hop_length,\n            ref=[ch.ref for ch in self._channel_metadata],\n            dB=dB,\n            Aw=Aw,\n        )\n        cf.sampling_rate = self.sampling_rate / hop_length\n        return cf\n\n    def sum(self) -&gt; \"ChannelFrame\":\n        \"\"\"Sum all channels.\n\n        Returns:\n            A new ChannelFrame with summed signal.\n        \"\"\"\n        return self.apply_operation(\"sum\")\n\n    def mean(self) -&gt; \"ChannelFrame\":\n        \"\"\"Average all channels.\n\n        Returns:\n            A new ChannelFrame with averaged signal.\n        \"\"\"\n        return self.apply_operation(\"mean\")\n\n    def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate channel differences relative to a reference channel.\n\n        Args:\n            other_channel: Reference channel index or label. Default is 0.\n\n        Returns:\n            A new ChannelFrame with channel differences.\n        \"\"\"\n        if isinstance(other_channel, str):\n            return self.apply_operation(\n                \"channel_difference\", other_channel=self.label2index(other_channel)\n            )\n        return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n\n    def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n        \"\"\"Compute Fast Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is next power of 2 of data length.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectralFrame containing the FFT results.\n        \"\"\"\n        from ..processing.time_series import FFT\n        from .spectral import SpectralFrame\n\n        params = {\"n_fft\": n_fft, \"window\": window}\n        operation_name = \"fft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"FFT\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        if n_fft is None:\n            is_even = spectrum_data.shape[-1] % 2 == 0\n            _n_fft = (\n                spectrum_data.shape[-1] * 2 - 2\n                if is_even\n                else spectrum_data.shape[-1] * 2 - 1\n            )\n        else:\n            _n_fft = n_fft\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=_n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def welch(\n        self,\n        n_fft: Optional[int] = None,\n        hop_length: Optional[int] = None,\n        win_length: int = 2048,\n        window: str = \"hann\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute power spectral density using Welch's method.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the power spectral density.\n        \"\"\"\n        from ..processing.time_series import Welch\n        from .spectral import SpectralFrame\n\n        params = dict(\n            n_fft=n_fft or win_length,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            average=average,\n        )\n        operation_name = \"welch\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Welch\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"welch\", \"params\": params},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def noct_spectrum(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"Compute N-octave band spectrum.\n\n        Args:\n            fmin: Minimum center frequency in Hz. Default is 20 Hz.\n            fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n            n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n            G: Reference gain in dB. Default is 10 dB.\n            fr: Reference frequency in Hz. Default is 1000 Hz.\n\n        Returns:\n            A NOctFrame containing the N-octave band spectrum.\n        \"\"\"\n        from ..processing.time_series import NOctSpectrum\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_spectrum\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSpectrum\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_spectrum\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def stft(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"Compute Short-Time Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectrogramFrame containing the STFT results.\n        \"\"\"\n        from ..processing.time_series import STFT, create_operation\n        from .spectrogram import SpectrogramFrame\n\n        # Set hop length and window length\n        _hop_length = hop_length if hop_length is not None else n_fft // 4\n        _win_length = win_length if win_length is not None else n_fft\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": _hop_length,\n            \"win_length\": _win_length,\n            \"window\": window,\n        }\n        operation_name = \"stft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"STFT\", operation)\n\n        # Apply processing to data\n        spectrogram_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n\n        # Create new instance\n        return SpectrogramFrame(\n            data=spectrogram_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=n_fft,\n            hop_length=_hop_length,\n            win_length=_win_length,\n            window=window,\n            label=f\"stft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def coherence(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute magnitude squared coherence.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n        Returns:\n            A SpectralFrame containing the magnitude squared coherence.\n        \"\"\"\n        from ..processing.time_series import Coherence, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n        }\n        operation_name = \"coherence\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Coherence\", operation)\n\n        # Apply processing to data\n        coherence_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=coherence_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Coherence of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def csd(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute cross-spectral density matrix.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the cross-spectral density matrix.\n        \"\"\"\n        from ..processing.time_series import CSD, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"csd\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"CSD\", operation)\n\n        # Apply processing to data\n        csd_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=csd_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def transfer_function(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute transfer function matrix.\n\n        The transfer function characterizes the signal transmission properties\n        between channels in the frequency domain, representing the input-output\n        relationship of a system.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the transfer function matrix.\n        \"\"\"\n        from ..processing.time_series import TransferFunction, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"transfer_function\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"TransferFunction\", operation)\n\n        # Apply processing to data\n        tf_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=tf_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Transfer function of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"Provide additional initialization arguments required for ChannelFrame.\"\"\"\n        return {}\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Returns the duration in seconds.</p>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>Returns the number of samples.</p>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.time","title":"<code>time</code>  <code>property</code>","text":"<p>Get time array for the signal.</p> <p>Returns:</p> Type Description <code>NDArrayReal</code> <p>Array of time points in seconds.</p>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.__init__","title":"<code>__init__(data, sampling_rate, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a ChannelFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>Dask array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate of the data in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>operation_history</code> <code>Optional[list[dict[str, Any]]]</code> <p>History of operations applied to the frame.</p> <code>None</code> <code>channel_metadata</code> <code>Optional[list[ChannelMetadata]]</code> <p>Metadata for each channel.</p> <code>None</code> <code>previous</code> <code>Optional[BaseFrame[Any]]</code> <p>Reference to the previous frame in the processing chain.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has more than 2 dimensions.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"Initialize a ChannelFrame.\n\n    Args:\n        data: Dask array containing channel data.\n        Shape should be (n_channels, n_samples).\n        sampling_rate: The sampling rate of the data in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        operation_history: History of operations applied to the frame.\n        channel_metadata: Metadata for each channel.\n        previous: Reference to the previous frame in the processing chain.\n\n    Raises:\n        ValueError: If data has more than 2 dimensions.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.a_weighting","title":"<code>a_weighting()</code>","text":"<p>Apply A-weighting filter to the signal.</p> <p>A-weighting adjusts the frequency response to approximate human hearing perception, following IEC 61672-1:2013 standard.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with A-weighted signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def a_weighting(self) -&gt; \"ChannelFrame\":\n    \"\"\"Apply A-weighting filter to the signal.\n\n    A-weighting adjusts the frequency response to approximate human hearing\n    perception, following IEC 61672-1:2013 standard.\n\n    Returns:\n        A new ChannelFrame with A-weighted signal.\n    \"\"\"\n    return self.apply_operation(\"a_weighting\")\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.abs","title":"<code>abs()</code>","text":"<p>Calculate the absolute value of the signal.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the absolute values.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def abs(self) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the absolute value of the signal.\n\n    Returns:\n        A new ChannelFrame containing the absolute values.\n    \"\"\"\n    return self.apply_operation(\"abs\")\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.add","title":"<code>add(other, snr=None)</code>","text":"<p>Add another signal or value to the current signal.</p> <p>If SNR is specified, performs addition with consideration for signal-to-noise ratio.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[ChannelFrame, int, float, NDArrayReal, Array]</code> <p>Signal or value to add.</p> required <code>snr</code> <code>Optional[float]</code> <p>Signal-to-noise ratio (dB). If specified, adjusts the scale of the other signal based on this SNR. self is treated as the signal, and other as the noise.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new channel frame containing the addition result (lazy execution).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def add(\n    self,\n    other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n    snr: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Add another signal or value to the current signal.\n\n    If SNR is specified, performs addition with consideration for\n    signal-to-noise ratio.\n\n    Args:\n        other: Signal or value to add.\n        snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n            other signal based on this SNR.\n            self is treated as the signal, and other as the noise.\n\n    Returns:\n        A new channel frame containing the addition result (lazy execution).\n    \"\"\"\n    logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n    # Special processing when SNR is specified\n    if snr is not None:\n        # First convert other to ChannelFrame if it's not\n        if not isinstance(other, ChannelFrame):\n            if isinstance(other, np.ndarray):\n                other = ChannelFrame.from_numpy(\n                    other, self.sampling_rate, label=\"array_data\"\n                )\n            elif isinstance(other, (int, float)):\n                # For scalar values, simply add (ignore SNR)\n                return self + other\n            else:\n                raise TypeError(\n                    \"Addition target with SNR must be a ChannelFrame or \"\n                    f\"NumPy array: {type(other)}\"\n                )\n\n        # Check if sampling rates match\n        if self.sampling_rate != other.sampling_rate:\n            raise ValueError(\n                \"Sampling rates do not match. Cannot perform operation.\"\n            )\n\n        # Apply addition operation with SNR adjustment\n        return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n    # Execute normal addition if SNR is not specified\n    return self + other\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.channel_difference","title":"<code>channel_difference(other_channel=0)</code>","text":"<p>Calculate channel differences relative to a reference channel.</p> <p>Parameters:</p> Name Type Description Default <code>other_channel</code> <code>Union[int, str]</code> <p>Reference channel index or label. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with channel differences.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate channel differences relative to a reference channel.\n\n    Args:\n        other_channel: Reference channel index or label. Default is 0.\n\n    Returns:\n        A new ChannelFrame with channel differences.\n    \"\"\"\n    if isinstance(other_channel, str):\n        return self.apply_operation(\n            \"channel_difference\", other_channel=self.label2index(other_channel)\n        )\n    return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.coherence","title":"<code>coherence(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant')</code>","text":"<p>Compute magnitude squared coherence.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the magnitude squared coherence.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def coherence(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute magnitude squared coherence.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n    Returns:\n        A SpectralFrame containing the magnitude squared coherence.\n    \"\"\"\n    from ..processing.time_series import Coherence, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n    }\n    operation_name = \"coherence\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Coherence\", operation)\n\n    # Apply processing to data\n    coherence_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=coherence_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Coherence of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.csd","title":"<code>csd(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute cross-spectral density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the cross-spectral density matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def csd(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute cross-spectral density matrix.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the cross-spectral density matrix.\n    \"\"\"\n    from ..processing.time_series import CSD, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"csd\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"CSD\", operation)\n\n    # Apply processing to data\n    csd_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=csd_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.describe","title":"<code>describe(normalize=True, **kwargs)</code>","text":"<p>Display visual and audio representation of the frame.</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>Whether to normalize the audio data for playback.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for visualization.</p> <code>{}</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n    \"\"\"Display visual and audio representation of the frame.\n\n    Args:\n        normalize: Whether to normalize the audio data for playback.\n        **kwargs: Additional parameters for visualization.\n    \"\"\"\n    if \"axis_config\" in kwargs:\n        logger.warning(\n            \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        axis_config = kwargs[\"axis_config\"]\n        if \"time_plot\" in axis_config:\n            kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n        if \"freq_plot\" in axis_config:\n            if \"xlim\" in axis_config[\"freq_plot\"]:\n                vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                kwargs[\"vmin\"] = vlim[0]\n                kwargs[\"vmax\"] = vlim[1]\n            if \"ylim\" in axis_config[\"freq_plot\"]:\n                ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                kwargs[\"ylim\"] = ylim\n\n    if \"cbar_config\" in kwargs:\n        logger.warning(\n            \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        cbar_config = kwargs[\"cbar_config\"]\n        if \"vmin\" in cbar_config:\n            kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n        if \"vmax\" in cbar_config:\n            kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n    for ch in self:\n        ax: Axes\n        _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n        if isinstance(_ax, Iterator):\n            ax = next(iter(_ax))\n        elif isinstance(_ax, Axes):\n            ax = _ax\n        else:\n            raise TypeError(\n                f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n            )\n        # Ignore type checks for display and Audio\n        display(ax.figure)  # type: ignore\n        plt.close(ax.figure)  # type: ignore\n        display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.fft","title":"<code>fft(n_fft=None, window='hann')</code>","text":"<p>Compute Fast Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is next power of 2 of data length.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the FFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n    \"\"\"Compute Fast Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is next power of 2 of data length.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectralFrame containing the FFT results.\n    \"\"\"\n    from ..processing.time_series import FFT\n    from .spectral import SpectralFrame\n\n    params = {\"n_fft\": n_fft, \"window\": window}\n    operation_name = \"fft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"FFT\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    if n_fft is None:\n        is_even = spectrum_data.shape[-1] % 2 == 0\n        _n_fft = (\n            spectrum_data.shape[-1] * 2 - 2\n            if is_even\n            else spectrum_data.shape[-1] * 2 - 1\n        )\n    else:\n        _n_fft = n_fft\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=_n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.from_file","title":"<code>from_file(path, channel=None, start=None, end=None, chunk_size=None, ch_labels=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from an audio file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the audio file.</p> required <code>channel</code> <code>Optional[Union[int, list[int]]]</code> <p>Channel(s) to load.</p> <code>None</code> <code>start</code> <code>Optional[float]</code> <p>Start time in seconds.</p> <code>None</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <code>chunk_size</code> <code>Optional[int]</code> <p>Chunk size for processing.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the file reader.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the loaded audio data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If channel selection is invalid.</p> <code>TypeError</code> <p>If channel parameter type is invalid.</p> <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    path: Union[str, Path],\n    channel: Optional[Union[int, list[int]]] = None,\n    start: Optional[float] = None,\n    end: Optional[float] = None,\n    chunk_size: Optional[int] = None,\n    ch_labels: Optional[list[str]] = None,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from an audio file.\n\n    Args:\n        path: Path to the audio file.\n        channel: Channel(s) to load.\n        start: Start time in seconds.\n        end: End time in seconds.\n        chunk_size: Chunk size for processing.\n        Specifies the splitting size for lazy processing.\n        ch_labels: Labels for each channel.\n        **kwargs: Additional arguments passed to the file reader.\n\n    Returns:\n        A new ChannelFrame containing the loaded audio data.\n\n    Raises:\n        ValueError: If channel selection is invalid.\n        TypeError: If channel parameter type is invalid.\n        FileNotFoundError: If the file doesn't exist.\n    \"\"\"\n    from .channel import ChannelFrame\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    # Get file reader\n    reader = get_file_reader(path)\n\n    # Get file info\n    info = reader.get_file_info(path, **kwargs)\n    sr = info[\"samplerate\"]\n    n_channels = info[\"channels\"]\n    n_frames = info[\"frames\"]\n    ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n    logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n    # Channel selection processing\n    all_channels = list(range(n_channels))\n\n    if channel is None:\n        channels_to_load = all_channels\n        logger.debug(f\"Will load all channels: {channels_to_load}\")\n    elif isinstance(channel, int):\n        if channel &lt; 0 or channel &gt;= n_channels:\n            raise ValueError(\n                f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n            )\n        channels_to_load = [channel]\n        logger.debug(f\"Will load single channel: {channel}\")\n    elif isinstance(channel, (list, tuple)):\n        for ch in channel:\n            if ch &lt; 0 or ch &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n        channels_to_load = list(channel)\n        logger.debug(f\"Will load specific channels: {channels_to_load}\")\n    else:\n        raise TypeError(\"channel must be int, list, or None\")\n\n    # Index calculation\n    start_idx = 0 if start is None else max(0, int(start * sr))\n    end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n    frames_to_read = end_idx - start_idx\n\n    logger.debug(\n        f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n        f\"start_idx={start_idx}, end_idx={end_idx}\"\n    )\n\n    # Settings for lazy loading\n    expected_shape = (len(channels_to_load), frames_to_read)\n\n    # Define the loading function using the file reader\n    def _load_audio() -&gt; NDArrayReal:\n        logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n        # Use the reader to get audio data with parameters\n        out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n        if not isinstance(out, np.ndarray):\n            raise ValueError(\"Unexpected data type after reading file\")\n        return out\n\n    logger.debug(\n        f\"Creating delayed dask task with expected shape: {expected_shape}\"\n    )\n\n    # Create delayed operation\n    delayed_data = dask_delayed(_load_audio)()\n    logger.debug(\"Wrapping delayed function in dask array\")\n\n    # Create dask array from delayed computation\n    dask_array = da_from_delayed(\n        delayed_data, shape=expected_shape, dtype=np.float32\n    )\n\n    if chunk_size is not None:\n        if chunk_size &lt;= 0:\n            raise ValueError(\"Chunk size must be a positive integer\")\n        logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n        dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n    logger.debug(\n        \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n    )\n\n    cf = ChannelFrame(\n        data=dask_array,\n        sampling_rate=sr,\n        label=path.stem,\n        metadata={\n            \"filename\": str(path),\n        },\n    )\n    if ch_labels is not None:\n        if len(ch_labels) != len(cf):\n            raise ValueError(\n                \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    return cf\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.from_ndarray","title":"<code>from_ndarray(array, sampling_rate, labels=None, unit=None, frame_label=None, metadata=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>This method is deprecated. Use from_numpy instead.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>NDArrayReal</code> <p>Signal data. Each row corresponds to a channel.</p> required <code>sampling_rate</code> <code>float</code> <p>Sampling rate (Hz).</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>unit</code> <code>Optional[Union[list[str], str]]</code> <p>Unit of the signal.</p> <code>None</code> <code>frame_label</code> <code>Optional[str]</code> <p>Label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_ndarray(\n    cls,\n    array: NDArrayReal,\n    sampling_rate: float,\n    labels: Optional[list[str]] = None,\n    unit: Optional[Union[list[str], str]] = None,\n    frame_label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    This method is deprecated. Use from_numpy instead.\n\n    Args:\n        array: Signal data. Each row corresponds to a channel.\n        sampling_rate: Sampling rate (Hz).\n        labels: Labels for each channel.\n        unit: Unit of the signal.\n        frame_label: Label for the frame.\n        metadata: Optional metadata dictionary.\n\n    Returns:\n        A new ChannelFrame containing the data.\n    \"\"\"\n    # Redirect to from_numpy for compatibility\n    # However, from_ndarray is deprecated\n    logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n    return cls.from_numpy(\n        data=array,\n        sampling_rate=sampling_rate,\n        label=frame_label,\n        metadata=metadata,\n        ch_labels=labels,\n        ch_units=unit,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.from_numpy","title":"<code>from_numpy(data, sampling_rate, label=None, metadata=None, ch_labels=None, ch_units=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArrayReal</code> <p>NumPy array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>ch_units</code> <code>Optional[Union[list[str], str]]</code> <p>Units for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the NumPy data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_numpy(\n    cls,\n    data: NDArrayReal,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    ch_labels: Optional[list[str]] = None,\n    ch_units: Optional[Union[list[str], str]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    Args:\n        data: NumPy array containing channel data.\n        sampling_rate: The sampling rate in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        ch_labels: Labels for each channel.\n        ch_units: Units for each channel.\n\n    Returns:\n        A new ChannelFrame containing the NumPy data.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n\n    # Convert NumPy array to dask array\n    dask_data = da_from_array(data)\n    cf = ChannelFrame(\n        data=dask_data,\n        sampling_rate=sampling_rate,\n        label=label or \"numpy_data\",\n    )\n    if metadata is not None:\n        cf.metadata = metadata\n    if ch_labels is not None:\n        if len(ch_labels) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel labels does not match the number of channels\"\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    if ch_units is not None:\n        if isinstance(ch_units, str):\n            ch_units = [ch_units] * cf.n_channels\n\n        if len(ch_units) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel units does not match the number of channels\"\n            )\n        for i in range(len(ch_units)):\n            cf._channel_metadata[i].unit = ch_units[i]\n\n    return cf\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.high_pass_filter","title":"<code>high_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a high-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a high-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.hpss_harmonic","title":"<code>hpss_harmonic(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract harmonic components using HPSS  (Harmonic-Percussive Source Separation).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_harmonic(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract harmonic components using HPSS\n     (Harmonic-Percussive Source Separation).\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_harmonic\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.hpss_percussive","title":"<code>hpss_percussive(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract percussive components using HPSS (Harmonic-Percussive Source Separation).</p> <p>This method separates the percussive (tonal) components from the signal.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Union[_IntLike_co, tuple[_IntLike_co, _IntLike_co], list[_IntLike_co]]</code> <p>Median filter size for HPSS.</p> <code>31</code> <code>power</code> <code>float</code> <p>Exponent for the Weiner filter used in HPSS.</p> <code>2</code> <code>margin</code> <code>Union[_FloatLike_co, tuple[_FloatLike_co, _FloatLike_co], list[_FloatLike_co]]</code> <p>Margin size for the separation.</p> <code>1</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the harmonic components.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_percussive(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract percussive components using HPSS\n    (Harmonic-Percussive Source Separation).\n\n    This method separates the percussive (tonal) components from the signal.\n\n    Args:\n        kernel_size: Median filter size for HPSS.\n        power: Exponent for the Weiner filter used in HPSS.\n        margin: Margin size for the separation.\n\n    Returns:\n        A new ChannelFrame containing the harmonic components.\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_percussive\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.low_pass_filter","title":"<code>low_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a low-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a low-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.mean","title":"<code>mean()</code>","text":"<p>Average all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with averaged signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def mean(self) -&gt; \"ChannelFrame\":\n    \"\"\"Average all channels.\n\n    Returns:\n        A new ChannelFrame with averaged signal.\n    \"\"\"\n    return self.apply_operation(\"mean\")\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.noct_spectrum","title":"<code>noct_spectrum(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Compute N-octave band spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>fmin</code> <code>float</code> <p>Minimum center frequency in Hz. Default is 20 Hz.</p> required <code>fmax</code> <code>float</code> <p>Maximum center frequency in Hz. Default is 20000 Hz.</p> required <code>n</code> <code>int</code> <p>Band division (1 for octave, 3 for 1/3 octave). Default is 3.</p> <code>3</code> <code>G</code> <code>int</code> <p>Reference gain in dB. Default is 10 dB.</p> <code>10</code> <code>fr</code> <code>int</code> <p>Reference frequency in Hz. Default is 1000 Hz.</p> <code>1000</code> <p>Returns:</p> Type Description <code>NOctFrame</code> <p>A NOctFrame containing the N-octave band spectrum.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def noct_spectrum(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"Compute N-octave band spectrum.\n\n    Args:\n        fmin: Minimum center frequency in Hz. Default is 20 Hz.\n        fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n        n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n        G: Reference gain in dB. Default is 10 dB.\n        fr: Reference frequency in Hz. Default is 1000 Hz.\n\n    Returns:\n        A NOctFrame containing the N-octave band spectrum.\n    \"\"\"\n    from ..processing.time_series import NOctSpectrum\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_spectrum\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSpectrum\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_spectrum\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.normalize","title":"<code>normalize(target_level=-20, channel_wise=True)</code>","text":"<p>Normalize the signal level.</p> <p>This method adjusts the signal amplitude to reach a target RMS level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target RMS level in dB. Default is -20.</p> <code>-20</code> <code>channel_wise</code> <code>bool</code> <p>If True, normalize each channel independently. If False, apply the same scaling to all channels.</p> <code>True</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the normalized signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def normalize(\n    self, target_level: float = -20, channel_wise: bool = True\n) -&gt; \"ChannelFrame\":\n    \"\"\"Normalize the signal level.\n\n    This method adjusts the signal amplitude to reach a target RMS level.\n\n    Args:\n        target_level: Target RMS level in dB. Default is -20.\n        channel_wise: If True, normalize each channel independently.\n            If False, apply the same scaling to all channels.\n\n    Returns:\n        A new ChannelFrame containing the normalized signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n    )\n    return self.apply_operation(\n        \"normalize\", target_level=target_level, channel_wise=channel_wise\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.plot","title":"<code>plot(plot_type='waveform', ax=None, **kwargs)</code>","text":"<p>Plot the frame data.</p> <p>Parameters:</p> Name Type Description Default <code>plot_type</code> <code>str</code> <p>Type of plot. Default is \"waveform\".</p> <code>'waveform'</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def plot(\n    self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Plot the frame data.\n\n    Args:\n        plot_type: Type of plot. Default is \"waveform\".\n        ax: Optional matplotlib axes for plotting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    plot_strategy = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.power","title":"<code>power(exponent=2.0)</code>","text":"<p>Calculate the power of the signal.</p> <p>Parameters:</p> Name Type Description Default <code>exponent</code> <code>float</code> <p>The exponent to raise the signal to. Default is 2.0.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the signal raised to the power.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the power of the signal.\n\n    Args:\n        exponent: The exponent to raise the signal to. Default is 2.0.\n\n    Returns:\n        A new ChannelFrame containing the signal raised to the power.\n    \"\"\"\n    return self.apply_operation(\"power\", exponent=exponent)\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.read_csv","title":"<code>read_csv(filename, time_column=0, labels=None, delimiter=',', header=0)</code>  <code>classmethod</code>","text":"<p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.read_wav","title":"<code>read_wav(filename, labels=None)</code>  <code>classmethod</code>","text":"<p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.resampling","title":"<code>resampling(target_sr, **kwargs)</code>","text":"<p>Resample audio data.</p>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.resampling--parameters","title":"Parameters","text":"<p>target_sr : float     Target sampling rate (Hz) resample_type : str, optional     Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.) **kwargs : dict     Additional resampling parameters</p>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.resampling--returns","title":"Returns","text":"<p>ChannelFrame     Resampled channel frame</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def resampling(\n    self,\n    target_sr: float,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Resample audio data.\n\n    Parameters\n    ----------\n    target_sr : float\n        Target sampling rate (Hz)\n    resample_type : str, optional\n        Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n    **kwargs : dict\n        Additional resampling parameters\n\n    Returns\n    -------\n    ChannelFrame\n        Resampled channel frame\n    \"\"\"\n    return self.apply_operation(\n        \"resampling\",\n        target_sr=target_sr,\n        **kwargs,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.rms_plot","title":"<code>rms_plot(ax=None, title=None, overlay=True, Aw=False, **kwargs)</code>","text":"<p>Generate an RMS plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title for the plot.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay the plot on the existing axis.</p> <code>True</code> <code>Aw</code> <code>bool</code> <p>Apply A-weighting.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_plot(\n    self,\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = True,\n    Aw: bool = False,  # noqa: N803\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Generate an RMS plot.\n\n    Args:\n        ax: Optional matplotlib axes for plotting.\n        title: Title for the plot.\n        overlay: Whether to overlay the plot on the existing axis.\n        Aw: Apply A-weighting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    kwargs = kwargs or {}\n    ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n    rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n    return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.rms_trend","title":"<code>rms_trend(frame_length=2048, hop_length=512, dB=False, Aw=False)</code>","text":"<p>Calculate the RMS trend of the signal.</p> <p>This method computes the root mean square value over sliding windows.</p> <p>Parameters:</p> Name Type Description Default <code>frame_length</code> <code>int</code> <p>The size of the sliding window in samples. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>int</code> <p>The hop length between windows in samples. Default is 512.</p> <code>512</code> <code>dB</code> <code>bool</code> <p>Whether to return the RMS values in decibels. Default is False.</p> <code>False</code> <code>Aw</code> <code>bool</code> <p>Whether to apply A-weighting. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the RMS trend.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_trend(\n    self,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the RMS trend of the signal.\n\n    This method computes the root mean square value over sliding windows.\n\n    Args:\n        frame_length: The size of the sliding window in samples. Default is 2048.\n        hop_length: The hop length between windows in samples. Default is 512.\n        dB: Whether to return the RMS values in decibels. Default is False.\n        Aw: Whether to apply A-weighting. Default is False.\n\n    Returns:\n        A new ChannelFrame containing the RMS trend.\n    \"\"\"\n    cf = self.apply_operation(\n        \"rms_trend\",\n        frame_length=frame_length,\n        hop_length=hop_length,\n        ref=[ch.ref for ch in self._channel_metadata],\n        dB=dB,\n        Aw=Aw,\n    )\n    cf.sampling_rate = self.sampling_rate / hop_length\n    return cf\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.save","title":"<code>save(path, format=None)</code>","text":"<p>Save the audio data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n    data = self.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    sf.write(str(path), data, int(self.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {path}\")\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.stft","title":"<code>stft(n_fft=2048, hop_length=None, win_length=None, window='hann')</code>","text":"<p>Compute Short-Time Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectrogramFrame</code> <p>A SpectrogramFrame containing the STFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def stft(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n) -&gt; \"SpectrogramFrame\":\n    \"\"\"Compute Short-Time Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectrogramFrame containing the STFT results.\n    \"\"\"\n    from ..processing.time_series import STFT, create_operation\n    from .spectrogram import SpectrogramFrame\n\n    # Set hop length and window length\n    _hop_length = hop_length if hop_length is not None else n_fft // 4\n    _win_length = win_length if win_length is not None else n_fft\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": _hop_length,\n        \"win_length\": _win_length,\n        \"window\": window,\n    }\n    operation_name = \"stft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"STFT\", operation)\n\n    # Apply processing to data\n    spectrogram_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n\n    # Create new instance\n    return SpectrogramFrame(\n        data=spectrogram_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=n_fft,\n        hop_length=_hop_length,\n        win_length=_win_length,\n        window=window,\n        label=f\"stft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.sum","title":"<code>sum()</code>","text":"<p>Sum all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with summed signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def sum(self) -&gt; \"ChannelFrame\":\n    \"\"\"Sum all channels.\n\n    Returns:\n        A new ChannelFrame with summed signal.\n    \"\"\"\n    return self.apply_operation(\"sum\")\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.transfer_function","title":"<code>transfer_function(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute transfer function matrix.</p> <p>The transfer function characterizes the signal transmission properties between channels in the frequency domain, representing the input-output relationship of a system.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the transfer function matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def transfer_function(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute transfer function matrix.\n\n    The transfer function characterizes the signal transmission properties\n    between channels in the frequency domain, representing the input-output\n    relationship of a system.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the transfer function matrix.\n    \"\"\"\n    from ..processing.time_series import TransferFunction, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"transfer_function\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"TransferFunction\", operation)\n\n    # Apply processing to data\n    tf_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=tf_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Transfer function of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.trim","title":"<code>trim(start=0, end=None)</code>","text":"<p>Trim the signal to specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>Start time in seconds.</p> <code>0</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with trimmed signal.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If end time is before start time.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def trim(\n    self,\n    start: float = 0,\n    end: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Trim the signal to specified time range.\n\n    Args:\n        start: Start time in seconds.\n        end: End time in seconds.\n\n    Returns:\n        A new ChannelFrame with trimmed signal.\n\n    Raises:\n        ValueError: If end time is before start time.\n    \"\"\"\n    if end is None:\n        end = self.duration\n    if start &gt; end:\n        raise ValueError(\"start must be less than end\")\n    # Apply trim operation\n    return self.apply_operation(\"trim\", start=start, end=end)\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.welch","title":"<code>welch(n_fft=None, hop_length=None, win_length=2048, window='hann', average='mean')</code>","text":"<p>Compute power spectral density using Welch's method.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is 2048.</p> <code>None</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>int</code> <p>Length of window. Default is n_fft.</p> <code>2048</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the power spectral density.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def welch(\n    self,\n    n_fft: Optional[int] = None,\n    hop_length: Optional[int] = None,\n    win_length: int = 2048,\n    window: str = \"hann\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute power spectral density using Welch's method.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the power spectral density.\n    \"\"\"\n    from ..processing.time_series import Welch\n    from .spectral import SpectralFrame\n\n    params = dict(\n        n_fft=n_fft or win_length,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        average=average,\n    )\n    operation_name = \"welch\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Welch\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"welch\", \"params\": params},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/frames/#spectralframe","title":"SpectralFrame","text":"<p><code>SpectralFrame</code> is a frame that handles frequency-domain data.</p> <pre><code>from wandas.frames.spectral import SpectralFrame\n\n# Or convert from ChannelFrame\nchannel_frame = wandas.read_wav(\"audio.wav\")\nspectral_frame = channel_frame.to_spectral()\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayComplex]</code></p> <p>Class for handling frequency-domain signal data.</p> <p>This class represents spectral data, providing methods for spectral analysis, manipulation, and visualization. It handles complex-valued frequency domain data obtained through operations like FFT.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The spectral data. Must be a dask array with shape:     - (channels, frequency_bins) for multi-channel data     - (frequency_bins,) for single-channel data, which will be       reshaped to (1, frequency_bins) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. n_fft : int     The FFT size used to generate this spectral data. window : str, default=\"hann\"     The window function used in the FFT. label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame--attributes","title":"Attributes","text":"<p>magnitude : NDArrayReal     The magnitude spectrum of the data. phase : NDArrayReal     The phase spectrum in radians. power : NDArrayReal     The power spectrum (magnitude squared). dB : NDArrayReal     The spectrum in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrum in decibels. freqs : NDArrayReal     The frequency axis values in Hz.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame--examples","title":"Examples","text":"<p>Create a SpectralFrame from FFT:</p> <p>signal = ChannelFrame.from_numpy(data, sampling_rate=44100) spectrum = signal.fft(n_fft=2048)</p> <p>Plot the magnitude spectrum:</p> <p>spectrum.plot()</p> <p>Perform binary operations:</p> <p>scaled = spectrum * 2.0 summed = spectrum1 + spectrum2  # Must have matching sampling rates</p> <p>Convert back to time domain:</p> <p>time_signal = spectrum.ifft()</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame--notes","title":"Notes","text":"<ul> <li>All operations are performed lazily using dask arrays for efficient memory usage.</li> <li>Binary operations (+, -, *, /) can be performed between SpectralFrames or with   scalar values.</li> <li>The class maintains the processing history and metadata through all operations.</li> </ul> Source code in <code>wandas/frames/spectral.py</code> <pre><code>class SpectralFrame(BaseFrame[NDArrayComplex]):\n    \"\"\"\n    Class for handling frequency-domain signal data.\n\n    This class represents spectral data, providing methods for spectral analysis,\n    manipulation, and visualization. It handles complex-valued frequency domain data\n    obtained through operations like FFT.\n\n    Parameters\n    ----------\n    data : DaArray\n        The spectral data. Must be a dask array with shape:\n        - (channels, frequency_bins) for multi-channel data\n        - (frequency_bins,) for single-channel data, which will be\n          reshaped to (1, frequency_bins)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    n_fft : int\n        The FFT size used to generate this spectral data.\n    window : str, default=\"hann\"\n        The window function used in the FFT.\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    magnitude : NDArrayReal\n        The magnitude spectrum of the data.\n    phase : NDArrayReal\n        The phase spectrum in radians.\n    power : NDArrayReal\n        The power spectrum (magnitude squared).\n    dB : NDArrayReal\n        The spectrum in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrum in decibels.\n    freqs : NDArrayReal\n        The frequency axis values in Hz.\n\n    Examples\n    --------\n    Create a SpectralFrame from FFT:\n    &gt;&gt;&gt; signal = ChannelFrame.from_numpy(data, sampling_rate=44100)\n    &gt;&gt;&gt; spectrum = signal.fft(n_fft=2048)\n\n    Plot the magnitude spectrum:\n    &gt;&gt;&gt; spectrum.plot()\n\n    Perform binary operations:\n    &gt;&gt;&gt; scaled = spectrum * 2.0\n    &gt;&gt;&gt; summed = spectrum1 + spectrum2  # Must have matching sampling rates\n\n    Convert back to time domain:\n    &gt;&gt;&gt; time_signal = spectrum.ifft()\n\n    Notes\n    -----\n    - All operations are performed lazily using dask arrays for efficient memory usage.\n    - Binary operations (+, -, *, /) can be performed between SpectralFrames or with\n      scalar values.\n    - The class maintains the processing history and metadata through all operations.\n    \"\"\"\n\n    n_fft: int\n    window: str\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        n_fft: int,\n        window: str = \"hann\",\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306f1\u6b21\u5143\u307e\u305f\u306f2\u6b21\u5143\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u5f62\u72b6: {data.shape}\"\n            )\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def magnitude(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the magnitude spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The absolute values of the complex spectrum.\n        \"\"\"\n        return np.abs(self.data)\n\n    @property\n    def phase(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the phase spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The phase angles of the complex spectrum in radians.\n        \"\"\"\n        return np.angle(self.data)\n\n    @property\n    def power(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the power spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The squared magnitude spectrum.\n        \"\"\"\n        return self.magnitude**2\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrum in decibels.\n\n        The reference values are taken from channel metadata. If no reference\n        is specified, uses 1.0.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrum in dB relative to channel references.\n        \"\"\"\n        mag: NDArrayReal = self.magnitude\n        ref_values: NDArrayReal = np.array([ch.ref for ch in self._channel_metadata])\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(mag / ref_values[:, np.newaxis], 1e-12)\n        )\n\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrum in decibels.\n\n        Applies A-weighting filter to the spectrum for better correlation with\n        perceived loudness.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrum in dB.\n        \"\"\"\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels.\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the frequency axis values in Hz.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of frequency values corresponding to each frequency bin.\n        \"\"\"\n        return np.fft.rfftfreq(self.n_fft, 1.0 / self.sampling_rate)\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Implementation of operation application for spectral data.\n\n        This internal method handles the application of various operations to\n        spectral data, maintaining lazy evaluation through dask.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters for the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        processed_data = operation.process(self._data)\n\n        # \u30e1\u30bf\u30c7\u30fc\u30bf\u66f4\u65b0\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\n            \"SpectralFrame\", int, float, complex, NDArrayComplex, NDArrayReal, \"DaArray\"\n        ],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"\n        Common implementation for binary operations.\n\n        This method handles binary operations between SpectralFrames and various types\n        of operands, maintaining lazy evaluation through dask arrays.\n\n        Parameters\n        ----------\n        other : Union[SpectralFrame, int, float, complex,\n                        NDArrayComplex, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation (e.g., lambda a, b: a + b)\n        symbol : str\n            String representation of the operation (e.g., '+')\n\n        Returns\n        -------\n        SpectralFrame\n            A new SpectralFrame containing the result of the operation.\n\n        Raises\n        ------\n        ValueError\n            If attempting to operate with a SpectralFrame\n            with a different sampling rate.\n        \"\"\"\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, SpectralFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u304c\u4e00\u81f4\u3057\u3066\u3044\u307e\u305b\u3093\u3002\u6f14\u7b97\u3067\u304d\u307e\u305b\u3093\u3002\"\n                )\n\n            # dask array\u3092\u76f4\u63a5\u6f14\u7b97\uff08\u9045\u5ef6\u5b9f\u884c\u3092\u7dad\u6301\uff09\n            result_data = op(self._data, other._data)\n\n            # \u30c1\u30e3\u30cd\u30eb\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u7d50\u5408\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return SpectralFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # \u30b9\u30ab\u30e9\u30fc\u3001NumPy\u914d\u5217\u3001\u307e\u305f\u306f\u4ed6\u306e\u30bf\u30a4\u30d7\u3068\u306e\u6f14\u7b97\n        else:\n            # dask array\u306b\u76f4\u63a5\u6f14\u7b97\u3092\u9069\u7528\uff08\u9045\u5ef6\u5b9f\u884c\u3092\u7dad\u6301\uff09\n            result_data = op(self._data, other)\n\n            # \u30aa\u30da\u30e9\u30f3\u30c9\u306e\u8868\u793a\u7528\u6587\u5b57\u5217\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, complex):\n                other_str = f\"complex({other.real}, {other.imag})\"\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # dask.array.Array\u306e\u30c1\u30a7\u30c3\u30af\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # \u30c1\u30e3\u30cd\u30eb\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u66f4\u65b0\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return SpectralFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n            )\n\n    def plot(\n        self,\n        plot_type: str = \"frequency\",\n        ax: Optional[\"Axes\"] = None,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the spectral data using various visualization strategies.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"frequency\"\n            Type of plot to create. Options include:\n            - \"frequency\": Standard frequency plot\n            - \"matrix\": Matrix plot for comparing channels\n            - Other types as defined by available plot strategies\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - title: Plot title\n            - xlabel, ylabel: Axis labels\n            - vmin, vmax: Value limits for plots\n            - cmap: Colormap name\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def ifft(self) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.\n\n        This method transforms the frequency-domain data back to the time domain using\n        the inverse FFT operation. The window function used in the forward FFT is\n        taken into account to ensure proper reconstruction.\n\n        Returns\n        -------\n        ChannelFrame\n            A new ChannelFrame containing the time-domain signal.\n        \"\"\"\n        from ..processing.time_series import IFFT, create_operation\n        from .channel import ChannelFrame\n\n        params = {\"n_fft\": self.n_fft, \"window\": self.window}\n        operation_name = \"ifft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"IFFT\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        time_series = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        return ChannelFrame(\n            data=time_series,\n            sampling_rate=self.sampling_rate,\n            label=f\"ifft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        SpectralFrame \u306b\u5fc5\u8981\u306a\u8ffd\u52a0\u306e\u521d\u671f\u5316\u5f15\u6570\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments for SpectralFrame.\n        \"\"\"\n        return {\n            \"n_fft\": self.n_fft,\n            \"window\": self.window,\n        }\n\n    def noct_synthesis(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"\n        Synthesize N-octave band spectrum.\n\n        This method combines frequency components into N-octave bands according to\n        standard acoustical band definitions. This is commonly used in noise and\n        vibration analysis.\n\n        Parameters\n        ----------\n        fmin : float\n            Lower frequency bound in Hz.\n        fmax : float\n            Upper frequency bound in Hz.\n        n : int, default=3\n            Number of bands per octave (e.g., 3 for third-octave bands).\n        G : int, default=10\n            Reference band number.\n        fr : int, default=1000\n            Reference frequency in Hz.\n\n        Returns\n        -------\n        NOctFrame\n            A new NOctFrame containing the N-octave band spectrum.\n\n        Raises\n        ------\n        ValueError\n            If the sampling rate is not 48000 Hz, which is required for this operation.\n        \"\"\"\n        if self.sampling_rate != 48000:\n            raise ValueError(\n                \"noct_synthesis\u306f48000Hz\u306e\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u3067\u306e\u307f\u4f7f\u7528\u3067\u304d\u307e\u3059\u3002\"\n            )\n        from ..processing.time_series import NOctSynthesis\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_synthesis\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSynthesis\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_synthesis\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def plot_matrix(\n        self,\n        plot_type: str = \"matrix\",\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot channel relationships in matrix format.\n\n        This method creates a matrix plot showing relationships between channels,\n        such as coherence, transfer functions, or cross-spectral density.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"matrix\"\n            Type of matrix plot to create.\n        **kwargs : dict\n            Additional plot parameters:\n            - vmin, vmax: Color scale limits\n            - cmap: Colormap name\n            - title: Plot title\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrum in decibels.</p> <p>The reference values are taken from channel metadata. If no reference is specified, uses 1.0.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrum in dB relative to channel references.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrum in decibels.</p> <p>Applies A-weighting filter to the spectrum for better correlation with perceived loudness.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrum in dB.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the frequency axis values in Hz.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of frequency values corresponding to each frequency bin.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.magnitude","title":"<code>magnitude</code>  <code>property</code>","text":"<p>Get the magnitude spectrum.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.magnitude--returns","title":"Returns","text":"<p>NDArrayReal     The absolute values of the complex spectrum.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.phase","title":"<code>phase</code>  <code>property</code>","text":"<p>Get the phase spectrum.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.phase--returns","title":"Returns","text":"<p>NDArrayReal     The phase angles of the complex spectrum in radians.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.power","title":"<code>power</code>  <code>property</code>","text":"<p>Get the power spectrum.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.power--returns","title":"Returns","text":"<p>NDArrayReal     The squared magnitude spectrum.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.ifft","title":"<code>ifft()</code>","text":"<p>Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.</p> <p>This method transforms the frequency-domain data back to the time domain using the inverse FFT operation. The window function used in the forward FFT is taken into account to ensure proper reconstruction.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.ifft--returns","title":"Returns","text":"<p>ChannelFrame     A new ChannelFrame containing the time-domain signal.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def ifft(self) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.\n\n    This method transforms the frequency-domain data back to the time domain using\n    the inverse FFT operation. The window function used in the forward FFT is\n    taken into account to ensure proper reconstruction.\n\n    Returns\n    -------\n    ChannelFrame\n        A new ChannelFrame containing the time-domain signal.\n    \"\"\"\n    from ..processing.time_series import IFFT, create_operation\n    from .channel import ChannelFrame\n\n    params = {\"n_fft\": self.n_fft, \"window\": self.window}\n    operation_name = \"ifft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"IFFT\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    time_series = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    return ChannelFrame(\n        data=time_series,\n        sampling_rate=self.sampling_rate,\n        label=f\"ifft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis","title":"<code>noct_synthesis(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Synthesize N-octave band spectrum.</p> <p>This method combines frequency components into N-octave bands according to standard acoustical band definitions. This is commonly used in noise and vibration analysis.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--parameters","title":"Parameters","text":"<p>fmin : float     Lower frequency bound in Hz. fmax : float     Upper frequency bound in Hz. n : int, default=3     Number of bands per octave (e.g., 3 for third-octave bands). G : int, default=10     Reference band number. fr : int, default=1000     Reference frequency in Hz.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--returns","title":"Returns","text":"<p>NOctFrame     A new NOctFrame containing the N-octave band spectrum.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--raises","title":"Raises","text":"<p>ValueError     If the sampling rate is not 48000 Hz, which is required for this operation.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def noct_synthesis(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"\n    Synthesize N-octave band spectrum.\n\n    This method combines frequency components into N-octave bands according to\n    standard acoustical band definitions. This is commonly used in noise and\n    vibration analysis.\n\n    Parameters\n    ----------\n    fmin : float\n        Lower frequency bound in Hz.\n    fmax : float\n        Upper frequency bound in Hz.\n    n : int, default=3\n        Number of bands per octave (e.g., 3 for third-octave bands).\n    G : int, default=10\n        Reference band number.\n    fr : int, default=1000\n        Reference frequency in Hz.\n\n    Returns\n    -------\n    NOctFrame\n        A new NOctFrame containing the N-octave band spectrum.\n\n    Raises\n    ------\n    ValueError\n        If the sampling rate is not 48000 Hz, which is required for this operation.\n    \"\"\"\n    if self.sampling_rate != 48000:\n        raise ValueError(\n            \"noct_synthesis\u306f48000Hz\u306e\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u3067\u306e\u307f\u4f7f\u7528\u3067\u304d\u307e\u3059\u3002\"\n        )\n    from ..processing.time_series import NOctSynthesis\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_synthesis\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSynthesis\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_synthesis\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.plot","title":"<code>plot(plot_type='frequency', ax=None, **kwargs)</code>","text":"<p>Plot the spectral data using various visualization strategies.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"frequency\"     Type of plot to create. Options include:     - \"frequency\": Standard frequency plot     - \"matrix\": Matrix plot for comparing channels     - Other types as defined by available plot strategies ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - title: Plot title     - xlabel, ylabel: Axis labels     - vmin, vmax: Value limits for plots     - cmap: Colormap name     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def plot(\n    self,\n    plot_type: str = \"frequency\",\n    ax: Optional[\"Axes\"] = None,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the spectral data using various visualization strategies.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"frequency\"\n        Type of plot to create. Options include:\n        - \"frequency\": Standard frequency plot\n        - \"matrix\": Matrix plot for comparing channels\n        - Other types as defined by available plot strategies\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - title: Plot title\n        - xlabel, ylabel: Axis labels\n        - vmin, vmax: Value limits for plots\n        - cmap: Colormap name\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix","title":"<code>plot_matrix(plot_type='matrix', **kwargs)</code>","text":"<p>Plot channel relationships in matrix format.</p> <p>This method creates a matrix plot showing relationships between channels, such as coherence, transfer functions, or cross-spectral density.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"matrix\"     Type of matrix plot to create. **kwargs : dict     Additional plot parameters:     - vmin, vmax: Color scale limits     - cmap: Colormap name     - title: Plot title</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def plot_matrix(\n    self,\n    plot_type: str = \"matrix\",\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot channel relationships in matrix format.\n\n    This method creates a matrix plot showing relationships between channels,\n    such as coherence, transfer functions, or cross-spectral density.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"matrix\"\n        Type of matrix plot to create.\n    **kwargs : dict\n        Additional plot parameters:\n        - vmin, vmax: Color scale limits\n        - cmap: Colormap name\n        - title: Plot title\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/api/frames/#spectrogramframe","title":"SpectrogramFrame","text":"<p><code>SpectrogramFrame</code> is a frame that handles time-frequency representation (spectrogram) data.</p> <pre><code>from wandas.frames.spectrogram import SpectrogramFrame\n\n# Or convert from ChannelFrame\nchannel_frame = wandas.read_wav(\"audio.wav\")\nspectrogram_frame = channel_frame.to_spectrogram()\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayComplex]</code></p> <p>Class for handling time-frequency domain data (spectrograms).</p> <p>This class represents spectrogram data obtained through Short-Time Fourier Transform (STFT) or similar time-frequency analysis methods. It provides methods for visualization, manipulation, and conversion back to time domain.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The spectrogram data. Must be a dask array with shape:     - (channels, frequency_bins, time_frames) for multi-channel data     - (frequency_bins, time_frames) for single-channel data, which will be       reshaped to (1, frequency_bins, time_frames) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. n_fft : int     The FFT size used to generate this spectrogram. hop_length : int     Number of samples between successive frames. win_length : int, optional     The window length in samples. If None, defaults to n_fft. window : str, default=\"hann\"     The window function to use (e.g., \"hann\", \"hamming\", \"blackman\"). label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame--attributes","title":"Attributes","text":"<p>magnitude : NDArrayReal     The magnitude spectrogram. phase : NDArrayReal     The phase spectrogram in radians. power : NDArrayReal     The power spectrogram. dB : NDArrayReal     The spectrogram in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrogram in decibels. n_frames : int     Number of time frames. n_freq_bins : int     Number of frequency bins. freqs : NDArrayReal     The frequency axis values in Hz. times : NDArrayReal     The time axis values in seconds.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame--examples","title":"Examples","text":"<p>Create a spectrogram from a time-domain signal:</p> <p>signal = ChannelFrame.from_wav(\"audio.wav\") spectrogram = signal.stft(n_fft=2048, hop_length=512)</p> <p>Extract a specific time frame:</p> <p>frame_at_1s = spectrogram.get_frame_at(int(1.0 * sampling_rate / hop_length))</p> <p>Convert back to time domain:</p> <p>reconstructed = spectrogram.to_channel_frame()</p> <p>Plot the spectrogram:</p> <p>spectrogram.plot()</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>class SpectrogramFrame(BaseFrame[NDArrayComplex]):\n    \"\"\"\n    Class for handling time-frequency domain data (spectrograms).\n\n    This class represents spectrogram data obtained through\n    Short-Time Fourier Transform (STFT)\n    or similar time-frequency analysis methods. It provides methods for visualization,\n    manipulation, and conversion back to time domain.\n\n    Parameters\n    ----------\n    data : DaArray\n        The spectrogram data. Must be a dask array with shape:\n        - (channels, frequency_bins, time_frames) for multi-channel data\n        - (frequency_bins, time_frames) for single-channel data, which will be\n          reshaped to (1, frequency_bins, time_frames)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    n_fft : int\n        The FFT size used to generate this spectrogram.\n    hop_length : int\n        Number of samples between successive frames.\n    win_length : int, optional\n        The window length in samples. If None, defaults to n_fft.\n    window : str, default=\"hann\"\n        The window function to use (e.g., \"hann\", \"hamming\", \"blackman\").\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    magnitude : NDArrayReal\n        The magnitude spectrogram.\n    phase : NDArrayReal\n        The phase spectrogram in radians.\n    power : NDArrayReal\n        The power spectrogram.\n    dB : NDArrayReal\n        The spectrogram in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrogram in decibels.\n    n_frames : int\n        Number of time frames.\n    n_freq_bins : int\n        Number of frequency bins.\n    freqs : NDArrayReal\n        The frequency axis values in Hz.\n    times : NDArrayReal\n        The time axis values in seconds.\n\n    Examples\n    --------\n    Create a spectrogram from a time-domain signal:\n    &gt;&gt;&gt; signal = ChannelFrame.from_wav(\"audio.wav\")\n    &gt;&gt;&gt; spectrogram = signal.stft(n_fft=2048, hop_length=512)\n\n    Extract a specific time frame:\n    &gt;&gt;&gt; frame_at_1s = spectrogram.get_frame_at(int(1.0 * sampling_rate / hop_length))\n\n    Convert back to time domain:\n    &gt;&gt;&gt; reconstructed = spectrogram.to_channel_frame()\n\n    Plot the spectrogram:\n    &gt;&gt;&gt; spectrogram.plot()\n    \"\"\"\n\n    n_fft: int\n    hop_length: int\n    win_length: int\n    window: str\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        if data.ndim == 2:\n            data = da.expand_dims(data, axis=0)  # type: ignore [unused-ignore]\n        elif data.ndim != 3:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306f2\u6b21\u5143\u307e\u305f\u306f3\u6b21\u5143\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u5f62\u72b6: {data.shape}\"\n            )\n        if not data.shape[-2] == n_fft // 2 + 1:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u304c\u7121\u52b9\u3067\u3059\u3002\u5468\u6ce2\u6570\u30d3\u30f3\u6570\u306f {n_fft // 2 + 1} \u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\"  # noqa: E501\n            )\n\n        self.n_fft = n_fft\n        self.hop_length = hop_length\n        self.win_length = win_length if win_length is not None else n_fft\n        self.window = window\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def magnitude(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the magnitude spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The absolute values of the complex spectrogram.\n        \"\"\"\n        return np.abs(self.data)\n\n    @property\n    def phase(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the phase spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The phase angles of the complex spectrogram in radians.\n        \"\"\"\n        return np.angle(self.data)\n\n    @property\n    def power(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the power spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The squared magnitude of the complex spectrogram.\n        \"\"\"\n        return np.abs(self.data) ** 2\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrogram in decibels relative to each channel's reference value.\n\n        The reference value for each channel is specified in its metadata.\n        A minimum value of -120 dB is enforced to avoid numerical issues.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrogram in decibels.\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        ref = np.array([ch.ref for ch in self._channel_metadata])\n        # dB\u5909\u63db\n        # 0\u9664\u7b97\u3092\u907f\u3051\u308b\u305f\u3081\u306b\u3001\u6700\u5927\u5024\u30681e-12\u306e\u3044\u305a\u308c\u304b\u3092\u4f7f\u7528\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(self.magnitude / ref[..., np.newaxis, np.newaxis], 1e-12)\n        )\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrogram in decibels.\n\n        A-weighting applies a frequency-dependent weighting filter that approximates\n        the human ear's response. This is particularly useful for analyzing noise\n        and acoustic measurements.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrogram in decibels.\n        \"\"\"\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted[:, np.newaxis]  # \u5468\u6ce2\u6570\u8ef8\u306b\u6cbf\u3063\u3066\u30d6\u30ed\u30fc\u30c9\u30ad\u30e3\u30b9\u30c8\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels.\n        \"\"\"\n        return self.shape[0]\n\n    @property\n    def n_frames(self) -&gt; int:\n        \"\"\"\n        Get the number of time frames.\n\n        Returns\n        -------\n        int\n            The number of time frames in the spectrogram.\n        \"\"\"\n        return self.shape[-1]\n\n    @property\n    def n_freq_bins(self) -&gt; int:\n        \"\"\"\n        Get the number of frequency bins.\n\n        Returns\n        -------\n        int\n            The number of frequency bins (n_fft // 2 + 1).\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the frequency axis values in Hz.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of frequency values corresponding to each frequency bin.\n        \"\"\"\n        return np.fft.rfftfreq(self.n_fft, 1.0 / self.sampling_rate)\n\n    @property\n    def times(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the time axis values in seconds.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of time values corresponding to each time frame.\n        \"\"\"\n        return np.arange(self.n_frames) * self.hop_length / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Implementation of operation application for spectrogram data.\n\n        This internal method handles the application of various operations to\n        spectrogram data, maintaining lazy evaluation through dask.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters for the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from wandas.processing.time_series import create_operation\n\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        processed_data = operation.process(self._data)\n\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\n            \"SpectrogramFrame\",\n            int,\n            float,\n            complex,\n            NDArrayComplex,\n            NDArrayReal,\n            \"DaArray\",\n        ],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"\n        Common implementation for binary operations.\n\n        This method handles binary operations between\n        SpectrogramFrames and various types\n        of operands, maintaining lazy evaluation through dask arrays.\n\n        Parameters\n        ----------\n        other : Union[SpectrogramFrame, int, float, complex,\n            NDArrayComplex, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation (e.g., lambda a, b: a + b)\n        symbol : str\n            String representation of the operation (e.g., '+')\n\n        Returns\n        -------\n        SpectrogramFrame\n            A new SpectrogramFrame containing the result of the operation.\n\n        Raises\n        ------\n        ValueError\n            If attempting to operate with a SpectrogramFrame\n            with a different sampling rate.\n        \"\"\"\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        if isinstance(other, SpectrogramFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u304c\u4e00\u81f4\u3057\u3066\u3044\u307e\u305b\u3093\u3002\u6f14\u7b97\u3067\u304d\u307e\u305b\u3093\u3002\"\n                )\n\n            result_data = op(self._data, other._data)\n\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return SpectrogramFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                hop_length=self.hop_length,\n                win_length=self.win_length,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n        else:\n            result_data = op(self._data, other)\n\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, complex):\n                other_str = f\"complex({other.real}, {other.imag})\"\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return SpectrogramFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                hop_length=self.hop_length,\n                win_length=self.win_length,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n            )\n\n    def plot(\n        self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the spectrogram using various visualization strategies.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"spectrogram\"\n            Type of plot to create.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - vmin, vmax: Colormap scaling\n            - cmap: Colormap name\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectrogramFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def plot_Aw(  # noqa: N802\n        self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the A-weighted spectrogram.\n\n        A convenience method that calls plot() with Aw=True, applying A-weighting\n        to the spectrogram before plotting.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"spectrogram\"\n            Type of plot to create.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to plot().\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot.\n        \"\"\"\n        return self.plot(plot_type=plot_type, ax=ax, Aw=True, **kwargs)\n\n    def get_frame_at(self, time_idx: int) -&gt; \"SpectralFrame\":\n        \"\"\"\n        Extract spectral data at a specific time frame.\n\n        Parameters\n        ----------\n        time_idx : int\n            Index of the time frame to extract.\n\n        Returns\n        -------\n        SpectralFrame\n            A new SpectralFrame containing the spectral data at the specified time.\n\n        Raises\n        ------\n        IndexError\n            If time_idx is out of range.\n        \"\"\"\n        from wandas.frames.spectral import SpectralFrame\n\n        if time_idx &lt; 0 or time_idx &gt;= self.n_frames:\n            raise IndexError(\n                f\"\u6642\u9593\u30a4\u30f3\u30c7\u30c3\u30af\u30b9 {time_idx} \u304c\u7bc4\u56f2\u5916\u3067\u3059\u3002\u6709\u52b9\u7bc4\u56f2: 0-{self.n_frames - 1}\"  # noqa: E501\n            )\n\n        frame_data = self._data[..., time_idx]\n\n        return SpectralFrame(\n            data=frame_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=self.n_fft,\n            window=self.window,\n            label=f\"{self.label} (Frame {time_idx}, Time {self.times[time_idx]:.3f}s)\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def to_channel_frame(self) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Convert the spectrogram back to time domain using inverse STFT.\n\n        This method performs an inverse Short-Time Fourier Transform (ISTFT) to\n        reconstruct the time-domain signal from the spectrogram.\n\n        Returns\n        -------\n        ChannelFrame\n            A new ChannelFrame containing the reconstructed time-domain signal.\n        \"\"\"\n        from wandas.frames.channel import ChannelFrame\n        from wandas.processing.time_series import ISTFT, create_operation\n\n        params = {\n            \"n_fft\": self.n_fft,\n            \"hop_length\": self.hop_length,\n            \"win_length\": self.win_length,\n            \"window\": self.window,\n        }\n        operation_name = \"istft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"ISTFT\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        time_series = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n\n        # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        return ChannelFrame(\n            data=time_series,\n            sampling_rate=self.sampling_rate,\n            label=f\"istft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get additional initialization arguments for SpectrogramFrame.\n\n        This internal method provides the additional initialization arguments\n        required by SpectrogramFrame beyond those required by BaseFrame.\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments.\n        \"\"\"\n        return {\n            \"n_fft\": self.n_fft,\n            \"hop_length\": self.hop_length,\n            \"win_length\": self.win_length,\n            \"window\": self.window,\n        }\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrogram in decibels relative to each channel's reference value.</p> <p>The reference value for each channel is specified in its metadata. A minimum value of -120 dB is enforced to avoid numerical issues.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrogram in decibels.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrogram in decibels.</p> <p>A-weighting applies a frequency-dependent weighting filter that approximates the human ear's response. This is particularly useful for analyzing noise and acoustic measurements.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrogram in decibels.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the frequency axis values in Hz.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of frequency values corresponding to each frequency bin.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.magnitude","title":"<code>magnitude</code>  <code>property</code>","text":"<p>Get the magnitude spectrogram.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.magnitude--returns","title":"Returns","text":"<p>NDArrayReal     The absolute values of the complex spectrogram.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_frames","title":"<code>n_frames</code>  <code>property</code>","text":"<p>Get the number of time frames.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_frames--returns","title":"Returns","text":"<p>int     The number of time frames in the spectrogram.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_freq_bins","title":"<code>n_freq_bins</code>  <code>property</code>","text":"<p>Get the number of frequency bins.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_freq_bins--returns","title":"Returns","text":"<p>int     The number of frequency bins (n_fft // 2 + 1).</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.phase","title":"<code>phase</code>  <code>property</code>","text":"<p>Get the phase spectrogram.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.phase--returns","title":"Returns","text":"<p>NDArrayReal     The phase angles of the complex spectrogram in radians.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.power","title":"<code>power</code>  <code>property</code>","text":"<p>Get the power spectrogram.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.power--returns","title":"Returns","text":"<p>NDArrayReal     The squared magnitude of the complex spectrogram.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.times","title":"<code>times</code>  <code>property</code>","text":"<p>Get the time axis values in seconds.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.times--returns","title":"Returns","text":"<p>NDArrayReal     Array of time values corresponding to each time frame.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at","title":"<code>get_frame_at(time_idx)</code>","text":"<p>Extract spectral data at a specific time frame.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--parameters","title":"Parameters","text":"<p>time_idx : int     Index of the time frame to extract.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--returns","title":"Returns","text":"<p>SpectralFrame     A new SpectralFrame containing the spectral data at the specified time.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--raises","title":"Raises","text":"<p>IndexError     If time_idx is out of range.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def get_frame_at(self, time_idx: int) -&gt; \"SpectralFrame\":\n    \"\"\"\n    Extract spectral data at a specific time frame.\n\n    Parameters\n    ----------\n    time_idx : int\n        Index of the time frame to extract.\n\n    Returns\n    -------\n    SpectralFrame\n        A new SpectralFrame containing the spectral data at the specified time.\n\n    Raises\n    ------\n    IndexError\n        If time_idx is out of range.\n    \"\"\"\n    from wandas.frames.spectral import SpectralFrame\n\n    if time_idx &lt; 0 or time_idx &gt;= self.n_frames:\n        raise IndexError(\n            f\"\u6642\u9593\u30a4\u30f3\u30c7\u30c3\u30af\u30b9 {time_idx} \u304c\u7bc4\u56f2\u5916\u3067\u3059\u3002\u6709\u52b9\u7bc4\u56f2: 0-{self.n_frames - 1}\"  # noqa: E501\n        )\n\n    frame_data = self._data[..., time_idx]\n\n    return SpectralFrame(\n        data=frame_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=self.n_fft,\n        window=self.window,\n        label=f\"{self.label} (Frame {time_idx}, Time {self.times[time_idx]:.3f}s)\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot","title":"<code>plot(plot_type='spectrogram', ax=None, **kwargs)</code>","text":"<p>Plot the spectrogram using various visualization strategies.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"spectrogram\"     Type of plot to create. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - vmin, vmax: Colormap scaling     - cmap: Colormap name     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def plot(\n    self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the spectrogram using various visualization strategies.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"spectrogram\"\n        Type of plot to create.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - vmin, vmax: Colormap scaling\n        - cmap: Colormap name\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectrogramFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw","title":"<code>plot_Aw(plot_type='spectrogram', ax=None, **kwargs)</code>","text":"<p>Plot the A-weighted spectrogram.</p> <p>A convenience method that calls plot() with Aw=True, applying A-weighting to the spectrogram before plotting.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"spectrogram\"     Type of plot to create. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to plot().</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def plot_Aw(  # noqa: N802\n    self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the A-weighted spectrogram.\n\n    A convenience method that calls plot() with Aw=True, applying A-weighting\n    to the spectrogram before plotting.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"spectrogram\"\n        Type of plot to create.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to plot().\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot.\n    \"\"\"\n    return self.plot(plot_type=plot_type, ax=ax, Aw=True, **kwargs)\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.to_channel_frame","title":"<code>to_channel_frame()</code>","text":"<p>Convert the spectrogram back to time domain using inverse STFT.</p> <p>This method performs an inverse Short-Time Fourier Transform (ISTFT) to reconstruct the time-domain signal from the spectrogram.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.to_channel_frame--returns","title":"Returns","text":"<p>ChannelFrame     A new ChannelFrame containing the reconstructed time-domain signal.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def to_channel_frame(self) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Convert the spectrogram back to time domain using inverse STFT.\n\n    This method performs an inverse Short-Time Fourier Transform (ISTFT) to\n    reconstruct the time-domain signal from the spectrogram.\n\n    Returns\n    -------\n    ChannelFrame\n        A new ChannelFrame containing the reconstructed time-domain signal.\n    \"\"\"\n    from wandas.frames.channel import ChannelFrame\n    from wandas.processing.time_series import ISTFT, create_operation\n\n    params = {\n        \"n_fft\": self.n_fft,\n        \"hop_length\": self.hop_length,\n        \"win_length\": self.win_length,\n        \"window\": self.window,\n    }\n    operation_name = \"istft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"ISTFT\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    time_series = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n    )\n\n    # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    return ChannelFrame(\n        data=time_series,\n        sampling_rate=self.sampling_rate,\n        label=f\"istft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/api/frames/#noctframe","title":"NOctFrame","text":"<p><code>NOctFrame</code> is a frame that handles N-octave analysis data.</p> <pre><code>from wandas.frames.noct import NOctFrame\n\n# Or convert from ChannelFrame\nchannel_frame = wandas.read_wav(\"audio.wav\")\nnoct_frame = channel_frame.to_noct()\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Class for handling N-octave band analysis data.</p> <p>This class represents frequency data analyzed in fractional octave bands, typically used in acoustic and vibration analysis. It handles real-valued data representing energy or power in each frequency band, following standard acoustical band definitions.</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The N-octave band data. Must be a dask array with shape:     - (channels, frequency_bins) for multi-channel data     - (frequency_bins,) for single-channel data, which will be       reshaped to (1, frequency_bins) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. fmin : float, default=0     Lower frequency bound in Hz. fmax : float, default=0     Upper frequency bound in Hz. n : int, default=3     Number of bands per octave (e.g., 3 for third-octave bands). G : int, default=10     Reference band number according to IEC 61260-1:2014. fr : int, default=1000     Reference frequency in Hz, typically 1000 Hz for acoustic analysis. label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame--attributes","title":"Attributes","text":"<p>freqs : NDArrayReal     The center frequencies of each band in Hz, calculated according to     the standard fractional octave band definitions. dB : NDArrayReal     The spectrum in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrum in decibels, applying frequency weighting     for better correlation with perceived loudness. fmin : float     Lower frequency bound in Hz. fmax : float     Upper frequency bound in Hz. n : int     Number of bands per octave. G : int     Reference band number. fr : int     Reference frequency in Hz.</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame--examples","title":"Examples","text":"<p>Create an N-octave band spectrum from a time-domain signal:</p> <p>signal = ChannelFrame.from_wav(\"audio.wav\") spectrum = signal.noct_spectrum(fmin=20, fmax=20000, n=3)</p> <p>Plot the N-octave band spectrum:</p> <p>spectrum.plot()</p> <p>Plot with A-weighting applied:</p> <p>spectrum.plot(Aw=True)</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame--notes","title":"Notes","text":"<ul> <li>Binary operations (addition, multiplication, etc.) are not currently   supported for N-octave band data.</li> <li>The actual frequency bands are determined by the parameters n, G, and fr   according to IEC 61260-1:2014 standard for fractional octave band filters.</li> <li>The class follows acoustic standards for band definitions and analysis,   making it suitable for noise measurements and sound level analysis.</li> <li>A-weighting is available for better correlation with human hearing   perception, following IEC 61672-1:2013.</li> </ul> Source code in <code>wandas/frames/noct.py</code> <pre><code>class NOctFrame(BaseFrame[NDArrayReal]):\n    \"\"\"\n    Class for handling N-octave band analysis data.\n\n    This class represents frequency data analyzed in fractional octave bands,\n    typically used in acoustic and vibration analysis. It handles real-valued\n    data representing energy or power in each frequency band, following standard\n    acoustical band definitions.\n\n    Parameters\n    ----------\n    data : DaArray\n        The N-octave band data. Must be a dask array with shape:\n        - (channels, frequency_bins) for multi-channel data\n        - (frequency_bins,) for single-channel data, which will be\n          reshaped to (1, frequency_bins)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    fmin : float, default=0\n        Lower frequency bound in Hz.\n    fmax : float, default=0\n        Upper frequency bound in Hz.\n    n : int, default=3\n        Number of bands per octave (e.g., 3 for third-octave bands).\n    G : int, default=10\n        Reference band number according to IEC 61260-1:2014.\n    fr : int, default=1000\n        Reference frequency in Hz, typically 1000 Hz for acoustic analysis.\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    freqs : NDArrayReal\n        The center frequencies of each band in Hz, calculated according to\n        the standard fractional octave band definitions.\n    dB : NDArrayReal\n        The spectrum in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrum in decibels, applying frequency weighting\n        for better correlation with perceived loudness.\n    fmin : float\n        Lower frequency bound in Hz.\n    fmax : float\n        Upper frequency bound in Hz.\n    n : int\n        Number of bands per octave.\n    G : int\n        Reference band number.\n    fr : int\n        Reference frequency in Hz.\n\n    Examples\n    --------\n    Create an N-octave band spectrum from a time-domain signal:\n    &gt;&gt;&gt; signal = ChannelFrame.from_wav(\"audio.wav\")\n    &gt;&gt;&gt; spectrum = signal.noct_spectrum(fmin=20, fmax=20000, n=3)\n\n    Plot the N-octave band spectrum:\n    &gt;&gt;&gt; spectrum.plot()\n\n    Plot with A-weighting applied:\n    &gt;&gt;&gt; spectrum.plot(Aw=True)\n\n    Notes\n    -----\n    - Binary operations (addition, multiplication, etc.) are not currently\n      supported for N-octave band data.\n    - The actual frequency bands are determined by the parameters n, G, and fr\n      according to IEC 61260-1:2014 standard for fractional octave band filters.\n    - The class follows acoustic standards for band definitions and analysis,\n      making it suitable for noise measurements and sound level analysis.\n    - A-weighting is available for better correlation with human hearing\n      perception, following IEC 61672-1:2013.\n    \"\"\"\n\n    fmin: float\n    fmax: float\n    n: int\n    G: int\n    fr: int\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        fmin: float = 0,\n        fmax: float = 0,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a NOctFrame instance.\n\n        Sets up N-octave band analysis parameters and prepares the frame for\n        storing band-filtered data. Data shape is validated to ensure compatibility\n        with N-octave band analysis.\n\n        See class docstring for parameter descriptions.\n        \"\"\"\n        self.n = n\n        self.G = G\n        self.fr = fr\n        self.fmin = fmin\n        self.fmax = fmax\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrum in decibels relative to each channel's reference value.\n\n        The reference value for each channel is specified in its metadata.\n        A minimum value of -120 dB is enforced to avoid numerical issues.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrum in decibels. Shape matches the input data shape:\n            (channels, frequency_bins).\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        ref = np.array([ch.ref for ch in self._channel_metadata])\n        # dB\u5909\u63db\n        # 0\u9664\u7b97\u3092\u907f\u3051\u308b\u305f\u3081\u306b\u3001\u6700\u5927\u5024\u30681e-12\u306e\u3044\u305a\u308c\u304b\u3092\u4f7f\u7528\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(self.data / ref[..., np.newaxis], 1e-12)\n        )\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrum in decibels.\n\n        A-weighting applies a frequency-dependent weighting filter that approximates\n        the human ear's response to different frequencies. This is particularly useful\n        for analyzing noise and acoustic measurements as it provides a better\n        correlation with perceived loudness.\n\n        The weighting is applied according to IEC 61672-1:2013 standard.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrum in decibels. Shape matches the input data shape:\n            (channels, frequency_bins).\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels in the N-octave band data.\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the center frequencies of each band in Hz.\n\n        These frequencies are calculated based on the N-octave band parameters\n        (n, G, fr) and the frequency bounds (fmin, fmax) according to\n        IEC 61260-1:2014 standard for fractional octave band filters.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of center frequencies for each frequency band.\n\n        Raises\n        ------\n        ValueError\n            If the center frequencies cannot be calculated or the result\n            is not a numpy array.\n        \"\"\"\n        _, freqs = _center_freq(\n            fmax=self.fmax,\n            fmin=self.fmin,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        if isinstance(freqs, np.ndarray):\n            return freqs\n        else:\n            raise ValueError(\"freqs is not numpy array.\")\n\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"\n        Binary operations are not currently supported for N-octave band data.\n\n        Parameters\n        ----------\n        other : Union[S, int, float, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation.\n        symbol : str\n            String representation of the operation (e.g., '+', '-', '*', '/').\n\n        Raises\n        ------\n        NotImplementedError\n            Always raises this error as operations are not implemented\n            for N-octave band data.\n        \"\"\"\n        raise NotImplementedError(\n            f\"Operation {symbol} is not implemented for NOctFrame.\"\n        )\n        return self\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        \u9045\u5ef6\u8a55\u4fa1\u3092\u4f7f\u7528\u3057\u3066\u64cd\u4f5c\u3092\u9069\u7528\u3057\u307e\u3059\u3002\n        \"\"\"\n        # \u9045\u5ef6\u8a55\u4fa1\u3092\u4f7f\u7528\u3057\u3066\u64cd\u4f5c\u3092\u9069\u7528\n        raise NotImplementedError(\n            f\"Operation {operation_name} is not implemented for NOctFrame.\"\n        )\n        return self\n\n    def plot(\n        self, plot_type: str = \"noct\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the N-octave band data using various visualization strategies.\n\n        Supports standard plotting configurations for acoustic analysis,\n        including decibel scales and A-weighting.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"noct\"\n            Type of plot to create. The default \"noct\" type creates a bar plot\n            suitable for displaying N-octave band data.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n            - title: Plot title\n            - xlabel, ylabel: Axis labels\n            - xscale: Set to \"log\" for logarithmic frequency axis\n            - grid: Whether to show grid lines\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[NOctFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get additional initialization arguments for NOctFrame.\n\n        This internal method provides the additional initialization arguments\n        required by NOctFrame beyond those required by BaseFrame. These include\n        the N-octave band analysis parameters that define the frequency bands.\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments specific to NOctFrame:\n            - n: Number of bands per octave\n            - G: Reference band number\n            - fr: Reference frequency\n            - fmin: Lower frequency bound\n            - fmax: Upper frequency bound\n        \"\"\"\n        return {\n            \"n\": self.n,\n            \"G\": self.G,\n            \"fr\": self.fr,\n            \"fmin\": self.fmin,\n            \"fmax\": self.fmax,\n        }\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrum in decibels relative to each channel's reference value.</p> <p>The reference value for each channel is specified in its metadata. A minimum value of -120 dB is enforced to avoid numerical issues.</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrum in decibels. Shape matches the input data shape:     (channels, frequency_bins).</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrum in decibels.</p> <p>A-weighting applies a frequency-dependent weighting filter that approximates the human ear's response to different frequencies. This is particularly useful for analyzing noise and acoustic measurements as it provides a better correlation with perceived loudness.</p> <p>The weighting is applied according to IEC 61672-1:2013 standard.</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrum in decibels. Shape matches the input data shape:     (channels, frequency_bins).</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the center frequencies of each band in Hz.</p> <p>These frequencies are calculated based on the N-octave band parameters (n, G, fr) and the frequency bounds (fmin, fmax) according to IEC 61260-1:2014 standard for fractional octave band filters.</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of center frequencies for each frequency band.</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.freqs--raises","title":"Raises","text":"<p>ValueError     If the center frequencies cannot be calculated or the result     is not a numpy array.</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.__init__","title":"<code>__init__(data, sampling_rate, fmin=0, fmax=0, n=3, G=10, fr=1000, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a NOctFrame instance.</p> <p>Sets up N-octave band analysis parameters and prepares the frame for storing band-filtered data. Data shape is validated to ensure compatibility with N-octave band analysis.</p> <p>See class docstring for parameter descriptions.</p> Source code in <code>wandas/frames/noct.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    fmin: float = 0,\n    fmax: float = 0,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a NOctFrame instance.\n\n    Sets up N-octave band analysis parameters and prepares the frame for\n    storing band-filtered data. Data shape is validated to ensure compatibility\n    with N-octave band analysis.\n\n    See class docstring for parameter descriptions.\n    \"\"\"\n    self.n = n\n    self.G = G\n    self.fr = fr\n    self.fmin = fmin\n    self.fmax = fmax\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.plot","title":"<code>plot(plot_type='noct', ax=None, **kwargs)</code>","text":"<p>Plot the N-octave band data using various visualization strategies.</p> <p>Supports standard plotting configurations for acoustic analysis, including decibel scales and A-weighting.</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"noct\"     Type of plot to create. The default \"noct\" type creates a bar plot     suitable for displaying N-octave band data. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting     - title: Plot title     - xlabel, ylabel: Axis labels     - xscale: Set to \"log\" for logarithmic frequency axis     - grid: Whether to show grid lines</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/noct.py</code> <pre><code>def plot(\n    self, plot_type: str = \"noct\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the N-octave band data using various visualization strategies.\n\n    Supports standard plotting configurations for acoustic analysis,\n    including decibel scales and A-weighting.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"noct\"\n        Type of plot to create. The default \"noct\" type creates a bar plot\n        suitable for displaying N-octave band data.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n        - title: Plot title\n        - xlabel, ylabel: Axis labels\n        - xscale: Set to \"log\" for logarithmic frequency axis\n        - grid: Whether to show grid lines\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[NOctFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/api/processing/","title":"Processing Module","text":"<p>This page explains the processing module of Wandas. The processing module provides various processing functions for time-series data.</p>"},{"location":"en/api/processing/#time-series-processing","title":"Time Series Processing","text":"<p>These are processing functions for time-series data. These functions are typically used through <code>ChannelFrame</code> methods.</p> <pre><code># Common usage\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")\nfiltered_frame = frame.filter(cutoff=1000, filter_type=\"lowpass\")\nresampled_frame = frame.resample(target_rate=16000)\n</code></pre>"},{"location":"en/api/processing/#key-processing-classes","title":"Key Processing Classes","text":"<p>The filtering and other signal processing functions are internally implemented by the following classes:</p> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>High-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HighPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"High-pass filter operation\"\"\"\n\n    name = \"highpass_filter\"\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize high-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            limit = self.sampling_rate / 2\n            raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up high-pass filter processor\"\"\"\n        # Calculate filter coefficients (once) - safely retrieve from instance variables\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"high\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Highpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying highpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Low-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class LowPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Low-pass filter operation\"\"\"\n\n    name = \"lowpass_filter\"\n    a: NDArrayReal\n    b: NDArrayReal\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize low-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            raise ValueError(\n                f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n            )\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up low-pass filter processor\"\"\"\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"low\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Lowpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying lowpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Resampling operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ReSampling(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Resampling operation\"\"\"\n\n    name = \"resampling\"\n\n    def __init__(self, sampling_rate: float, target_sr: float):\n        \"\"\"\n        Initialize resampling operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        target_sampling_rate : float\n            Target sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate, target_sr=target_sr)\n        self.target_sr = target_sr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after resampling\n        ratio = float(self.target_sr) / float(self.sampling_rate)\n        n_samples = int(np.ceil(input_shape[-1] * ratio))\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for resampling operation\"\"\"\n        logger.debug(f\"Applying resampling to array with shape: {x.shape}\")\n        result = librosa.resample(\n            x, orig_sr=self.sampling_rate, target_sr=self.target_sr\n        )\n        logger.debug(f\"Resampling applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>A-weighting filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AWeighting(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"A-weighting filter operation\"\"\"\n\n    name = \"a_weighting\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize A-weighting filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for A-weighting filter\"\"\"\n        logger.debug(f\"Applying A-weighting to array with shape: {x.shape}\")\n        result = A_weight(x, self.sampling_rate)\n\n        # Handle case where A_weight returns a tuple\n        if isinstance(result, tuple):\n            # Use the first element of the tuple\n            result = result[0]\n\n        logger.debug(\n            f\"A-weighting applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.HighPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize high-pass filter</p>"},{"location":"en/api/processing/#wandas.processing.time_series.HighPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize high-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.HighPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        limit = self.sampling_rate / 2\n        raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.LowPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize low-pass filter</p>"},{"location":"en/api/processing/#wandas.processing.time_series.LowPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize low-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.LowPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        raise ValueError(\n            f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n        )\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.ReSampling.__init__","title":"<code>__init__(sampling_rate, target_sr)</code>","text":"<p>Initialize resampling operation</p>"},{"location":"en/api/processing/#wandas.processing.time_series.ReSampling.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) target_sampling_rate : float     Target sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, target_sr: float):\n    \"\"\"\n    Initialize resampling operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    target_sampling_rate : float\n        Target sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate, target_sr=target_sr)\n    self.target_sr = target_sr\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.ReSampling.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/processing/#wandas.processing.time_series.ReSampling.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/api/processing/#wandas.processing.time_series.ReSampling.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after resampling\n    ratio = float(self.target_sr) / float(self.sampling_rate)\n    n_samples = int(np.ceil(input_shape[-1] * ratio))\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.AWeighting.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize A-weighting filter</p>"},{"location":"en/api/processing/#wandas.processing.time_series.AWeighting.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize A-weighting filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"en/api/processing/#audiooperation","title":"AudioOperation","text":"<p>The <code>AudioOperation</code> class enables abstraction and chaining of audio processing operations.</p> <pre><code>from wandas.processing.time_series import AudioOperation\n\n# Usage example\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")\n\n# Chain multiple processing steps\noperation = (\n    AudioOperation()\n    .add_step(\"filter\", cutoff=1000, filter_type=\"lowpass\")\n    .add_step(\"normalize\")\n)\n\n# Apply the processing\nprocessed_frame = operation.apply(frame)\n</code></pre> <p>               Bases: <code>Generic[InputArrayType, OutputArrayType]</code></p> <p>Abstract base class for audio processing operations.</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AudioOperation(Generic[InputArrayType, OutputArrayType]):\n    \"\"\"Abstract base class for audio processing operations.\"\"\"\n\n    # Class variable: operation name\n    name: ClassVar[str]\n\n    def __init__(self, sampling_rate: float, **params: Any):\n        \"\"\"\n        Initialize AudioOperation.\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        **params : Any\n            Operation-specific parameters\n        \"\"\"\n        self.sampling_rate = sampling_rate\n        self.params = params\n\n        # Validate parameters during initialization\n        self.validate_params()\n\n        # Create processor function (lazy initialization possible)\n        self._setup_processor()\n\n        logger.debug(\n            f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n        )\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n        pass\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up processor function (implemented by subclasses)\"\"\"\n        pass\n\n    def _process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function (implemented by subclasses)\"\"\"\n        # Default is no-op function\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    @dask.delayed  # type: ignore [misc, unused-ignore]\n    def process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n        # Default is no-op function\n        logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n        return self._process_array(x)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation (implemented by subclasses)\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        \"\"\"\n        Execute operation and return result\n        data shape is (channels, samples)\n        \"\"\"\n        # Add task as delayed processing\n        logger.debug(\"Adding delayed operation to computation graph\")\n        delayed_result = self.process_array(data)\n        # Convert delayed result to dask array and return\n        output_shape = self.calculate_output_shape(data.shape)\n        return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.AudioOperation.__init__","title":"<code>__init__(sampling_rate, **params)</code>","text":"<p>Initialize AudioOperation.</p>"},{"location":"en/api/processing/#wandas.processing.time_series.AudioOperation.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) **params : Any     Operation-specific parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, **params: Any):\n    \"\"\"\n    Initialize AudioOperation.\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    **params : Any\n        Operation-specific parameters\n    \"\"\"\n    self.sampling_rate = sampling_rate\n    self.params = params\n\n    # Validate parameters during initialization\n    self.validate_params()\n\n    # Create processor function (lazy initialization possible)\n    self._setup_processor()\n\n    logger.debug(\n        f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n    )\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.AudioOperation.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation (implemented by subclasses)</p>"},{"location":"en/api/processing/#wandas.processing.time_series.AudioOperation.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/api/processing/#wandas.processing.time_series.AudioOperation.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation (implemented by subclasses)\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.AudioOperation.process","title":"<code>process(data)</code>","text":"<p>Execute operation and return result data shape is (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    \"\"\"\n    Execute operation and return result\n    data shape is (channels, samples)\n    \"\"\"\n    # Add task as delayed processing\n    logger.debug(\"Adding delayed operation to computation graph\")\n    delayed_result = self.process_array(data)\n    # Convert delayed result to dask array and return\n    output_shape = self.calculate_output_shape(data.shape)\n    return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.AudioOperation.process_array","title":"<code>process_array(x)</code>","text":"<p>Processing function wrapped with @dask.delayed</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>@dask.delayed  # type: ignore [misc, unused-ignore]\ndef process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n    \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n    # Default is no-op function\n    logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n    return self._process_array(x)\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.AudioOperation.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters (raises exception if invalid)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n    pass\n</code></pre>"},{"location":"en/explanation/","title":"Theory Background and Architecture","text":"<p>This section explains the design philosophy, internal architecture, and theoretical background used in the Wandas library.</p>"},{"location":"en/explanation/#design-philosophy","title":"Design Philosophy","text":"<p>Wandas is developed based on the following design principles:</p> <ol> <li>Intuitive API Design - Consistent interface that users can easily use</li> <li>Efficient Memory Usage - Memory-efficient implementation suitable for processing large-scale data</li> <li>Extensibility - Expandable architecture that makes it easy to add new features and algorithms</li> <li>Scientific Accuracy - Accurate implementation based on acoustic signal processing theory</li> </ol>"},{"location":"en/explanation/#core-architecture","title":"Core Architecture","text":""},{"location":"en/explanation/#data-model","title":"Data Model","text":"<p>The central data model of the Wandas library is hierarchically structured:</p> <pre><code>BaseChannel (base class)\n \u251c\u2500\u2500 Channel (time-domain signal)\n \u2502    \u2514\u2500\u2500 FrequencyChannel (frequency-domain signal)\n \u2502         \u2514\u2500\u2500 TimeFrequencyChannel (time-frequency domain signal)\n \u2514\u2500\u2500 ChannelFrame (container for multiple channels)\n      \u251c\u2500\u2500 FileFrame (file-based multiple channels)\n      \u2514\u2500\u2500 FrequencyChannelFrame (multiple channels in frequency domain)\n</code></pre> <p>Responsibilities of each class:</p> <ul> <li>BaseChannel: Base class for all channels. Provides basic functionality for data access and metadata management</li> <li>Channel: Implements time-domain signal data and processing methods</li> <li>FrequencyChannel: Implements FFT-based frequency-domain data and processing</li> <li>TimeFrequencyChannel: Implements time-frequency domain representations such as Short-Time Fourier Transform (STFT)</li> <li>ChannelFrame: Manages multiple channels and enables batch processing</li> </ul>"},{"location":"en/explanation/#data-processing-flow","title":"Data Processing Flow","text":"<ol> <li>Input Stage: Generate <code>Channel</code> or <code>ChannelFrame</code> objects from files such as WAV and CSV</li> <li>Processing Stage: Apply processing such as filtering and resampling</li> <li>Analysis Stage: Analyze signal characteristics (spectrum, level, etc.)</li> <li>Output Stage: Save processing results to files or visualize as graphs</li> </ol>"},{"location":"en/explanation/#implementation-details","title":"Implementation Details","text":""},{"location":"en/explanation/#memory-efficiency","title":"Memory Efficiency","text":"<p>Wandas ensures memory efficiency for handling large audio data through the following methods:</p> <ul> <li>Lazy Evaluation: A mechanism that delays calculations until needed</li> <li>Memory Mapping: Access to large files without loading them entirely into memory</li> <li>Dask and H5PY: Utilizing libraries suitable for large-scale data processing</li> </ul>"},{"location":"en/explanation/#signal-processing-algorithms","title":"Signal Processing Algorithms","text":"<p>Wandas implements signal processing algorithms such as:</p> <ul> <li>Digital Filters: IIR/FIR filters such as Butterworth filters</li> <li>Spectral Analysis: Frequency analysis based on Fast Fourier Transform (FFT)</li> <li>Time-Frequency Analysis: Short-Time Fourier Transform (STFT), spectrograms</li> <li>Statistical Analysis: Calculation of signal characteristics such as RMS, peak values, crest factor</li> </ul>"},{"location":"en/explanation/#performance-considerations","title":"Performance Considerations","text":"<p>Performance considerations when using Wandas:</p> <ul> <li>When processing large amounts of data, consider processing in chunks</li> <li>When building complex processing chains, improve performance by caching intermediate results</li> <li>Multi-channel processing efficiently utilizes multi-core processors</li> </ul>"},{"location":"en/explanation/#references","title":"References","text":"<ol> <li>Smith, J. O. (2011). Spectral Audio Signal Processing. W3K Publishing.</li> <li>M\u00fcller, M. (2015). Fundamentals of Music Processing: Audio, Analysis, Algorithms, Applications. Springer.</li> <li>Z\u00f6lzer, U. (2008). Digital Audio Signal Processing. Wiley.</li> </ol>"},{"location":"en/how_to/","title":"Cookbook (Use Case Recipes)","text":"<p>This section provides examples of various practical tasks using the Wandas library.</p>"},{"location":"en/how_to/#basic-audio-analysis","title":"Basic Audio Analysis","text":"<ul> <li>Get basic information from audio files</li> <li>Analyze the frequency spectrum of audio</li> <li>Measure volume characteristics such as RMS level and peak level</li> </ul>"},{"location":"en/how_to/#signal-processing","title":"Signal Processing","text":"<ul> <li>Apply low-pass/high-pass/band-pass filters</li> <li>Adjust the volume of specific frequency bands (equalizer)</li> <li>Perform noise reduction</li> <li>Change the pitch of audio</li> </ul>"},{"location":"en/how_to/#audio-data-manipulation","title":"Audio Data Manipulation","text":"<ul> <li>Concatenate multiple audio files</li> <li>Extract specific parts</li> <li>Apply fade-in/fade-out to audio</li> <li>Convert between different formats</li> </ul>"},{"location":"en/how_to/#special-effects","title":"Special Effects","text":"<ul> <li>Add reverb effects</li> <li>Add echo effects</li> <li>Apply distortion effects</li> </ul>"},{"location":"en/how_to/#advanced-applications","title":"Advanced Applications","text":"<ul> <li>Use as preprocessing for speech recognition</li> <li>Efficiently process large datasets</li> <li>Build real-time processing pipelines</li> </ul>"},{"location":"en/how_to/#adding-custom-processing","title":"Adding Custom Processing","text":"<ul> <li>Define your own filters</li> <li>Implement new processing functions</li> <li>Integrate wandas with other libraries</li> </ul> <p>Tip</p> <p>Each recipe is independent and can be referenced as needed. If you don't understand the basic usage, please see the Tutorial first.</p>"},{"location":"en/tutorial/","title":"Tutorial","text":"<p>This tutorial will teach you the basics of the Wandas library in 5 minutes.</p>"},{"location":"en/tutorial/#installation","title":"Installation","text":"<pre><code>pip install wandas\n</code></pre>"},{"location":"en/tutorial/#basic-usage","title":"Basic Usage","text":""},{"location":"en/tutorial/#1-import-the-library","title":"1. Import the Library","text":"<pre><code>import wandas as wd\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"en/tutorial/#2-load-audio-files","title":"2. Load Audio Files","text":"<pre><code># Load a WAV file\naudio = wd.io.read_wav(\"path/to/audio.wav\")\nprint(f\"Sampling rate: {audio.sampling_rate} Hz\")\nprint(f\"Number of channels: {len(audio)}\")\n</code></pre>"},{"location":"en/tutorial/#3-visualize-signals","title":"3. Visualize Signals","text":"<pre><code># Display waveform\naudio.plot()\nplt.show()\n</code></pre>"},{"location":"en/tutorial/#4-basic-signal-processing","title":"4. Basic Signal Processing","text":"<pre><code># Apply a low-pass filter (passing frequencies below 1kHz)\nfiltered = audio.filter(lowpass=1000)\n\n# Visualize and compare results\nfig, axes = plt.subplots(2, 1, figsize=(10, 6))\naudio.plot(ax=axes[0], title=\"Original Signal\")\nfiltered.plot(ax=axes[1], title=\"Filtered Signal\")\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"en/tutorial/#5-save-processing-results","title":"5. Save Processing Results","text":"<pre><code># Save the processed signal as a WAV file\nwd.io.write_wav(filtered, \"filtered_audio.wav\")\n</code></pre>"},{"location":"en/tutorial/#next-steps","title":"Next Steps","text":"<ul> <li>Check out various applications in the Cookbook</li> <li>Look up detailed functions in the API Reference</li> <li>Understand the library's design philosophy in the Theory Background</li> </ul>"},{"location":"ja/","title":"Wandas: Waveform Analysis Data Structures","text":"<p>Wandas \u306f\u3001Python\u306b\u3088\u308b\u52b9\u7387\u7684\u306a\u4fe1\u53f7\u89e3\u6790\u306e\u305f\u3081\u306e\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3059\u3002Wandas \u306f\u3001\u4fe1\u53f7\u51e6\u7406\u306e\u305f\u3081\u306e\u5305\u62ec\u7684\u306a\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u3001Matplotlib\u3068\u306e\u30b7\u30fc\u30e0\u30ec\u30b9\u306a\u7d71\u5408\u3092\u5b9f\u73fe\u3057\u3066\u3044\u307e\u3059\u3002</p>"},{"location":"ja/#_1","title":"\u6a5f\u80fd","text":"<ul> <li>\u5305\u62ec\u7684\u306a\u4fe1\u53f7\u51e6\u7406\u6a5f\u80fd: \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3001\u30d5\u30fc\u30ea\u30a8\u5909\u63db\u3001STFT\u306a\u3069\u3001\u57fa\u672c\u7684\u306a\u4fe1\u53f7\u51e6\u7406\u64cd\u4f5c\u3092\u7c21\u5358\u306b\u5b9f\u884c\u53ef\u80fd</li> <li>\u53ef\u8996\u5316\u30e9\u30a4\u30d6\u30e9\u30ea\u3068\u306e\u7d71\u5408: Matplotlib\u3068\u30b7\u30fc\u30e0\u30ec\u30b9\u306b\u7d71\u5408\u3057\u3066\u30c7\u30fc\u30bf\u3092\u7c21\u5358\u306b\u53ef\u8996\u5316\u53ef\u80fd</li> <li>\u9045\u5ef6\u8a55\u4fa1: dask\u3092\u6d3b\u7528\u3057\u305f\u52b9\u7387\u7684\u306a\u5927\u898f\u6a21\u30c7\u30fc\u30bf\u51e6\u7406</li> <li>\u591a\u69d8\u306a\u5206\u6790\u30c4\u30fc\u30eb: \u5468\u6ce2\u6570\u5206\u6790\u3001\u30aa\u30af\u30bf\u30fc\u30d6\u30d0\u30f3\u30c9\u5206\u6790\u3001\u6642\u9593-\u5468\u6ce2\u6570\u5206\u6790\u306a\u3069</li> </ul>"},{"location":"ja/#_2","title":"\u4f7f\u7528\u4f8b","text":""},{"location":"ja/#_3","title":"\u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\u3068\u53ef\u8996\u5316","text":"<pre><code>import wandas as wd\n\n# docs/docs/ja/index.md \u304b\u3089\u306e\u76f8\u5bfe\u30d1\u30b9\u3067\u30b5\u30f3\u30d7\u30eb\u30c7\u30fc\u30bf\u3092\u6307\u5b9a\n# \u5b9f\u969b\u306e\u4f7f\u7528\u6642\u306f\u9069\u5207\u306a\u30d1\u30b9\u306b\u5909\u66f4\u3057\u3066\u304f\u3060\u3055\u3044\n# cf = wd.read_wav(\"../../examples/data/summer_streets1.wav\")\n# cf.describe()\n</code></pre>"},{"location":"ja/#_4","title":"\u30d5\u30a3\u30eb\u30bf\u51e6\u7406","text":"<pre><code># import wandas as wd\n# import numpy as np\n# signal = wd.generate_sin(freqs=[5000, 1000], duration=1)\n# \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3092\u9069\u7528\n# filtered_signal = signal.low_pass_filter(cutoff=1000)\n# filtered_signal.fft().plot()\n</code></pre> <p>\u8a73\u7d30\u306a\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3084\u4f7f\u7528\u4f8b\u306b\u3064\u3044\u3066\u306f\u3001\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3084\u30af\u30c3\u30af\u30d6\u30c3\u30af\u3092\u3054\u89a7\u304f\u3060\u3055\u3044\u3002</p>"},{"location":"ja/#_5","title":"\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u69cb\u6210","text":"<ul> <li>\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb - 5\u5206\u3067\u59cb\u3081\u3089\u308c\u308b\u5165\u9580\u30ac\u30a4\u30c9</li> <li>\u30af\u30c3\u30af\u30d6\u30c3\u30af - \u4e00\u822c\u7684\u306a\u30bf\u30b9\u30af\u306e\u30ec\u30b7\u30d4\u96c6</li> <li>API\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9 - \u8a73\u7d30\u306aAPI\u4ed5\u69d8</li> <li>\u7406\u8ad6\u80cc\u666f/\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3 - \u8a2d\u8a08\u601d\u60f3\u3068\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u89e3\u8aac</li> <li>\u8ca2\u732e\u30ac\u30a4\u30c9 - \u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30b7\u30e7\u30f3\u306e\u30eb\u30fc\u30eb\u3068\u65b9\u6cd5</li> </ul>"},{"location":"ja/#_6","title":"\u30e9\u30a4\u30bb\u30f3\u30b9","text":"<p>\u3053\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306f MIT\u30e9\u30a4\u30bb\u30f3\u30b9 \u306e\u4e0b\u3067\u516c\u958b\u3055\u308c\u3066\u3044\u307e\u3059\u3002</p>"},{"location":"ja/contributing/","title":"\u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30b7\u30e7\u30f3\u30ac\u30a4\u30c9","text":"<p>Wandas\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3078\u306e\u8ca2\u732e\u306b\u8208\u5473\u3092\u6301\u3063\u3066\u3044\u305f\u3060\u304d\u3042\u308a\u304c\u3068\u3046\u3054\u3056\u3044\u307e\u3059\u3002\u3053\u306e\u30ac\u30a4\u30c9\u3067\u306f\u3001\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30c8\u3059\u308b\u65b9\u6cd5\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002</p>"},{"location":"ja/contributing/#_2","title":"\u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30b7\u30e7\u30f3\u306e\u7a2e\u985e","text":"<p>\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u5f62\u3067Wandas\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u8ca2\u732e\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff1a</p> <ul> <li>\u30d0\u30b0\u5831\u544a\u3084\u6a5f\u80fd\u30ea\u30af\u30a8\u30b9\u30c8</li> <li>\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306e\u6539\u5584</li> <li>\u30d0\u30b0\u4fee\u6b63</li> <li>\u65b0\u6a5f\u80fd\u306e\u5b9f\u88c5</li> <li>\u30c6\u30b9\u30c8\u306e\u8ffd\u52a0\u3084\u6539\u5584</li> <li>\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u306e\u6700\u9069\u5316</li> </ul>"},{"location":"ja/contributing/#_3","title":"\u958b\u767a\u74b0\u5883\u306e\u30bb\u30c3\u30c8\u30a2\u30c3\u30d7","text":""},{"location":"ja/contributing/#1","title":"1. \u30ea\u30dd\u30b8\u30c8\u30ea\u306e\u30af\u30ed\u30fc\u30f3","text":"<pre><code>git clone https://github.com/yourusername/wandas.git\ncd wandas\n</code></pre>"},{"location":"ja/contributing/#2","title":"2. \u4eee\u60f3\u74b0\u5883\u306e\u30bb\u30c3\u30c8\u30a2\u30c3\u30d7\u3068\u4f9d\u5b58\u95a2\u4fc2\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb","text":"<pre><code>python -m venv venv\nsource venv/bin/activate  # Windows\u306e\u5834\u5408: venv\\Scripts\\activate\npip install -e \".[dev]\"\n</code></pre>"},{"location":"ja/contributing/#_4","title":"\u958b\u767a\u30ef\u30fc\u30af\u30d5\u30ed\u30fc","text":""},{"location":"ja/contributing/#1_1","title":"1. \u65b0\u3057\u3044\u30d6\u30e9\u30f3\u30c1\u306e\u4f5c\u6210","text":"<p>\u65b0\u3057\u3044\u6a5f\u80fd\u3084\u30d0\u30b0\u4fee\u6b63\u306b\u306f\u3001\u65b0\u3057\u3044\u30d6\u30e9\u30f3\u30c1\u3092\u4f5c\u6210\u3057\u3066\u304f\u3060\u3055\u3044\uff1a</p> <pre><code>git checkout -b feature/your-feature-name\n# \u307e\u305f\u306f\ngit checkout -b fix/issue-description\n</code></pre>"},{"location":"ja/contributing/#2_1","title":"2. \u30b3\u30fc\u30c9\u30b9\u30bf\u30a4\u30eb","text":"<p>\u30b3\u30fc\u30c9\u306fPEP 8\u30b9\u30bf\u30a4\u30eb\u30ac\u30a4\u30c9\u306b\u5f93\u3063\u3066\u304f\u3060\u3055\u3044\u3002\u30b3\u30fc\u30c9\u306e\u54c1\u8cea\u3092\u78ba\u4fdd\u3059\u308b\u305f\u3081\u306b\u3001\u4ee5\u4e0b\u306e\u30c4\u30fc\u30eb\u3092\u4f7f\u7528\u3057\u3066\u3044\u307e\u3059\uff1a</p> <ul> <li>Ruff: \u30b3\u30fc\u30c9\u30ea\u30f3\u30bf\u30fc\u3068\u30d5\u30a9\u30fc\u30de\u30c3\u30bf\u30fc</li> <li>mypy: \u9759\u7684\u578b\u30c1\u30a7\u30c3\u30af</li> </ul> <p>\u30b3\u30fc\u30c9\u3092\u30b3\u30df\u30c3\u30c8\u3059\u308b\u524d\u306b\u3001\u4ee5\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u3066\u30b3\u30fc\u30c9\u30b9\u30bf\u30a4\u30eb\u3092\u30c1\u30a7\u30c3\u30af\u3057\u3066\u304f\u3060\u3055\u3044\uff1a</p> <pre><code># \u30ea\u30f3\u30c6\u30a3\u30f3\u30b0\nruff check wandas tests\n\n# \u578b\u30c1\u30a7\u30c3\u30af\nmypy wandas tests\n</code></pre>"},{"location":"ja/contributing/#3","title":"3. \u30c6\u30b9\u30c8","text":"<p>\u65b0\u3057\u3044\u6a5f\u80fd\u3084\u30d0\u30b0\u4fee\u6b63\u306b\u306f\u3001\u5fc5\u305a\u30c6\u30b9\u30c8\u3092\u8ffd\u52a0\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u30c6\u30b9\u30c8\u306f<code>pytest</code>\u3092\u4f7f\u7528\u3057\u3066\u5b9f\u884c\u3057\u307e\u3059\uff1a</p> <pre><code>pytest\n</code></pre> <p>\u30ab\u30d0\u30ec\u30c3\u30b8\u30ec\u30dd\u30fc\u30c8\u3092\u751f\u6210\u3059\u308b\u306b\u306f\uff1a</p> <pre><code>pytest --cov=wandas tests/\n</code></pre>"},{"location":"ja/contributing/#4","title":"4. \u30c9\u30ad\u30e5\u30e1\u30f3\u30c8","text":"<p>\u30b3\u30fc\u30c9\u306e\u5909\u66f4\u306b\u306f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306e\u66f4\u65b0\u304c\u5fc5\u8981\u3067\u3059\uff1a</p> <ul> <li>\u95a2\u6570\u3084\u30af\u30e9\u30b9\u306b\u306fNumPy\u5f62\u5f0f\u306edocstring\u3092\u8a18\u8ff0</li> <li>\u65b0\u3057\u3044\u6a5f\u80fd\u306b\u3064\u3044\u3066\u306f\u3001\u9069\u5207\u306a\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u30da\u30fc\u30b8\uff08\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3001\u30cf\u30a6\u30c4\u30fc\u3001API\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\uff09\u3092\u66f4\u65b0\u307e\u305f\u306f\u8ffd\u52a0</li> <li>\u5fc5\u8981\u306b\u5fdc\u3058\u3066\u3001<code>examples/</code>\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3092\u8ffd\u52a0</li> </ul> <p>\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3092\u30d3\u30eb\u30c9\u3057\u3066\u78ba\u8a8d\u3059\u308b\u306b\u306f\uff1a</p> <pre><code>cd docs\nmkdocs serve\n</code></pre> <p>\u305d\u306e\u5f8c\u3001\u30d6\u30e9\u30a6\u30b6\u3067 http://localhost:8000 \u306b\u30a2\u30af\u30bb\u30b9\u3057\u3066\u78ba\u8a8d\u3067\u304d\u307e\u3059\u3002</p>"},{"location":"ja/contributing/#5","title":"5. \u30d7\u30eb\u30ea\u30af\u30a8\u30b9\u30c8\u306e\u4f5c\u6210","text":"<p>\u5909\u66f4\u304c\u5b8c\u4e86\u3057\u305f\u3089\u3001\u30d7\u30eb\u30ea\u30af\u30a8\u30b9\u30c8\uff08PR\uff09\u3092\u4f5c\u6210\u3057\u3066\u304f\u3060\u3055\u3044\uff1a</p> <ol> <li> <p>\u5909\u66f4\u3092\u30b3\u30df\u30c3\u30c8\u3057\u3001\u30ea\u30e2\u30fc\u30c8\u30ea\u30dd\u30b8\u30c8\u30ea\u306b\u30d7\u30c3\u30b7\u30e5    <pre><code>git add .\ngit commit -m \"\u8aac\u660e\u7684\u306a\u30b3\u30df\u30c3\u30c8\u30e1\u30c3\u30bb\u30fc\u30b8\"\ngit push origin your-branch-name\n</code></pre></p> </li> <li> <p>GitHub\u30ea\u30dd\u30b8\u30c8\u30ea\u30da\u30fc\u30b8\u3067\u30d7\u30eb\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u4f5c\u6210</p> </li> <li>PR\u306e\u8aac\u660e\u306b\u306f\u3001\u5909\u66f4\u5185\u5bb9\u3001\u89e3\u6c7a\u3057\u305f\u554f\u984c\u3001\u30c6\u30b9\u30c8\u65b9\u6cd5\u306a\u3069\u3092\u8a18\u8f09</li> </ol>"},{"location":"ja/contributing/#_5","title":"\u30ec\u30d3\u30e5\u30fc\u30d7\u30ed\u30bb\u30b9","text":"<p>\u3059\u3079\u3066\u306ePR\u306f\u4ee5\u4e0b\u306e\u30d7\u30ed\u30bb\u30b9\u3067\u30ec\u30d3\u30e5\u30fc\u3055\u308c\u307e\u3059\uff1a</p> <ol> <li>\u81ea\u52d5CI\u30c6\u30b9\u30c8\u304c\u6210\u529f\u3059\u308b\u3053\u3068</li> <li>\u5c11\u306a\u304f\u3068\u30821\u4eba\u306e\u30e1\u30f3\u30c6\u30ca\u306b\u3088\u308b\u30b3\u30fc\u30c9\u30ec\u30d3\u30e5\u30fc</li> <li>\u5fc5\u8981\u306b\u5fdc\u3058\u3066\u5909\u66f4\u306e\u4f9d\u983c\u3068\u5bfe\u5fdc</li> <li>\u30de\u30fc\u30b8\u627f\u8a8d</li> </ol>"},{"location":"ja/contributing/#_6","title":"\u30b3\u30df\u30e5\u30cb\u30b1\u30fc\u30b7\u30e7\u30f3","text":"<p>\u8cea\u554f\u3084\u8b70\u8ad6\u304c\u3042\u308c\u3070\u3001\u4ee5\u4e0b\u306e\u65b9\u6cd5\u3067\u30b3\u30df\u30e5\u30cb\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u53d6\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff1a</p> <ul> <li>GitHub Issues: \u30d0\u30b0\u5831\u544a\u3084\u6a5f\u80fd\u30ea\u30af\u30a8\u30b9\u30c8</li> <li>GitHub Discussions: \u4e00\u822c\u7684\u306a\u8cea\u554f\u3084\u8b70\u8ad6</li> <li>\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306e\u30e1\u30fc\u30ea\u30f3\u30b0\u30ea\u30b9\u30c8\uff08\u3042\u308b\u5834\u5408\uff09</li> </ul>"},{"location":"ja/contributing/#_7","title":"\u884c\u52d5\u898f\u7bc4","text":"<p>\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u53c2\u52a0\u3059\u308b\u3059\u3079\u3066\u306e\u4eba\u306f\u3001\u884c\u52d5\u898f\u7bc4\u306b\u5f93\u3046\u3053\u3068\u304c\u671f\u5f85\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u4ed6\u306e\u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30bf\u30fc\u306b\u5bfe\u3057\u3066\u656c\u610f\u3092\u6301\u3063\u3066\u63a5\u3057\u3001\u5354\u529b\u7684\u3067\u5efa\u8a2d\u7684\u306a\u30b3\u30df\u30e5\u30cb\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u5fc3\u304c\u3051\u3066\u304f\u3060\u3055\u3044\u3002</p>"},{"location":"ja/api/","title":"API\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9","text":"<p>\u3053\u306e\u30bb\u30af\u30b7\u30e7\u30f3\u3067\u306f\u3001Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u5168\u3066\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3001\u30af\u30e9\u30b9\u3001\u30e1\u30bd\u30c3\u30c9\u306e\u8a73\u7d30\u306a\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u304b\u3089\u81ea\u52d5\u7684\u306b\u751f\u6210\u3055\u308c\u305f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3092\u542b\u3093\u3067\u3044\u307e\u3059\u3002</p>"},{"location":"ja/api/#_1","title":"\u30b3\u30a2\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8","text":""},{"location":"ja/api/#baseframe","title":"BaseFrame","text":"<p><code>BaseFrame</code>\u30af\u30e9\u30b9\u306fWandas\u306e\u57fa\u672c\u5358\u4f4d\u3068\u306a\u308b\u30c7\u30fc\u30bf\u69cb\u9020\u3067\u3059\u3002</p> <pre><code>from wandas.core.base_frame import BaseFrame\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for all signal frame types.</p> <p>This class provides the common interface and functionality for all frame types used in signal processing. It implements basic operations like indexing, iteration, and data manipulation that are shared across all frame types.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The signal data to process. Must be a dask array. sampling_rate : float     The sampling rate of the signal in Hz. label : str, optional     A label for the frame. If not provided, defaults to \"unnamed_frame\". metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame--attributes","title":"Attributes","text":"<p>sampling_rate : float     The sampling rate of the signal in Hz. label : str     The label of the frame. metadata : dict     Additional metadata for the frame. operation_history : list[dict]     History of operations performed on this frame.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>class BaseFrame(ABC, Generic[T]):\n    \"\"\"\n    Abstract base class for all signal frame types.\n\n    This class provides the common interface and functionality for all frame types\n    used in signal processing. It implements basic operations like indexing, iteration,\n    and data manipulation that are shared across all frame types.\n\n    Parameters\n    ----------\n    data : DaArray\n        The signal data to process. Must be a dask array.\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str, optional\n        A label for the frame. If not provided, defaults to \"unnamed_frame\".\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str\n        The label of the frame.\n    metadata : dict\n        Additional metadata for the frame.\n    operation_history : list[dict]\n        History of operations performed on this frame.\n    \"\"\"\n\n    _data: DaArray\n    sampling_rate: float\n    label: str\n    metadata: dict[str, Any]\n    operation_history: list[dict[str, Any]]\n    _channel_metadata: list[ChannelMetadata]\n    _previous: Optional[\"BaseFrame[Any]\"]\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ):\n        self._data = data.rechunk(chunks=-1)  # type: ignore [unused-ignore]\n        if self._data.ndim == 1:\n            self._data = self._data.reshape((1, -1))\n        self.sampling_rate = sampling_rate\n        self.label = label or \"unnamed_frame\"\n        self.metadata = metadata or {}\n        self.operation_history = operation_history or []\n        self._previous = previous\n\n        if channel_metadata:\n            self._channel_metadata = copy.deepcopy(channel_metadata)\n        else:\n            self._channel_metadata = [\n                ChannelMetadata(label=f\"ch{i}\", unit=\"\", extra={})\n                for i in range(self._n_channels)\n            ]\n\n        try:\n            # Display information for newer dask versions\n            logger.debug(f\"Dask graph layers: {list(self._data.dask.layers.keys())}\")\n            logger.debug(\n                f\"Dask graph dependencies: {len(self._data.dask.dependencies)}\"\n            )\n        except Exception as e:\n            logger.debug(f\"Dask graph visualization details unavailable: {e}\")\n\n    @property\n    @abstractmethod\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n\n    @property\n    def n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return len(self)\n\n    @property\n    def channels(self) -&gt; list[ChannelMetadata]:\n        \"\"\"Property to access channel metadata.\"\"\"\n        return self._channel_metadata\n\n    @property\n    def previous(self) -&gt; Optional[\"BaseFrame[Any]\"]:\n        \"\"\"\n        Returns the previous frame.\n        \"\"\"\n        return self._previous\n\n    def get_channel(self: S, channel_idx: int) -&gt; S:\n        n_channels = len(self)\n        if channel_idx &lt; 0 or channel_idx &gt;= n_channels:\n            range_max = n_channels - 1\n            raise ValueError(\n                f\"Channel index out of range: {channel_idx} \"\n                f\"(valid range: 0-{range_max})\"\n            )\n        logger.debug(f\"Extracting channel index={channel_idx} (lazy operation).\")\n        channel_data = self._data[channel_idx : channel_idx + 1]\n\n        return self._create_new_instance(\n            data=channel_data,\n            operation_history=self.operation_history,\n            channel_metadata=[self._channel_metadata[channel_idx]],\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Returns the number of channels.\n        \"\"\"\n        return len(self._channel_metadata)\n\n    def __iter__(self: S) -&gt; Iterator[S]:\n        for idx in range(len(self)):\n            yield self[idx]\n\n    def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n        \"\"\"\n        Method to get a channel by name or index.\n\n        Parameters\n        ----------\n        key : str, int, slice, or tuple of slices\n            Channel name (label) or index number.\n\n        Returns\n        -------\n        BaseFrame\n            The corresponding channel.\n\n        Raises\n        ------\n        ValueError\n            If the key length is invalid for the shape.\n        IndexError\n            If the channel index is out of range.\n        TypeError\n            If the key type is invalid.\n        \"\"\"\n        if isinstance(key, str):\n            index = self.label2index(key)\n            return self.get_channel(index)\n\n        elif isinstance(key, tuple):\n            # When key is a tuple, treat the first element as an index\n            if len(key) &gt; len(self.shape):\n                raise ValueError(\n                    f\"Invalid key length: {len(key)} for shape {self.shape}\"\n                )\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key[0]]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, slice):\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, numbers.Integral):\n            # Access by index number\n            if key &lt; 0 or key &gt;= len(self):\n                raise IndexError(f\"Channel index {key} out of range.\")\n            return self.get_channel(key)\n        else:\n            raise TypeError(\n                f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n            )\n\n    def label2index(self, label: str) -&gt; int:\n        \"\"\"\n        Get the index from a channel label.\n\n        Parameters\n        ----------\n        label : str\n            Channel label.\n\n        Returns\n        -------\n        int\n            Corresponding index.\n\n        Raises\n        ------\n        KeyError\n            If the channel label is not found.\n        \"\"\"\n        for idx, ch in enumerate(self._channel_metadata):\n            if ch.label == label:\n                return idx\n        raise KeyError(f\"Channel label '{label}' not found.\")\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        _shape: tuple[int, ...] = self._data.shape\n        return _shape\n\n    @property\n    def data(self) -&gt; T:\n        \"\"\"\n        Returns the computed data.\n        Calculation is executed the first time this is accessed.\n        \"\"\"\n        return self.compute()\n\n    @property\n    def labels(self) -&gt; list[str]:\n        \"\"\"Get a list of all channel labels.\"\"\"\n        return [ch.label for ch in self._channel_metadata]\n\n    def compute(self) -&gt; T:\n        \"\"\"\n        Compute and return the data.\n        This method materializes lazily computed data into a concrete NumPy array.\n\n        Returns\n        -------\n        NDArrayReal\n            The computed data.\n\n        Raises\n        ------\n        ValueError\n            If the computed result is not a NumPy array.\n        \"\"\"\n        logger.debug(\n            \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n        )\n        result = self._data.compute()\n\n        if not isinstance(result, np.ndarray):\n            raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n        logger.debug(f\"Computation complete, result shape: {result.shape}\")\n        return cast(T, result)\n\n    @abstractmethod\n    def plot(\n        self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n    ) -&gt; Union[Axes, Iterator[Axes]]:\n        \"\"\"Plot the data\"\"\"\n        pass\n\n    def persist(self: S) -&gt; S:\n        \"\"\"Persist the data in memory\"\"\"\n        persisted_data = self._data.persist()\n        return self._create_new_instance(data=persisted_data)\n\n    @abstractmethod\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Abstract method for derived classes to provide\n        additional initialization arguments.\n        \"\"\"\n        pass\n\n    def _create_new_instance(self: S, data: DaArray, **kwargs: Any) -&gt; S:\n        \"\"\"\n        Create a new channel instance based on an existing channel.\n        Keyword arguments can override or extend the original attributes.\n        \"\"\"\n\n        sampling_rate = kwargs.pop(\"sampling_rate\", self.sampling_rate)\n        # if not isinstance(sampling_rate, int):\n        #     raise TypeError(\"Sampling rate must be an integer\")\n\n        label = kwargs.pop(\"label\", self.label)\n        if not isinstance(label, str):\n            raise TypeError(\"Label must be a string\")\n\n        metadata = kwargs.pop(\"metadata\", copy.deepcopy(self.metadata))\n        if not isinstance(metadata, dict):\n            raise TypeError(\"Metadata must be a dictionary\")\n\n        # Get additional initialization arguments from derived classes\n        additional_kwargs = self._get_additional_init_kwargs()\n        kwargs.update(additional_kwargs)\n\n        return type(self)(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            previous=self,\n            **kwargs,\n        )\n\n    def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n        \"\"\"Implicit conversion to NumPy array\"\"\"\n        result = self.compute()\n        if dtype is not None:\n            return result.astype(dtype)\n        return result\n\n    def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n        \"\"\"Visualize the computation graph and save it to a file\"\"\"\n        try:\n            filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n            self._data.visualize(filename=filename)\n            return filename\n        except Exception as e:\n            logger.warning(f\"Failed to visualize the graph: {e}\")\n            return None\n\n    @abstractmethod\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"Basic implementation of binary operations\"\"\"\n        # Basic logic\n        # Actual implementation is left to derived classes\n        pass\n\n    def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Addition operator\"\"\"\n        return self._binary_op(other, lambda x, y: x + y, \"+\")\n\n    def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Subtraction operator\"\"\"\n        return self._binary_op(other, lambda x, y: x - y, \"-\")\n\n    def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Multiplication operator\"\"\"\n        return self._binary_op(other, lambda x, y: x * y, \"*\")\n\n    def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Division operator\"\"\"\n        return self._binary_op(other, lambda x, y: x / y, \"/\")\n\n    def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Apply a named operation.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters to pass to the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        # Apply the operation through abstract method\n        return self._apply_operation_impl(operation_name, **params)\n\n    @abstractmethod\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"Implementation of operation application\"\"\"\n        pass\n\n    def debug_info(self) -&gt; None:\n        \"\"\"Output detailed debug information\"\"\"\n        logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n        logger.debug(f\"Label: {self.label}\")\n        logger.debug(f\"Shape: {self.shape}\")\n        logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n        logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n        self._debug_info_impl()\n        logger.debug(\"=== End Debug Info ===\")\n\n    def _debug_info_impl(self) -&gt; None:\n        \"\"\"Implement derived class-specific debug information\"\"\"\n        pass\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.channels","title":"<code>channels</code>  <code>property</code>","text":"<p>Property to access channel metadata.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.data","title":"<code>data</code>  <code>property</code>","text":"<p>Returns the computed data. Calculation is executed the first time this is accessed.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>Get a list of all channel labels.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.n_channels","title":"<code>n_channels</code>  <code>property</code>","text":"<p>Returns the number of channels.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.previous","title":"<code>previous</code>  <code>property</code>","text":"<p>Returns the previous frame.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__add__","title":"<code>__add__(other)</code>","text":"<p>Addition operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Addition operator\"\"\"\n    return self._binary_op(other, lambda x, y: x + y, \"+\")\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__array__","title":"<code>__array__(dtype=None)</code>","text":"<p>Implicit conversion to NumPy array</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n    \"\"\"Implicit conversion to NumPy array\"\"\"\n    result = self.compute()\n    if dtype is not None:\n        return result.astype(dtype)\n    return result\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Method to get a channel by name or index.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__getitem__--parameters","title":"Parameters","text":"<p>key : str, int, slice, or tuple of slices     Channel name (label) or index number.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__getitem__--returns","title":"Returns","text":"<p>BaseFrame     The corresponding channel.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__getitem__--raises","title":"Raises","text":"<p>ValueError     If the key length is invalid for the shape. IndexError     If the channel index is out of range. TypeError     If the key type is invalid.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n    \"\"\"\n    Method to get a channel by name or index.\n\n    Parameters\n    ----------\n    key : str, int, slice, or tuple of slices\n        Channel name (label) or index number.\n\n    Returns\n    -------\n    BaseFrame\n        The corresponding channel.\n\n    Raises\n    ------\n    ValueError\n        If the key length is invalid for the shape.\n    IndexError\n        If the channel index is out of range.\n    TypeError\n        If the key type is invalid.\n    \"\"\"\n    if isinstance(key, str):\n        index = self.label2index(key)\n        return self.get_channel(index)\n\n    elif isinstance(key, tuple):\n        # When key is a tuple, treat the first element as an index\n        if len(key) &gt; len(self.shape):\n            raise ValueError(\n                f\"Invalid key length: {len(key)} for shape {self.shape}\"\n            )\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key[0]]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, slice):\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, numbers.Integral):\n        # Access by index number\n        if key &lt; 0 or key &gt;= len(self):\n            raise IndexError(f\"Channel index {key} out of range.\")\n        return self.get_channel(key)\n    else:\n        raise TypeError(\n            f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n        )\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of channels.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of channels.\n    \"\"\"\n    return len(self._channel_metadata)\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplication operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Multiplication operator\"\"\"\n    return self._binary_op(other, lambda x, y: x * y, \"*\")\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtraction operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Subtraction operator\"\"\"\n    return self._binary_op(other, lambda x, y: x - y, \"-\")\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Division operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Division operator\"\"\"\n    return self._binary_op(other, lambda x, y: x / y, \"/\")\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.apply_operation","title":"<code>apply_operation(operation_name, **params)</code>","text":"<p>Apply a named operation.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.apply_operation--parameters","title":"Parameters","text":"<p>operation_name : str     Name of the operation to apply. **params : Any     Parameters to pass to the operation.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.apply_operation--returns","title":"Returns","text":"<p>S     A new instance with the operation applied.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n    \"\"\"\n    Apply a named operation.\n\n    Parameters\n    ----------\n    operation_name : str\n        Name of the operation to apply.\n    **params : Any\n        Parameters to pass to the operation.\n\n    Returns\n    -------\n    S\n        A new instance with the operation applied.\n    \"\"\"\n    # Apply the operation through abstract method\n    return self._apply_operation_impl(operation_name, **params)\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.compute","title":"<code>compute()</code>","text":"<p>Compute and return the data. This method materializes lazily computed data into a concrete NumPy array.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.compute--returns","title":"Returns","text":"<p>NDArrayReal     The computed data.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.compute--raises","title":"Raises","text":"<p>ValueError     If the computed result is not a NumPy array.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def compute(self) -&gt; T:\n    \"\"\"\n    Compute and return the data.\n    This method materializes lazily computed data into a concrete NumPy array.\n\n    Returns\n    -------\n    NDArrayReal\n        The computed data.\n\n    Raises\n    ------\n    ValueError\n        If the computed result is not a NumPy array.\n    \"\"\"\n    logger.debug(\n        \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n    )\n    result = self._data.compute()\n\n    if not isinstance(result, np.ndarray):\n        raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n    logger.debug(f\"Computation complete, result shape: {result.shape}\")\n    return cast(T, result)\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.debug_info","title":"<code>debug_info()</code>","text":"<p>Output detailed debug information</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def debug_info(self) -&gt; None:\n    \"\"\"Output detailed debug information\"\"\"\n    logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n    logger.debug(f\"Label: {self.label}\")\n    logger.debug(f\"Shape: {self.shape}\")\n    logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n    logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n    self._debug_info_impl()\n    logger.debug(\"=== End Debug Info ===\")\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.label2index","title":"<code>label2index(label)</code>","text":"<p>Get the index from a channel label.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.label2index--parameters","title":"Parameters","text":"<p>label : str     Channel label.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.label2index--returns","title":"Returns","text":"<p>int     Corresponding index.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.label2index--raises","title":"Raises","text":"<p>KeyError     If the channel label is not found.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def label2index(self, label: str) -&gt; int:\n    \"\"\"\n    Get the index from a channel label.\n\n    Parameters\n    ----------\n    label : str\n        Channel label.\n\n    Returns\n    -------\n    int\n        Corresponding index.\n\n    Raises\n    ------\n    KeyError\n        If the channel label is not found.\n    \"\"\"\n    for idx, ch in enumerate(self._channel_metadata):\n        if ch.label == label:\n            return idx\n    raise KeyError(f\"Channel label '{label}' not found.\")\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.persist","title":"<code>persist()</code>","text":"<p>Persist the data in memory</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def persist(self: S) -&gt; S:\n    \"\"\"Persist the data in memory\"\"\"\n    persisted_data = self._data.persist()\n    return self._create_new_instance(data=persisted_data)\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.plot","title":"<code>plot(plot_type='default', ax=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Plot the data</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>@abstractmethod\ndef plot(\n    self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n) -&gt; Union[Axes, Iterator[Axes]]:\n    \"\"\"Plot the data\"\"\"\n    pass\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.visualize_graph","title":"<code>visualize_graph(filename=None)</code>","text":"<p>Visualize the computation graph and save it to a file</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"Visualize the computation graph and save it to a file\"\"\"\n    try:\n        filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n        self._data.visualize(filename=filename)\n        return filename\n    except Exception as e:\n        logger.warning(f\"Failed to visualize the graph: {e}\")\n        return None\n</code></pre>"},{"location":"ja/api/#_2","title":"\u30d5\u30ec\u30fc\u30e0\u30e2\u30b8\u30e5\u30fc\u30eb","text":""},{"location":"ja/api/#channelframe","title":"ChannelFrame","text":"<p><code>ChannelFrame</code>\u306f\u6642\u9593\u9818\u57df\u306e\u4fe1\u53f7\u30c7\u30fc\u30bf\u3092\u6271\u3046\u30af\u30e9\u30b9\u3067\u3059\u3002</p> <pre><code>from wandas.frames.channel import ChannelFrame\n</code></pre> <p>\u307e\u305f\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u76f4\u63a5\u30a4\u30f3\u30dd\u30fc\u30c8\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059\uff1a</p> <pre><code>import wandas\n# \u4ee5\u4e0b\u306e\u3088\u3046\u306b\u4f7f\u7528\u3067\u304d\u307e\u3059\nframe = wandas.read_wav(\"audio.wav\")\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Channel-based data frame for handling audio signals and time series data.</p> <p>This frame represents channel-based data such as audio signals and time series data, with each channel containing data samples in the time domain.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>class ChannelFrame(BaseFrame[NDArrayReal]):\n    \"\"\"Channel-based data frame for handling audio signals and time series data.\n\n    This frame represents channel-based data such as audio signals and time series data,\n    with each channel containing data samples in the time domain.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"Initialize a ChannelFrame.\n\n        Args:\n            data: Dask array containing channel data.\n            Shape should be (n_channels, n_samples).\n            sampling_rate: The sampling rate of the data in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            operation_history: History of operations applied to the frame.\n            channel_metadata: Metadata for each channel.\n            previous: Reference to the previous frame in the processing chain.\n\n        Raises:\n            ValueError: If data has more than 2 dimensions.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return self.shape[-2]\n\n    @property\n    def time(self) -&gt; NDArrayReal:\n        \"\"\"Get time array for the signal.\n\n        Returns:\n            Array of time points in seconds.\n        \"\"\"\n        return np.arange(self.n_samples) / self.sampling_rate\n\n    @property\n    def n_samples(self) -&gt; int:\n        \"\"\"Returns the number of samples.\"\"\"\n        n: int = self._data.shape[-1]\n        return n\n\n    @property\n    def duration(self) -&gt; float:\n        \"\"\"Returns the duration in seconds.\"\"\"\n        return self.n_samples / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # Apply processing to data\n        processed_data = operation.process(self._data)\n\n        # Update metadata\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        if operation_name == \"resampling\":\n            # For resampling, update sampling rate\n            return self._create_new_instance(\n                sampling_rate=params[\"target_sr\"],\n                data=processed_data,\n                metadata=new_metadata,\n                operation_history=new_history,\n            )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Common implementation for binary operations\n        - utilizing dask's lazy evaluation.\n\n        Args:\n            other: Right operand for the operation.\n            op: Function to execute the operation (e.g., lambda a, b: a + b).\n            symbol: Symbolic representation of the operation (e.g., '+').\n\n        Returns:\n            A new channel containing the operation result (lazy execution).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, ChannelFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Perform operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other._data)\n\n            # Merge channel metadata\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # Perform operation with scalar, NumPy array, or other types\n        else:\n            # Apply operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other)\n\n            # Operand display string\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # Check for dask.array.Array\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # Update channel metadata\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n                previous=self,\n            )\n\n    def add(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        snr: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Add another signal or value to the current signal.\n\n        If SNR is specified, performs addition with consideration for\n        signal-to-noise ratio.\n\n        Args:\n            other: Signal or value to add.\n            snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n                other signal based on this SNR.\n                self is treated as the signal, and other as the noise.\n\n        Returns:\n            A new channel frame containing the addition result (lazy execution).\n        \"\"\"\n        logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n        # Special processing when SNR is specified\n        if snr is not None:\n            # First convert other to ChannelFrame if it's not\n            if not isinstance(other, ChannelFrame):\n                if isinstance(other, np.ndarray):\n                    other = ChannelFrame.from_numpy(\n                        other, self.sampling_rate, label=\"array_data\"\n                    )\n                elif isinstance(other, (int, float)):\n                    # For scalar values, simply add (ignore SNR)\n                    return self + other\n                else:\n                    raise TypeError(\n                        \"Addition target with SNR must be a ChannelFrame or \"\n                        f\"NumPy array: {type(other)}\"\n                    )\n\n            # Check if sampling rates match\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Apply addition operation with SNR adjustment\n            return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n        # Execute normal addition if SNR is not specified\n        return self + other\n\n    def plot(\n        self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Plot the frame data.\n\n        Args:\n            plot_type: Type of plot. Default is \"waveform\".\n            ax: Optional matplotlib axes for plotting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        plot_strategy = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def rms_plot(\n        self,\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = True,\n        Aw: bool = False,  # noqa: N803\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Generate an RMS plot.\n\n        Args:\n            ax: Optional matplotlib axes for plotting.\n            title: Title for the plot.\n            overlay: Whether to overlay the plot on the existing axis.\n            Aw: Apply A-weighting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        kwargs = kwargs or {}\n        ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n        rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n        return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n\n    def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n        \"\"\"Display visual and audio representation of the frame.\n\n        Args:\n            normalize: Whether to normalize the audio data for playback.\n            **kwargs: Additional parameters for visualization.\n        \"\"\"\n        if \"axis_config\" in kwargs:\n            logger.warning(\n                \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            axis_config = kwargs[\"axis_config\"]\n            if \"time_plot\" in axis_config:\n                kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n            if \"freq_plot\" in axis_config:\n                if \"xlim\" in axis_config[\"freq_plot\"]:\n                    vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                    kwargs[\"vmin\"] = vlim[0]\n                    kwargs[\"vmax\"] = vlim[1]\n                if \"ylim\" in axis_config[\"freq_plot\"]:\n                    ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                    kwargs[\"ylim\"] = ylim\n\n        if \"cbar_config\" in kwargs:\n            logger.warning(\n                \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            cbar_config = kwargs[\"cbar_config\"]\n            if \"vmin\" in cbar_config:\n                kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n            if \"vmax\" in cbar_config:\n                kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n        for ch in self:\n            ax: Axes\n            _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n            if isinstance(_ax, Iterator):\n                ax = next(iter(_ax))\n            elif isinstance(_ax, Axes):\n                ax = _ax\n            else:\n                raise TypeError(\n                    f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n                )\n            # Ignore type checks for display and Audio\n            display(ax.figure)  # type: ignore\n            plt.close(ax.figure)  # type: ignore\n            display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n\n    @classmethod\n    def from_numpy(\n        cls,\n        data: NDArrayReal,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        ch_labels: Optional[list[str]] = None,\n        ch_units: Optional[Union[list[str], str]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        Args:\n            data: NumPy array containing channel data.\n            sampling_rate: The sampling rate in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            ch_labels: Labels for each channel.\n            ch_units: Units for each channel.\n\n        Returns:\n            A new ChannelFrame containing the NumPy data.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n\n        # Convert NumPy array to dask array\n        dask_data = da_from_array(data)\n        cf = ChannelFrame(\n            data=dask_data,\n            sampling_rate=sampling_rate,\n            label=label or \"numpy_data\",\n        )\n        if metadata is not None:\n            cf.metadata = metadata\n        if ch_labels is not None:\n            if len(ch_labels) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel labels does not match the number of channels\"\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        if ch_units is not None:\n            if isinstance(ch_units, str):\n                ch_units = [ch_units] * cf.n_channels\n\n            if len(ch_units) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel units does not match the number of channels\"\n                )\n            for i in range(len(ch_units)):\n                cf._channel_metadata[i].unit = ch_units[i]\n\n        return cf\n\n    @classmethod\n    def from_ndarray(\n        cls,\n        array: NDArrayReal,\n        sampling_rate: float,\n        labels: Optional[list[str]] = None,\n        unit: Optional[Union[list[str], str]] = None,\n        frame_label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        This method is deprecated. Use from_numpy instead.\n\n        Args:\n            array: Signal data. Each row corresponds to a channel.\n            sampling_rate: Sampling rate (Hz).\n            labels: Labels for each channel.\n            unit: Unit of the signal.\n            frame_label: Label for the frame.\n            metadata: Optional metadata dictionary.\n\n        Returns:\n            A new ChannelFrame containing the data.\n        \"\"\"\n        # Redirect to from_numpy for compatibility\n        # However, from_ndarray is deprecated\n        logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n        return cls.from_numpy(\n            data=array,\n            sampling_rate=sampling_rate,\n            label=frame_label,\n            metadata=metadata,\n            ch_labels=labels,\n            ch_units=unit,\n        )\n\n    @classmethod\n    def from_file(\n        cls,\n        path: Union[str, Path],\n        channel: Optional[Union[int, list[int]]] = None,\n        start: Optional[float] = None,\n        end: Optional[float] = None,\n        chunk_size: Optional[int] = None,\n        ch_labels: Optional[list[str]] = None,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from an audio file.\n\n        Args:\n            path: Path to the audio file.\n            channel: Channel(s) to load.\n            start: Start time in seconds.\n            end: End time in seconds.\n            chunk_size: Chunk size for processing.\n            Specifies the splitting size for lazy processing.\n            ch_labels: Labels for each channel.\n            **kwargs: Additional arguments passed to the file reader.\n\n        Returns:\n            A new ChannelFrame containing the loaded audio data.\n\n        Raises:\n            ValueError: If channel selection is invalid.\n            TypeError: If channel parameter type is invalid.\n            FileNotFoundError: If the file doesn't exist.\n        \"\"\"\n        from .channel import ChannelFrame\n\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"File not found: {path}\")\n\n        # Get file reader\n        reader = get_file_reader(path)\n\n        # Get file info\n        info = reader.get_file_info(path, **kwargs)\n        sr = info[\"samplerate\"]\n        n_channels = info[\"channels\"]\n        n_frames = info[\"frames\"]\n        ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n        logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n        # Channel selection processing\n        all_channels = list(range(n_channels))\n\n        if channel is None:\n            channels_to_load = all_channels\n            logger.debug(f\"Will load all channels: {channels_to_load}\")\n        elif isinstance(channel, int):\n            if channel &lt; 0 or channel &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n            channels_to_load = [channel]\n            logger.debug(f\"Will load single channel: {channel}\")\n        elif isinstance(channel, (list, tuple)):\n            for ch in channel:\n                if ch &lt; 0 or ch &gt;= n_channels:\n                    raise ValueError(\n                        f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                    )\n            channels_to_load = list(channel)\n            logger.debug(f\"Will load specific channels: {channels_to_load}\")\n        else:\n            raise TypeError(\"channel must be int, list, or None\")\n\n        # Index calculation\n        start_idx = 0 if start is None else max(0, int(start * sr))\n        end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n        frames_to_read = end_idx - start_idx\n\n        logger.debug(\n            f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n            f\"start_idx={start_idx}, end_idx={end_idx}\"\n        )\n\n        # Settings for lazy loading\n        expected_shape = (len(channels_to_load), frames_to_read)\n\n        # Define the loading function using the file reader\n        def _load_audio() -&gt; NDArrayReal:\n            logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n            # Use the reader to get audio data with parameters\n            out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n            if not isinstance(out, np.ndarray):\n                raise ValueError(\"Unexpected data type after reading file\")\n            return out\n\n        logger.debug(\n            f\"Creating delayed dask task with expected shape: {expected_shape}\"\n        )\n\n        # Create delayed operation\n        delayed_data = dask_delayed(_load_audio)()\n        logger.debug(\"Wrapping delayed function in dask array\")\n\n        # Create dask array from delayed computation\n        dask_array = da_from_delayed(\n            delayed_data, shape=expected_shape, dtype=np.float32\n        )\n\n        if chunk_size is not None:\n            if chunk_size &lt;= 0:\n                raise ValueError(\"Chunk size must be a positive integer\")\n            logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n            dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n        logger.debug(\n            \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n        )\n\n        cf = ChannelFrame(\n            data=dask_array,\n            sampling_rate=sr,\n            label=path.stem,\n            metadata={\n                \"filename\": str(path),\n            },\n        )\n        if ch_labels is not None:\n            if len(ch_labels) != len(cf):\n                raise ValueError(\n                    \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        return cf\n\n    @classmethod\n    def read_wav(\n        cls, filename: str, labels: Optional[list[str]] = None\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a WAV file.\n\n        Args:\n            filename: Path to the WAV file.\n            labels: Labels to set for each channel.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(filename, ch_labels=labels)\n        return cf\n\n    @classmethod\n    def read_csv(\n        cls,\n        filename: str,\n        time_column: Union[int, str] = 0,\n        labels: Optional[list[str]] = None,\n        delimiter: str = \",\",\n        header: Optional[int] = 0,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a CSV file.\n\n        Args:\n            filename: Path to the CSV file.\n            time_column: Index or name of the time column.\n            labels: Labels to set for each channel.\n            delimiter: Delimiter character.\n            header: Row number to use as header.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(\n            filename,\n            ch_labels=labels,\n            time_column=time_column,\n            delimiter=delimiter,\n            header=header,\n        )\n        return cf\n\n    def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n        \"\"\"Save the audio data to a file.\n\n        Args:\n            path: Path to save the file.\n            format: File format. If None, determined from file extension.\n        \"\"\"\n        logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n        data = self.compute()\n        data = data.T\n        if data.shape[1] == 1:\n            data = data.squeeze(axis=1)\n        sf.write(str(path), data, int(self.sampling_rate), format=format)\n        logger.debug(f\"Save complete: {path}\")\n\n    def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a high-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n\n    def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a low-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n\n    def normalize(\n        self, target_level: float = -20, channel_wise: bool = True\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Normalize the signal level.\n\n        This method adjusts the signal amplitude to reach a target RMS level.\n\n        Args:\n            target_level: Target RMS level in dB. Default is -20.\n            channel_wise: If True, normalize each channel independently.\n                If False, apply the same scaling to all channels.\n\n        Returns:\n            A new ChannelFrame containing the normalized signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n        )\n        return self.apply_operation(\n            \"normalize\", target_level=target_level, channel_wise=channel_wise\n        )\n\n    def a_weighting(self) -&gt; \"ChannelFrame\":\n        \"\"\"Apply A-weighting filter to the signal.\n\n        A-weighting adjusts the frequency response to approximate human hearing\n        perception, following IEC 61672-1:2013 standard.\n\n        Returns:\n            A new ChannelFrame with A-weighted signal.\n        \"\"\"\n        return self.apply_operation(\"a_weighting\")\n\n    def hpss_harmonic(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract harmonic components using HPSS\n         (Harmonic-Percussive Source Separation).\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_harmonic\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def hpss_percussive(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract percussive components using HPSS\n        (Harmonic-Percussive Source Separation).\n\n        This method separates the percussive (tonal) components from the signal.\n\n        Args:\n            kernel_size: Median filter size for HPSS.\n            power: Exponent for the Weiner filter used in HPSS.\n            margin: Margin size for the separation.\n\n        Returns:\n            A new ChannelFrame containing the harmonic components.\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_percussive\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def resampling(\n        self,\n        target_sr: float,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Resample audio data.\n\n        Parameters\n        ----------\n        target_sr : float\n            Target sampling rate (Hz)\n        resample_type : str, optional\n            Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n        **kwargs : dict\n            Additional resampling parameters\n\n        Returns\n        -------\n        ChannelFrame\n            Resampled channel frame\n        \"\"\"\n        return self.apply_operation(\n            \"resampling\",\n            target_sr=target_sr,\n            **kwargs,\n        )\n\n    def abs(self) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the absolute value of the signal.\n\n        Returns:\n            A new ChannelFrame containing the absolute values.\n        \"\"\"\n        return self.apply_operation(\"abs\")\n\n    def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the power of the signal.\n\n        Args:\n            exponent: The exponent to raise the signal to. Default is 2.0.\n\n        Returns:\n            A new ChannelFrame containing the signal raised to the power.\n        \"\"\"\n        return self.apply_operation(\"power\", exponent=exponent)\n\n    def trim(\n        self,\n        start: float = 0,\n        end: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Trim the signal to specified time range.\n\n        Args:\n            start: Start time in seconds.\n            end: End time in seconds.\n\n        Returns:\n            A new ChannelFrame with trimmed signal.\n\n        Raises:\n            ValueError: If end time is before start time.\n        \"\"\"\n        if end is None:\n            end = self.duration\n        if start &gt; end:\n            raise ValueError(\"start must be less than end\")\n        # Apply trim operation\n        return self.apply_operation(\"trim\", start=start, end=end)\n\n    def rms_trend(\n        self,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the RMS trend of the signal.\n\n        This method computes the root mean square value over sliding windows.\n\n        Args:\n            frame_length: The size of the sliding window in samples. Default is 2048.\n            hop_length: The hop length between windows in samples. Default is 512.\n            dB: Whether to return the RMS values in decibels. Default is False.\n            Aw: Whether to apply A-weighting. Default is False.\n\n        Returns:\n            A new ChannelFrame containing the RMS trend.\n        \"\"\"\n        cf = self.apply_operation(\n            \"rms_trend\",\n            frame_length=frame_length,\n            hop_length=hop_length,\n            ref=[ch.ref for ch in self._channel_metadata],\n            dB=dB,\n            Aw=Aw,\n        )\n        cf.sampling_rate = self.sampling_rate / hop_length\n        return cf\n\n    def sum(self) -&gt; \"ChannelFrame\":\n        \"\"\"Sum all channels.\n\n        Returns:\n            A new ChannelFrame with summed signal.\n        \"\"\"\n        return self.apply_operation(\"sum\")\n\n    def mean(self) -&gt; \"ChannelFrame\":\n        \"\"\"Average all channels.\n\n        Returns:\n            A new ChannelFrame with averaged signal.\n        \"\"\"\n        return self.apply_operation(\"mean\")\n\n    def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate channel differences relative to a reference channel.\n\n        Args:\n            other_channel: Reference channel index or label. Default is 0.\n\n        Returns:\n            A new ChannelFrame with channel differences.\n        \"\"\"\n        if isinstance(other_channel, str):\n            return self.apply_operation(\n                \"channel_difference\", other_channel=self.label2index(other_channel)\n            )\n        return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n\n    def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n        \"\"\"Compute Fast Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is next power of 2 of data length.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectralFrame containing the FFT results.\n        \"\"\"\n        from ..processing.time_series import FFT\n        from .spectral import SpectralFrame\n\n        params = {\"n_fft\": n_fft, \"window\": window}\n        operation_name = \"fft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"FFT\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        if n_fft is None:\n            is_even = spectrum_data.shape[-1] % 2 == 0\n            _n_fft = (\n                spectrum_data.shape[-1] * 2 - 2\n                if is_even\n                else spectrum_data.shape[-1] * 2 - 1\n            )\n        else:\n            _n_fft = n_fft\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=_n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def welch(\n        self,\n        n_fft: Optional[int] = None,\n        hop_length: Optional[int] = None,\n        win_length: int = 2048,\n        window: str = \"hann\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute power spectral density using Welch's method.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the power spectral density.\n        \"\"\"\n        from ..processing.time_series import Welch\n        from .spectral import SpectralFrame\n\n        params = dict(\n            n_fft=n_fft or win_length,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            average=average,\n        )\n        operation_name = \"welch\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Welch\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"welch\", \"params\": params},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def noct_spectrum(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"Compute N-octave band spectrum.\n\n        Args:\n            fmin: Minimum center frequency in Hz. Default is 20 Hz.\n            fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n            n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n            G: Reference gain in dB. Default is 10 dB.\n            fr: Reference frequency in Hz. Default is 1000 Hz.\n\n        Returns:\n            A NOctFrame containing the N-octave band spectrum.\n        \"\"\"\n        from ..processing.time_series import NOctSpectrum\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_spectrum\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSpectrum\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_spectrum\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def stft(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"Compute Short-Time Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectrogramFrame containing the STFT results.\n        \"\"\"\n        from ..processing.time_series import STFT, create_operation\n        from .spectrogram import SpectrogramFrame\n\n        # Set hop length and window length\n        _hop_length = hop_length if hop_length is not None else n_fft // 4\n        _win_length = win_length if win_length is not None else n_fft\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": _hop_length,\n            \"win_length\": _win_length,\n            \"window\": window,\n        }\n        operation_name = \"stft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"STFT\", operation)\n\n        # Apply processing to data\n        spectrogram_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n\n        # Create new instance\n        return SpectrogramFrame(\n            data=spectrogram_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=n_fft,\n            hop_length=_hop_length,\n            win_length=_win_length,\n            window=window,\n            label=f\"stft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def coherence(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute magnitude squared coherence.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n        Returns:\n            A SpectralFrame containing the magnitude squared coherence.\n        \"\"\"\n        from ..processing.time_series import Coherence, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n        }\n        operation_name = \"coherence\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Coherence\", operation)\n\n        # Apply processing to data\n        coherence_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=coherence_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Coherence of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def csd(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute cross-spectral density matrix.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the cross-spectral density matrix.\n        \"\"\"\n        from ..processing.time_series import CSD, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"csd\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"CSD\", operation)\n\n        # Apply processing to data\n        csd_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=csd_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def transfer_function(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute transfer function matrix.\n\n        The transfer function characterizes the signal transmission properties\n        between channels in the frequency domain, representing the input-output\n        relationship of a system.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the transfer function matrix.\n        \"\"\"\n        from ..processing.time_series import TransferFunction, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"transfer_function\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"TransferFunction\", operation)\n\n        # Apply processing to data\n        tf_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=tf_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Transfer function of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"Provide additional initialization arguments required for ChannelFrame.\"\"\"\n        return {}\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Returns the duration in seconds.</p>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>Returns the number of samples.</p>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.time","title":"<code>time</code>  <code>property</code>","text":"<p>Get time array for the signal.</p> <p>Returns:</p> Type Description <code>NDArrayReal</code> <p>Array of time points in seconds.</p>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.__init__","title":"<code>__init__(data, sampling_rate, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a ChannelFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>Dask array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate of the data in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>operation_history</code> <code>Optional[list[dict[str, Any]]]</code> <p>History of operations applied to the frame.</p> <code>None</code> <code>channel_metadata</code> <code>Optional[list[ChannelMetadata]]</code> <p>Metadata for each channel.</p> <code>None</code> <code>previous</code> <code>Optional[BaseFrame[Any]]</code> <p>Reference to the previous frame in the processing chain.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has more than 2 dimensions.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"Initialize a ChannelFrame.\n\n    Args:\n        data: Dask array containing channel data.\n        Shape should be (n_channels, n_samples).\n        sampling_rate: The sampling rate of the data in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        operation_history: History of operations applied to the frame.\n        channel_metadata: Metadata for each channel.\n        previous: Reference to the previous frame in the processing chain.\n\n    Raises:\n        ValueError: If data has more than 2 dimensions.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.a_weighting","title":"<code>a_weighting()</code>","text":"<p>Apply A-weighting filter to the signal.</p> <p>A-weighting adjusts the frequency response to approximate human hearing perception, following IEC 61672-1:2013 standard.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with A-weighted signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def a_weighting(self) -&gt; \"ChannelFrame\":\n    \"\"\"Apply A-weighting filter to the signal.\n\n    A-weighting adjusts the frequency response to approximate human hearing\n    perception, following IEC 61672-1:2013 standard.\n\n    Returns:\n        A new ChannelFrame with A-weighted signal.\n    \"\"\"\n    return self.apply_operation(\"a_weighting\")\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.abs","title":"<code>abs()</code>","text":"<p>Calculate the absolute value of the signal.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the absolute values.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def abs(self) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the absolute value of the signal.\n\n    Returns:\n        A new ChannelFrame containing the absolute values.\n    \"\"\"\n    return self.apply_operation(\"abs\")\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.add","title":"<code>add(other, snr=None)</code>","text":"<p>Add another signal or value to the current signal.</p> <p>If SNR is specified, performs addition with consideration for signal-to-noise ratio.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[ChannelFrame, int, float, NDArrayReal, Array]</code> <p>Signal or value to add.</p> required <code>snr</code> <code>Optional[float]</code> <p>Signal-to-noise ratio (dB). If specified, adjusts the scale of the other signal based on this SNR. self is treated as the signal, and other as the noise.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new channel frame containing the addition result (lazy execution).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def add(\n    self,\n    other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n    snr: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Add another signal or value to the current signal.\n\n    If SNR is specified, performs addition with consideration for\n    signal-to-noise ratio.\n\n    Args:\n        other: Signal or value to add.\n        snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n            other signal based on this SNR.\n            self is treated as the signal, and other as the noise.\n\n    Returns:\n        A new channel frame containing the addition result (lazy execution).\n    \"\"\"\n    logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n    # Special processing when SNR is specified\n    if snr is not None:\n        # First convert other to ChannelFrame if it's not\n        if not isinstance(other, ChannelFrame):\n            if isinstance(other, np.ndarray):\n                other = ChannelFrame.from_numpy(\n                    other, self.sampling_rate, label=\"array_data\"\n                )\n            elif isinstance(other, (int, float)):\n                # For scalar values, simply add (ignore SNR)\n                return self + other\n            else:\n                raise TypeError(\n                    \"Addition target with SNR must be a ChannelFrame or \"\n                    f\"NumPy array: {type(other)}\"\n                )\n\n        # Check if sampling rates match\n        if self.sampling_rate != other.sampling_rate:\n            raise ValueError(\n                \"Sampling rates do not match. Cannot perform operation.\"\n            )\n\n        # Apply addition operation with SNR adjustment\n        return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n    # Execute normal addition if SNR is not specified\n    return self + other\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.channel_difference","title":"<code>channel_difference(other_channel=0)</code>","text":"<p>Calculate channel differences relative to a reference channel.</p> <p>Parameters:</p> Name Type Description Default <code>other_channel</code> <code>Union[int, str]</code> <p>Reference channel index or label. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with channel differences.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate channel differences relative to a reference channel.\n\n    Args:\n        other_channel: Reference channel index or label. Default is 0.\n\n    Returns:\n        A new ChannelFrame with channel differences.\n    \"\"\"\n    if isinstance(other_channel, str):\n        return self.apply_operation(\n            \"channel_difference\", other_channel=self.label2index(other_channel)\n        )\n    return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.coherence","title":"<code>coherence(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant')</code>","text":"<p>Compute magnitude squared coherence.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the magnitude squared coherence.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def coherence(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute magnitude squared coherence.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n    Returns:\n        A SpectralFrame containing the magnitude squared coherence.\n    \"\"\"\n    from ..processing.time_series import Coherence, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n    }\n    operation_name = \"coherence\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Coherence\", operation)\n\n    # Apply processing to data\n    coherence_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=coherence_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Coherence of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.csd","title":"<code>csd(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute cross-spectral density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the cross-spectral density matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def csd(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute cross-spectral density matrix.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the cross-spectral density matrix.\n    \"\"\"\n    from ..processing.time_series import CSD, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"csd\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"CSD\", operation)\n\n    # Apply processing to data\n    csd_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=csd_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.describe","title":"<code>describe(normalize=True, **kwargs)</code>","text":"<p>Display visual and audio representation of the frame.</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>Whether to normalize the audio data for playback.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for visualization.</p> <code>{}</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n    \"\"\"Display visual and audio representation of the frame.\n\n    Args:\n        normalize: Whether to normalize the audio data for playback.\n        **kwargs: Additional parameters for visualization.\n    \"\"\"\n    if \"axis_config\" in kwargs:\n        logger.warning(\n            \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        axis_config = kwargs[\"axis_config\"]\n        if \"time_plot\" in axis_config:\n            kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n        if \"freq_plot\" in axis_config:\n            if \"xlim\" in axis_config[\"freq_plot\"]:\n                vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                kwargs[\"vmin\"] = vlim[0]\n                kwargs[\"vmax\"] = vlim[1]\n            if \"ylim\" in axis_config[\"freq_plot\"]:\n                ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                kwargs[\"ylim\"] = ylim\n\n    if \"cbar_config\" in kwargs:\n        logger.warning(\n            \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        cbar_config = kwargs[\"cbar_config\"]\n        if \"vmin\" in cbar_config:\n            kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n        if \"vmax\" in cbar_config:\n            kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n    for ch in self:\n        ax: Axes\n        _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n        if isinstance(_ax, Iterator):\n            ax = next(iter(_ax))\n        elif isinstance(_ax, Axes):\n            ax = _ax\n        else:\n            raise TypeError(\n                f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n            )\n        # Ignore type checks for display and Audio\n        display(ax.figure)  # type: ignore\n        plt.close(ax.figure)  # type: ignore\n        display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.fft","title":"<code>fft(n_fft=None, window='hann')</code>","text":"<p>Compute Fast Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is next power of 2 of data length.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the FFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n    \"\"\"Compute Fast Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is next power of 2 of data length.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectralFrame containing the FFT results.\n    \"\"\"\n    from ..processing.time_series import FFT\n    from .spectral import SpectralFrame\n\n    params = {\"n_fft\": n_fft, \"window\": window}\n    operation_name = \"fft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"FFT\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    if n_fft is None:\n        is_even = spectrum_data.shape[-1] % 2 == 0\n        _n_fft = (\n            spectrum_data.shape[-1] * 2 - 2\n            if is_even\n            else spectrum_data.shape[-1] * 2 - 1\n        )\n    else:\n        _n_fft = n_fft\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=_n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.from_file","title":"<code>from_file(path, channel=None, start=None, end=None, chunk_size=None, ch_labels=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from an audio file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the audio file.</p> required <code>channel</code> <code>Optional[Union[int, list[int]]]</code> <p>Channel(s) to load.</p> <code>None</code> <code>start</code> <code>Optional[float]</code> <p>Start time in seconds.</p> <code>None</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <code>chunk_size</code> <code>Optional[int]</code> <p>Chunk size for processing.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the file reader.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the loaded audio data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If channel selection is invalid.</p> <code>TypeError</code> <p>If channel parameter type is invalid.</p> <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    path: Union[str, Path],\n    channel: Optional[Union[int, list[int]]] = None,\n    start: Optional[float] = None,\n    end: Optional[float] = None,\n    chunk_size: Optional[int] = None,\n    ch_labels: Optional[list[str]] = None,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from an audio file.\n\n    Args:\n        path: Path to the audio file.\n        channel: Channel(s) to load.\n        start: Start time in seconds.\n        end: End time in seconds.\n        chunk_size: Chunk size for processing.\n        Specifies the splitting size for lazy processing.\n        ch_labels: Labels for each channel.\n        **kwargs: Additional arguments passed to the file reader.\n\n    Returns:\n        A new ChannelFrame containing the loaded audio data.\n\n    Raises:\n        ValueError: If channel selection is invalid.\n        TypeError: If channel parameter type is invalid.\n        FileNotFoundError: If the file doesn't exist.\n    \"\"\"\n    from .channel import ChannelFrame\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    # Get file reader\n    reader = get_file_reader(path)\n\n    # Get file info\n    info = reader.get_file_info(path, **kwargs)\n    sr = info[\"samplerate\"]\n    n_channels = info[\"channels\"]\n    n_frames = info[\"frames\"]\n    ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n    logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n    # Channel selection processing\n    all_channels = list(range(n_channels))\n\n    if channel is None:\n        channels_to_load = all_channels\n        logger.debug(f\"Will load all channels: {channels_to_load}\")\n    elif isinstance(channel, int):\n        if channel &lt; 0 or channel &gt;= n_channels:\n            raise ValueError(\n                f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n            )\n        channels_to_load = [channel]\n        logger.debug(f\"Will load single channel: {channel}\")\n    elif isinstance(channel, (list, tuple)):\n        for ch in channel:\n            if ch &lt; 0 or ch &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n        channels_to_load = list(channel)\n        logger.debug(f\"Will load specific channels: {channels_to_load}\")\n    else:\n        raise TypeError(\"channel must be int, list, or None\")\n\n    # Index calculation\n    start_idx = 0 if start is None else max(0, int(start * sr))\n    end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n    frames_to_read = end_idx - start_idx\n\n    logger.debug(\n        f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n        f\"start_idx={start_idx}, end_idx={end_idx}\"\n    )\n\n    # Settings for lazy loading\n    expected_shape = (len(channels_to_load), frames_to_read)\n\n    # Define the loading function using the file reader\n    def _load_audio() -&gt; NDArrayReal:\n        logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n        # Use the reader to get audio data with parameters\n        out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n        if not isinstance(out, np.ndarray):\n            raise ValueError(\"Unexpected data type after reading file\")\n        return out\n\n    logger.debug(\n        f\"Creating delayed dask task with expected shape: {expected_shape}\"\n    )\n\n    # Create delayed operation\n    delayed_data = dask_delayed(_load_audio)()\n    logger.debug(\"Wrapping delayed function in dask array\")\n\n    # Create dask array from delayed computation\n    dask_array = da_from_delayed(\n        delayed_data, shape=expected_shape, dtype=np.float32\n    )\n\n    if chunk_size is not None:\n        if chunk_size &lt;= 0:\n            raise ValueError(\"Chunk size must be a positive integer\")\n        logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n        dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n    logger.debug(\n        \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n    )\n\n    cf = ChannelFrame(\n        data=dask_array,\n        sampling_rate=sr,\n        label=path.stem,\n        metadata={\n            \"filename\": str(path),\n        },\n    )\n    if ch_labels is not None:\n        if len(ch_labels) != len(cf):\n            raise ValueError(\n                \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    return cf\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.from_ndarray","title":"<code>from_ndarray(array, sampling_rate, labels=None, unit=None, frame_label=None, metadata=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>This method is deprecated. Use from_numpy instead.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>NDArrayReal</code> <p>Signal data. Each row corresponds to a channel.</p> required <code>sampling_rate</code> <code>float</code> <p>Sampling rate (Hz).</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>unit</code> <code>Optional[Union[list[str], str]]</code> <p>Unit of the signal.</p> <code>None</code> <code>frame_label</code> <code>Optional[str]</code> <p>Label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_ndarray(\n    cls,\n    array: NDArrayReal,\n    sampling_rate: float,\n    labels: Optional[list[str]] = None,\n    unit: Optional[Union[list[str], str]] = None,\n    frame_label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    This method is deprecated. Use from_numpy instead.\n\n    Args:\n        array: Signal data. Each row corresponds to a channel.\n        sampling_rate: Sampling rate (Hz).\n        labels: Labels for each channel.\n        unit: Unit of the signal.\n        frame_label: Label for the frame.\n        metadata: Optional metadata dictionary.\n\n    Returns:\n        A new ChannelFrame containing the data.\n    \"\"\"\n    # Redirect to from_numpy for compatibility\n    # However, from_ndarray is deprecated\n    logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n    return cls.from_numpy(\n        data=array,\n        sampling_rate=sampling_rate,\n        label=frame_label,\n        metadata=metadata,\n        ch_labels=labels,\n        ch_units=unit,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.from_numpy","title":"<code>from_numpy(data, sampling_rate, label=None, metadata=None, ch_labels=None, ch_units=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArrayReal</code> <p>NumPy array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>ch_units</code> <code>Optional[Union[list[str], str]]</code> <p>Units for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the NumPy data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_numpy(\n    cls,\n    data: NDArrayReal,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    ch_labels: Optional[list[str]] = None,\n    ch_units: Optional[Union[list[str], str]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    Args:\n        data: NumPy array containing channel data.\n        sampling_rate: The sampling rate in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        ch_labels: Labels for each channel.\n        ch_units: Units for each channel.\n\n    Returns:\n        A new ChannelFrame containing the NumPy data.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n\n    # Convert NumPy array to dask array\n    dask_data = da_from_array(data)\n    cf = ChannelFrame(\n        data=dask_data,\n        sampling_rate=sampling_rate,\n        label=label or \"numpy_data\",\n    )\n    if metadata is not None:\n        cf.metadata = metadata\n    if ch_labels is not None:\n        if len(ch_labels) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel labels does not match the number of channels\"\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    if ch_units is not None:\n        if isinstance(ch_units, str):\n            ch_units = [ch_units] * cf.n_channels\n\n        if len(ch_units) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel units does not match the number of channels\"\n            )\n        for i in range(len(ch_units)):\n            cf._channel_metadata[i].unit = ch_units[i]\n\n    return cf\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.high_pass_filter","title":"<code>high_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a high-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a high-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.hpss_harmonic","title":"<code>hpss_harmonic(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract harmonic components using HPSS  (Harmonic-Percussive Source Separation).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_harmonic(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract harmonic components using HPSS\n     (Harmonic-Percussive Source Separation).\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_harmonic\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.hpss_percussive","title":"<code>hpss_percussive(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract percussive components using HPSS (Harmonic-Percussive Source Separation).</p> <p>This method separates the percussive (tonal) components from the signal.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Union[_IntLike_co, tuple[_IntLike_co, _IntLike_co], list[_IntLike_co]]</code> <p>Median filter size for HPSS.</p> <code>31</code> <code>power</code> <code>float</code> <p>Exponent for the Weiner filter used in HPSS.</p> <code>2</code> <code>margin</code> <code>Union[_FloatLike_co, tuple[_FloatLike_co, _FloatLike_co], list[_FloatLike_co]]</code> <p>Margin size for the separation.</p> <code>1</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the harmonic components.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_percussive(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract percussive components using HPSS\n    (Harmonic-Percussive Source Separation).\n\n    This method separates the percussive (tonal) components from the signal.\n\n    Args:\n        kernel_size: Median filter size for HPSS.\n        power: Exponent for the Weiner filter used in HPSS.\n        margin: Margin size for the separation.\n\n    Returns:\n        A new ChannelFrame containing the harmonic components.\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_percussive\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.low_pass_filter","title":"<code>low_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a low-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a low-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.mean","title":"<code>mean()</code>","text":"<p>Average all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with averaged signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def mean(self) -&gt; \"ChannelFrame\":\n    \"\"\"Average all channels.\n\n    Returns:\n        A new ChannelFrame with averaged signal.\n    \"\"\"\n    return self.apply_operation(\"mean\")\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.noct_spectrum","title":"<code>noct_spectrum(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Compute N-octave band spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>fmin</code> <code>float</code> <p>Minimum center frequency in Hz. Default is 20 Hz.</p> required <code>fmax</code> <code>float</code> <p>Maximum center frequency in Hz. Default is 20000 Hz.</p> required <code>n</code> <code>int</code> <p>Band division (1 for octave, 3 for 1/3 octave). Default is 3.</p> <code>3</code> <code>G</code> <code>int</code> <p>Reference gain in dB. Default is 10 dB.</p> <code>10</code> <code>fr</code> <code>int</code> <p>Reference frequency in Hz. Default is 1000 Hz.</p> <code>1000</code> <p>Returns:</p> Type Description <code>NOctFrame</code> <p>A NOctFrame containing the N-octave band spectrum.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def noct_spectrum(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"Compute N-octave band spectrum.\n\n    Args:\n        fmin: Minimum center frequency in Hz. Default is 20 Hz.\n        fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n        n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n        G: Reference gain in dB. Default is 10 dB.\n        fr: Reference frequency in Hz. Default is 1000 Hz.\n\n    Returns:\n        A NOctFrame containing the N-octave band spectrum.\n    \"\"\"\n    from ..processing.time_series import NOctSpectrum\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_spectrum\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSpectrum\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_spectrum\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.normalize","title":"<code>normalize(target_level=-20, channel_wise=True)</code>","text":"<p>Normalize the signal level.</p> <p>This method adjusts the signal amplitude to reach a target RMS level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target RMS level in dB. Default is -20.</p> <code>-20</code> <code>channel_wise</code> <code>bool</code> <p>If True, normalize each channel independently. If False, apply the same scaling to all channels.</p> <code>True</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the normalized signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def normalize(\n    self, target_level: float = -20, channel_wise: bool = True\n) -&gt; \"ChannelFrame\":\n    \"\"\"Normalize the signal level.\n\n    This method adjusts the signal amplitude to reach a target RMS level.\n\n    Args:\n        target_level: Target RMS level in dB. Default is -20.\n        channel_wise: If True, normalize each channel independently.\n            If False, apply the same scaling to all channels.\n\n    Returns:\n        A new ChannelFrame containing the normalized signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n    )\n    return self.apply_operation(\n        \"normalize\", target_level=target_level, channel_wise=channel_wise\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.plot","title":"<code>plot(plot_type='waveform', ax=None, **kwargs)</code>","text":"<p>Plot the frame data.</p> <p>Parameters:</p> Name Type Description Default <code>plot_type</code> <code>str</code> <p>Type of plot. Default is \"waveform\".</p> <code>'waveform'</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def plot(\n    self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Plot the frame data.\n\n    Args:\n        plot_type: Type of plot. Default is \"waveform\".\n        ax: Optional matplotlib axes for plotting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    plot_strategy = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.power","title":"<code>power(exponent=2.0)</code>","text":"<p>Calculate the power of the signal.</p> <p>Parameters:</p> Name Type Description Default <code>exponent</code> <code>float</code> <p>The exponent to raise the signal to. Default is 2.0.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the signal raised to the power.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the power of the signal.\n\n    Args:\n        exponent: The exponent to raise the signal to. Default is 2.0.\n\n    Returns:\n        A new ChannelFrame containing the signal raised to the power.\n    \"\"\"\n    return self.apply_operation(\"power\", exponent=exponent)\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.read_csv","title":"<code>read_csv(filename, time_column=0, labels=None, delimiter=',', header=0)</code>  <code>classmethod</code>","text":"<p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.read_wav","title":"<code>read_wav(filename, labels=None)</code>  <code>classmethod</code>","text":"<p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.resampling","title":"<code>resampling(target_sr, **kwargs)</code>","text":"<p>Resample audio data.</p>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.resampling--parameters","title":"Parameters","text":"<p>target_sr : float     Target sampling rate (Hz) resample_type : str, optional     Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.) **kwargs : dict     Additional resampling parameters</p>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.resampling--returns","title":"Returns","text":"<p>ChannelFrame     Resampled channel frame</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def resampling(\n    self,\n    target_sr: float,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Resample audio data.\n\n    Parameters\n    ----------\n    target_sr : float\n        Target sampling rate (Hz)\n    resample_type : str, optional\n        Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n    **kwargs : dict\n        Additional resampling parameters\n\n    Returns\n    -------\n    ChannelFrame\n        Resampled channel frame\n    \"\"\"\n    return self.apply_operation(\n        \"resampling\",\n        target_sr=target_sr,\n        **kwargs,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.rms_plot","title":"<code>rms_plot(ax=None, title=None, overlay=True, Aw=False, **kwargs)</code>","text":"<p>Generate an RMS plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title for the plot.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay the plot on the existing axis.</p> <code>True</code> <code>Aw</code> <code>bool</code> <p>Apply A-weighting.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_plot(\n    self,\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = True,\n    Aw: bool = False,  # noqa: N803\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Generate an RMS plot.\n\n    Args:\n        ax: Optional matplotlib axes for plotting.\n        title: Title for the plot.\n        overlay: Whether to overlay the plot on the existing axis.\n        Aw: Apply A-weighting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    kwargs = kwargs or {}\n    ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n    rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n    return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.rms_trend","title":"<code>rms_trend(frame_length=2048, hop_length=512, dB=False, Aw=False)</code>","text":"<p>Calculate the RMS trend of the signal.</p> <p>This method computes the root mean square value over sliding windows.</p> <p>Parameters:</p> Name Type Description Default <code>frame_length</code> <code>int</code> <p>The size of the sliding window in samples. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>int</code> <p>The hop length between windows in samples. Default is 512.</p> <code>512</code> <code>dB</code> <code>bool</code> <p>Whether to return the RMS values in decibels. Default is False.</p> <code>False</code> <code>Aw</code> <code>bool</code> <p>Whether to apply A-weighting. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the RMS trend.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_trend(\n    self,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the RMS trend of the signal.\n\n    This method computes the root mean square value over sliding windows.\n\n    Args:\n        frame_length: The size of the sliding window in samples. Default is 2048.\n        hop_length: The hop length between windows in samples. Default is 512.\n        dB: Whether to return the RMS values in decibels. Default is False.\n        Aw: Whether to apply A-weighting. Default is False.\n\n    Returns:\n        A new ChannelFrame containing the RMS trend.\n    \"\"\"\n    cf = self.apply_operation(\n        \"rms_trend\",\n        frame_length=frame_length,\n        hop_length=hop_length,\n        ref=[ch.ref for ch in self._channel_metadata],\n        dB=dB,\n        Aw=Aw,\n    )\n    cf.sampling_rate = self.sampling_rate / hop_length\n    return cf\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.save","title":"<code>save(path, format=None)</code>","text":"<p>Save the audio data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n    data = self.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    sf.write(str(path), data, int(self.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {path}\")\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.stft","title":"<code>stft(n_fft=2048, hop_length=None, win_length=None, window='hann')</code>","text":"<p>Compute Short-Time Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectrogramFrame</code> <p>A SpectrogramFrame containing the STFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def stft(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n) -&gt; \"SpectrogramFrame\":\n    \"\"\"Compute Short-Time Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectrogramFrame containing the STFT results.\n    \"\"\"\n    from ..processing.time_series import STFT, create_operation\n    from .spectrogram import SpectrogramFrame\n\n    # Set hop length and window length\n    _hop_length = hop_length if hop_length is not None else n_fft // 4\n    _win_length = win_length if win_length is not None else n_fft\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": _hop_length,\n        \"win_length\": _win_length,\n        \"window\": window,\n    }\n    operation_name = \"stft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"STFT\", operation)\n\n    # Apply processing to data\n    spectrogram_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n\n    # Create new instance\n    return SpectrogramFrame(\n        data=spectrogram_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=n_fft,\n        hop_length=_hop_length,\n        win_length=_win_length,\n        window=window,\n        label=f\"stft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.sum","title":"<code>sum()</code>","text":"<p>Sum all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with summed signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def sum(self) -&gt; \"ChannelFrame\":\n    \"\"\"Sum all channels.\n\n    Returns:\n        A new ChannelFrame with summed signal.\n    \"\"\"\n    return self.apply_operation(\"sum\")\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.transfer_function","title":"<code>transfer_function(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute transfer function matrix.</p> <p>The transfer function characterizes the signal transmission properties between channels in the frequency domain, representing the input-output relationship of a system.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the transfer function matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def transfer_function(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute transfer function matrix.\n\n    The transfer function characterizes the signal transmission properties\n    between channels in the frequency domain, representing the input-output\n    relationship of a system.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the transfer function matrix.\n    \"\"\"\n    from ..processing.time_series import TransferFunction, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"transfer_function\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"TransferFunction\", operation)\n\n    # Apply processing to data\n    tf_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=tf_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Transfer function of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.trim","title":"<code>trim(start=0, end=None)</code>","text":"<p>Trim the signal to specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>Start time in seconds.</p> <code>0</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with trimmed signal.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If end time is before start time.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def trim(\n    self,\n    start: float = 0,\n    end: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Trim the signal to specified time range.\n\n    Args:\n        start: Start time in seconds.\n        end: End time in seconds.\n\n    Returns:\n        A new ChannelFrame with trimmed signal.\n\n    Raises:\n        ValueError: If end time is before start time.\n    \"\"\"\n    if end is None:\n        end = self.duration\n    if start &gt; end:\n        raise ValueError(\"start must be less than end\")\n    # Apply trim operation\n    return self.apply_operation(\"trim\", start=start, end=end)\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.welch","title":"<code>welch(n_fft=None, hop_length=None, win_length=2048, window='hann', average='mean')</code>","text":"<p>Compute power spectral density using Welch's method.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is 2048.</p> <code>None</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>int</code> <p>Length of window. Default is n_fft.</p> <code>2048</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the power spectral density.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def welch(\n    self,\n    n_fft: Optional[int] = None,\n    hop_length: Optional[int] = None,\n    win_length: int = 2048,\n    window: str = \"hann\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute power spectral density using Welch's method.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the power spectral density.\n    \"\"\"\n    from ..processing.time_series import Welch\n    from .spectral import SpectralFrame\n\n    params = dict(\n        n_fft=n_fft or win_length,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        average=average,\n    )\n    operation_name = \"welch\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Welch\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"welch\", \"params\": params},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/#io","title":"\u5165\u51fa\u529b (I/O)","text":"<p>Wandas\u3067\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u65b9\u6cd5\u3067\u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u3084CSV\u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u3080\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002</p>"},{"location":"ja/api/#wav","title":"WAV\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\u3068\u66f8\u304d\u8fbc\u307f","text":"<pre><code># WAV\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\nfrom wandas.frames.channel import ChannelFrame\nframe = ChannelFrame.read_wav(\"audio.wav\")\n\n# \u307e\u305f\u306f\u76f4\u63a5\u30a4\u30f3\u30dd\u30fc\u30c8\u3092\u4f7f\u7528\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")\n\n# WAV\u30d5\u30a1\u30a4\u30eb\u306e\u66f8\u304d\u8fbc\u307f\nframe.save(\"output.wav\")\n</code></pre> <p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre> <p>Save the audio data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n    data = self.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    sf.write(str(path), data, int(self.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {path}\")\n</code></pre>"},{"location":"ja/api/#csv","title":"CSV\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f","text":"<pre><code># CSV\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\nfrom wandas.frames.channel import ChannelFrame\nframe = ChannelFrame.read_csv(\"data.csv\")\n\n# \u307e\u305f\u306f\u76f4\u63a5\u30a4\u30f3\u30dd\u30fc\u30c8\u3092\u4f7f\u7528\nimport wandas\nframe = wandas.read_csv(\"data.csv\")\n</code></pre> <p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"ja/api/#_3","title":"\u4fe1\u53f7\u51e6\u7406","text":"<p>Wandas\u306f\u69d8\u3005\u306a\u4fe1\u53f7\u51e6\u7406\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"ja/api/#wandas.processing.time_series.ABS","title":"<code>ABS</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Absolute value operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ABS(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Absolute value operation\"\"\"\n\n    name = \"abs\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize absolute value operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        return da.abs(data)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.ABS.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize absolute value operation</p>"},{"location":"ja/api/#wandas.processing.time_series.ABS.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize absolute value operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AWeighting","title":"<code>AWeighting</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>A-weighting filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AWeighting(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"A-weighting filter operation\"\"\"\n\n    name = \"a_weighting\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize A-weighting filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for A-weighting filter\"\"\"\n        logger.debug(f\"Applying A-weighting to array with shape: {x.shape}\")\n        result = A_weight(x, self.sampling_rate)\n\n        # Handle case where A_weight returns a tuple\n        if isinstance(result, tuple):\n            # Use the first element of the tuple\n            result = result[0]\n\n        logger.debug(\n            f\"A-weighting applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AWeighting.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize A-weighting filter</p>"},{"location":"ja/api/#wandas.processing.time_series.AWeighting.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize A-weighting filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AddWithSNR","title":"<code>AddWithSNR</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Addition operation considering SNR</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AddWithSNR(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Addition operation considering SNR\"\"\"\n\n    name = \"add_with_snr\"\n\n    def __init__(self, sampling_rate: float, other: DaArray, snr: float):\n        \"\"\"\n        Initialize addition operation considering SNR\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        other : DaArray\n            Noise signal to add (channel-frame format)\n        snr : float\n            Signal-to-noise ratio (dB)\n        \"\"\"\n        super().__init__(sampling_rate, other=other, snr=snr)\n\n        self.other = other\n        self.snr = snr\n        logger.debug(f\"Initialized AddWithSNR operation with SNR: {snr} dB\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape (same as input)\n        \"\"\"\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Perform addition processing considering SNR\"\"\"\n        logger.debug(f\"Applying SNR-based addition with shape: {x.shape}\")\n        other: NDArrayReal = self.other.compute()\n\n        # Use multi-channel versions of calculate_rms and calculate_desired_noise_rms\n        clean_rms = util.calculate_rms(x)\n        other_rms = util.calculate_rms(other)\n\n        # Adjust noise gain based on specified SNR (apply per channel)\n        desired_noise_rms = util.calculate_desired_noise_rms(clean_rms, self.snr)\n\n        # Apply gain per channel using broadcasting\n        gain = desired_noise_rms / other_rms\n        # Add adjusted noise to signal\n        result: NDArrayReal = x + other * gain\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AddWithSNR.__init__","title":"<code>__init__(sampling_rate, other, snr)</code>","text":"<p>Initialize addition operation considering SNR</p>"},{"location":"ja/api/#wandas.processing.time_series.AddWithSNR.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) other : DaArray     Noise signal to add (channel-frame format) snr : float     Signal-to-noise ratio (dB)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, other: DaArray, snr: float):\n    \"\"\"\n    Initialize addition operation considering SNR\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    other : DaArray\n        Noise signal to add (channel-frame format)\n    snr : float\n        Signal-to-noise ratio (dB)\n    \"\"\"\n    super().__init__(sampling_rate, other=other, snr=snr)\n\n    self.other = other\n    self.snr = snr\n    logger.debug(f\"Initialized AddWithSNR operation with SNR: {snr} dB\")\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AddWithSNR.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.AddWithSNR.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"ja/api/#wandas.processing.time_series.AddWithSNR.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (same as input)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape (same as input)\n    \"\"\"\n    return input_shape\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AudioOperation","title":"<code>AudioOperation</code>","text":"<p>               Bases: <code>Generic[InputArrayType, OutputArrayType]</code></p> <p>Abstract base class for audio processing operations.</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AudioOperation(Generic[InputArrayType, OutputArrayType]):\n    \"\"\"Abstract base class for audio processing operations.\"\"\"\n\n    # Class variable: operation name\n    name: ClassVar[str]\n\n    def __init__(self, sampling_rate: float, **params: Any):\n        \"\"\"\n        Initialize AudioOperation.\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        **params : Any\n            Operation-specific parameters\n        \"\"\"\n        self.sampling_rate = sampling_rate\n        self.params = params\n\n        # Validate parameters during initialization\n        self.validate_params()\n\n        # Create processor function (lazy initialization possible)\n        self._setup_processor()\n\n        logger.debug(\n            f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n        )\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n        pass\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up processor function (implemented by subclasses)\"\"\"\n        pass\n\n    def _process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function (implemented by subclasses)\"\"\"\n        # Default is no-op function\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    @dask.delayed  # type: ignore [misc, unused-ignore]\n    def process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n        # Default is no-op function\n        logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n        return self._process_array(x)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation (implemented by subclasses)\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        \"\"\"\n        Execute operation and return result\n        data shape is (channels, samples)\n        \"\"\"\n        # Add task as delayed processing\n        logger.debug(\"Adding delayed operation to computation graph\")\n        delayed_result = self.process_array(data)\n        # Convert delayed result to dask array and return\n        output_shape = self.calculate_output_shape(data.shape)\n        return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AudioOperation.__init__","title":"<code>__init__(sampling_rate, **params)</code>","text":"<p>Initialize AudioOperation.</p>"},{"location":"ja/api/#wandas.processing.time_series.AudioOperation.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) **params : Any     Operation-specific parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, **params: Any):\n    \"\"\"\n    Initialize AudioOperation.\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    **params : Any\n        Operation-specific parameters\n    \"\"\"\n    self.sampling_rate = sampling_rate\n    self.params = params\n\n    # Validate parameters during initialization\n    self.validate_params()\n\n    # Create processor function (lazy initialization possible)\n    self._setup_processor()\n\n    logger.debug(\n        f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n    )\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AudioOperation.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation (implemented by subclasses)</p>"},{"location":"ja/api/#wandas.processing.time_series.AudioOperation.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"ja/api/#wandas.processing.time_series.AudioOperation.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation (implemented by subclasses)\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AudioOperation.process","title":"<code>process(data)</code>","text":"<p>Execute operation and return result data shape is (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    \"\"\"\n    Execute operation and return result\n    data shape is (channels, samples)\n    \"\"\"\n    # Add task as delayed processing\n    logger.debug(\"Adding delayed operation to computation graph\")\n    delayed_result = self.process_array(data)\n    # Convert delayed result to dask array and return\n    output_shape = self.calculate_output_shape(data.shape)\n    return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AudioOperation.process_array","title":"<code>process_array(x)</code>","text":"<p>Processing function wrapped with @dask.delayed</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>@dask.delayed  # type: ignore [misc, unused-ignore]\ndef process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n    \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n    # Default is no-op function\n    logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n    return self._process_array(x)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AudioOperation.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters (raises exception if invalid)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n    pass\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.CSD","title":"<code>CSD</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Cross-spectral density estimation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class CSD(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Cross-spectral density estimation operation\"\"\"\n\n    name = \"csd\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n        scaling: str,\n        average: str,\n    ):\n        \"\"\"\n        Initialize cross-spectral density estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        scaling : str\n            Type of scaling\n        average : str\n            Method of averaging\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        self.scaling = scaling\n        self.average = average\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n            scaling=scaling,\n            average=average,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Processor function for cross-spectral density estimation operation\"\"\"\n        logger.debug(f\"Applying CSD estimation to array with shape: {x.shape}\")\n        from scipy import signal as ss\n\n        # Calculate all combinations using scipy's csd function\n        _, csd_result = ss.csd(\n            x=x[:, np.newaxis],\n            y=x[np.newaxis, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n        )\n\n        # Reshape result to (n_channels * n_channels, n_freqs)\n        result: NDArrayComplex = csd_result.transpose(1, 0, 2).reshape(\n            -1, csd_result.shape[-1]\n        )\n\n        logger.debug(f\"CSD estimation applied, result shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.CSD.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend, scaling, average)</code>","text":"<p>Initialize cross-spectral density estimation operation</p>"},{"location":"ja/api/#wandas.processing.time_series.CSD.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend scaling : str     Type of scaling average : str     Method of averaging</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n    scaling: str,\n    average: str,\n):\n    \"\"\"\n    Initialize cross-spectral density estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    scaling : str\n        Type of scaling\n    average : str\n        Method of averaging\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    self.scaling = scaling\n    self.average = average\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n        scaling=scaling,\n        average=average,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.CSD.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.CSD.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"ja/api/#wandas.processing.time_series.CSD.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.ChannelDifference","title":"<code>ChannelDifference</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Channel difference calculation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ChannelDifference(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Channel difference calculation operation\"\"\"\n\n    name = \"channel_difference\"\n    other_channel: int\n\n    def __init__(self, sampling_rate: float, other_channel: int = 0):\n        \"\"\"\n        Initialize channel difference calculation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        other_channel : int\n            Channel to calculate difference with, default is 0\n        \"\"\"\n        self.other_channel = other_channel\n        super().__init__(sampling_rate, other_channel=other_channel)\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        result = data - data[self.other_channel]\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.ChannelDifference.__init__","title":"<code>__init__(sampling_rate, other_channel=0)</code>","text":"<p>Initialize channel difference calculation</p>"},{"location":"ja/api/#wandas.processing.time_series.ChannelDifference.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) other_channel : int     Channel to calculate difference with, default is 0</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, other_channel: int = 0):\n    \"\"\"\n    Initialize channel difference calculation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    other_channel : int\n        Channel to calculate difference with, default is 0\n    \"\"\"\n    self.other_channel = other_channel\n    super().__init__(sampling_rate, other_channel=other_channel)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Coherence","title":"<code>Coherence</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Coherence estimation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Coherence(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Coherence estimation operation\"\"\"\n\n    name = \"coherence\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n    ):\n        \"\"\"\n        Initialize coherence estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Processor function for coherence estimation operation\"\"\"\n        logger.debug(f\"Applying coherence estimation to array with shape: {x.shape}\")\n        from scipy import signal as ss\n\n        _, coh = ss.coherence(\n            x=x[:, np.newaxis],\n            y=x[np.newaxis, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n        )\n\n        # Reshape result to (n_channels * n_channels, n_freqs)\n        result: NDArrayReal = coh.transpose(1, 0, 2).reshape(-1, coh.shape[-1])\n\n        logger.debug(f\"Coherence estimation applied, result shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Coherence.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend)</code>","text":"<p>Initialize coherence estimation operation</p>"},{"location":"ja/api/#wandas.processing.time_series.Coherence.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n):\n    \"\"\"\n    Initialize coherence estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Coherence.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.Coherence.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"ja/api/#wandas.processing.time_series.Coherence.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.FFT","title":"<code>FFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>FFT (Fast Fourier Transform) operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class FFT(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"FFT (Fast Fourier Transform) operation\"\"\"\n\n    name = \"fft\"\n    n_fft: Optional[int]\n    window: str\n\n    def __init__(\n        self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n    ):\n        \"\"\"\n        Initialize FFT operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int, optional\n            FFT size, default is None (determined by input size)\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(sampling_rate, n_fft=n_fft, window=window)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        \u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059\n\n        Parameters\n        ----------\n        input_shape : tuple\n            \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)\n\n        Returns\n        -------\n        tuple\n            \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)\n        \"\"\"\n        n_freqs = self.n_fft // 2 + 1 if self.n_fft else input_shape[-1] // 2 + 1\n        return (*input_shape[:-1], n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"FFT\u64cd\u4f5c\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u95a2\u6570\u3092\u4f5c\u6210\"\"\"\n        from scipy.signal import get_window\n\n        win = get_window(self.window, x.shape[-1])\n        x = x * win\n        result: NDArrayComplex = np.fft.rfft(x, n=self.n_fft, axis=-1)\n        result[..., 1:-1] *= 2.0\n        # \u7a93\u95a2\u6570\u88dc\u6b63\n        scaling_factor = np.sum(win)\n        result = result / scaling_factor\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.FFT.__init__","title":"<code>__init__(sampling_rate, n_fft=None, window='hann')</code>","text":"<p>Initialize FFT operation</p>"},{"location":"ja/api/#wandas.processing.time_series.FFT.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int, optional     FFT size, default is None (determined by input size) window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n):\n    \"\"\"\n    Initialize FFT operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int, optional\n        FFT size, default is None (determined by input size)\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(sampling_rate, n_fft=n_fft, window=window)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.FFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>\u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059</p>"},{"location":"ja/api/#wandas.processing.time_series.FFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)</p>"},{"location":"ja/api/#wandas.processing.time_series.FFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    \u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059\n\n    Parameters\n    ----------\n    input_shape : tuple\n        \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)\n\n    Returns\n    -------\n    tuple\n        \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)\n    \"\"\"\n    n_freqs = self.n_fft // 2 + 1 if self.n_fft else input_shape[-1] // 2 + 1\n    return (*input_shape[:-1], n_freqs)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.HighPassFilter","title":"<code>HighPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>High-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HighPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"High-pass filter operation\"\"\"\n\n    name = \"highpass_filter\"\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize high-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            limit = self.sampling_rate / 2\n            raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up high-pass filter processor\"\"\"\n        # Calculate filter coefficients (once) - safely retrieve from instance variables\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"high\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Highpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying highpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.HighPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize high-pass filter</p>"},{"location":"ja/api/#wandas.processing.time_series.HighPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize high-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.HighPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        limit = self.sampling_rate / 2\n        raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.HpssHarmonic","title":"<code>HpssHarmonic</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>HPSS Harmonic operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HpssHarmonic(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"HPSS Harmonic operation\"\"\"\n\n    name = \"hpss_harmonic\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize HPSS Harmonic\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        self.kwargs = kwargs\n        super().__init__(sampling_rate, **kwargs)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for HPSS Harmonic\"\"\"\n        logger.debug(f\"Applying HPSS Harmonic to array with shape: {x.shape}\")\n        result = librosa.effects.harmonic(x, **self.kwargs)\n        logger.debug(\n            f\"HPSS Harmonic applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.HpssHarmonic.__init__","title":"<code>__init__(sampling_rate, **kwargs)</code>","text":"<p>Initialize HPSS Harmonic</p>"},{"location":"ja/api/#wandas.processing.time_series.HpssHarmonic.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize HPSS Harmonic\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    self.kwargs = kwargs\n    super().__init__(sampling_rate, **kwargs)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.HpssPercussive","title":"<code>HpssPercussive</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>HPSS Percussive operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HpssPercussive(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"HPSS Percussive operation\"\"\"\n\n    name = \"hpss_percussive\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize HPSS Percussive\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        self.kwargs = kwargs\n        super().__init__(sampling_rate, **kwargs)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for HPSS Percussive\"\"\"\n        logger.debug(f\"Applying HPSS Percussive to array with shape: {x.shape}\")\n        result = librosa.effects.percussive(x, **self.kwargs)\n        logger.debug(\n            f\"HPSS Percussive applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.HpssPercussive.__init__","title":"<code>__init__(sampling_rate, **kwargs)</code>","text":"<p>Initialize HPSS Percussive</p>"},{"location":"ja/api/#wandas.processing.time_series.HpssPercussive.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize HPSS Percussive\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    self.kwargs = kwargs\n    super().__init__(sampling_rate, **kwargs)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.IFFT","title":"<code>IFFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayComplex, NDArrayReal]</code></p> <p>IFFT (Inverse Fast Fourier Transform) operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class IFFT(AudioOperation[NDArrayComplex, NDArrayReal]):\n    \"\"\"IFFT (Inverse Fast Fourier Transform) operation\"\"\"\n\n    name = \"ifft\"\n    n_fft: Optional[int]\n    window: str\n\n    def __init__(\n        self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n    ):\n        \"\"\"\n        Initialize IFFT operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : Optional[int], optional\n            IFFT size, default is None (determined based on input size)\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(sampling_rate, n_fft=n_fft, window=window)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, freqs)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, samples)\n        \"\"\"\n        n_samples = 2 * (input_shape[-1] - 1) if self.n_fft is None else self.n_fft\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayComplex) -&gt; NDArrayReal:\n        \"\"\"Create processor function for IFFT operation\"\"\"\n        logger.debug(f\"Applying IFFT to array with shape: {x.shape}\")\n\n        # Restore frequency component scaling (remove the 2.0 multiplier applied in FFT)\n        _x = x.copy()\n        _x[..., 1:-1] /= 2.0\n\n        # Execute IFFT\n        result: NDArrayReal = np.fft.irfft(_x, n=self.n_fft, axis=-1)\n\n        # Window function correction (inverse of FFT operation)\n        from scipy.signal import get_window\n\n        win = get_window(self.window, result.shape[-1])\n\n        # Correct the FFT window function scaling\n        scaling_factor = np.sum(win) / result.shape[-1]\n        result = result / scaling_factor\n\n        logger.debug(f\"IFFT applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.IFFT.__init__","title":"<code>__init__(sampling_rate, n_fft=None, window='hann')</code>","text":"<p>Initialize IFFT operation</p>"},{"location":"ja/api/#wandas.processing.time_series.IFFT.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : Optional[int], optional     IFFT size, default is None (determined based on input size) window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n):\n    \"\"\"\n    Initialize IFFT operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : Optional[int], optional\n        IFFT size, default is None (determined based on input size)\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(sampling_rate, n_fft=n_fft, window=window)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.IFFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.IFFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, freqs)</p>"},{"location":"ja/api/#wandas.processing.time_series.IFFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, freqs)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, samples)\n    \"\"\"\n    n_samples = 2 * (input_shape[-1] - 1) if self.n_fft is None else self.n_fft\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.ISTFT","title":"<code>ISTFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayComplex, NDArrayReal]</code></p> <p>Inverse Short-Time Fourier Transform operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ISTFT(AudioOperation[NDArrayComplex, NDArrayReal]):\n    \"\"\"Inverse Short-Time Fourier Transform operation\"\"\"\n\n    name = \"istft\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        length: Optional[int] = None,\n    ):\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.length = length\n\n        # Instantiate ShortTimeFFT for ISTFT calculation\n        self.SFT = ShortTimeFFT(\n            win=get_window(window, self.win_length),\n            hop=self.hop_length,\n            fs=sampling_rate,\n            mfft=self.n_fft,\n            scale_to=\"magnitude\",  # Consistent scaling with STFT\n        )\n\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n            length=length,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, freqs, time_frames)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, samples)\n        \"\"\"\n        k0: int = 0\n        q_max = input_shape[-1] + self.SFT.p_min\n        k_max = (q_max - 1) * self.SFT.hop + self.SFT.m_num - self.SFT.m_num_mid\n        k_q0, k_q1 = self.SFT.nearest_k_p(k0), self.SFT.nearest_k_p(k_max, left=False)\n        n_pts = k_q1 - k_q0 + self.SFT.m_num - self.SFT.m_num_mid\n\n        return input_shape[:-2] + (n_pts,)\n\n    def _process_array(self, x: NDArrayComplex) -&gt; NDArrayReal:\n        \"\"\"\n        Apply SciPy ISTFT processing to multiple channels at once using ShortTimeFFT\"\"\"\n        logger.debug(\n            f\"Applying SciPy ISTFT (ShortTimeFFT) to array with shape: {x.shape}\"\n        )\n\n        # Convert 2D input to 3D (assume single channel)\n        if x.ndim == 2:\n            x = x.reshape(1, *x.shape)\n\n        # Adjust scaling back if STFT applied factor of 2\n        _x = np.copy(x)\n        _x[..., 1:-1, :] /= 2.0\n\n        # Apply ISTFT using the ShortTimeFFT instance\n        result: NDArrayReal = self.SFT.istft(_x)\n\n        # Trim to desired length if specified\n        if self.length is not None:\n            result = result[..., : self.length]\n\n        logger.debug(\n            f\"ShortTimeFFT applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.ISTFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.ISTFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, freqs, time_frames)</p>"},{"location":"ja/api/#wandas.processing.time_series.ISTFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, freqs, time_frames)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, samples)\n    \"\"\"\n    k0: int = 0\n    q_max = input_shape[-1] + self.SFT.p_min\n    k_max = (q_max - 1) * self.SFT.hop + self.SFT.m_num - self.SFT.m_num_mid\n    k_q0, k_q1 = self.SFT.nearest_k_p(k0), self.SFT.nearest_k_p(k_max, left=False)\n    n_pts = k_q1 - k_q0 + self.SFT.m_num - self.SFT.m_num_mid\n\n    return input_shape[:-2] + (n_pts,)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.LowPassFilter","title":"<code>LowPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Low-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class LowPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Low-pass filter operation\"\"\"\n\n    name = \"lowpass_filter\"\n    a: NDArrayReal\n    b: NDArrayReal\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize low-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            raise ValueError(\n                f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n            )\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up low-pass filter processor\"\"\"\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"low\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Lowpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying lowpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.LowPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize low-pass filter</p>"},{"location":"ja/api/#wandas.processing.time_series.LowPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize low-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.LowPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        raise ValueError(\n            f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n        )\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Mean","title":"<code>Mean</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Mean calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Mean(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Mean calculation\"\"\"\n\n    name = \"mean\"\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # Use Dask's aggregate function directly without map_blocks\n        return data.mean(axis=0, keepdims=True)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.NOctSpectrum","title":"<code>NOctSpectrum</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>N-octave spectrum operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class NOctSpectrum(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"N-octave spectrum operation\"\"\"\n\n    name = \"noct_spectrum\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ):\n        \"\"\"\n        Initialize N-octave spectrum\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        fmin : float\n            Minimum frequency (Hz)\n        fmax : float\n            Maximum frequency (Hz)\n        n : int, optional\n            Number of octave divisions, default is 3\n        G : int, optional\n            Reference level, default is 10\n        fr : int, optional\n            Reference frequency, default is 1000\n        \"\"\"\n        super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n        self.fmin = fmin\n        self.fmax = fmax\n        self.n = n\n        self.G = G\n        self.fr = fr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate output shape for octave spectrum\n        _, fpref = _center_freq(\n            fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n        )\n        return (input_shape[0], fpref.shape[0])\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for octave spectrum\"\"\"\n        logger.debug(f\"Applying NoctSpectrum to array with shape: {x.shape}\")\n        spec, _ = noct_spectrum(\n            sig=x.T,\n            fs=self.sampling_rate,\n            fmin=self.fmin,\n            fmax=self.fmax,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        if spec.ndim == 1:\n            # Add channel dimension for 1D\n            spec = np.expand_dims(spec, axis=0)\n        else:\n            spec = spec.T\n        logger.debug(f\"NoctSpectrum applied, returning result with shape: {spec.shape}\")\n        return np.array(spec)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.NOctSpectrum.__init__","title":"<code>__init__(sampling_rate, fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Initialize N-octave spectrum</p>"},{"location":"ja/api/#wandas.processing.time_series.NOctSpectrum.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) fmin : float     Minimum frequency (Hz) fmax : float     Maximum frequency (Hz) n : int, optional     Number of octave divisions, default is 3 G : int, optional     Reference level, default is 10 fr : int, optional     Reference frequency, default is 1000</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n):\n    \"\"\"\n    Initialize N-octave spectrum\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    fmin : float\n        Minimum frequency (Hz)\n    fmax : float\n        Maximum frequency (Hz)\n    n : int, optional\n        Number of octave divisions, default is 3\n    G : int, optional\n        Reference level, default is 10\n    fr : int, optional\n        Reference frequency, default is 1000\n    \"\"\"\n    super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n    self.fmin = fmin\n    self.fmax = fmax\n    self.n = n\n    self.G = G\n    self.fr = fr\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.NOctSpectrum.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.NOctSpectrum.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"ja/api/#wandas.processing.time_series.NOctSpectrum.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate output shape for octave spectrum\n    _, fpref = _center_freq(\n        fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n    )\n    return (input_shape[0], fpref.shape[0])\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.NOctSynthesis","title":"<code>NOctSynthesis</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Octave synthesis operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class NOctSynthesis(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Octave synthesis operation\"\"\"\n\n    name = \"noct_synthesis\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ):\n        \"\"\"\n        Initialize octave synthesis\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        fmin : float\n            Minimum frequency (Hz)\n        fmax : float\n            Maximum frequency (Hz)\n        n : int, optional\n            Number of octave divisions, default is 3\n        G : int, optional\n            Reference level, default is 10\n        fr : int, optional\n            Reference frequency, default is 1000\n        \"\"\"\n        super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n\n        self.fmin = fmin\n        self.fmax = fmax\n        self.n = n\n        self.G = G\n        self.fr = fr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate output shape for octave spectrum\n        _, fpref = _center_freq(\n            fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n        )\n        return (input_shape[0], fpref.shape[0])\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for octave synthesis\"\"\"\n        logger.debug(f\"Applying NoctSynthesis to array with shape: {x.shape}\")\n        # Calculate n from shape[-1]\n        n = x.shape[-1]  # Calculate n from shape[-1]\n        if n % 2 == 0:\n            n = n * 2 - 1\n        else:\n            n = (n - 1) * 2\n        freqs = np.fft.rfftfreq(n, d=1 / self.sampling_rate)\n        result, _ = noct_synthesis(\n            spectrum=np.abs(x).T,\n            freqs=freqs,\n            fmin=self.fmin,\n            fmax=self.fmax,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        result = result.T\n        logger.debug(\n            f\"NoctSynthesis applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.NOctSynthesis.__init__","title":"<code>__init__(sampling_rate, fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Initialize octave synthesis</p>"},{"location":"ja/api/#wandas.processing.time_series.NOctSynthesis.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) fmin : float     Minimum frequency (Hz) fmax : float     Maximum frequency (Hz) n : int, optional     Number of octave divisions, default is 3 G : int, optional     Reference level, default is 10 fr : int, optional     Reference frequency, default is 1000</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n):\n    \"\"\"\n    Initialize octave synthesis\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    fmin : float\n        Minimum frequency (Hz)\n    fmax : float\n        Maximum frequency (Hz)\n    n : int, optional\n        Number of octave divisions, default is 3\n    G : int, optional\n        Reference level, default is 10\n    fr : int, optional\n        Reference frequency, default is 1000\n    \"\"\"\n    super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n\n    self.fmin = fmin\n    self.fmax = fmax\n    self.n = n\n    self.G = G\n    self.fr = fr\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.NOctSynthesis.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.NOctSynthesis.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"ja/api/#wandas.processing.time_series.NOctSynthesis.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate output shape for octave spectrum\n    _, fpref = _center_freq(\n        fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n    )\n    return (input_shape[0], fpref.shape[0])\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Power","title":"<code>Power</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Power operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Power(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Power operation\"\"\"\n\n    name = \"power\"\n\n    def __init__(self, sampling_rate: float, exponent: float):\n        \"\"\"\n        Initialize power operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        exponent : float\n            Power exponent\n        \"\"\"\n        super().__init__(sampling_rate)\n        self.exp = exponent\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        return da.power(data, self.exp)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Power.__init__","title":"<code>__init__(sampling_rate, exponent)</code>","text":"<p>Initialize power operation</p>"},{"location":"ja/api/#wandas.processing.time_series.Power.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) exponent : float     Power exponent</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, exponent: float):\n    \"\"\"\n    Initialize power operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    exponent : float\n        Power exponent\n    \"\"\"\n    super().__init__(sampling_rate)\n    self.exp = exponent\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.ReSampling","title":"<code>ReSampling</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Resampling operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ReSampling(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Resampling operation\"\"\"\n\n    name = \"resampling\"\n\n    def __init__(self, sampling_rate: float, target_sr: float):\n        \"\"\"\n        Initialize resampling operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        target_sampling_rate : float\n            Target sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate, target_sr=target_sr)\n        self.target_sr = target_sr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after resampling\n        ratio = float(self.target_sr) / float(self.sampling_rate)\n        n_samples = int(np.ceil(input_shape[-1] * ratio))\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for resampling operation\"\"\"\n        logger.debug(f\"Applying resampling to array with shape: {x.shape}\")\n        result = librosa.resample(\n            x, orig_sr=self.sampling_rate, target_sr=self.target_sr\n        )\n        logger.debug(f\"Resampling applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.ReSampling.__init__","title":"<code>__init__(sampling_rate, target_sr)</code>","text":"<p>Initialize resampling operation</p>"},{"location":"ja/api/#wandas.processing.time_series.ReSampling.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) target_sampling_rate : float     Target sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, target_sr: float):\n    \"\"\"\n    Initialize resampling operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    target_sampling_rate : float\n        Target sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate, target_sr=target_sr)\n    self.target_sr = target_sr\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.ReSampling.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.ReSampling.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"ja/api/#wandas.processing.time_series.ReSampling.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after resampling\n    ratio = float(self.target_sr) / float(self.sampling_rate)\n    n_samples = int(np.ceil(input_shape[-1] * ratio))\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.RmsTrend","title":"<code>RmsTrend</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>RMS calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class RmsTrend(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"RMS calculation\"\"\"\n\n    name = \"rms_trend\"\n    frame_length: int\n    hop_length: int\n    Aw: bool\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        ref: Union[list[float], float] = 1.0,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; None:\n        \"\"\"\n        Initialize RMS calculation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        frame_length : int\n            Frame length, default is 2048\n        hop_length : int\n            Hop length, default is 512\n        ref : Union[list[float], float]\n            Reference value(s) for dB calculation\n        dB : bool\n            Whether to convert to decibels\n        Aw : bool\n            Whether to apply A-weighting before RMS calculation\n        \"\"\"\n        self.frame_length = frame_length\n        self.hop_length = hop_length\n        self.dB = dB\n        self.Aw = Aw\n        self.ref = np.array(ref if isinstance(ref, list) else [ref])\n        super().__init__(\n            sampling_rate,\n            frame_length=frame_length,\n            hop_length=hop_length,\n            dB=dB,\n            Aw=Aw,\n            ref=self.ref,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, frames)\n        \"\"\"\n        n_frames = librosa.feature.rms(\n            y=np.ones((1, input_shape[-1])),\n            frame_length=self.frame_length,\n            hop_length=self.hop_length,\n        ).shape[-1]\n        return (*input_shape[:-1], n_frames)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for RMS calculation\"\"\"\n        logger.debug(f\"Applying RMS to array with shape: {x.shape}\")\n\n        if self.Aw:\n            # Apply A-weighting\n            _x = A_weight(x, self.sampling_rate)\n            if isinstance(_x, np.ndarray):\n                # A_weight\u304c\u30bf\u30d7\u30eb\u3092\u8fd4\u3059\u5834\u5408\u3001\u6700\u521d\u306e\u8981\u7d20\u3092\u4f7f\u7528\n                x = _x\n            elif isinstance(_x, tuple):\n                # Use the first element if A_weight returns a tuple\n                x = _x[0]\n            else:\n                raise ValueError(\"A_weighting returned an unexpected type.\")\n\n        # Calculate RMS\n        result = librosa.feature.rms(\n            y=x, frame_length=self.frame_length, hop_length=self.hop_length\n        )[..., 0, :]\n\n        if self.dB:\n            # Convert to dB\n            result = 20 * np.log10(\n                np.maximum(result / self.ref[..., np.newaxis], 1e-12)\n            )\n        #\n        logger.debug(f\"RMS applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.RmsTrend.__init__","title":"<code>__init__(sampling_rate, frame_length=2048, hop_length=512, ref=1.0, dB=False, Aw=False)</code>","text":"<p>Initialize RMS calculation</p>"},{"location":"ja/api/#wandas.processing.time_series.RmsTrend.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) frame_length : int     Frame length, default is 2048 hop_length : int     Hop length, default is 512 ref : Union[list[float], float]     Reference value(s) for dB calculation dB : bool     Whether to convert to decibels Aw : bool     Whether to apply A-weighting before RMS calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    ref: Union[list[float], float] = 1.0,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; None:\n    \"\"\"\n    Initialize RMS calculation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    frame_length : int\n        Frame length, default is 2048\n    hop_length : int\n        Hop length, default is 512\n    ref : Union[list[float], float]\n        Reference value(s) for dB calculation\n    dB : bool\n        Whether to convert to decibels\n    Aw : bool\n        Whether to apply A-weighting before RMS calculation\n    \"\"\"\n    self.frame_length = frame_length\n    self.hop_length = hop_length\n    self.dB = dB\n    self.Aw = Aw\n    self.ref = np.array(ref if isinstance(ref, list) else [ref])\n    super().__init__(\n        sampling_rate,\n        frame_length=frame_length,\n        hop_length=hop_length,\n        dB=dB,\n        Aw=Aw,\n        ref=self.ref,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.RmsTrend.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.RmsTrend.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"ja/api/#wandas.processing.time_series.RmsTrend.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, frames)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, frames)\n    \"\"\"\n    n_frames = librosa.feature.rms(\n        y=np.ones((1, input_shape[-1])),\n        frame_length=self.frame_length,\n        hop_length=self.hop_length,\n    ).shape[-1]\n    return (*input_shape[:-1], n_frames)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.STFT","title":"<code>STFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Short-Time Fourier Transform operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class STFT(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Short-Time Fourier Transform operation\"\"\"\n\n    name = \"stft\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ):\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.noverlap = (\n            self.win_length - self.hop_length if hop_length is not None else None\n        )\n        self.window = window\n\n        self.SFT = ShortTimeFFT(\n            win=get_window(window, self.win_length),\n            hop=self.hop_length,\n            fs=sampling_rate,\n            mfft=self.n_fft,\n            scale_to=\"magnitude\",\n        )\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        n_samples = input_shape[-1]\n        n_f = len(self.SFT.f)\n        n_t = len(self.SFT.t(n_samples))\n        return (input_shape[0], n_f, n_t)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Apply SciPy STFT processing to multiple channels at once\"\"\"\n        logger.debug(f\"Applying SciPy STFT to array with shape: {x.shape}\")\n\n        # Convert 1D input to 2D\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n\n        # Apply STFT to all channels at once\n        result: NDArrayComplex = self.SFT.stft(x)\n        result[..., 1:-1, :] *= 2.0\n        logger.debug(f\"SciPy STFT applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.STFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.STFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"ja/api/#wandas.processing.time_series.STFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    n_samples = input_shape[-1]\n    n_f = len(self.SFT.f)\n    n_t = len(self.SFT.t(n_samples))\n    return (input_shape[0], n_f, n_t)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Sum","title":"<code>Sum</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Sum calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Sum(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Sum calculation\"\"\"\n\n    name = \"sum\"\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # Use Dask's aggregate function directly without map_blocks\n        return data.sum(axis=0, keepdims=True)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.TransferFunction","title":"<code>TransferFunction</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Transfer function estimation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class TransferFunction(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Transfer function estimation operation\"\"\"\n\n    name = \"transfer_function\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ):\n        \"\"\"\n        Initialize transfer function estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        scaling : str\n            Type of scaling\n        average : str\n            Method of averaging\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        self.scaling = scaling\n        self.average = average\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n            scaling=scaling,\n            average=average,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Processor function for transfer function estimation operation\"\"\"\n        logger.debug(\n            f\"Applying transfer function estimation to array with shape: {x.shape}\"\n        )\n        from scipy import signal as ss\n\n        # Calculate cross-spectral density between all channels\n        f, p_yx = ss.csd(\n            x=x[:, np.newaxis, :],\n            y=x[np.newaxis, :, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n            axis=-1,\n        )\n        # p_yx shape: (num_channels, num_channels, num_frequencies)\n\n        # Calculate power spectral density for each channel\n        f, p_xx = ss.welch(\n            x=x,\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n            axis=-1,\n        )\n        # p_xx shape: (num_channels, num_frequencies)\n\n        # Calculate transfer function H(f) = P_yx / P_xx\n        h_f = p_yx / p_xx[np.newaxis, :, :]\n        result: NDArrayComplex = h_f.transpose(1, 0, 2).reshape(-1, h_f.shape[-1])\n\n        logger.debug(\n            f\"Transfer function estimation applied, result shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.TransferFunction.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend, scaling='spectrum', average='mean')</code>","text":"<p>Initialize transfer function estimation operation</p>"},{"location":"ja/api/#wandas.processing.time_series.TransferFunction.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend scaling : str     Type of scaling average : str     Method of averaging</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n):\n    \"\"\"\n    Initialize transfer function estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    scaling : str\n        Type of scaling\n    average : str\n        Method of averaging\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    self.scaling = scaling\n    self.average = average\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n        scaling=scaling,\n        average=average,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.TransferFunction.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.TransferFunction.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"ja/api/#wandas.processing.time_series.TransferFunction.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Trim","title":"<code>Trim</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Trimming operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Trim(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Trimming operation\"\"\"\n\n    name = \"trim\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        start: float,\n        end: float,\n    ):\n        \"\"\"\n        Initialize trimming operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        start : float\n            Start time for trimming (seconds)\n        end : float\n            End time for trimming (seconds)\n        \"\"\"\n        super().__init__(sampling_rate, start=start, end=end)\n        self.start = start\n        self.end = end\n        self.start_sample = int(start * sampling_rate)\n        self.end_sample = int(end * sampling_rate)\n        logger.debug(\n            f\"Initialized Trim operation with start: {self.start}, end: {self.end}\"\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after trimming\n        # Exclude parts where there is no signal\n        end_sample = min(self.end_sample, input_shape[-1])\n        n_samples = end_sample - self.start_sample\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for trimming operation\"\"\"\n        logger.debug(f\"Applying trim to array with shape: {x.shape}\")\n        # Apply trimming\n        result = x[..., self.start_sample : self.end_sample]\n        logger.debug(f\"Trim applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Trim.__init__","title":"<code>__init__(sampling_rate, start, end)</code>","text":"<p>Initialize trimming operation</p>"},{"location":"ja/api/#wandas.processing.time_series.Trim.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) start : float     Start time for trimming (seconds) end : float     End time for trimming (seconds)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    start: float,\n    end: float,\n):\n    \"\"\"\n    Initialize trimming operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    start : float\n        Start time for trimming (seconds)\n    end : float\n        End time for trimming (seconds)\n    \"\"\"\n    super().__init__(sampling_rate, start=start, end=end)\n    self.start = start\n    self.end = end\n    self.start_sample = int(start * sampling_rate)\n    self.end_sample = int(end * sampling_rate)\n    logger.debug(\n        f\"Initialized Trim operation with start: {self.start}, end: {self.end}\"\n    )\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Trim.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.Trim.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"ja/api/#wandas.processing.time_series.Trim.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after trimming\n    # Exclude parts where there is no signal\n    end_sample = min(self.end_sample, input_shape[-1])\n    n_samples = end_sample - self.start_sample\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Welch","title":"<code>Welch</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Welch</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Welch(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Welch\"\"\"\n\n    name = \"welch\"\n    n_fft: int\n    window: str\n    hop_length: Optional[int]\n    win_length: Optional[int]\n    average: str\n    detrend: str\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        average: str = \"mean\",\n        detrend: str = \"constant\",\n    ):\n        \"\"\"\n        Initialize Welch operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int, optional\n            FFT size, default is 2048\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.noverlap = (\n            self.win_length - self.hop_length if hop_length is not None else None\n        )\n        self.window = window\n        self.average = average\n        self.detrend = detrend\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n            average=average,\n            detrend=detrend,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, freqs)\n        \"\"\"\n        n_freqs = self.n_fft // 2 + 1\n        return (*input_shape[:-1], n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for Welch operation\"\"\"\n        from scipy import signal as ss\n\n        _, result = ss.welch(\n            x,\n            nperseg=self.win_length,\n            noverlap=self.noverlap,\n            nfft=self.n_fft,\n            window=self.window,\n            average=self.average,\n            detrend=self.detrend,\n            scaling=\"spectrum\",\n        )\n\n        if not isinstance(x, np.ndarray):\n            # Trigger computation for Dask array\n            raise ValueError(\n                \"Welch operation requires a Dask array, but received a non-ndarray.\"\n            )\n        return np.array(result)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Welch.__init__","title":"<code>__init__(sampling_rate, n_fft=2048, hop_length=None, win_length=None, window='hann', average='mean', detrend='constant')</code>","text":"<p>Initialize Welch operation</p>"},{"location":"ja/api/#wandas.processing.time_series.Welch.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int, optional     FFT size, default is 2048 window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    average: str = \"mean\",\n    detrend: str = \"constant\",\n):\n    \"\"\"\n    Initialize Welch operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int, optional\n        FFT size, default is 2048\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.noverlap = (\n        self.win_length - self.hop_length if hop_length is not None else None\n    )\n    self.window = window\n    self.average = average\n    self.detrend = detrend\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        win_length=self.win_length,\n        hop_length=self.hop_length,\n        window=window,\n        average=average,\n        detrend=detrend,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Welch.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.Welch.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"ja/api/#wandas.processing.time_series.Welch.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, freqs)\n    \"\"\"\n    n_freqs = self.n_fft // 2 + 1\n    return (*input_shape[:-1], n_freqs)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.create_operation","title":"<code>create_operation(name, sampling_rate, **params)</code>","text":"<p>Create operation instance from name and parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def create_operation(\n    name: str, sampling_rate: float, **params: Any\n) -&gt; AudioOperation[Any, Any]:\n    \"\"\"Create operation instance from name and parameters\"\"\"\n    operation_class = get_operation(name)\n    return operation_class(sampling_rate, **params)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.get_operation","title":"<code>get_operation(name)</code>","text":"<p>Get operation class by name</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def get_operation(name: str) -&gt; type[AudioOperation[Any, Any]]:\n    \"\"\"Get operation class by name\"\"\"\n    if name not in _OPERATION_REGISTRY:\n        raise ValueError(f\"Unknown operation type: {name}\")\n    return _OPERATION_REGISTRY[name]\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.register_operation","title":"<code>register_operation(operation_class)</code>","text":"<p>Register a new operation type</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def register_operation(operation_class: type) -&gt; None:\n    \"\"\"Register a new operation type\"\"\"\n\n    if not issubclass(operation_class, AudioOperation):\n        raise TypeError(\"Strategy class must inherit from AudioOperation.\")\n    if inspect.isabstract(operation_class):\n        raise TypeError(\"Cannot register abstract AudioOperation class.\")\n\n    _OPERATION_REGISTRY[operation_class.name] = operation_class\n</code></pre>"},{"location":"ja/api/#_4","title":"\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3","text":""},{"location":"ja/api/core/","title":"\u30b3\u30a2\u30e2\u30b8\u30e5\u30fc\u30eb\uff08Core\uff09","text":"<p>\u3053\u306e\u30da\u30fc\u30b8\u3067\u306fWandas\u306e\u30b3\u30a2\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002\u30b3\u30a2\u30e2\u30b8\u30e5\u30fc\u30eb\u306fWandas\u306e\u57fa\u672c\u30c7\u30fc\u30bf\u69cb\u9020\u3068\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"ja/api/core/#baseframe","title":"BaseFrame","text":"<p><code>BaseFrame</code>\u306fWandas\u306e\u5168\u3066\u306e\u30d5\u30ec\u30fc\u30e0\u30af\u30e9\u30b9\u306e\u57fa\u5e95\u30af\u30e9\u30b9\u3067\u3059\u3002\u76f4\u63a5\u3053\u306e\u30af\u30e9\u30b9\u3092\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u5316\u3059\u308b\u3053\u3068\u306f\u306a\u304f\u3001\u6d3e\u751f\u30af\u30e9\u30b9\uff08ChannelFrame\u306a\u3069\uff09\u3092\u901a\u3058\u3066\u4f7f\u7528\u3057\u307e\u3059\u3002</p> <pre><code>from wandas.core.base_frame import BaseFrame\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for all signal frame types.</p> <p>This class provides the common interface and functionality for all frame types used in signal processing. It implements basic operations like indexing, iteration, and data manipulation that are shared across all frame types.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The signal data to process. Must be a dask array. sampling_rate : float     The sampling rate of the signal in Hz. label : str, optional     A label for the frame. If not provided, defaults to \"unnamed_frame\". metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame--attributes","title":"Attributes","text":"<p>sampling_rate : float     The sampling rate of the signal in Hz. label : str     The label of the frame. metadata : dict     Additional metadata for the frame. operation_history : list[dict]     History of operations performed on this frame.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>class BaseFrame(ABC, Generic[T]):\n    \"\"\"\n    Abstract base class for all signal frame types.\n\n    This class provides the common interface and functionality for all frame types\n    used in signal processing. It implements basic operations like indexing, iteration,\n    and data manipulation that are shared across all frame types.\n\n    Parameters\n    ----------\n    data : DaArray\n        The signal data to process. Must be a dask array.\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str, optional\n        A label for the frame. If not provided, defaults to \"unnamed_frame\".\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str\n        The label of the frame.\n    metadata : dict\n        Additional metadata for the frame.\n    operation_history : list[dict]\n        History of operations performed on this frame.\n    \"\"\"\n\n    _data: DaArray\n    sampling_rate: float\n    label: str\n    metadata: dict[str, Any]\n    operation_history: list[dict[str, Any]]\n    _channel_metadata: list[ChannelMetadata]\n    _previous: Optional[\"BaseFrame[Any]\"]\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ):\n        self._data = data.rechunk(chunks=-1)  # type: ignore [unused-ignore]\n        if self._data.ndim == 1:\n            self._data = self._data.reshape((1, -1))\n        self.sampling_rate = sampling_rate\n        self.label = label or \"unnamed_frame\"\n        self.metadata = metadata or {}\n        self.operation_history = operation_history or []\n        self._previous = previous\n\n        if channel_metadata:\n            self._channel_metadata = copy.deepcopy(channel_metadata)\n        else:\n            self._channel_metadata = [\n                ChannelMetadata(label=f\"ch{i}\", unit=\"\", extra={})\n                for i in range(self._n_channels)\n            ]\n\n        try:\n            # Display information for newer dask versions\n            logger.debug(f\"Dask graph layers: {list(self._data.dask.layers.keys())}\")\n            logger.debug(\n                f\"Dask graph dependencies: {len(self._data.dask.dependencies)}\"\n            )\n        except Exception as e:\n            logger.debug(f\"Dask graph visualization details unavailable: {e}\")\n\n    @property\n    @abstractmethod\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n\n    @property\n    def n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return len(self)\n\n    @property\n    def channels(self) -&gt; list[ChannelMetadata]:\n        \"\"\"Property to access channel metadata.\"\"\"\n        return self._channel_metadata\n\n    @property\n    def previous(self) -&gt; Optional[\"BaseFrame[Any]\"]:\n        \"\"\"\n        Returns the previous frame.\n        \"\"\"\n        return self._previous\n\n    def get_channel(self: S, channel_idx: int) -&gt; S:\n        n_channels = len(self)\n        if channel_idx &lt; 0 or channel_idx &gt;= n_channels:\n            range_max = n_channels - 1\n            raise ValueError(\n                f\"Channel index out of range: {channel_idx} \"\n                f\"(valid range: 0-{range_max})\"\n            )\n        logger.debug(f\"Extracting channel index={channel_idx} (lazy operation).\")\n        channel_data = self._data[channel_idx : channel_idx + 1]\n\n        return self._create_new_instance(\n            data=channel_data,\n            operation_history=self.operation_history,\n            channel_metadata=[self._channel_metadata[channel_idx]],\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Returns the number of channels.\n        \"\"\"\n        return len(self._channel_metadata)\n\n    def __iter__(self: S) -&gt; Iterator[S]:\n        for idx in range(len(self)):\n            yield self[idx]\n\n    def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n        \"\"\"\n        Method to get a channel by name or index.\n\n        Parameters\n        ----------\n        key : str, int, slice, or tuple of slices\n            Channel name (label) or index number.\n\n        Returns\n        -------\n        BaseFrame\n            The corresponding channel.\n\n        Raises\n        ------\n        ValueError\n            If the key length is invalid for the shape.\n        IndexError\n            If the channel index is out of range.\n        TypeError\n            If the key type is invalid.\n        \"\"\"\n        if isinstance(key, str):\n            index = self.label2index(key)\n            return self.get_channel(index)\n\n        elif isinstance(key, tuple):\n            # When key is a tuple, treat the first element as an index\n            if len(key) &gt; len(self.shape):\n                raise ValueError(\n                    f\"Invalid key length: {len(key)} for shape {self.shape}\"\n                )\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key[0]]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, slice):\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, numbers.Integral):\n            # Access by index number\n            if key &lt; 0 or key &gt;= len(self):\n                raise IndexError(f\"Channel index {key} out of range.\")\n            return self.get_channel(key)\n        else:\n            raise TypeError(\n                f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n            )\n\n    def label2index(self, label: str) -&gt; int:\n        \"\"\"\n        Get the index from a channel label.\n\n        Parameters\n        ----------\n        label : str\n            Channel label.\n\n        Returns\n        -------\n        int\n            Corresponding index.\n\n        Raises\n        ------\n        KeyError\n            If the channel label is not found.\n        \"\"\"\n        for idx, ch in enumerate(self._channel_metadata):\n            if ch.label == label:\n                return idx\n        raise KeyError(f\"Channel label '{label}' not found.\")\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        _shape: tuple[int, ...] = self._data.shape\n        return _shape\n\n    @property\n    def data(self) -&gt; T:\n        \"\"\"\n        Returns the computed data.\n        Calculation is executed the first time this is accessed.\n        \"\"\"\n        return self.compute()\n\n    @property\n    def labels(self) -&gt; list[str]:\n        \"\"\"Get a list of all channel labels.\"\"\"\n        return [ch.label for ch in self._channel_metadata]\n\n    def compute(self) -&gt; T:\n        \"\"\"\n        Compute and return the data.\n        This method materializes lazily computed data into a concrete NumPy array.\n\n        Returns\n        -------\n        NDArrayReal\n            The computed data.\n\n        Raises\n        ------\n        ValueError\n            If the computed result is not a NumPy array.\n        \"\"\"\n        logger.debug(\n            \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n        )\n        result = self._data.compute()\n\n        if not isinstance(result, np.ndarray):\n            raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n        logger.debug(f\"Computation complete, result shape: {result.shape}\")\n        return cast(T, result)\n\n    @abstractmethod\n    def plot(\n        self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n    ) -&gt; Union[Axes, Iterator[Axes]]:\n        \"\"\"Plot the data\"\"\"\n        pass\n\n    def persist(self: S) -&gt; S:\n        \"\"\"Persist the data in memory\"\"\"\n        persisted_data = self._data.persist()\n        return self._create_new_instance(data=persisted_data)\n\n    @abstractmethod\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Abstract method for derived classes to provide\n        additional initialization arguments.\n        \"\"\"\n        pass\n\n    def _create_new_instance(self: S, data: DaArray, **kwargs: Any) -&gt; S:\n        \"\"\"\n        Create a new channel instance based on an existing channel.\n        Keyword arguments can override or extend the original attributes.\n        \"\"\"\n\n        sampling_rate = kwargs.pop(\"sampling_rate\", self.sampling_rate)\n        # if not isinstance(sampling_rate, int):\n        #     raise TypeError(\"Sampling rate must be an integer\")\n\n        label = kwargs.pop(\"label\", self.label)\n        if not isinstance(label, str):\n            raise TypeError(\"Label must be a string\")\n\n        metadata = kwargs.pop(\"metadata\", copy.deepcopy(self.metadata))\n        if not isinstance(metadata, dict):\n            raise TypeError(\"Metadata must be a dictionary\")\n\n        # Get additional initialization arguments from derived classes\n        additional_kwargs = self._get_additional_init_kwargs()\n        kwargs.update(additional_kwargs)\n\n        return type(self)(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            previous=self,\n            **kwargs,\n        )\n\n    def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n        \"\"\"Implicit conversion to NumPy array\"\"\"\n        result = self.compute()\n        if dtype is not None:\n            return result.astype(dtype)\n        return result\n\n    def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n        \"\"\"Visualize the computation graph and save it to a file\"\"\"\n        try:\n            filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n            self._data.visualize(filename=filename)\n            return filename\n        except Exception as e:\n            logger.warning(f\"Failed to visualize the graph: {e}\")\n            return None\n\n    @abstractmethod\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"Basic implementation of binary operations\"\"\"\n        # Basic logic\n        # Actual implementation is left to derived classes\n        pass\n\n    def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Addition operator\"\"\"\n        return self._binary_op(other, lambda x, y: x + y, \"+\")\n\n    def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Subtraction operator\"\"\"\n        return self._binary_op(other, lambda x, y: x - y, \"-\")\n\n    def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Multiplication operator\"\"\"\n        return self._binary_op(other, lambda x, y: x * y, \"*\")\n\n    def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Division operator\"\"\"\n        return self._binary_op(other, lambda x, y: x / y, \"/\")\n\n    def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Apply a named operation.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters to pass to the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        # Apply the operation through abstract method\n        return self._apply_operation_impl(operation_name, **params)\n\n    @abstractmethod\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"Implementation of operation application\"\"\"\n        pass\n\n    def debug_info(self) -&gt; None:\n        \"\"\"Output detailed debug information\"\"\"\n        logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n        logger.debug(f\"Label: {self.label}\")\n        logger.debug(f\"Shape: {self.shape}\")\n        logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n        logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n        self._debug_info_impl()\n        logger.debug(\"=== End Debug Info ===\")\n\n    def _debug_info_impl(self) -&gt; None:\n        \"\"\"Implement derived class-specific debug information\"\"\"\n        pass\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.channels","title":"<code>channels</code>  <code>property</code>","text":"<p>Property to access channel metadata.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.data","title":"<code>data</code>  <code>property</code>","text":"<p>Returns the computed data. Calculation is executed the first time this is accessed.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>Get a list of all channel labels.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.n_channels","title":"<code>n_channels</code>  <code>property</code>","text":"<p>Returns the number of channels.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.previous","title":"<code>previous</code>  <code>property</code>","text":"<p>Returns the previous frame.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__add__","title":"<code>__add__(other)</code>","text":"<p>Addition operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Addition operator\"\"\"\n    return self._binary_op(other, lambda x, y: x + y, \"+\")\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__array__","title":"<code>__array__(dtype=None)</code>","text":"<p>Implicit conversion to NumPy array</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n    \"\"\"Implicit conversion to NumPy array\"\"\"\n    result = self.compute()\n    if dtype is not None:\n        return result.astype(dtype)\n    return result\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Method to get a channel by name or index.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__getitem__--parameters","title":"Parameters","text":"<p>key : str, int, slice, or tuple of slices     Channel name (label) or index number.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__getitem__--returns","title":"Returns","text":"<p>BaseFrame     The corresponding channel.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__getitem__--raises","title":"Raises","text":"<p>ValueError     If the key length is invalid for the shape. IndexError     If the channel index is out of range. TypeError     If the key type is invalid.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n    \"\"\"\n    Method to get a channel by name or index.\n\n    Parameters\n    ----------\n    key : str, int, slice, or tuple of slices\n        Channel name (label) or index number.\n\n    Returns\n    -------\n    BaseFrame\n        The corresponding channel.\n\n    Raises\n    ------\n    ValueError\n        If the key length is invalid for the shape.\n    IndexError\n        If the channel index is out of range.\n    TypeError\n        If the key type is invalid.\n    \"\"\"\n    if isinstance(key, str):\n        index = self.label2index(key)\n        return self.get_channel(index)\n\n    elif isinstance(key, tuple):\n        # When key is a tuple, treat the first element as an index\n        if len(key) &gt; len(self.shape):\n            raise ValueError(\n                f\"Invalid key length: {len(key)} for shape {self.shape}\"\n            )\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key[0]]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, slice):\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, numbers.Integral):\n        # Access by index number\n        if key &lt; 0 or key &gt;= len(self):\n            raise IndexError(f\"Channel index {key} out of range.\")\n        return self.get_channel(key)\n    else:\n        raise TypeError(\n            f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n        )\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of channels.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of channels.\n    \"\"\"\n    return len(self._channel_metadata)\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplication operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Multiplication operator\"\"\"\n    return self._binary_op(other, lambda x, y: x * y, \"*\")\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtraction operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Subtraction operator\"\"\"\n    return self._binary_op(other, lambda x, y: x - y, \"-\")\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Division operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Division operator\"\"\"\n    return self._binary_op(other, lambda x, y: x / y, \"/\")\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.apply_operation","title":"<code>apply_operation(operation_name, **params)</code>","text":"<p>Apply a named operation.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.apply_operation--parameters","title":"Parameters","text":"<p>operation_name : str     Name of the operation to apply. **params : Any     Parameters to pass to the operation.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.apply_operation--returns","title":"Returns","text":"<p>S     A new instance with the operation applied.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n    \"\"\"\n    Apply a named operation.\n\n    Parameters\n    ----------\n    operation_name : str\n        Name of the operation to apply.\n    **params : Any\n        Parameters to pass to the operation.\n\n    Returns\n    -------\n    S\n        A new instance with the operation applied.\n    \"\"\"\n    # Apply the operation through abstract method\n    return self._apply_operation_impl(operation_name, **params)\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.compute","title":"<code>compute()</code>","text":"<p>Compute and return the data. This method materializes lazily computed data into a concrete NumPy array.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.compute--returns","title":"Returns","text":"<p>NDArrayReal     The computed data.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.compute--raises","title":"Raises","text":"<p>ValueError     If the computed result is not a NumPy array.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def compute(self) -&gt; T:\n    \"\"\"\n    Compute and return the data.\n    This method materializes lazily computed data into a concrete NumPy array.\n\n    Returns\n    -------\n    NDArrayReal\n        The computed data.\n\n    Raises\n    ------\n    ValueError\n        If the computed result is not a NumPy array.\n    \"\"\"\n    logger.debug(\n        \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n    )\n    result = self._data.compute()\n\n    if not isinstance(result, np.ndarray):\n        raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n    logger.debug(f\"Computation complete, result shape: {result.shape}\")\n    return cast(T, result)\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.debug_info","title":"<code>debug_info()</code>","text":"<p>Output detailed debug information</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def debug_info(self) -&gt; None:\n    \"\"\"Output detailed debug information\"\"\"\n    logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n    logger.debug(f\"Label: {self.label}\")\n    logger.debug(f\"Shape: {self.shape}\")\n    logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n    logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n    self._debug_info_impl()\n    logger.debug(\"=== End Debug Info ===\")\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.label2index","title":"<code>label2index(label)</code>","text":"<p>Get the index from a channel label.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.label2index--parameters","title":"Parameters","text":"<p>label : str     Channel label.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.label2index--returns","title":"Returns","text":"<p>int     Corresponding index.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.label2index--raises","title":"Raises","text":"<p>KeyError     If the channel label is not found.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def label2index(self, label: str) -&gt; int:\n    \"\"\"\n    Get the index from a channel label.\n\n    Parameters\n    ----------\n    label : str\n        Channel label.\n\n    Returns\n    -------\n    int\n        Corresponding index.\n\n    Raises\n    ------\n    KeyError\n        If the channel label is not found.\n    \"\"\"\n    for idx, ch in enumerate(self._channel_metadata):\n        if ch.label == label:\n            return idx\n    raise KeyError(f\"Channel label '{label}' not found.\")\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.persist","title":"<code>persist()</code>","text":"<p>Persist the data in memory</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def persist(self: S) -&gt; S:\n    \"\"\"Persist the data in memory\"\"\"\n    persisted_data = self._data.persist()\n    return self._create_new_instance(data=persisted_data)\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.plot","title":"<code>plot(plot_type='default', ax=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Plot the data</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>@abstractmethod\ndef plot(\n    self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n) -&gt; Union[Axes, Iterator[Axes]]:\n    \"\"\"Plot the data\"\"\"\n    pass\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.visualize_graph","title":"<code>visualize_graph(filename=None)</code>","text":"<p>Visualize the computation graph and save it to a file</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"Visualize the computation graph and save it to a file\"\"\"\n    try:\n        filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n        self._data.visualize(filename=filename)\n        return filename\n    except Exception as e:\n        logger.warning(f\"Failed to visualize the graph: {e}\")\n        return None\n</code></pre>"},{"location":"ja/api/core/#channelmetadata","title":"ChannelMetadata","text":"<p><code>ChannelMetadata</code>\u306f\u30c1\u30e3\u30f3\u30cd\u30eb\u3054\u3068\u306e\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u7ba1\u7406\u3059\u308b\u305f\u3081\u306e\u30af\u30e9\u30b9\u3067\u3059\u3002\u30c1\u30e3\u30f3\u30cd\u30eb\u540d\u3001\u5358\u4f4d\u3001\u305d\u306e\u4ed6\u306e\u4ed8\u52a0\u60c5\u5831\u3092\u4fdd\u6301\u3057\u307e\u3059\u3002</p> <pre><code>from wandas.core.metadata import ChannelMetadata\n\n# \u4f7f\u7528\u4f8b\nmetadata = ChannelMetadata(label=\"\u5de6\u30c1\u30e3\u30f3\u30cd\u30eb\", unit=\"dB\", extra={\"\u30c7\u30d0\u30a4\u30b9\": \"\u30de\u30a4\u30af\"})\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>Data class for storing channel metadata</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>class ChannelMetadata(BaseModel):\n    \"\"\"\n    Data class for storing channel metadata\n    \"\"\"\n\n    label: str = \"\"\n    unit: str = \"\"\n    ref: float = 1.0\n    # Additional metadata for extensibility\n    extra: dict[str, Any] = Field(default_factory=dict)\n\n    def __getitem__(self, key: str) -&gt; Any:\n        \"\"\"Provide dictionary-like behavior\"\"\"\n        if key == \"label\":\n            return self.label\n        elif key == \"unit\":\n            return self.unit\n        elif key == \"ref\":\n            return self.ref\n        else:\n            return self.extra.get(key)\n\n    def __setitem__(self, key: str, value: Any) -&gt; None:\n        \"\"\"Provide dictionary-like behavior\"\"\"\n        if key == \"label\":\n            self.label = value\n        elif key == \"unit\":\n            self.unit = value\n        elif key == \"ref\":\n            self.ref = value\n        else:\n            self.extra[key] = value\n\n    def to_json(self) -&gt; str:\n        \"\"\"Convert to JSON format\"\"\"\n        json_data: str = self.model_dump_json(indent=4)\n        return json_data\n\n    @classmethod\n    def from_json(cls, json_data: str) -&gt; \"ChannelMetadata\":\n        \"\"\"Convert from JSON format\"\"\"\n        root_model: ChannelMetadata = ChannelMetadata.model_validate_json(json_data)\n\n        return root_model\n</code></pre>"},{"location":"ja/api/core/#wandas.core.metadata.ChannelMetadata.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Provide dictionary-like behavior</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Any:\n    \"\"\"Provide dictionary-like behavior\"\"\"\n    if key == \"label\":\n        return self.label\n    elif key == \"unit\":\n        return self.unit\n    elif key == \"ref\":\n        return self.ref\n    else:\n        return self.extra.get(key)\n</code></pre>"},{"location":"ja/api/core/#wandas.core.metadata.ChannelMetadata.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Provide dictionary-like behavior</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def __setitem__(self, key: str, value: Any) -&gt; None:\n    \"\"\"Provide dictionary-like behavior\"\"\"\n    if key == \"label\":\n        self.label = value\n    elif key == \"unit\":\n        self.unit = value\n    elif key == \"ref\":\n        self.ref = value\n    else:\n        self.extra[key] = value\n</code></pre>"},{"location":"ja/api/core/#wandas.core.metadata.ChannelMetadata.from_json","title":"<code>from_json(json_data)</code>  <code>classmethod</code>","text":"<p>Convert from JSON format</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>@classmethod\ndef from_json(cls, json_data: str) -&gt; \"ChannelMetadata\":\n    \"\"\"Convert from JSON format\"\"\"\n    root_model: ChannelMetadata = ChannelMetadata.model_validate_json(json_data)\n\n    return root_model\n</code></pre>"},{"location":"ja/api/core/#wandas.core.metadata.ChannelMetadata.to_json","title":"<code>to_json()</code>","text":"<p>Convert to JSON format</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Convert to JSON format\"\"\"\n    json_data: str = self.model_dump_json(indent=4)\n    return json_data\n</code></pre>"},{"location":"ja/api/frames/","title":"\u30d5\u30ec\u30fc\u30e0\u30e2\u30b8\u30e5\u30fc\u30eb\uff08Frames\uff09","text":"<p>\u3053\u306e\u30da\u30fc\u30b8\u3067\u306fWandas\u306e\u30d5\u30ec\u30fc\u30e0\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002\u30d5\u30ec\u30fc\u30e0\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u306f\u3001\u3055\u307e\u3056\u307e\u306a\u30bf\u30a4\u30d7\u306e\u30c7\u30fc\u30bf\u30d5\u30ec\u30fc\u30e0\u304c\u542b\u307e\u308c\u3066\u3044\u307e\u3059\u3002</p>"},{"location":"ja/api/frames/#channelframe","title":"ChannelFrame","text":"<p><code>ChannelFrame</code>\u306f\u6642\u9593\u9818\u57df\u306e\u4fe1\u53f7\u30c7\u30fc\u30bf\u3092\u6271\u3046\u30d5\u30ec\u30fc\u30e0\u3067\u3059\u3002</p> <pre><code>from wandas.frames.channel import ChannelFrame\n\n# \u307e\u305f\u306f\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")  # ChannelFrame\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u8fd4\u3057\u307e\u3059\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Channel-based data frame for handling audio signals and time series data.</p> <p>This frame represents channel-based data such as audio signals and time series data, with each channel containing data samples in the time domain.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>class ChannelFrame(BaseFrame[NDArrayReal]):\n    \"\"\"Channel-based data frame for handling audio signals and time series data.\n\n    This frame represents channel-based data such as audio signals and time series data,\n    with each channel containing data samples in the time domain.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"Initialize a ChannelFrame.\n\n        Args:\n            data: Dask array containing channel data.\n            Shape should be (n_channels, n_samples).\n            sampling_rate: The sampling rate of the data in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            operation_history: History of operations applied to the frame.\n            channel_metadata: Metadata for each channel.\n            previous: Reference to the previous frame in the processing chain.\n\n        Raises:\n            ValueError: If data has more than 2 dimensions.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return self.shape[-2]\n\n    @property\n    def time(self) -&gt; NDArrayReal:\n        \"\"\"Get time array for the signal.\n\n        Returns:\n            Array of time points in seconds.\n        \"\"\"\n        return np.arange(self.n_samples) / self.sampling_rate\n\n    @property\n    def n_samples(self) -&gt; int:\n        \"\"\"Returns the number of samples.\"\"\"\n        n: int = self._data.shape[-1]\n        return n\n\n    @property\n    def duration(self) -&gt; float:\n        \"\"\"Returns the duration in seconds.\"\"\"\n        return self.n_samples / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # Apply processing to data\n        processed_data = operation.process(self._data)\n\n        # Update metadata\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        if operation_name == \"resampling\":\n            # For resampling, update sampling rate\n            return self._create_new_instance(\n                sampling_rate=params[\"target_sr\"],\n                data=processed_data,\n                metadata=new_metadata,\n                operation_history=new_history,\n            )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Common implementation for binary operations\n        - utilizing dask's lazy evaluation.\n\n        Args:\n            other: Right operand for the operation.\n            op: Function to execute the operation (e.g., lambda a, b: a + b).\n            symbol: Symbolic representation of the operation (e.g., '+').\n\n        Returns:\n            A new channel containing the operation result (lazy execution).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, ChannelFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Perform operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other._data)\n\n            # Merge channel metadata\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # Perform operation with scalar, NumPy array, or other types\n        else:\n            # Apply operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other)\n\n            # Operand display string\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # Check for dask.array.Array\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # Update channel metadata\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n                previous=self,\n            )\n\n    def add(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        snr: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Add another signal or value to the current signal.\n\n        If SNR is specified, performs addition with consideration for\n        signal-to-noise ratio.\n\n        Args:\n            other: Signal or value to add.\n            snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n                other signal based on this SNR.\n                self is treated as the signal, and other as the noise.\n\n        Returns:\n            A new channel frame containing the addition result (lazy execution).\n        \"\"\"\n        logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n        # Special processing when SNR is specified\n        if snr is not None:\n            # First convert other to ChannelFrame if it's not\n            if not isinstance(other, ChannelFrame):\n                if isinstance(other, np.ndarray):\n                    other = ChannelFrame.from_numpy(\n                        other, self.sampling_rate, label=\"array_data\"\n                    )\n                elif isinstance(other, (int, float)):\n                    # For scalar values, simply add (ignore SNR)\n                    return self + other\n                else:\n                    raise TypeError(\n                        \"Addition target with SNR must be a ChannelFrame or \"\n                        f\"NumPy array: {type(other)}\"\n                    )\n\n            # Check if sampling rates match\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Apply addition operation with SNR adjustment\n            return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n        # Execute normal addition if SNR is not specified\n        return self + other\n\n    def plot(\n        self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Plot the frame data.\n\n        Args:\n            plot_type: Type of plot. Default is \"waveform\".\n            ax: Optional matplotlib axes for plotting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        plot_strategy = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def rms_plot(\n        self,\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = True,\n        Aw: bool = False,  # noqa: N803\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Generate an RMS plot.\n\n        Args:\n            ax: Optional matplotlib axes for plotting.\n            title: Title for the plot.\n            overlay: Whether to overlay the plot on the existing axis.\n            Aw: Apply A-weighting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        kwargs = kwargs or {}\n        ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n        rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n        return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n\n    def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n        \"\"\"Display visual and audio representation of the frame.\n\n        Args:\n            normalize: Whether to normalize the audio data for playback.\n            **kwargs: Additional parameters for visualization.\n        \"\"\"\n        if \"axis_config\" in kwargs:\n            logger.warning(\n                \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            axis_config = kwargs[\"axis_config\"]\n            if \"time_plot\" in axis_config:\n                kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n            if \"freq_plot\" in axis_config:\n                if \"xlim\" in axis_config[\"freq_plot\"]:\n                    vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                    kwargs[\"vmin\"] = vlim[0]\n                    kwargs[\"vmax\"] = vlim[1]\n                if \"ylim\" in axis_config[\"freq_plot\"]:\n                    ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                    kwargs[\"ylim\"] = ylim\n\n        if \"cbar_config\" in kwargs:\n            logger.warning(\n                \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            cbar_config = kwargs[\"cbar_config\"]\n            if \"vmin\" in cbar_config:\n                kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n            if \"vmax\" in cbar_config:\n                kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n        for ch in self:\n            ax: Axes\n            _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n            if isinstance(_ax, Iterator):\n                ax = next(iter(_ax))\n            elif isinstance(_ax, Axes):\n                ax = _ax\n            else:\n                raise TypeError(\n                    f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n                )\n            # Ignore type checks for display and Audio\n            display(ax.figure)  # type: ignore\n            plt.close(ax.figure)  # type: ignore\n            display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n\n    @classmethod\n    def from_numpy(\n        cls,\n        data: NDArrayReal,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        ch_labels: Optional[list[str]] = None,\n        ch_units: Optional[Union[list[str], str]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        Args:\n            data: NumPy array containing channel data.\n            sampling_rate: The sampling rate in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            ch_labels: Labels for each channel.\n            ch_units: Units for each channel.\n\n        Returns:\n            A new ChannelFrame containing the NumPy data.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n\n        # Convert NumPy array to dask array\n        dask_data = da_from_array(data)\n        cf = ChannelFrame(\n            data=dask_data,\n            sampling_rate=sampling_rate,\n            label=label or \"numpy_data\",\n        )\n        if metadata is not None:\n            cf.metadata = metadata\n        if ch_labels is not None:\n            if len(ch_labels) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel labels does not match the number of channels\"\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        if ch_units is not None:\n            if isinstance(ch_units, str):\n                ch_units = [ch_units] * cf.n_channels\n\n            if len(ch_units) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel units does not match the number of channels\"\n                )\n            for i in range(len(ch_units)):\n                cf._channel_metadata[i].unit = ch_units[i]\n\n        return cf\n\n    @classmethod\n    def from_ndarray(\n        cls,\n        array: NDArrayReal,\n        sampling_rate: float,\n        labels: Optional[list[str]] = None,\n        unit: Optional[Union[list[str], str]] = None,\n        frame_label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        This method is deprecated. Use from_numpy instead.\n\n        Args:\n            array: Signal data. Each row corresponds to a channel.\n            sampling_rate: Sampling rate (Hz).\n            labels: Labels for each channel.\n            unit: Unit of the signal.\n            frame_label: Label for the frame.\n            metadata: Optional metadata dictionary.\n\n        Returns:\n            A new ChannelFrame containing the data.\n        \"\"\"\n        # Redirect to from_numpy for compatibility\n        # However, from_ndarray is deprecated\n        logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n        return cls.from_numpy(\n            data=array,\n            sampling_rate=sampling_rate,\n            label=frame_label,\n            metadata=metadata,\n            ch_labels=labels,\n            ch_units=unit,\n        )\n\n    @classmethod\n    def from_file(\n        cls,\n        path: Union[str, Path],\n        channel: Optional[Union[int, list[int]]] = None,\n        start: Optional[float] = None,\n        end: Optional[float] = None,\n        chunk_size: Optional[int] = None,\n        ch_labels: Optional[list[str]] = None,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from an audio file.\n\n        Args:\n            path: Path to the audio file.\n            channel: Channel(s) to load.\n            start: Start time in seconds.\n            end: End time in seconds.\n            chunk_size: Chunk size for processing.\n            Specifies the splitting size for lazy processing.\n            ch_labels: Labels for each channel.\n            **kwargs: Additional arguments passed to the file reader.\n\n        Returns:\n            A new ChannelFrame containing the loaded audio data.\n\n        Raises:\n            ValueError: If channel selection is invalid.\n            TypeError: If channel parameter type is invalid.\n            FileNotFoundError: If the file doesn't exist.\n        \"\"\"\n        from .channel import ChannelFrame\n\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"File not found: {path}\")\n\n        # Get file reader\n        reader = get_file_reader(path)\n\n        # Get file info\n        info = reader.get_file_info(path, **kwargs)\n        sr = info[\"samplerate\"]\n        n_channels = info[\"channels\"]\n        n_frames = info[\"frames\"]\n        ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n        logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n        # Channel selection processing\n        all_channels = list(range(n_channels))\n\n        if channel is None:\n            channels_to_load = all_channels\n            logger.debug(f\"Will load all channels: {channels_to_load}\")\n        elif isinstance(channel, int):\n            if channel &lt; 0 or channel &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n            channels_to_load = [channel]\n            logger.debug(f\"Will load single channel: {channel}\")\n        elif isinstance(channel, (list, tuple)):\n            for ch in channel:\n                if ch &lt; 0 or ch &gt;= n_channels:\n                    raise ValueError(\n                        f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                    )\n            channels_to_load = list(channel)\n            logger.debug(f\"Will load specific channels: {channels_to_load}\")\n        else:\n            raise TypeError(\"channel must be int, list, or None\")\n\n        # Index calculation\n        start_idx = 0 if start is None else max(0, int(start * sr))\n        end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n        frames_to_read = end_idx - start_idx\n\n        logger.debug(\n            f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n            f\"start_idx={start_idx}, end_idx={end_idx}\"\n        )\n\n        # Settings for lazy loading\n        expected_shape = (len(channels_to_load), frames_to_read)\n\n        # Define the loading function using the file reader\n        def _load_audio() -&gt; NDArrayReal:\n            logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n            # Use the reader to get audio data with parameters\n            out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n            if not isinstance(out, np.ndarray):\n                raise ValueError(\"Unexpected data type after reading file\")\n            return out\n\n        logger.debug(\n            f\"Creating delayed dask task with expected shape: {expected_shape}\"\n        )\n\n        # Create delayed operation\n        delayed_data = dask_delayed(_load_audio)()\n        logger.debug(\"Wrapping delayed function in dask array\")\n\n        # Create dask array from delayed computation\n        dask_array = da_from_delayed(\n            delayed_data, shape=expected_shape, dtype=np.float32\n        )\n\n        if chunk_size is not None:\n            if chunk_size &lt;= 0:\n                raise ValueError(\"Chunk size must be a positive integer\")\n            logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n            dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n        logger.debug(\n            \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n        )\n\n        cf = ChannelFrame(\n            data=dask_array,\n            sampling_rate=sr,\n            label=path.stem,\n            metadata={\n                \"filename\": str(path),\n            },\n        )\n        if ch_labels is not None:\n            if len(ch_labels) != len(cf):\n                raise ValueError(\n                    \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        return cf\n\n    @classmethod\n    def read_wav(\n        cls, filename: str, labels: Optional[list[str]] = None\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a WAV file.\n\n        Args:\n            filename: Path to the WAV file.\n            labels: Labels to set for each channel.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(filename, ch_labels=labels)\n        return cf\n\n    @classmethod\n    def read_csv(\n        cls,\n        filename: str,\n        time_column: Union[int, str] = 0,\n        labels: Optional[list[str]] = None,\n        delimiter: str = \",\",\n        header: Optional[int] = 0,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a CSV file.\n\n        Args:\n            filename: Path to the CSV file.\n            time_column: Index or name of the time column.\n            labels: Labels to set for each channel.\n            delimiter: Delimiter character.\n            header: Row number to use as header.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(\n            filename,\n            ch_labels=labels,\n            time_column=time_column,\n            delimiter=delimiter,\n            header=header,\n        )\n        return cf\n\n    def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n        \"\"\"Save the audio data to a file.\n\n        Args:\n            path: Path to save the file.\n            format: File format. If None, determined from file extension.\n        \"\"\"\n        logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n        data = self.compute()\n        data = data.T\n        if data.shape[1] == 1:\n            data = data.squeeze(axis=1)\n        sf.write(str(path), data, int(self.sampling_rate), format=format)\n        logger.debug(f\"Save complete: {path}\")\n\n    def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a high-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n\n    def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a low-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n\n    def normalize(\n        self, target_level: float = -20, channel_wise: bool = True\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Normalize the signal level.\n\n        This method adjusts the signal amplitude to reach a target RMS level.\n\n        Args:\n            target_level: Target RMS level in dB. Default is -20.\n            channel_wise: If True, normalize each channel independently.\n                If False, apply the same scaling to all channels.\n\n        Returns:\n            A new ChannelFrame containing the normalized signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n        )\n        return self.apply_operation(\n            \"normalize\", target_level=target_level, channel_wise=channel_wise\n        )\n\n    def a_weighting(self) -&gt; \"ChannelFrame\":\n        \"\"\"Apply A-weighting filter to the signal.\n\n        A-weighting adjusts the frequency response to approximate human hearing\n        perception, following IEC 61672-1:2013 standard.\n\n        Returns:\n            A new ChannelFrame with A-weighted signal.\n        \"\"\"\n        return self.apply_operation(\"a_weighting\")\n\n    def hpss_harmonic(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract harmonic components using HPSS\n         (Harmonic-Percussive Source Separation).\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_harmonic\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def hpss_percussive(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract percussive components using HPSS\n        (Harmonic-Percussive Source Separation).\n\n        This method separates the percussive (tonal) components from the signal.\n\n        Args:\n            kernel_size: Median filter size for HPSS.\n            power: Exponent for the Weiner filter used in HPSS.\n            margin: Margin size for the separation.\n\n        Returns:\n            A new ChannelFrame containing the harmonic components.\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_percussive\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def resampling(\n        self,\n        target_sr: float,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Resample audio data.\n\n        Parameters\n        ----------\n        target_sr : float\n            Target sampling rate (Hz)\n        resample_type : str, optional\n            Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n        **kwargs : dict\n            Additional resampling parameters\n\n        Returns\n        -------\n        ChannelFrame\n            Resampled channel frame\n        \"\"\"\n        return self.apply_operation(\n            \"resampling\",\n            target_sr=target_sr,\n            **kwargs,\n        )\n\n    def abs(self) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the absolute value of the signal.\n\n        Returns:\n            A new ChannelFrame containing the absolute values.\n        \"\"\"\n        return self.apply_operation(\"abs\")\n\n    def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the power of the signal.\n\n        Args:\n            exponent: The exponent to raise the signal to. Default is 2.0.\n\n        Returns:\n            A new ChannelFrame containing the signal raised to the power.\n        \"\"\"\n        return self.apply_operation(\"power\", exponent=exponent)\n\n    def trim(\n        self,\n        start: float = 0,\n        end: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Trim the signal to specified time range.\n\n        Args:\n            start: Start time in seconds.\n            end: End time in seconds.\n\n        Returns:\n            A new ChannelFrame with trimmed signal.\n\n        Raises:\n            ValueError: If end time is before start time.\n        \"\"\"\n        if end is None:\n            end = self.duration\n        if start &gt; end:\n            raise ValueError(\"start must be less than end\")\n        # Apply trim operation\n        return self.apply_operation(\"trim\", start=start, end=end)\n\n    def rms_trend(\n        self,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the RMS trend of the signal.\n\n        This method computes the root mean square value over sliding windows.\n\n        Args:\n            frame_length: The size of the sliding window in samples. Default is 2048.\n            hop_length: The hop length between windows in samples. Default is 512.\n            dB: Whether to return the RMS values in decibels. Default is False.\n            Aw: Whether to apply A-weighting. Default is False.\n\n        Returns:\n            A new ChannelFrame containing the RMS trend.\n        \"\"\"\n        cf = self.apply_operation(\n            \"rms_trend\",\n            frame_length=frame_length,\n            hop_length=hop_length,\n            ref=[ch.ref for ch in self._channel_metadata],\n            dB=dB,\n            Aw=Aw,\n        )\n        cf.sampling_rate = self.sampling_rate / hop_length\n        return cf\n\n    def sum(self) -&gt; \"ChannelFrame\":\n        \"\"\"Sum all channels.\n\n        Returns:\n            A new ChannelFrame with summed signal.\n        \"\"\"\n        return self.apply_operation(\"sum\")\n\n    def mean(self) -&gt; \"ChannelFrame\":\n        \"\"\"Average all channels.\n\n        Returns:\n            A new ChannelFrame with averaged signal.\n        \"\"\"\n        return self.apply_operation(\"mean\")\n\n    def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate channel differences relative to a reference channel.\n\n        Args:\n            other_channel: Reference channel index or label. Default is 0.\n\n        Returns:\n            A new ChannelFrame with channel differences.\n        \"\"\"\n        if isinstance(other_channel, str):\n            return self.apply_operation(\n                \"channel_difference\", other_channel=self.label2index(other_channel)\n            )\n        return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n\n    def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n        \"\"\"Compute Fast Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is next power of 2 of data length.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectralFrame containing the FFT results.\n        \"\"\"\n        from ..processing.time_series import FFT\n        from .spectral import SpectralFrame\n\n        params = {\"n_fft\": n_fft, \"window\": window}\n        operation_name = \"fft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"FFT\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        if n_fft is None:\n            is_even = spectrum_data.shape[-1] % 2 == 0\n            _n_fft = (\n                spectrum_data.shape[-1] * 2 - 2\n                if is_even\n                else spectrum_data.shape[-1] * 2 - 1\n            )\n        else:\n            _n_fft = n_fft\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=_n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def welch(\n        self,\n        n_fft: Optional[int] = None,\n        hop_length: Optional[int] = None,\n        win_length: int = 2048,\n        window: str = \"hann\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute power spectral density using Welch's method.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the power spectral density.\n        \"\"\"\n        from ..processing.time_series import Welch\n        from .spectral import SpectralFrame\n\n        params = dict(\n            n_fft=n_fft or win_length,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            average=average,\n        )\n        operation_name = \"welch\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Welch\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"welch\", \"params\": params},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def noct_spectrum(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"Compute N-octave band spectrum.\n\n        Args:\n            fmin: Minimum center frequency in Hz. Default is 20 Hz.\n            fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n            n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n            G: Reference gain in dB. Default is 10 dB.\n            fr: Reference frequency in Hz. Default is 1000 Hz.\n\n        Returns:\n            A NOctFrame containing the N-octave band spectrum.\n        \"\"\"\n        from ..processing.time_series import NOctSpectrum\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_spectrum\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSpectrum\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_spectrum\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def stft(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"Compute Short-Time Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectrogramFrame containing the STFT results.\n        \"\"\"\n        from ..processing.time_series import STFT, create_operation\n        from .spectrogram import SpectrogramFrame\n\n        # Set hop length and window length\n        _hop_length = hop_length if hop_length is not None else n_fft // 4\n        _win_length = win_length if win_length is not None else n_fft\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": _hop_length,\n            \"win_length\": _win_length,\n            \"window\": window,\n        }\n        operation_name = \"stft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"STFT\", operation)\n\n        # Apply processing to data\n        spectrogram_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n\n        # Create new instance\n        return SpectrogramFrame(\n            data=spectrogram_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=n_fft,\n            hop_length=_hop_length,\n            win_length=_win_length,\n            window=window,\n            label=f\"stft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def coherence(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute magnitude squared coherence.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n        Returns:\n            A SpectralFrame containing the magnitude squared coherence.\n        \"\"\"\n        from ..processing.time_series import Coherence, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n        }\n        operation_name = \"coherence\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Coherence\", operation)\n\n        # Apply processing to data\n        coherence_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=coherence_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Coherence of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def csd(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute cross-spectral density matrix.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the cross-spectral density matrix.\n        \"\"\"\n        from ..processing.time_series import CSD, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"csd\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"CSD\", operation)\n\n        # Apply processing to data\n        csd_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=csd_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def transfer_function(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute transfer function matrix.\n\n        The transfer function characterizes the signal transmission properties\n        between channels in the frequency domain, representing the input-output\n        relationship of a system.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the transfer function matrix.\n        \"\"\"\n        from ..processing.time_series import TransferFunction, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"transfer_function\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"TransferFunction\", operation)\n\n        # Apply processing to data\n        tf_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=tf_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Transfer function of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"Provide additional initialization arguments required for ChannelFrame.\"\"\"\n        return {}\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Returns the duration in seconds.</p>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>Returns the number of samples.</p>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.time","title":"<code>time</code>  <code>property</code>","text":"<p>Get time array for the signal.</p> <p>Returns:</p> Type Description <code>NDArrayReal</code> <p>Array of time points in seconds.</p>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.__init__","title":"<code>__init__(data, sampling_rate, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a ChannelFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>Dask array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate of the data in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>operation_history</code> <code>Optional[list[dict[str, Any]]]</code> <p>History of operations applied to the frame.</p> <code>None</code> <code>channel_metadata</code> <code>Optional[list[ChannelMetadata]]</code> <p>Metadata for each channel.</p> <code>None</code> <code>previous</code> <code>Optional[BaseFrame[Any]]</code> <p>Reference to the previous frame in the processing chain.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has more than 2 dimensions.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"Initialize a ChannelFrame.\n\n    Args:\n        data: Dask array containing channel data.\n        Shape should be (n_channels, n_samples).\n        sampling_rate: The sampling rate of the data in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        operation_history: History of operations applied to the frame.\n        channel_metadata: Metadata for each channel.\n        previous: Reference to the previous frame in the processing chain.\n\n    Raises:\n        ValueError: If data has more than 2 dimensions.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.a_weighting","title":"<code>a_weighting()</code>","text":"<p>Apply A-weighting filter to the signal.</p> <p>A-weighting adjusts the frequency response to approximate human hearing perception, following IEC 61672-1:2013 standard.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with A-weighted signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def a_weighting(self) -&gt; \"ChannelFrame\":\n    \"\"\"Apply A-weighting filter to the signal.\n\n    A-weighting adjusts the frequency response to approximate human hearing\n    perception, following IEC 61672-1:2013 standard.\n\n    Returns:\n        A new ChannelFrame with A-weighted signal.\n    \"\"\"\n    return self.apply_operation(\"a_weighting\")\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.abs","title":"<code>abs()</code>","text":"<p>Calculate the absolute value of the signal.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the absolute values.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def abs(self) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the absolute value of the signal.\n\n    Returns:\n        A new ChannelFrame containing the absolute values.\n    \"\"\"\n    return self.apply_operation(\"abs\")\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.add","title":"<code>add(other, snr=None)</code>","text":"<p>Add another signal or value to the current signal.</p> <p>If SNR is specified, performs addition with consideration for signal-to-noise ratio.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[ChannelFrame, int, float, NDArrayReal, Array]</code> <p>Signal or value to add.</p> required <code>snr</code> <code>Optional[float]</code> <p>Signal-to-noise ratio (dB). If specified, adjusts the scale of the other signal based on this SNR. self is treated as the signal, and other as the noise.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new channel frame containing the addition result (lazy execution).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def add(\n    self,\n    other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n    snr: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Add another signal or value to the current signal.\n\n    If SNR is specified, performs addition with consideration for\n    signal-to-noise ratio.\n\n    Args:\n        other: Signal or value to add.\n        snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n            other signal based on this SNR.\n            self is treated as the signal, and other as the noise.\n\n    Returns:\n        A new channel frame containing the addition result (lazy execution).\n    \"\"\"\n    logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n    # Special processing when SNR is specified\n    if snr is not None:\n        # First convert other to ChannelFrame if it's not\n        if not isinstance(other, ChannelFrame):\n            if isinstance(other, np.ndarray):\n                other = ChannelFrame.from_numpy(\n                    other, self.sampling_rate, label=\"array_data\"\n                )\n            elif isinstance(other, (int, float)):\n                # For scalar values, simply add (ignore SNR)\n                return self + other\n            else:\n                raise TypeError(\n                    \"Addition target with SNR must be a ChannelFrame or \"\n                    f\"NumPy array: {type(other)}\"\n                )\n\n        # Check if sampling rates match\n        if self.sampling_rate != other.sampling_rate:\n            raise ValueError(\n                \"Sampling rates do not match. Cannot perform operation.\"\n            )\n\n        # Apply addition operation with SNR adjustment\n        return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n    # Execute normal addition if SNR is not specified\n    return self + other\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.channel_difference","title":"<code>channel_difference(other_channel=0)</code>","text":"<p>Calculate channel differences relative to a reference channel.</p> <p>Parameters:</p> Name Type Description Default <code>other_channel</code> <code>Union[int, str]</code> <p>Reference channel index or label. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with channel differences.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate channel differences relative to a reference channel.\n\n    Args:\n        other_channel: Reference channel index or label. Default is 0.\n\n    Returns:\n        A new ChannelFrame with channel differences.\n    \"\"\"\n    if isinstance(other_channel, str):\n        return self.apply_operation(\n            \"channel_difference\", other_channel=self.label2index(other_channel)\n        )\n    return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.coherence","title":"<code>coherence(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant')</code>","text":"<p>Compute magnitude squared coherence.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the magnitude squared coherence.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def coherence(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute magnitude squared coherence.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n    Returns:\n        A SpectralFrame containing the magnitude squared coherence.\n    \"\"\"\n    from ..processing.time_series import Coherence, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n    }\n    operation_name = \"coherence\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Coherence\", operation)\n\n    # Apply processing to data\n    coherence_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=coherence_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Coherence of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.csd","title":"<code>csd(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute cross-spectral density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the cross-spectral density matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def csd(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute cross-spectral density matrix.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the cross-spectral density matrix.\n    \"\"\"\n    from ..processing.time_series import CSD, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"csd\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"CSD\", operation)\n\n    # Apply processing to data\n    csd_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=csd_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.describe","title":"<code>describe(normalize=True, **kwargs)</code>","text":"<p>Display visual and audio representation of the frame.</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>Whether to normalize the audio data for playback.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for visualization.</p> <code>{}</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n    \"\"\"Display visual and audio representation of the frame.\n\n    Args:\n        normalize: Whether to normalize the audio data for playback.\n        **kwargs: Additional parameters for visualization.\n    \"\"\"\n    if \"axis_config\" in kwargs:\n        logger.warning(\n            \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        axis_config = kwargs[\"axis_config\"]\n        if \"time_plot\" in axis_config:\n            kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n        if \"freq_plot\" in axis_config:\n            if \"xlim\" in axis_config[\"freq_plot\"]:\n                vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                kwargs[\"vmin\"] = vlim[0]\n                kwargs[\"vmax\"] = vlim[1]\n            if \"ylim\" in axis_config[\"freq_plot\"]:\n                ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                kwargs[\"ylim\"] = ylim\n\n    if \"cbar_config\" in kwargs:\n        logger.warning(\n            \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        cbar_config = kwargs[\"cbar_config\"]\n        if \"vmin\" in cbar_config:\n            kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n        if \"vmax\" in cbar_config:\n            kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n    for ch in self:\n        ax: Axes\n        _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n        if isinstance(_ax, Iterator):\n            ax = next(iter(_ax))\n        elif isinstance(_ax, Axes):\n            ax = _ax\n        else:\n            raise TypeError(\n                f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n            )\n        # Ignore type checks for display and Audio\n        display(ax.figure)  # type: ignore\n        plt.close(ax.figure)  # type: ignore\n        display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.fft","title":"<code>fft(n_fft=None, window='hann')</code>","text":"<p>Compute Fast Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is next power of 2 of data length.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the FFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n    \"\"\"Compute Fast Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is next power of 2 of data length.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectralFrame containing the FFT results.\n    \"\"\"\n    from ..processing.time_series import FFT\n    from .spectral import SpectralFrame\n\n    params = {\"n_fft\": n_fft, \"window\": window}\n    operation_name = \"fft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"FFT\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    if n_fft is None:\n        is_even = spectrum_data.shape[-1] % 2 == 0\n        _n_fft = (\n            spectrum_data.shape[-1] * 2 - 2\n            if is_even\n            else spectrum_data.shape[-1] * 2 - 1\n        )\n    else:\n        _n_fft = n_fft\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=_n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.from_file","title":"<code>from_file(path, channel=None, start=None, end=None, chunk_size=None, ch_labels=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from an audio file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the audio file.</p> required <code>channel</code> <code>Optional[Union[int, list[int]]]</code> <p>Channel(s) to load.</p> <code>None</code> <code>start</code> <code>Optional[float]</code> <p>Start time in seconds.</p> <code>None</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <code>chunk_size</code> <code>Optional[int]</code> <p>Chunk size for processing.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the file reader.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the loaded audio data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If channel selection is invalid.</p> <code>TypeError</code> <p>If channel parameter type is invalid.</p> <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    path: Union[str, Path],\n    channel: Optional[Union[int, list[int]]] = None,\n    start: Optional[float] = None,\n    end: Optional[float] = None,\n    chunk_size: Optional[int] = None,\n    ch_labels: Optional[list[str]] = None,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from an audio file.\n\n    Args:\n        path: Path to the audio file.\n        channel: Channel(s) to load.\n        start: Start time in seconds.\n        end: End time in seconds.\n        chunk_size: Chunk size for processing.\n        Specifies the splitting size for lazy processing.\n        ch_labels: Labels for each channel.\n        **kwargs: Additional arguments passed to the file reader.\n\n    Returns:\n        A new ChannelFrame containing the loaded audio data.\n\n    Raises:\n        ValueError: If channel selection is invalid.\n        TypeError: If channel parameter type is invalid.\n        FileNotFoundError: If the file doesn't exist.\n    \"\"\"\n    from .channel import ChannelFrame\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    # Get file reader\n    reader = get_file_reader(path)\n\n    # Get file info\n    info = reader.get_file_info(path, **kwargs)\n    sr = info[\"samplerate\"]\n    n_channels = info[\"channels\"]\n    n_frames = info[\"frames\"]\n    ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n    logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n    # Channel selection processing\n    all_channels = list(range(n_channels))\n\n    if channel is None:\n        channels_to_load = all_channels\n        logger.debug(f\"Will load all channels: {channels_to_load}\")\n    elif isinstance(channel, int):\n        if channel &lt; 0 or channel &gt;= n_channels:\n            raise ValueError(\n                f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n            )\n        channels_to_load = [channel]\n        logger.debug(f\"Will load single channel: {channel}\")\n    elif isinstance(channel, (list, tuple)):\n        for ch in channel:\n            if ch &lt; 0 or ch &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n        channels_to_load = list(channel)\n        logger.debug(f\"Will load specific channels: {channels_to_load}\")\n    else:\n        raise TypeError(\"channel must be int, list, or None\")\n\n    # Index calculation\n    start_idx = 0 if start is None else max(0, int(start * sr))\n    end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n    frames_to_read = end_idx - start_idx\n\n    logger.debug(\n        f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n        f\"start_idx={start_idx}, end_idx={end_idx}\"\n    )\n\n    # Settings for lazy loading\n    expected_shape = (len(channels_to_load), frames_to_read)\n\n    # Define the loading function using the file reader\n    def _load_audio() -&gt; NDArrayReal:\n        logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n        # Use the reader to get audio data with parameters\n        out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n        if not isinstance(out, np.ndarray):\n            raise ValueError(\"Unexpected data type after reading file\")\n        return out\n\n    logger.debug(\n        f\"Creating delayed dask task with expected shape: {expected_shape}\"\n    )\n\n    # Create delayed operation\n    delayed_data = dask_delayed(_load_audio)()\n    logger.debug(\"Wrapping delayed function in dask array\")\n\n    # Create dask array from delayed computation\n    dask_array = da_from_delayed(\n        delayed_data, shape=expected_shape, dtype=np.float32\n    )\n\n    if chunk_size is not None:\n        if chunk_size &lt;= 0:\n            raise ValueError(\"Chunk size must be a positive integer\")\n        logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n        dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n    logger.debug(\n        \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n    )\n\n    cf = ChannelFrame(\n        data=dask_array,\n        sampling_rate=sr,\n        label=path.stem,\n        metadata={\n            \"filename\": str(path),\n        },\n    )\n    if ch_labels is not None:\n        if len(ch_labels) != len(cf):\n            raise ValueError(\n                \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    return cf\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.from_ndarray","title":"<code>from_ndarray(array, sampling_rate, labels=None, unit=None, frame_label=None, metadata=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>This method is deprecated. Use from_numpy instead.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>NDArrayReal</code> <p>Signal data. Each row corresponds to a channel.</p> required <code>sampling_rate</code> <code>float</code> <p>Sampling rate (Hz).</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>unit</code> <code>Optional[Union[list[str], str]]</code> <p>Unit of the signal.</p> <code>None</code> <code>frame_label</code> <code>Optional[str]</code> <p>Label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_ndarray(\n    cls,\n    array: NDArrayReal,\n    sampling_rate: float,\n    labels: Optional[list[str]] = None,\n    unit: Optional[Union[list[str], str]] = None,\n    frame_label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    This method is deprecated. Use from_numpy instead.\n\n    Args:\n        array: Signal data. Each row corresponds to a channel.\n        sampling_rate: Sampling rate (Hz).\n        labels: Labels for each channel.\n        unit: Unit of the signal.\n        frame_label: Label for the frame.\n        metadata: Optional metadata dictionary.\n\n    Returns:\n        A new ChannelFrame containing the data.\n    \"\"\"\n    # Redirect to from_numpy for compatibility\n    # However, from_ndarray is deprecated\n    logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n    return cls.from_numpy(\n        data=array,\n        sampling_rate=sampling_rate,\n        label=frame_label,\n        metadata=metadata,\n        ch_labels=labels,\n        ch_units=unit,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.from_numpy","title":"<code>from_numpy(data, sampling_rate, label=None, metadata=None, ch_labels=None, ch_units=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArrayReal</code> <p>NumPy array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>ch_units</code> <code>Optional[Union[list[str], str]]</code> <p>Units for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the NumPy data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_numpy(\n    cls,\n    data: NDArrayReal,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    ch_labels: Optional[list[str]] = None,\n    ch_units: Optional[Union[list[str], str]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    Args:\n        data: NumPy array containing channel data.\n        sampling_rate: The sampling rate in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        ch_labels: Labels for each channel.\n        ch_units: Units for each channel.\n\n    Returns:\n        A new ChannelFrame containing the NumPy data.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n\n    # Convert NumPy array to dask array\n    dask_data = da_from_array(data)\n    cf = ChannelFrame(\n        data=dask_data,\n        sampling_rate=sampling_rate,\n        label=label or \"numpy_data\",\n    )\n    if metadata is not None:\n        cf.metadata = metadata\n    if ch_labels is not None:\n        if len(ch_labels) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel labels does not match the number of channels\"\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    if ch_units is not None:\n        if isinstance(ch_units, str):\n            ch_units = [ch_units] * cf.n_channels\n\n        if len(ch_units) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel units does not match the number of channels\"\n            )\n        for i in range(len(ch_units)):\n            cf._channel_metadata[i].unit = ch_units[i]\n\n    return cf\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.high_pass_filter","title":"<code>high_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a high-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a high-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.hpss_harmonic","title":"<code>hpss_harmonic(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract harmonic components using HPSS  (Harmonic-Percussive Source Separation).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_harmonic(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract harmonic components using HPSS\n     (Harmonic-Percussive Source Separation).\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_harmonic\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.hpss_percussive","title":"<code>hpss_percussive(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract percussive components using HPSS (Harmonic-Percussive Source Separation).</p> <p>This method separates the percussive (tonal) components from the signal.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Union[_IntLike_co, tuple[_IntLike_co, _IntLike_co], list[_IntLike_co]]</code> <p>Median filter size for HPSS.</p> <code>31</code> <code>power</code> <code>float</code> <p>Exponent for the Weiner filter used in HPSS.</p> <code>2</code> <code>margin</code> <code>Union[_FloatLike_co, tuple[_FloatLike_co, _FloatLike_co], list[_FloatLike_co]]</code> <p>Margin size for the separation.</p> <code>1</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the harmonic components.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_percussive(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract percussive components using HPSS\n    (Harmonic-Percussive Source Separation).\n\n    This method separates the percussive (tonal) components from the signal.\n\n    Args:\n        kernel_size: Median filter size for HPSS.\n        power: Exponent for the Weiner filter used in HPSS.\n        margin: Margin size for the separation.\n\n    Returns:\n        A new ChannelFrame containing the harmonic components.\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_percussive\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.low_pass_filter","title":"<code>low_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a low-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a low-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.mean","title":"<code>mean()</code>","text":"<p>Average all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with averaged signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def mean(self) -&gt; \"ChannelFrame\":\n    \"\"\"Average all channels.\n\n    Returns:\n        A new ChannelFrame with averaged signal.\n    \"\"\"\n    return self.apply_operation(\"mean\")\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.noct_spectrum","title":"<code>noct_spectrum(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Compute N-octave band spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>fmin</code> <code>float</code> <p>Minimum center frequency in Hz. Default is 20 Hz.</p> required <code>fmax</code> <code>float</code> <p>Maximum center frequency in Hz. Default is 20000 Hz.</p> required <code>n</code> <code>int</code> <p>Band division (1 for octave, 3 for 1/3 octave). Default is 3.</p> <code>3</code> <code>G</code> <code>int</code> <p>Reference gain in dB. Default is 10 dB.</p> <code>10</code> <code>fr</code> <code>int</code> <p>Reference frequency in Hz. Default is 1000 Hz.</p> <code>1000</code> <p>Returns:</p> Type Description <code>NOctFrame</code> <p>A NOctFrame containing the N-octave band spectrum.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def noct_spectrum(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"Compute N-octave band spectrum.\n\n    Args:\n        fmin: Minimum center frequency in Hz. Default is 20 Hz.\n        fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n        n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n        G: Reference gain in dB. Default is 10 dB.\n        fr: Reference frequency in Hz. Default is 1000 Hz.\n\n    Returns:\n        A NOctFrame containing the N-octave band spectrum.\n    \"\"\"\n    from ..processing.time_series import NOctSpectrum\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_spectrum\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSpectrum\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_spectrum\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.normalize","title":"<code>normalize(target_level=-20, channel_wise=True)</code>","text":"<p>Normalize the signal level.</p> <p>This method adjusts the signal amplitude to reach a target RMS level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target RMS level in dB. Default is -20.</p> <code>-20</code> <code>channel_wise</code> <code>bool</code> <p>If True, normalize each channel independently. If False, apply the same scaling to all channels.</p> <code>True</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the normalized signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def normalize(\n    self, target_level: float = -20, channel_wise: bool = True\n) -&gt; \"ChannelFrame\":\n    \"\"\"Normalize the signal level.\n\n    This method adjusts the signal amplitude to reach a target RMS level.\n\n    Args:\n        target_level: Target RMS level in dB. Default is -20.\n        channel_wise: If True, normalize each channel independently.\n            If False, apply the same scaling to all channels.\n\n    Returns:\n        A new ChannelFrame containing the normalized signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n    )\n    return self.apply_operation(\n        \"normalize\", target_level=target_level, channel_wise=channel_wise\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.plot","title":"<code>plot(plot_type='waveform', ax=None, **kwargs)</code>","text":"<p>Plot the frame data.</p> <p>Parameters:</p> Name Type Description Default <code>plot_type</code> <code>str</code> <p>Type of plot. Default is \"waveform\".</p> <code>'waveform'</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def plot(\n    self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Plot the frame data.\n\n    Args:\n        plot_type: Type of plot. Default is \"waveform\".\n        ax: Optional matplotlib axes for plotting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    plot_strategy = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.power","title":"<code>power(exponent=2.0)</code>","text":"<p>Calculate the power of the signal.</p> <p>Parameters:</p> Name Type Description Default <code>exponent</code> <code>float</code> <p>The exponent to raise the signal to. Default is 2.0.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the signal raised to the power.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the power of the signal.\n\n    Args:\n        exponent: The exponent to raise the signal to. Default is 2.0.\n\n    Returns:\n        A new ChannelFrame containing the signal raised to the power.\n    \"\"\"\n    return self.apply_operation(\"power\", exponent=exponent)\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.read_csv","title":"<code>read_csv(filename, time_column=0, labels=None, delimiter=',', header=0)</code>  <code>classmethod</code>","text":"<p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.read_wav","title":"<code>read_wav(filename, labels=None)</code>  <code>classmethod</code>","text":"<p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.resampling","title":"<code>resampling(target_sr, **kwargs)</code>","text":"<p>Resample audio data.</p>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.resampling--parameters","title":"Parameters","text":"<p>target_sr : float     Target sampling rate (Hz) resample_type : str, optional     Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.) **kwargs : dict     Additional resampling parameters</p>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.resampling--returns","title":"Returns","text":"<p>ChannelFrame     Resampled channel frame</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def resampling(\n    self,\n    target_sr: float,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Resample audio data.\n\n    Parameters\n    ----------\n    target_sr : float\n        Target sampling rate (Hz)\n    resample_type : str, optional\n        Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n    **kwargs : dict\n        Additional resampling parameters\n\n    Returns\n    -------\n    ChannelFrame\n        Resampled channel frame\n    \"\"\"\n    return self.apply_operation(\n        \"resampling\",\n        target_sr=target_sr,\n        **kwargs,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.rms_plot","title":"<code>rms_plot(ax=None, title=None, overlay=True, Aw=False, **kwargs)</code>","text":"<p>Generate an RMS plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title for the plot.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay the plot on the existing axis.</p> <code>True</code> <code>Aw</code> <code>bool</code> <p>Apply A-weighting.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_plot(\n    self,\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = True,\n    Aw: bool = False,  # noqa: N803\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Generate an RMS plot.\n\n    Args:\n        ax: Optional matplotlib axes for plotting.\n        title: Title for the plot.\n        overlay: Whether to overlay the plot on the existing axis.\n        Aw: Apply A-weighting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    kwargs = kwargs or {}\n    ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n    rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n    return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.rms_trend","title":"<code>rms_trend(frame_length=2048, hop_length=512, dB=False, Aw=False)</code>","text":"<p>Calculate the RMS trend of the signal.</p> <p>This method computes the root mean square value over sliding windows.</p> <p>Parameters:</p> Name Type Description Default <code>frame_length</code> <code>int</code> <p>The size of the sliding window in samples. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>int</code> <p>The hop length between windows in samples. Default is 512.</p> <code>512</code> <code>dB</code> <code>bool</code> <p>Whether to return the RMS values in decibels. Default is False.</p> <code>False</code> <code>Aw</code> <code>bool</code> <p>Whether to apply A-weighting. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the RMS trend.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_trend(\n    self,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the RMS trend of the signal.\n\n    This method computes the root mean square value over sliding windows.\n\n    Args:\n        frame_length: The size of the sliding window in samples. Default is 2048.\n        hop_length: The hop length between windows in samples. Default is 512.\n        dB: Whether to return the RMS values in decibels. Default is False.\n        Aw: Whether to apply A-weighting. Default is False.\n\n    Returns:\n        A new ChannelFrame containing the RMS trend.\n    \"\"\"\n    cf = self.apply_operation(\n        \"rms_trend\",\n        frame_length=frame_length,\n        hop_length=hop_length,\n        ref=[ch.ref for ch in self._channel_metadata],\n        dB=dB,\n        Aw=Aw,\n    )\n    cf.sampling_rate = self.sampling_rate / hop_length\n    return cf\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.save","title":"<code>save(path, format=None)</code>","text":"<p>Save the audio data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n    data = self.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    sf.write(str(path), data, int(self.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {path}\")\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.stft","title":"<code>stft(n_fft=2048, hop_length=None, win_length=None, window='hann')</code>","text":"<p>Compute Short-Time Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectrogramFrame</code> <p>A SpectrogramFrame containing the STFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def stft(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n) -&gt; \"SpectrogramFrame\":\n    \"\"\"Compute Short-Time Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectrogramFrame containing the STFT results.\n    \"\"\"\n    from ..processing.time_series import STFT, create_operation\n    from .spectrogram import SpectrogramFrame\n\n    # Set hop length and window length\n    _hop_length = hop_length if hop_length is not None else n_fft // 4\n    _win_length = win_length if win_length is not None else n_fft\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": _hop_length,\n        \"win_length\": _win_length,\n        \"window\": window,\n    }\n    operation_name = \"stft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"STFT\", operation)\n\n    # Apply processing to data\n    spectrogram_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n\n    # Create new instance\n    return SpectrogramFrame(\n        data=spectrogram_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=n_fft,\n        hop_length=_hop_length,\n        win_length=_win_length,\n        window=window,\n        label=f\"stft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.sum","title":"<code>sum()</code>","text":"<p>Sum all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with summed signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def sum(self) -&gt; \"ChannelFrame\":\n    \"\"\"Sum all channels.\n\n    Returns:\n        A new ChannelFrame with summed signal.\n    \"\"\"\n    return self.apply_operation(\"sum\")\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.transfer_function","title":"<code>transfer_function(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute transfer function matrix.</p> <p>The transfer function characterizes the signal transmission properties between channels in the frequency domain, representing the input-output relationship of a system.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the transfer function matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def transfer_function(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute transfer function matrix.\n\n    The transfer function characterizes the signal transmission properties\n    between channels in the frequency domain, representing the input-output\n    relationship of a system.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the transfer function matrix.\n    \"\"\"\n    from ..processing.time_series import TransferFunction, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"transfer_function\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"TransferFunction\", operation)\n\n    # Apply processing to data\n    tf_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=tf_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Transfer function of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.trim","title":"<code>trim(start=0, end=None)</code>","text":"<p>Trim the signal to specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>Start time in seconds.</p> <code>0</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with trimmed signal.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If end time is before start time.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def trim(\n    self,\n    start: float = 0,\n    end: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Trim the signal to specified time range.\n\n    Args:\n        start: Start time in seconds.\n        end: End time in seconds.\n\n    Returns:\n        A new ChannelFrame with trimmed signal.\n\n    Raises:\n        ValueError: If end time is before start time.\n    \"\"\"\n    if end is None:\n        end = self.duration\n    if start &gt; end:\n        raise ValueError(\"start must be less than end\")\n    # Apply trim operation\n    return self.apply_operation(\"trim\", start=start, end=end)\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.welch","title":"<code>welch(n_fft=None, hop_length=None, win_length=2048, window='hann', average='mean')</code>","text":"<p>Compute power spectral density using Welch's method.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is 2048.</p> <code>None</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>int</code> <p>Length of window. Default is n_fft.</p> <code>2048</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the power spectral density.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def welch(\n    self,\n    n_fft: Optional[int] = None,\n    hop_length: Optional[int] = None,\n    win_length: int = 2048,\n    window: str = \"hann\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute power spectral density using Welch's method.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the power spectral density.\n    \"\"\"\n    from ..processing.time_series import Welch\n    from .spectral import SpectralFrame\n\n    params = dict(\n        n_fft=n_fft or win_length,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        average=average,\n    )\n    operation_name = \"welch\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Welch\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"welch\", \"params\": params},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/frames/#spectralframe","title":"SpectralFrame","text":"<p><code>SpectralFrame</code>\u306f\u5468\u6ce2\u6570\u9818\u57df\u306e\u30c7\u30fc\u30bf\u3092\u6271\u3046\u30d5\u30ec\u30fc\u30e0\u3067\u3059\u3002</p> <pre><code>from wandas.frames.spectral import SpectralFrame\n\n# \u307e\u305f\u306f ChannelFrame\u304b\u3089\u5909\u63db\nchannel_frame = wandas.read_wav(\"audio.wav\")\nspectral_frame = channel_frame.to_spectral()\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayComplex]</code></p> <p>Class for handling frequency-domain signal data.</p> <p>This class represents spectral data, providing methods for spectral analysis, manipulation, and visualization. It handles complex-valued frequency domain data obtained through operations like FFT.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The spectral data. Must be a dask array with shape:     - (channels, frequency_bins) for multi-channel data     - (frequency_bins,) for single-channel data, which will be       reshaped to (1, frequency_bins) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. n_fft : int     The FFT size used to generate this spectral data. window : str, default=\"hann\"     The window function used in the FFT. label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame--attributes","title":"Attributes","text":"<p>magnitude : NDArrayReal     The magnitude spectrum of the data. phase : NDArrayReal     The phase spectrum in radians. power : NDArrayReal     The power spectrum (magnitude squared). dB : NDArrayReal     The spectrum in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrum in decibels. freqs : NDArrayReal     The frequency axis values in Hz.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame--examples","title":"Examples","text":"<p>Create a SpectralFrame from FFT:</p> <p>signal = ChannelFrame.from_numpy(data, sampling_rate=44100) spectrum = signal.fft(n_fft=2048)</p> <p>Plot the magnitude spectrum:</p> <p>spectrum.plot()</p> <p>Perform binary operations:</p> <p>scaled = spectrum * 2.0 summed = spectrum1 + spectrum2  # Must have matching sampling rates</p> <p>Convert back to time domain:</p> <p>time_signal = spectrum.ifft()</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame--notes","title":"Notes","text":"<ul> <li>All operations are performed lazily using dask arrays for efficient memory usage.</li> <li>Binary operations (+, -, *, /) can be performed between SpectralFrames or with   scalar values.</li> <li>The class maintains the processing history and metadata through all operations.</li> </ul> Source code in <code>wandas/frames/spectral.py</code> <pre><code>class SpectralFrame(BaseFrame[NDArrayComplex]):\n    \"\"\"\n    Class for handling frequency-domain signal data.\n\n    This class represents spectral data, providing methods for spectral analysis,\n    manipulation, and visualization. It handles complex-valued frequency domain data\n    obtained through operations like FFT.\n\n    Parameters\n    ----------\n    data : DaArray\n        The spectral data. Must be a dask array with shape:\n        - (channels, frequency_bins) for multi-channel data\n        - (frequency_bins,) for single-channel data, which will be\n          reshaped to (1, frequency_bins)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    n_fft : int\n        The FFT size used to generate this spectral data.\n    window : str, default=\"hann\"\n        The window function used in the FFT.\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    magnitude : NDArrayReal\n        The magnitude spectrum of the data.\n    phase : NDArrayReal\n        The phase spectrum in radians.\n    power : NDArrayReal\n        The power spectrum (magnitude squared).\n    dB : NDArrayReal\n        The spectrum in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrum in decibels.\n    freqs : NDArrayReal\n        The frequency axis values in Hz.\n\n    Examples\n    --------\n    Create a SpectralFrame from FFT:\n    &gt;&gt;&gt; signal = ChannelFrame.from_numpy(data, sampling_rate=44100)\n    &gt;&gt;&gt; spectrum = signal.fft(n_fft=2048)\n\n    Plot the magnitude spectrum:\n    &gt;&gt;&gt; spectrum.plot()\n\n    Perform binary operations:\n    &gt;&gt;&gt; scaled = spectrum * 2.0\n    &gt;&gt;&gt; summed = spectrum1 + spectrum2  # Must have matching sampling rates\n\n    Convert back to time domain:\n    &gt;&gt;&gt; time_signal = spectrum.ifft()\n\n    Notes\n    -----\n    - All operations are performed lazily using dask arrays for efficient memory usage.\n    - Binary operations (+, -, *, /) can be performed between SpectralFrames or with\n      scalar values.\n    - The class maintains the processing history and metadata through all operations.\n    \"\"\"\n\n    n_fft: int\n    window: str\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        n_fft: int,\n        window: str = \"hann\",\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306f1\u6b21\u5143\u307e\u305f\u306f2\u6b21\u5143\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u5f62\u72b6: {data.shape}\"\n            )\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def magnitude(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the magnitude spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The absolute values of the complex spectrum.\n        \"\"\"\n        return np.abs(self.data)\n\n    @property\n    def phase(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the phase spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The phase angles of the complex spectrum in radians.\n        \"\"\"\n        return np.angle(self.data)\n\n    @property\n    def power(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the power spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The squared magnitude spectrum.\n        \"\"\"\n        return self.magnitude**2\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrum in decibels.\n\n        The reference values are taken from channel metadata. If no reference\n        is specified, uses 1.0.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrum in dB relative to channel references.\n        \"\"\"\n        mag: NDArrayReal = self.magnitude\n        ref_values: NDArrayReal = np.array([ch.ref for ch in self._channel_metadata])\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(mag / ref_values[:, np.newaxis], 1e-12)\n        )\n\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrum in decibels.\n\n        Applies A-weighting filter to the spectrum for better correlation with\n        perceived loudness.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrum in dB.\n        \"\"\"\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels.\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the frequency axis values in Hz.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of frequency values corresponding to each frequency bin.\n        \"\"\"\n        return np.fft.rfftfreq(self.n_fft, 1.0 / self.sampling_rate)\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Implementation of operation application for spectral data.\n\n        This internal method handles the application of various operations to\n        spectral data, maintaining lazy evaluation through dask.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters for the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        processed_data = operation.process(self._data)\n\n        # \u30e1\u30bf\u30c7\u30fc\u30bf\u66f4\u65b0\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\n            \"SpectralFrame\", int, float, complex, NDArrayComplex, NDArrayReal, \"DaArray\"\n        ],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"\n        Common implementation for binary operations.\n\n        This method handles binary operations between SpectralFrames and various types\n        of operands, maintaining lazy evaluation through dask arrays.\n\n        Parameters\n        ----------\n        other : Union[SpectralFrame, int, float, complex,\n                        NDArrayComplex, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation (e.g., lambda a, b: a + b)\n        symbol : str\n            String representation of the operation (e.g., '+')\n\n        Returns\n        -------\n        SpectralFrame\n            A new SpectralFrame containing the result of the operation.\n\n        Raises\n        ------\n        ValueError\n            If attempting to operate with a SpectralFrame\n            with a different sampling rate.\n        \"\"\"\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, SpectralFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u304c\u4e00\u81f4\u3057\u3066\u3044\u307e\u305b\u3093\u3002\u6f14\u7b97\u3067\u304d\u307e\u305b\u3093\u3002\"\n                )\n\n            # dask array\u3092\u76f4\u63a5\u6f14\u7b97\uff08\u9045\u5ef6\u5b9f\u884c\u3092\u7dad\u6301\uff09\n            result_data = op(self._data, other._data)\n\n            # \u30c1\u30e3\u30cd\u30eb\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u7d50\u5408\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return SpectralFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # \u30b9\u30ab\u30e9\u30fc\u3001NumPy\u914d\u5217\u3001\u307e\u305f\u306f\u4ed6\u306e\u30bf\u30a4\u30d7\u3068\u306e\u6f14\u7b97\n        else:\n            # dask array\u306b\u76f4\u63a5\u6f14\u7b97\u3092\u9069\u7528\uff08\u9045\u5ef6\u5b9f\u884c\u3092\u7dad\u6301\uff09\n            result_data = op(self._data, other)\n\n            # \u30aa\u30da\u30e9\u30f3\u30c9\u306e\u8868\u793a\u7528\u6587\u5b57\u5217\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, complex):\n                other_str = f\"complex({other.real}, {other.imag})\"\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # dask.array.Array\u306e\u30c1\u30a7\u30c3\u30af\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # \u30c1\u30e3\u30cd\u30eb\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u66f4\u65b0\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return SpectralFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n            )\n\n    def plot(\n        self,\n        plot_type: str = \"frequency\",\n        ax: Optional[\"Axes\"] = None,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the spectral data using various visualization strategies.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"frequency\"\n            Type of plot to create. Options include:\n            - \"frequency\": Standard frequency plot\n            - \"matrix\": Matrix plot for comparing channels\n            - Other types as defined by available plot strategies\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - title: Plot title\n            - xlabel, ylabel: Axis labels\n            - vmin, vmax: Value limits for plots\n            - cmap: Colormap name\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def ifft(self) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.\n\n        This method transforms the frequency-domain data back to the time domain using\n        the inverse FFT operation. The window function used in the forward FFT is\n        taken into account to ensure proper reconstruction.\n\n        Returns\n        -------\n        ChannelFrame\n            A new ChannelFrame containing the time-domain signal.\n        \"\"\"\n        from ..processing.time_series import IFFT, create_operation\n        from .channel import ChannelFrame\n\n        params = {\"n_fft\": self.n_fft, \"window\": self.window}\n        operation_name = \"ifft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"IFFT\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        time_series = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        return ChannelFrame(\n            data=time_series,\n            sampling_rate=self.sampling_rate,\n            label=f\"ifft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        SpectralFrame \u306b\u5fc5\u8981\u306a\u8ffd\u52a0\u306e\u521d\u671f\u5316\u5f15\u6570\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments for SpectralFrame.\n        \"\"\"\n        return {\n            \"n_fft\": self.n_fft,\n            \"window\": self.window,\n        }\n\n    def noct_synthesis(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"\n        Synthesize N-octave band spectrum.\n\n        This method combines frequency components into N-octave bands according to\n        standard acoustical band definitions. This is commonly used in noise and\n        vibration analysis.\n\n        Parameters\n        ----------\n        fmin : float\n            Lower frequency bound in Hz.\n        fmax : float\n            Upper frequency bound in Hz.\n        n : int, default=3\n            Number of bands per octave (e.g., 3 for third-octave bands).\n        G : int, default=10\n            Reference band number.\n        fr : int, default=1000\n            Reference frequency in Hz.\n\n        Returns\n        -------\n        NOctFrame\n            A new NOctFrame containing the N-octave band spectrum.\n\n        Raises\n        ------\n        ValueError\n            If the sampling rate is not 48000 Hz, which is required for this operation.\n        \"\"\"\n        if self.sampling_rate != 48000:\n            raise ValueError(\n                \"noct_synthesis\u306f48000Hz\u306e\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u3067\u306e\u307f\u4f7f\u7528\u3067\u304d\u307e\u3059\u3002\"\n            )\n        from ..processing.time_series import NOctSynthesis\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_synthesis\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSynthesis\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_synthesis\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def plot_matrix(\n        self,\n        plot_type: str = \"matrix\",\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot channel relationships in matrix format.\n\n        This method creates a matrix plot showing relationships between channels,\n        such as coherence, transfer functions, or cross-spectral density.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"matrix\"\n            Type of matrix plot to create.\n        **kwargs : dict\n            Additional plot parameters:\n            - vmin, vmax: Color scale limits\n            - cmap: Colormap name\n            - title: Plot title\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrum in decibels.</p> <p>The reference values are taken from channel metadata. If no reference is specified, uses 1.0.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrum in dB relative to channel references.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrum in decibels.</p> <p>Applies A-weighting filter to the spectrum for better correlation with perceived loudness.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrum in dB.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the frequency axis values in Hz.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of frequency values corresponding to each frequency bin.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.magnitude","title":"<code>magnitude</code>  <code>property</code>","text":"<p>Get the magnitude spectrum.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.magnitude--returns","title":"Returns","text":"<p>NDArrayReal     The absolute values of the complex spectrum.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.phase","title":"<code>phase</code>  <code>property</code>","text":"<p>Get the phase spectrum.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.phase--returns","title":"Returns","text":"<p>NDArrayReal     The phase angles of the complex spectrum in radians.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.power","title":"<code>power</code>  <code>property</code>","text":"<p>Get the power spectrum.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.power--returns","title":"Returns","text":"<p>NDArrayReal     The squared magnitude spectrum.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.ifft","title":"<code>ifft()</code>","text":"<p>Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.</p> <p>This method transforms the frequency-domain data back to the time domain using the inverse FFT operation. The window function used in the forward FFT is taken into account to ensure proper reconstruction.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.ifft--returns","title":"Returns","text":"<p>ChannelFrame     A new ChannelFrame containing the time-domain signal.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def ifft(self) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.\n\n    This method transforms the frequency-domain data back to the time domain using\n    the inverse FFT operation. The window function used in the forward FFT is\n    taken into account to ensure proper reconstruction.\n\n    Returns\n    -------\n    ChannelFrame\n        A new ChannelFrame containing the time-domain signal.\n    \"\"\"\n    from ..processing.time_series import IFFT, create_operation\n    from .channel import ChannelFrame\n\n    params = {\"n_fft\": self.n_fft, \"window\": self.window}\n    operation_name = \"ifft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"IFFT\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    time_series = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    return ChannelFrame(\n        data=time_series,\n        sampling_rate=self.sampling_rate,\n        label=f\"ifft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis","title":"<code>noct_synthesis(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Synthesize N-octave band spectrum.</p> <p>This method combines frequency components into N-octave bands according to standard acoustical band definitions. This is commonly used in noise and vibration analysis.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--parameters","title":"Parameters","text":"<p>fmin : float     Lower frequency bound in Hz. fmax : float     Upper frequency bound in Hz. n : int, default=3     Number of bands per octave (e.g., 3 for third-octave bands). G : int, default=10     Reference band number. fr : int, default=1000     Reference frequency in Hz.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--returns","title":"Returns","text":"<p>NOctFrame     A new NOctFrame containing the N-octave band spectrum.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--raises","title":"Raises","text":"<p>ValueError     If the sampling rate is not 48000 Hz, which is required for this operation.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def noct_synthesis(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"\n    Synthesize N-octave band spectrum.\n\n    This method combines frequency components into N-octave bands according to\n    standard acoustical band definitions. This is commonly used in noise and\n    vibration analysis.\n\n    Parameters\n    ----------\n    fmin : float\n        Lower frequency bound in Hz.\n    fmax : float\n        Upper frequency bound in Hz.\n    n : int, default=3\n        Number of bands per octave (e.g., 3 for third-octave bands).\n    G : int, default=10\n        Reference band number.\n    fr : int, default=1000\n        Reference frequency in Hz.\n\n    Returns\n    -------\n    NOctFrame\n        A new NOctFrame containing the N-octave band spectrum.\n\n    Raises\n    ------\n    ValueError\n        If the sampling rate is not 48000 Hz, which is required for this operation.\n    \"\"\"\n    if self.sampling_rate != 48000:\n        raise ValueError(\n            \"noct_synthesis\u306f48000Hz\u306e\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u3067\u306e\u307f\u4f7f\u7528\u3067\u304d\u307e\u3059\u3002\"\n        )\n    from ..processing.time_series import NOctSynthesis\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_synthesis\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSynthesis\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_synthesis\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.plot","title":"<code>plot(plot_type='frequency', ax=None, **kwargs)</code>","text":"<p>Plot the spectral data using various visualization strategies.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"frequency\"     Type of plot to create. Options include:     - \"frequency\": Standard frequency plot     - \"matrix\": Matrix plot for comparing channels     - Other types as defined by available plot strategies ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - title: Plot title     - xlabel, ylabel: Axis labels     - vmin, vmax: Value limits for plots     - cmap: Colormap name     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def plot(\n    self,\n    plot_type: str = \"frequency\",\n    ax: Optional[\"Axes\"] = None,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the spectral data using various visualization strategies.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"frequency\"\n        Type of plot to create. Options include:\n        - \"frequency\": Standard frequency plot\n        - \"matrix\": Matrix plot for comparing channels\n        - Other types as defined by available plot strategies\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - title: Plot title\n        - xlabel, ylabel: Axis labels\n        - vmin, vmax: Value limits for plots\n        - cmap: Colormap name\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix","title":"<code>plot_matrix(plot_type='matrix', **kwargs)</code>","text":"<p>Plot channel relationships in matrix format.</p> <p>This method creates a matrix plot showing relationships between channels, such as coherence, transfer functions, or cross-spectral density.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"matrix\"     Type of matrix plot to create. **kwargs : dict     Additional plot parameters:     - vmin, vmax: Color scale limits     - cmap: Colormap name     - title: Plot title</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def plot_matrix(\n    self,\n    plot_type: str = \"matrix\",\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot channel relationships in matrix format.\n\n    This method creates a matrix plot showing relationships between channels,\n    such as coherence, transfer functions, or cross-spectral density.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"matrix\"\n        Type of matrix plot to create.\n    **kwargs : dict\n        Additional plot parameters:\n        - vmin, vmax: Color scale limits\n        - cmap: Colormap name\n        - title: Plot title\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"ja/api/frames/#spectrogramframe","title":"SpectrogramFrame","text":"<p><code>SpectrogramFrame</code>\u306f\u6642\u9593\u5468\u6ce2\u6570\u8868\u73fe\uff08\u30b9\u30da\u30af\u30c8\u30ed\u30b0\u30e9\u30e0\uff09\u306e\u30c7\u30fc\u30bf\u3092\u6271\u3046\u30d5\u30ec\u30fc\u30e0\u3067\u3059\u3002</p> <pre><code>from wandas.frames.spectrogram import SpectrogramFrame\n\n# \u307e\u305f\u306f ChannelFrame\u304b\u3089\u5909\u63db\nchannel_frame = wandas.read_wav(\"audio.wav\")\nspectrogram_frame = channel_frame.to_spectrogram()\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayComplex]</code></p> <p>Class for handling time-frequency domain data (spectrograms).</p> <p>This class represents spectrogram data obtained through Short-Time Fourier Transform (STFT) or similar time-frequency analysis methods. It provides methods for visualization, manipulation, and conversion back to time domain.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The spectrogram data. Must be a dask array with shape:     - (channels, frequency_bins, time_frames) for multi-channel data     - (frequency_bins, time_frames) for single-channel data, which will be       reshaped to (1, frequency_bins, time_frames) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. n_fft : int     The FFT size used to generate this spectrogram. hop_length : int     Number of samples between successive frames. win_length : int, optional     The window length in samples. If None, defaults to n_fft. window : str, default=\"hann\"     The window function to use (e.g., \"hann\", \"hamming\", \"blackman\"). label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame--attributes","title":"Attributes","text":"<p>magnitude : NDArrayReal     The magnitude spectrogram. phase : NDArrayReal     The phase spectrogram in radians. power : NDArrayReal     The power spectrogram. dB : NDArrayReal     The spectrogram in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrogram in decibels. n_frames : int     Number of time frames. n_freq_bins : int     Number of frequency bins. freqs : NDArrayReal     The frequency axis values in Hz. times : NDArrayReal     The time axis values in seconds.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame--examples","title":"Examples","text":"<p>Create a spectrogram from a time-domain signal:</p> <p>signal = ChannelFrame.from_wav(\"audio.wav\") spectrogram = signal.stft(n_fft=2048, hop_length=512)</p> <p>Extract a specific time frame:</p> <p>frame_at_1s = spectrogram.get_frame_at(int(1.0 * sampling_rate / hop_length))</p> <p>Convert back to time domain:</p> <p>reconstructed = spectrogram.to_channel_frame()</p> <p>Plot the spectrogram:</p> <p>spectrogram.plot()</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>class SpectrogramFrame(BaseFrame[NDArrayComplex]):\n    \"\"\"\n    Class for handling time-frequency domain data (spectrograms).\n\n    This class represents spectrogram data obtained through\n    Short-Time Fourier Transform (STFT)\n    or similar time-frequency analysis methods. It provides methods for visualization,\n    manipulation, and conversion back to time domain.\n\n    Parameters\n    ----------\n    data : DaArray\n        The spectrogram data. Must be a dask array with shape:\n        - (channels, frequency_bins, time_frames) for multi-channel data\n        - (frequency_bins, time_frames) for single-channel data, which will be\n          reshaped to (1, frequency_bins, time_frames)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    n_fft : int\n        The FFT size used to generate this spectrogram.\n    hop_length : int\n        Number of samples between successive frames.\n    win_length : int, optional\n        The window length in samples. If None, defaults to n_fft.\n    window : str, default=\"hann\"\n        The window function to use (e.g., \"hann\", \"hamming\", \"blackman\").\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    magnitude : NDArrayReal\n        The magnitude spectrogram.\n    phase : NDArrayReal\n        The phase spectrogram in radians.\n    power : NDArrayReal\n        The power spectrogram.\n    dB : NDArrayReal\n        The spectrogram in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrogram in decibels.\n    n_frames : int\n        Number of time frames.\n    n_freq_bins : int\n        Number of frequency bins.\n    freqs : NDArrayReal\n        The frequency axis values in Hz.\n    times : NDArrayReal\n        The time axis values in seconds.\n\n    Examples\n    --------\n    Create a spectrogram from a time-domain signal:\n    &gt;&gt;&gt; signal = ChannelFrame.from_wav(\"audio.wav\")\n    &gt;&gt;&gt; spectrogram = signal.stft(n_fft=2048, hop_length=512)\n\n    Extract a specific time frame:\n    &gt;&gt;&gt; frame_at_1s = spectrogram.get_frame_at(int(1.0 * sampling_rate / hop_length))\n\n    Convert back to time domain:\n    &gt;&gt;&gt; reconstructed = spectrogram.to_channel_frame()\n\n    Plot the spectrogram:\n    &gt;&gt;&gt; spectrogram.plot()\n    \"\"\"\n\n    n_fft: int\n    hop_length: int\n    win_length: int\n    window: str\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        if data.ndim == 2:\n            data = da.expand_dims(data, axis=0)  # type: ignore [unused-ignore]\n        elif data.ndim != 3:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306f2\u6b21\u5143\u307e\u305f\u306f3\u6b21\u5143\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u5f62\u72b6: {data.shape}\"\n            )\n        if not data.shape[-2] == n_fft // 2 + 1:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u304c\u7121\u52b9\u3067\u3059\u3002\u5468\u6ce2\u6570\u30d3\u30f3\u6570\u306f {n_fft // 2 + 1} \u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\"  # noqa: E501\n            )\n\n        self.n_fft = n_fft\n        self.hop_length = hop_length\n        self.win_length = win_length if win_length is not None else n_fft\n        self.window = window\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def magnitude(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the magnitude spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The absolute values of the complex spectrogram.\n        \"\"\"\n        return np.abs(self.data)\n\n    @property\n    def phase(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the phase spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The phase angles of the complex spectrogram in radians.\n        \"\"\"\n        return np.angle(self.data)\n\n    @property\n    def power(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the power spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The squared magnitude of the complex spectrogram.\n        \"\"\"\n        return np.abs(self.data) ** 2\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrogram in decibels relative to each channel's reference value.\n\n        The reference value for each channel is specified in its metadata.\n        A minimum value of -120 dB is enforced to avoid numerical issues.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrogram in decibels.\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        ref = np.array([ch.ref for ch in self._channel_metadata])\n        # dB\u5909\u63db\n        # 0\u9664\u7b97\u3092\u907f\u3051\u308b\u305f\u3081\u306b\u3001\u6700\u5927\u5024\u30681e-12\u306e\u3044\u305a\u308c\u304b\u3092\u4f7f\u7528\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(self.magnitude / ref[..., np.newaxis, np.newaxis], 1e-12)\n        )\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrogram in decibels.\n\n        A-weighting applies a frequency-dependent weighting filter that approximates\n        the human ear's response. This is particularly useful for analyzing noise\n        and acoustic measurements.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrogram in decibels.\n        \"\"\"\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted[:, np.newaxis]  # \u5468\u6ce2\u6570\u8ef8\u306b\u6cbf\u3063\u3066\u30d6\u30ed\u30fc\u30c9\u30ad\u30e3\u30b9\u30c8\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels.\n        \"\"\"\n        return self.shape[0]\n\n    @property\n    def n_frames(self) -&gt; int:\n        \"\"\"\n        Get the number of time frames.\n\n        Returns\n        -------\n        int\n            The number of time frames in the spectrogram.\n        \"\"\"\n        return self.shape[-1]\n\n    @property\n    def n_freq_bins(self) -&gt; int:\n        \"\"\"\n        Get the number of frequency bins.\n\n        Returns\n        -------\n        int\n            The number of frequency bins (n_fft // 2 + 1).\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the frequency axis values in Hz.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of frequency values corresponding to each frequency bin.\n        \"\"\"\n        return np.fft.rfftfreq(self.n_fft, 1.0 / self.sampling_rate)\n\n    @property\n    def times(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the time axis values in seconds.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of time values corresponding to each time frame.\n        \"\"\"\n        return np.arange(self.n_frames) * self.hop_length / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Implementation of operation application for spectrogram data.\n\n        This internal method handles the application of various operations to\n        spectrogram data, maintaining lazy evaluation through dask.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters for the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from wandas.processing.time_series import create_operation\n\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        processed_data = operation.process(self._data)\n\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\n            \"SpectrogramFrame\",\n            int,\n            float,\n            complex,\n            NDArrayComplex,\n            NDArrayReal,\n            \"DaArray\",\n        ],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"\n        Common implementation for binary operations.\n\n        This method handles binary operations between\n        SpectrogramFrames and various types\n        of operands, maintaining lazy evaluation through dask arrays.\n\n        Parameters\n        ----------\n        other : Union[SpectrogramFrame, int, float, complex,\n            NDArrayComplex, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation (e.g., lambda a, b: a + b)\n        symbol : str\n            String representation of the operation (e.g., '+')\n\n        Returns\n        -------\n        SpectrogramFrame\n            A new SpectrogramFrame containing the result of the operation.\n\n        Raises\n        ------\n        ValueError\n            If attempting to operate with a SpectrogramFrame\n            with a different sampling rate.\n        \"\"\"\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        if isinstance(other, SpectrogramFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u304c\u4e00\u81f4\u3057\u3066\u3044\u307e\u305b\u3093\u3002\u6f14\u7b97\u3067\u304d\u307e\u305b\u3093\u3002\"\n                )\n\n            result_data = op(self._data, other._data)\n\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return SpectrogramFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                hop_length=self.hop_length,\n                win_length=self.win_length,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n        else:\n            result_data = op(self._data, other)\n\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, complex):\n                other_str = f\"complex({other.real}, {other.imag})\"\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return SpectrogramFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                hop_length=self.hop_length,\n                win_length=self.win_length,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n            )\n\n    def plot(\n        self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the spectrogram using various visualization strategies.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"spectrogram\"\n            Type of plot to create.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - vmin, vmax: Colormap scaling\n            - cmap: Colormap name\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectrogramFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def plot_Aw(  # noqa: N802\n        self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the A-weighted spectrogram.\n\n        A convenience method that calls plot() with Aw=True, applying A-weighting\n        to the spectrogram before plotting.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"spectrogram\"\n            Type of plot to create.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to plot().\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot.\n        \"\"\"\n        return self.plot(plot_type=plot_type, ax=ax, Aw=True, **kwargs)\n\n    def get_frame_at(self, time_idx: int) -&gt; \"SpectralFrame\":\n        \"\"\"\n        Extract spectral data at a specific time frame.\n\n        Parameters\n        ----------\n        time_idx : int\n            Index of the time frame to extract.\n\n        Returns\n        -------\n        SpectralFrame\n            A new SpectralFrame containing the spectral data at the specified time.\n\n        Raises\n        ------\n        IndexError\n            If time_idx is out of range.\n        \"\"\"\n        from wandas.frames.spectral import SpectralFrame\n\n        if time_idx &lt; 0 or time_idx &gt;= self.n_frames:\n            raise IndexError(\n                f\"\u6642\u9593\u30a4\u30f3\u30c7\u30c3\u30af\u30b9 {time_idx} \u304c\u7bc4\u56f2\u5916\u3067\u3059\u3002\u6709\u52b9\u7bc4\u56f2: 0-{self.n_frames - 1}\"  # noqa: E501\n            )\n\n        frame_data = self._data[..., time_idx]\n\n        return SpectralFrame(\n            data=frame_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=self.n_fft,\n            window=self.window,\n            label=f\"{self.label} (Frame {time_idx}, Time {self.times[time_idx]:.3f}s)\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def to_channel_frame(self) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Convert the spectrogram back to time domain using inverse STFT.\n\n        This method performs an inverse Short-Time Fourier Transform (ISTFT) to\n        reconstruct the time-domain signal from the spectrogram.\n\n        Returns\n        -------\n        ChannelFrame\n            A new ChannelFrame containing the reconstructed time-domain signal.\n        \"\"\"\n        from wandas.frames.channel import ChannelFrame\n        from wandas.processing.time_series import ISTFT, create_operation\n\n        params = {\n            \"n_fft\": self.n_fft,\n            \"hop_length\": self.hop_length,\n            \"win_length\": self.win_length,\n            \"window\": self.window,\n        }\n        operation_name = \"istft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"ISTFT\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        time_series = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n\n        # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        return ChannelFrame(\n            data=time_series,\n            sampling_rate=self.sampling_rate,\n            label=f\"istft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get additional initialization arguments for SpectrogramFrame.\n\n        This internal method provides the additional initialization arguments\n        required by SpectrogramFrame beyond those required by BaseFrame.\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments.\n        \"\"\"\n        return {\n            \"n_fft\": self.n_fft,\n            \"hop_length\": self.hop_length,\n            \"win_length\": self.win_length,\n            \"window\": self.window,\n        }\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrogram in decibels relative to each channel's reference value.</p> <p>The reference value for each channel is specified in its metadata. A minimum value of -120 dB is enforced to avoid numerical issues.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrogram in decibels.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrogram in decibels.</p> <p>A-weighting applies a frequency-dependent weighting filter that approximates the human ear's response. This is particularly useful for analyzing noise and acoustic measurements.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrogram in decibels.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the frequency axis values in Hz.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of frequency values corresponding to each frequency bin.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.magnitude","title":"<code>magnitude</code>  <code>property</code>","text":"<p>Get the magnitude spectrogram.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.magnitude--returns","title":"Returns","text":"<p>NDArrayReal     The absolute values of the complex spectrogram.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_frames","title":"<code>n_frames</code>  <code>property</code>","text":"<p>Get the number of time frames.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_frames--returns","title":"Returns","text":"<p>int     The number of time frames in the spectrogram.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_freq_bins","title":"<code>n_freq_bins</code>  <code>property</code>","text":"<p>Get the number of frequency bins.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_freq_bins--returns","title":"Returns","text":"<p>int     The number of frequency bins (n_fft // 2 + 1).</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.phase","title":"<code>phase</code>  <code>property</code>","text":"<p>Get the phase spectrogram.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.phase--returns","title":"Returns","text":"<p>NDArrayReal     The phase angles of the complex spectrogram in radians.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.power","title":"<code>power</code>  <code>property</code>","text":"<p>Get the power spectrogram.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.power--returns","title":"Returns","text":"<p>NDArrayReal     The squared magnitude of the complex spectrogram.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.times","title":"<code>times</code>  <code>property</code>","text":"<p>Get the time axis values in seconds.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.times--returns","title":"Returns","text":"<p>NDArrayReal     Array of time values corresponding to each time frame.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at","title":"<code>get_frame_at(time_idx)</code>","text":"<p>Extract spectral data at a specific time frame.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--parameters","title":"Parameters","text":"<p>time_idx : int     Index of the time frame to extract.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--returns","title":"Returns","text":"<p>SpectralFrame     A new SpectralFrame containing the spectral data at the specified time.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--raises","title":"Raises","text":"<p>IndexError     If time_idx is out of range.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def get_frame_at(self, time_idx: int) -&gt; \"SpectralFrame\":\n    \"\"\"\n    Extract spectral data at a specific time frame.\n\n    Parameters\n    ----------\n    time_idx : int\n        Index of the time frame to extract.\n\n    Returns\n    -------\n    SpectralFrame\n        A new SpectralFrame containing the spectral data at the specified time.\n\n    Raises\n    ------\n    IndexError\n        If time_idx is out of range.\n    \"\"\"\n    from wandas.frames.spectral import SpectralFrame\n\n    if time_idx &lt; 0 or time_idx &gt;= self.n_frames:\n        raise IndexError(\n            f\"\u6642\u9593\u30a4\u30f3\u30c7\u30c3\u30af\u30b9 {time_idx} \u304c\u7bc4\u56f2\u5916\u3067\u3059\u3002\u6709\u52b9\u7bc4\u56f2: 0-{self.n_frames - 1}\"  # noqa: E501\n        )\n\n    frame_data = self._data[..., time_idx]\n\n    return SpectralFrame(\n        data=frame_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=self.n_fft,\n        window=self.window,\n        label=f\"{self.label} (Frame {time_idx}, Time {self.times[time_idx]:.3f}s)\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot","title":"<code>plot(plot_type='spectrogram', ax=None, **kwargs)</code>","text":"<p>Plot the spectrogram using various visualization strategies.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"spectrogram\"     Type of plot to create. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - vmin, vmax: Colormap scaling     - cmap: Colormap name     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def plot(\n    self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the spectrogram using various visualization strategies.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"spectrogram\"\n        Type of plot to create.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - vmin, vmax: Colormap scaling\n        - cmap: Colormap name\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectrogramFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw","title":"<code>plot_Aw(plot_type='spectrogram', ax=None, **kwargs)</code>","text":"<p>Plot the A-weighted spectrogram.</p> <p>A convenience method that calls plot() with Aw=True, applying A-weighting to the spectrogram before plotting.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"spectrogram\"     Type of plot to create. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to plot().</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def plot_Aw(  # noqa: N802\n    self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the A-weighted spectrogram.\n\n    A convenience method that calls plot() with Aw=True, applying A-weighting\n    to the spectrogram before plotting.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"spectrogram\"\n        Type of plot to create.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to plot().\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot.\n    \"\"\"\n    return self.plot(plot_type=plot_type, ax=ax, Aw=True, **kwargs)\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.to_channel_frame","title":"<code>to_channel_frame()</code>","text":"<p>Convert the spectrogram back to time domain using inverse STFT.</p> <p>This method performs an inverse Short-Time Fourier Transform (ISTFT) to reconstruct the time-domain signal from the spectrogram.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.to_channel_frame--returns","title":"Returns","text":"<p>ChannelFrame     A new ChannelFrame containing the reconstructed time-domain signal.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def to_channel_frame(self) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Convert the spectrogram back to time domain using inverse STFT.\n\n    This method performs an inverse Short-Time Fourier Transform (ISTFT) to\n    reconstruct the time-domain signal from the spectrogram.\n\n    Returns\n    -------\n    ChannelFrame\n        A new ChannelFrame containing the reconstructed time-domain signal.\n    \"\"\"\n    from wandas.frames.channel import ChannelFrame\n    from wandas.processing.time_series import ISTFT, create_operation\n\n    params = {\n        \"n_fft\": self.n_fft,\n        \"hop_length\": self.hop_length,\n        \"win_length\": self.win_length,\n        \"window\": self.window,\n    }\n    operation_name = \"istft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"ISTFT\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    time_series = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n    )\n\n    # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    return ChannelFrame(\n        data=time_series,\n        sampling_rate=self.sampling_rate,\n        label=f\"istft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"ja/api/frames/#noctframe","title":"NOctFrame","text":"<p><code>NOctFrame</code>\u306fN\u30aa\u30af\u30bf\u30fc\u30d6\u5206\u6790\u306e\u30c7\u30fc\u30bf\u3092\u6271\u3046\u30d5\u30ec\u30fc\u30e0\u3067\u3059\u3002</p> <pre><code>from wandas.frames.noct import NOctFrame\n\n# \u307e\u305f\u306f ChannelFrame\u304b\u3089\u5909\u63db\nchannel_frame = wandas.read_wav(\"audio.wav\")\nnoct_frame = channel_frame.to_noct()\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Class for handling N-octave band analysis data.</p> <p>This class represents frequency data analyzed in fractional octave bands, typically used in acoustic and vibration analysis. It handles real-valued data representing energy or power in each frequency band, following standard acoustical band definitions.</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The N-octave band data. Must be a dask array with shape:     - (channels, frequency_bins) for multi-channel data     - (frequency_bins,) for single-channel data, which will be       reshaped to (1, frequency_bins) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. fmin : float, default=0     Lower frequency bound in Hz. fmax : float, default=0     Upper frequency bound in Hz. n : int, default=3     Number of bands per octave (e.g., 3 for third-octave bands). G : int, default=10     Reference band number according to IEC 61260-1:2014. fr : int, default=1000     Reference frequency in Hz, typically 1000 Hz for acoustic analysis. label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame--attributes","title":"Attributes","text":"<p>freqs : NDArrayReal     The center frequencies of each band in Hz, calculated according to     the standard fractional octave band definitions. dB : NDArrayReal     The spectrum in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrum in decibels, applying frequency weighting     for better correlation with perceived loudness. fmin : float     Lower frequency bound in Hz. fmax : float     Upper frequency bound in Hz. n : int     Number of bands per octave. G : int     Reference band number. fr : int     Reference frequency in Hz.</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame--examples","title":"Examples","text":"<p>Create an N-octave band spectrum from a time-domain signal:</p> <p>signal = ChannelFrame.from_wav(\"audio.wav\") spectrum = signal.noct_spectrum(fmin=20, fmax=20000, n=3)</p> <p>Plot the N-octave band spectrum:</p> <p>spectrum.plot()</p> <p>Plot with A-weighting applied:</p> <p>spectrum.plot(Aw=True)</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame--notes","title":"Notes","text":"<ul> <li>Binary operations (addition, multiplication, etc.) are not currently   supported for N-octave band data.</li> <li>The actual frequency bands are determined by the parameters n, G, and fr   according to IEC 61260-1:2014 standard for fractional octave band filters.</li> <li>The class follows acoustic standards for band definitions and analysis,   making it suitable for noise measurements and sound level analysis.</li> <li>A-weighting is available for better correlation with human hearing   perception, following IEC 61672-1:2013.</li> </ul> Source code in <code>wandas/frames/noct.py</code> <pre><code>class NOctFrame(BaseFrame[NDArrayReal]):\n    \"\"\"\n    Class for handling N-octave band analysis data.\n\n    This class represents frequency data analyzed in fractional octave bands,\n    typically used in acoustic and vibration analysis. It handles real-valued\n    data representing energy or power in each frequency band, following standard\n    acoustical band definitions.\n\n    Parameters\n    ----------\n    data : DaArray\n        The N-octave band data. Must be a dask array with shape:\n        - (channels, frequency_bins) for multi-channel data\n        - (frequency_bins,) for single-channel data, which will be\n          reshaped to (1, frequency_bins)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    fmin : float, default=0\n        Lower frequency bound in Hz.\n    fmax : float, default=0\n        Upper frequency bound in Hz.\n    n : int, default=3\n        Number of bands per octave (e.g., 3 for third-octave bands).\n    G : int, default=10\n        Reference band number according to IEC 61260-1:2014.\n    fr : int, default=1000\n        Reference frequency in Hz, typically 1000 Hz for acoustic analysis.\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    freqs : NDArrayReal\n        The center frequencies of each band in Hz, calculated according to\n        the standard fractional octave band definitions.\n    dB : NDArrayReal\n        The spectrum in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrum in decibels, applying frequency weighting\n        for better correlation with perceived loudness.\n    fmin : float\n        Lower frequency bound in Hz.\n    fmax : float\n        Upper frequency bound in Hz.\n    n : int\n        Number of bands per octave.\n    G : int\n        Reference band number.\n    fr : int\n        Reference frequency in Hz.\n\n    Examples\n    --------\n    Create an N-octave band spectrum from a time-domain signal:\n    &gt;&gt;&gt; signal = ChannelFrame.from_wav(\"audio.wav\")\n    &gt;&gt;&gt; spectrum = signal.noct_spectrum(fmin=20, fmax=20000, n=3)\n\n    Plot the N-octave band spectrum:\n    &gt;&gt;&gt; spectrum.plot()\n\n    Plot with A-weighting applied:\n    &gt;&gt;&gt; spectrum.plot(Aw=True)\n\n    Notes\n    -----\n    - Binary operations (addition, multiplication, etc.) are not currently\n      supported for N-octave band data.\n    - The actual frequency bands are determined by the parameters n, G, and fr\n      according to IEC 61260-1:2014 standard for fractional octave band filters.\n    - The class follows acoustic standards for band definitions and analysis,\n      making it suitable for noise measurements and sound level analysis.\n    - A-weighting is available for better correlation with human hearing\n      perception, following IEC 61672-1:2013.\n    \"\"\"\n\n    fmin: float\n    fmax: float\n    n: int\n    G: int\n    fr: int\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        fmin: float = 0,\n        fmax: float = 0,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a NOctFrame instance.\n\n        Sets up N-octave band analysis parameters and prepares the frame for\n        storing band-filtered data. Data shape is validated to ensure compatibility\n        with N-octave band analysis.\n\n        See class docstring for parameter descriptions.\n        \"\"\"\n        self.n = n\n        self.G = G\n        self.fr = fr\n        self.fmin = fmin\n        self.fmax = fmax\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrum in decibels relative to each channel's reference value.\n\n        The reference value for each channel is specified in its metadata.\n        A minimum value of -120 dB is enforced to avoid numerical issues.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrum in decibels. Shape matches the input data shape:\n            (channels, frequency_bins).\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        ref = np.array([ch.ref for ch in self._channel_metadata])\n        # dB\u5909\u63db\n        # 0\u9664\u7b97\u3092\u907f\u3051\u308b\u305f\u3081\u306b\u3001\u6700\u5927\u5024\u30681e-12\u306e\u3044\u305a\u308c\u304b\u3092\u4f7f\u7528\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(self.data / ref[..., np.newaxis], 1e-12)\n        )\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrum in decibels.\n\n        A-weighting applies a frequency-dependent weighting filter that approximates\n        the human ear's response to different frequencies. This is particularly useful\n        for analyzing noise and acoustic measurements as it provides a better\n        correlation with perceived loudness.\n\n        The weighting is applied according to IEC 61672-1:2013 standard.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrum in decibels. Shape matches the input data shape:\n            (channels, frequency_bins).\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels in the N-octave band data.\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the center frequencies of each band in Hz.\n\n        These frequencies are calculated based on the N-octave band parameters\n        (n, G, fr) and the frequency bounds (fmin, fmax) according to\n        IEC 61260-1:2014 standard for fractional octave band filters.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of center frequencies for each frequency band.\n\n        Raises\n        ------\n        ValueError\n            If the center frequencies cannot be calculated or the result\n            is not a numpy array.\n        \"\"\"\n        _, freqs = _center_freq(\n            fmax=self.fmax,\n            fmin=self.fmin,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        if isinstance(freqs, np.ndarray):\n            return freqs\n        else:\n            raise ValueError(\"freqs is not numpy array.\")\n\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"\n        Binary operations are not currently supported for N-octave band data.\n\n        Parameters\n        ----------\n        other : Union[S, int, float, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation.\n        symbol : str\n            String representation of the operation (e.g., '+', '-', '*', '/').\n\n        Raises\n        ------\n        NotImplementedError\n            Always raises this error as operations are not implemented\n            for N-octave band data.\n        \"\"\"\n        raise NotImplementedError(\n            f\"Operation {symbol} is not implemented for NOctFrame.\"\n        )\n        return self\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        \u9045\u5ef6\u8a55\u4fa1\u3092\u4f7f\u7528\u3057\u3066\u64cd\u4f5c\u3092\u9069\u7528\u3057\u307e\u3059\u3002\n        \"\"\"\n        # \u9045\u5ef6\u8a55\u4fa1\u3092\u4f7f\u7528\u3057\u3066\u64cd\u4f5c\u3092\u9069\u7528\n        raise NotImplementedError(\n            f\"Operation {operation_name} is not implemented for NOctFrame.\"\n        )\n        return self\n\n    def plot(\n        self, plot_type: str = \"noct\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the N-octave band data using various visualization strategies.\n\n        Supports standard plotting configurations for acoustic analysis,\n        including decibel scales and A-weighting.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"noct\"\n            Type of plot to create. The default \"noct\" type creates a bar plot\n            suitable for displaying N-octave band data.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n            - title: Plot title\n            - xlabel, ylabel: Axis labels\n            - xscale: Set to \"log\" for logarithmic frequency axis\n            - grid: Whether to show grid lines\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[NOctFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get additional initialization arguments for NOctFrame.\n\n        This internal method provides the additional initialization arguments\n        required by NOctFrame beyond those required by BaseFrame. These include\n        the N-octave band analysis parameters that define the frequency bands.\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments specific to NOctFrame:\n            - n: Number of bands per octave\n            - G: Reference band number\n            - fr: Reference frequency\n            - fmin: Lower frequency bound\n            - fmax: Upper frequency bound\n        \"\"\"\n        return {\n            \"n\": self.n,\n            \"G\": self.G,\n            \"fr\": self.fr,\n            \"fmin\": self.fmin,\n            \"fmax\": self.fmax,\n        }\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrum in decibels relative to each channel's reference value.</p> <p>The reference value for each channel is specified in its metadata. A minimum value of -120 dB is enforced to avoid numerical issues.</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrum in decibels. Shape matches the input data shape:     (channels, frequency_bins).</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrum in decibels.</p> <p>A-weighting applies a frequency-dependent weighting filter that approximates the human ear's response to different frequencies. This is particularly useful for analyzing noise and acoustic measurements as it provides a better correlation with perceived loudness.</p> <p>The weighting is applied according to IEC 61672-1:2013 standard.</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrum in decibels. Shape matches the input data shape:     (channels, frequency_bins).</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the center frequencies of each band in Hz.</p> <p>These frequencies are calculated based on the N-octave band parameters (n, G, fr) and the frequency bounds (fmin, fmax) according to IEC 61260-1:2014 standard for fractional octave band filters.</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of center frequencies for each frequency band.</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.freqs--raises","title":"Raises","text":"<p>ValueError     If the center frequencies cannot be calculated or the result     is not a numpy array.</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.__init__","title":"<code>__init__(data, sampling_rate, fmin=0, fmax=0, n=3, G=10, fr=1000, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a NOctFrame instance.</p> <p>Sets up N-octave band analysis parameters and prepares the frame for storing band-filtered data. Data shape is validated to ensure compatibility with N-octave band analysis.</p> <p>See class docstring for parameter descriptions.</p> Source code in <code>wandas/frames/noct.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    fmin: float = 0,\n    fmax: float = 0,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a NOctFrame instance.\n\n    Sets up N-octave band analysis parameters and prepares the frame for\n    storing band-filtered data. Data shape is validated to ensure compatibility\n    with N-octave band analysis.\n\n    See class docstring for parameter descriptions.\n    \"\"\"\n    self.n = n\n    self.G = G\n    self.fr = fr\n    self.fmin = fmin\n    self.fmax = fmax\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.plot","title":"<code>plot(plot_type='noct', ax=None, **kwargs)</code>","text":"<p>Plot the N-octave band data using various visualization strategies.</p> <p>Supports standard plotting configurations for acoustic analysis, including decibel scales and A-weighting.</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"noct\"     Type of plot to create. The default \"noct\" type creates a bar plot     suitable for displaying N-octave band data. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting     - title: Plot title     - xlabel, ylabel: Axis labels     - xscale: Set to \"log\" for logarithmic frequency axis     - grid: Whether to show grid lines</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/noct.py</code> <pre><code>def plot(\n    self, plot_type: str = \"noct\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the N-octave band data using various visualization strategies.\n\n    Supports standard plotting configurations for acoustic analysis,\n    including decibel scales and A-weighting.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"noct\"\n        Type of plot to create. The default \"noct\" type creates a bar plot\n        suitable for displaying N-octave band data.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n        - title: Plot title\n        - xlabel, ylabel: Axis labels\n        - xscale: Set to \"log\" for logarithmic frequency axis\n        - grid: Whether to show grid lines\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[NOctFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"ja/api/processing/","title":"\u4fe1\u53f7\u51e6\u7406\u30e2\u30b8\u30e5\u30fc\u30eb\uff08Processing\uff09","text":"<p>\u3053\u306e\u30da\u30fc\u30b8\u3067\u306fWandas\u306e\u4fe1\u53f7\u51e6\u7406\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002\u4fe1\u53f7\u51e6\u7406\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u3001\u6642\u7cfb\u5217\u30c7\u30fc\u30bf\u306b\u5bfe\u3059\u308b\u69d8\u3005\u306a\u51e6\u7406\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"ja/api/processing/#_1","title":"\u6642\u7cfb\u5217\u51e6\u7406","text":"<p>\u6642\u7cfb\u5217\u30c7\u30fc\u30bf\u306b\u5bfe\u3059\u308b\u51e6\u7406\u95a2\u6570\u3067\u3059\u3002\u3053\u308c\u3089\u306e\u95a2\u6570\u306f\u57fa\u672c\u7684\u306b<code>ChannelFrame</code>\u30e1\u30bd\u30c3\u30c9\u3092\u901a\u3058\u3066\u4f7f\u7528\u3057\u307e\u3059\u3002</p> <pre><code># \u4e00\u822c\u7684\u306a\u4f7f\u7528\u65b9\u6cd5\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")\nfiltered_frame = frame.filter(cutoff=1000, filter_type=\"lowpass\")\nresampled_frame = frame.resample(target_rate=16000)\n</code></pre>"},{"location":"ja/api/processing/#_2","title":"\u4e3b\u8981\u306a\u51e6\u7406\u30af\u30e9\u30b9","text":"<p>\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3084\u4ed6\u306e\u4fe1\u53f7\u51e6\u7406\u6a5f\u80fd\u306f\u3001\u5185\u90e8\u7684\u306b\u306f\u4ee5\u4e0b\u306e\u30af\u30e9\u30b9\u306b\u3088\u3063\u3066\u5b9f\u88c5\u3055\u308c\u3066\u3044\u307e\u3059\uff1a</p> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>High-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HighPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"High-pass filter operation\"\"\"\n\n    name = \"highpass_filter\"\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize high-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            limit = self.sampling_rate / 2\n            raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up high-pass filter processor\"\"\"\n        # Calculate filter coefficients (once) - safely retrieve from instance variables\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"high\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Highpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying highpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Low-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class LowPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Low-pass filter operation\"\"\"\n\n    name = \"lowpass_filter\"\n    a: NDArrayReal\n    b: NDArrayReal\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize low-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            raise ValueError(\n                f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n            )\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up low-pass filter processor\"\"\"\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"low\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Lowpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying lowpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Resampling operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ReSampling(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Resampling operation\"\"\"\n\n    name = \"resampling\"\n\n    def __init__(self, sampling_rate: float, target_sr: float):\n        \"\"\"\n        Initialize resampling operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        target_sampling_rate : float\n            Target sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate, target_sr=target_sr)\n        self.target_sr = target_sr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after resampling\n        ratio = float(self.target_sr) / float(self.sampling_rate)\n        n_samples = int(np.ceil(input_shape[-1] * ratio))\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for resampling operation\"\"\"\n        logger.debug(f\"Applying resampling to array with shape: {x.shape}\")\n        result = librosa.resample(\n            x, orig_sr=self.sampling_rate, target_sr=self.target_sr\n        )\n        logger.debug(f\"Resampling applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>A-weighting filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AWeighting(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"A-weighting filter operation\"\"\"\n\n    name = \"a_weighting\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize A-weighting filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for A-weighting filter\"\"\"\n        logger.debug(f\"Applying A-weighting to array with shape: {x.shape}\")\n        result = A_weight(x, self.sampling_rate)\n\n        # Handle case where A_weight returns a tuple\n        if isinstance(result, tuple):\n            # Use the first element of the tuple\n            result = result[0]\n\n        logger.debug(\n            f\"A-weighting applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.HighPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize high-pass filter</p>"},{"location":"ja/api/processing/#wandas.processing.time_series.HighPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize high-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.HighPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        limit = self.sampling_rate / 2\n        raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.LowPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize low-pass filter</p>"},{"location":"ja/api/processing/#wandas.processing.time_series.LowPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize low-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.LowPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        raise ValueError(\n            f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n        )\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.ReSampling.__init__","title":"<code>__init__(sampling_rate, target_sr)</code>","text":"<p>Initialize resampling operation</p>"},{"location":"ja/api/processing/#wandas.processing.time_series.ReSampling.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) target_sampling_rate : float     Target sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, target_sr: float):\n    \"\"\"\n    Initialize resampling operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    target_sampling_rate : float\n        Target sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate, target_sr=target_sr)\n    self.target_sr = target_sr\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.ReSampling.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/processing/#wandas.processing.time_series.ReSampling.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"ja/api/processing/#wandas.processing.time_series.ReSampling.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after resampling\n    ratio = float(self.target_sr) / float(self.sampling_rate)\n    n_samples = int(np.ceil(input_shape[-1] * ratio))\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.AWeighting.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize A-weighting filter</p>"},{"location":"ja/api/processing/#wandas.processing.time_series.AWeighting.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize A-weighting filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"ja/api/processing/#audiooperation","title":"AudioOperation","text":"<p><code>AudioOperation</code> \u30af\u30e9\u30b9\u306f\u97f3\u58f0\u51e6\u7406\u64cd\u4f5c\u306e\u62bd\u8c61\u5316\u3068\u9023\u9396\u51e6\u7406\u3092\u53ef\u80fd\u306b\u3057\u307e\u3059\u3002</p> <pre><code>from wandas.processing.time_series import AudioOperation\n\n# \u4f7f\u7528\u4f8b\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")\n\n# \u8907\u6570\u306e\u51e6\u7406\u3092\u9023\u9396\u3055\u305b\u308b\noperation = (\n    AudioOperation()\n    .add_step(\"filter\", cutoff=1000, filter_type=\"lowpass\")\n    .add_step(\"normalize\")\n)\n\n# \u51e6\u7406\u3092\u9069\u7528\nprocessed_frame = operation.apply(frame)\n</code></pre> <p>               Bases: <code>Generic[InputArrayType, OutputArrayType]</code></p> <p>Abstract base class for audio processing operations.</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AudioOperation(Generic[InputArrayType, OutputArrayType]):\n    \"\"\"Abstract base class for audio processing operations.\"\"\"\n\n    # Class variable: operation name\n    name: ClassVar[str]\n\n    def __init__(self, sampling_rate: float, **params: Any):\n        \"\"\"\n        Initialize AudioOperation.\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        **params : Any\n            Operation-specific parameters\n        \"\"\"\n        self.sampling_rate = sampling_rate\n        self.params = params\n\n        # Validate parameters during initialization\n        self.validate_params()\n\n        # Create processor function (lazy initialization possible)\n        self._setup_processor()\n\n        logger.debug(\n            f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n        )\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n        pass\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up processor function (implemented by subclasses)\"\"\"\n        pass\n\n    def _process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function (implemented by subclasses)\"\"\"\n        # Default is no-op function\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    @dask.delayed  # type: ignore [misc, unused-ignore]\n    def process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n        # Default is no-op function\n        logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n        return self._process_array(x)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation (implemented by subclasses)\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        \"\"\"\n        Execute operation and return result\n        data shape is (channels, samples)\n        \"\"\"\n        # Add task as delayed processing\n        logger.debug(\"Adding delayed operation to computation graph\")\n        delayed_result = self.process_array(data)\n        # Convert delayed result to dask array and return\n        output_shape = self.calculate_output_shape(data.shape)\n        return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.AudioOperation.__init__","title":"<code>__init__(sampling_rate, **params)</code>","text":"<p>Initialize AudioOperation.</p>"},{"location":"ja/api/processing/#wandas.processing.time_series.AudioOperation.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) **params : Any     Operation-specific parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, **params: Any):\n    \"\"\"\n    Initialize AudioOperation.\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    **params : Any\n        Operation-specific parameters\n    \"\"\"\n    self.sampling_rate = sampling_rate\n    self.params = params\n\n    # Validate parameters during initialization\n    self.validate_params()\n\n    # Create processor function (lazy initialization possible)\n    self._setup_processor()\n\n    logger.debug(\n        f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n    )\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.AudioOperation.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation (implemented by subclasses)</p>"},{"location":"ja/api/processing/#wandas.processing.time_series.AudioOperation.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"ja/api/processing/#wandas.processing.time_series.AudioOperation.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation (implemented by subclasses)\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.AudioOperation.process","title":"<code>process(data)</code>","text":"<p>Execute operation and return result data shape is (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    \"\"\"\n    Execute operation and return result\n    data shape is (channels, samples)\n    \"\"\"\n    # Add task as delayed processing\n    logger.debug(\"Adding delayed operation to computation graph\")\n    delayed_result = self.process_array(data)\n    # Convert delayed result to dask array and return\n    output_shape = self.calculate_output_shape(data.shape)\n    return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.AudioOperation.process_array","title":"<code>process_array(x)</code>","text":"<p>Processing function wrapped with @dask.delayed</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>@dask.delayed  # type: ignore [misc, unused-ignore]\ndef process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n    \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n    # Default is no-op function\n    logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n    return self._process_array(x)\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.AudioOperation.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters (raises exception if invalid)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n    pass\n</code></pre>"},{"location":"ja/explanation/","title":"\u7406\u8ad6\u80cc\u666f\u3068\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3","text":"<p>\u3053\u306e\u30bb\u30af\u30b7\u30e7\u30f3\u3067\u306f\u3001Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u8a2d\u8a08\u601d\u60f3\u3001\u5185\u90e8\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u3001\u304a\u3088\u3073\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u4f7f\u7528\u3055\u308c\u3066\u3044\u308b\u7406\u8ad6\u7684\u80cc\u666f\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002</p>"},{"location":"ja/explanation/#_2","title":"\u8a2d\u8a08\u601d\u60f3","text":"<p>Wandas\u306f\u4ee5\u4e0b\u306e\u8a2d\u8a08\u539f\u5247\u306b\u57fa\u3065\u3044\u3066\u958b\u767a\u3055\u308c\u3066\u3044\u307e\u3059\uff1a</p> <ol> <li>\u76f4\u611f\u7684\u306aAPI\u8a2d\u8a08 - \u30e6\u30fc\u30b6\u30fc\u304c\u7c21\u5358\u306b\u4f7f\u3048\u308b\u4e00\u8cab\u6027\u306e\u3042\u308b\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9</li> <li>\u52b9\u7387\u7684\u306a\u30e1\u30e2\u30ea\u4f7f\u7528 - \u5927\u898f\u6a21\u30c7\u30fc\u30bf\u306e\u51e6\u7406\u306b\u9069\u3057\u305f\u30e1\u30e2\u30ea\u52b9\u7387\u306e\u826f\u3044\u5b9f\u88c5</li> <li>\u62e1\u5f35\u6027 - \u65b0\u3057\u3044\u6a5f\u80fd\u3084\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u8ffd\u52a0\u3057\u3084\u3059\u3044\u62e1\u5f35\u53ef\u80fd\u306a\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3</li> <li>\u79d1\u5b66\u7684\u6b63\u78ba\u6027 - \u97f3\u97ff\u4fe1\u53f7\u51e6\u7406\u306e\u7406\u8ad6\u306b\u57fa\u3065\u304f\u6b63\u78ba\u306a\u5b9f\u88c5</li> </ol>"},{"location":"ja/explanation/#_3","title":"\u30b3\u30a2\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3","text":""},{"location":"ja/explanation/#_4","title":"\u30c7\u30fc\u30bf\u30e2\u30c7\u30eb","text":"<p>Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u4e2d\u5fc3\u3068\u306a\u308b\u30c7\u30fc\u30bf\u30e2\u30c7\u30eb\u306f\u968e\u5c64\u7684\u306b\u69cb\u6210\u3055\u308c\u3066\u3044\u307e\u3059\uff1a</p> <pre><code>BaseChannel (\u57fa\u5e95\u30af\u30e9\u30b9)\n \u251c\u2500\u2500 Channel (\u6642\u9593\u9818\u57df\u4fe1\u53f7)\n \u2502    \u2514\u2500\u2500 FrequencyChannel (\u5468\u6ce2\u6570\u9818\u57df\u4fe1\u53f7)\n \u2502         \u2514\u2500\u2500 TimeFrequencyChannel (\u6642\u9593-\u5468\u6ce2\u6570\u9818\u57df\u4fe1\u53f7)\n \u2514\u2500\u2500 ChannelFrame (\u8907\u6570\u30c1\u30e3\u30f3\u30cd\u30eb\u306e\u30b3\u30f3\u30c6\u30ca)\n      \u251c\u2500\u2500 FileFrame (\u30d5\u30a1\u30a4\u30eb\u30d9\u30fc\u30b9\u306e\u8907\u6570\u30c1\u30e3\u30f3\u30cd\u30eb)\n      \u2514\u2500\u2500 FrequencyChannelFrame (\u5468\u6ce2\u6570\u9818\u57df\u306e\u8907\u6570\u30c1\u30e3\u30f3\u30cd\u30eb)\n</code></pre> <p>\u5404\u30af\u30e9\u30b9\u306e\u8cac\u4efb\uff1a</p> <ul> <li>BaseChannel: \u3059\u3079\u3066\u306e\u30c1\u30e3\u30f3\u30cd\u30eb\u306e\u57fa\u5e95\u30af\u30e9\u30b9\u3002\u30c7\u30fc\u30bf\u30a2\u30af\u30bb\u30b9\u3001\u30e1\u30bf\u30c7\u30fc\u30bf\u7ba1\u7406\u306e\u57fa\u672c\u6a5f\u80fd\u3092\u63d0\u4f9b</li> <li>Channel: \u6642\u9593\u9818\u57df\u306e\u4fe1\u53f7\u30c7\u30fc\u30bf\u3068\u3001\u305d\u308c\u306b\u5bfe\u3059\u308b\u51e6\u7406\u30e1\u30bd\u30c3\u30c9\u3092\u5b9f\u88c5</li> <li>FrequencyChannel: FFT\u30d9\u30fc\u30b9\u306e\u5468\u6ce2\u6570\u9818\u57df\u30c7\u30fc\u30bf\u3068\u51e6\u7406\u3092\u5b9f\u88c5</li> <li>TimeFrequencyChannel: \u77ed\u6642\u9593\u30d5\u30fc\u30ea\u30a8\u5909\u63db\uff08STFT\uff09\u306a\u3069\u306e\u6642\u9593-\u5468\u6ce2\u6570\u9818\u57df\u8868\u73fe\u3092\u5b9f\u88c5</li> <li>ChannelFrame: \u8907\u6570\u306e\u30c1\u30e3\u30f3\u30cd\u30eb\u3092\u7ba1\u7406\u3057\u3001\u4e00\u62ec\u51e6\u7406\u3092\u53ef\u80fd\u306b\u3059\u308b\u30b3\u30f3\u30c6\u30ca</li> </ul>"},{"location":"ja/explanation/#_5","title":"\u30c7\u30fc\u30bf\u51e6\u7406\u30d5\u30ed\u30fc","text":"<ol> <li>\u5165\u529b\u6bb5\u968e: WAV\u3084CSV\u306a\u3069\u306e\u30d5\u30a1\u30a4\u30eb\u304b\u3089<code>Channel</code>\u307e\u305f\u306f<code>ChannelFrame</code>\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210</li> <li>\u51e6\u7406\u6bb5\u968e: \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3001\u30ea\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u306a\u3069\u306e\u51e6\u7406\u3092\u9069\u7528</li> <li>\u5206\u6790\u6bb5\u968e: \u4fe1\u53f7\u306e\u7279\u6027\uff08\u30b9\u30da\u30af\u30c8\u30eb\u3001\u30ec\u30d9\u30eb\u7b49\uff09\u3092\u5206\u6790</li> <li>\u51fa\u529b\u6bb5\u968e: \u51e6\u7406\u7d50\u679c\u3092\u30d5\u30a1\u30a4\u30eb\u306b\u4fdd\u5b58\u307e\u305f\u306f\u30b0\u30e9\u30d5\u3068\u3057\u3066\u53ef\u8996\u5316</li> </ol>"},{"location":"ja/explanation/#_6","title":"\u5b9f\u88c5\u8a73\u7d30","text":""},{"location":"ja/explanation/#_7","title":"\u30e1\u30e2\u30ea\u52b9\u7387","text":"<p>Wandas\u306f\u5927\u898f\u6a21\u306a\u30aa\u30fc\u30c7\u30a3\u30aa\u30c7\u30fc\u30bf\u3092\u6271\u3046\u305f\u3081\u306b\u3001\u4ee5\u4e0b\u306e\u65b9\u6cd5\u3067\u30e1\u30e2\u30ea\u52b9\u7387\u3092\u78ba\u4fdd\u3057\u3066\u3044\u307e\u3059\uff1a</p> <ul> <li>\u9045\u5ef6\u8a55\u4fa1: \u5fc5\u8981\u306b\u306a\u308b\u307e\u3067\u8a08\u7b97\u3092\u9045\u5ef6\u3055\u305b\u308b\u4ed5\u7d44\u307f</li> <li>\u30e1\u30e2\u30ea\u30de\u30c3\u30d4\u30f3\u30b0: \u5927\u304d\u306a\u30d5\u30a1\u30a4\u30eb\u3067\u3082\u30e1\u30e2\u30ea\u306b\u5168\u3066\u8aad\u307f\u8fbc\u307e\u305a\u306b\u30a2\u30af\u30bb\u30b9</li> <li>dask\u3068H5PY: \u5927\u898f\u6a21\u30c7\u30fc\u30bf\u306e\u51e6\u7406\u306b\u9069\u3057\u305f\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u6d3b\u7528</li> </ul>"},{"location":"ja/explanation/#_8","title":"\u4fe1\u53f7\u51e6\u7406\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0","text":"<p>Wandas\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u4fe1\u53f7\u51e6\u7406\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u5b9f\u88c5\u3057\u3066\u3044\u307e\u3059\uff1a</p> <ul> <li>\u30c7\u30b8\u30bf\u30eb\u30d5\u30a3\u30eb\u30bf: \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf\u306a\u3069\u306eIIR/FIR\u30d5\u30a3\u30eb\u30bf</li> <li>\u30b9\u30da\u30af\u30c8\u30eb\u5206\u6790: \u9ad8\u901f\u30d5\u30fc\u30ea\u30a8\u5909\u63db\uff08FFT\uff09\u306b\u57fa\u3065\u304f\u5468\u6ce2\u6570\u5206\u6790</li> <li>\u6642\u9593-\u5468\u6ce2\u6570\u5206\u6790: \u77ed\u6642\u9593\u30d5\u30fc\u30ea\u30a8\u5909\u63db\uff08STFT\uff09\u3001\u30b9\u30da\u30af\u30c8\u30ed\u30b0\u30e9\u30e0</li> <li>\u7d71\u8a08\u7684\u5206\u6790: RMS\u3001\u30d4\u30fc\u30af\u5024\u3001\u30af\u30ec\u30b9\u30c8\u30d5\u30a1\u30af\u30bf\u30fc\u306a\u3069\u306e\u4fe1\u53f7\u7279\u6027\u306e\u8a08\u7b97</li> </ul>"},{"location":"ja/explanation/#_9","title":"\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u306e\u8003\u616e\u4e8b\u9805","text":"<p>Wandas\u3092\u4f7f\u7528\u3059\u308b\u969b\u306e\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u306b\u95a2\u3059\u308b\u8003\u616e\u4e8b\u9805\uff1a</p> <ul> <li>\u5927\u91cf\u306e\u30c7\u30fc\u30bf\u3092\u51e6\u7406\u3059\u308b\u5834\u5408\u306f\u3001\u51e6\u7406\u3092\u30c1\u30e3\u30f3\u30af\u5358\u4f4d\u3067\u884c\u3046\u3053\u3068\u3092\u691c\u8a0e</li> <li>\u8907\u96d1\u306a\u51e6\u7406\u30c1\u30a7\u30fc\u30f3\u3092\u69cb\u7bc9\u3059\u308b\u5834\u5408\u306f\u3001\u4e2d\u9593\u7d50\u679c\u3092\u30ad\u30e3\u30c3\u30b7\u30e5\u3059\u308b\u3053\u3068\u3067\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u3092\u5411\u4e0a</li> <li>\u30de\u30eb\u30c1\u30c1\u30e3\u30f3\u30cd\u30eb\u51e6\u7406\u306f\u30de\u30eb\u30c1\u30b3\u30a2\u30d7\u30ed\u30bb\u30c3\u30b5\u3092\u52b9\u7387\u7684\u306b\u6d3b\u7528</li> </ul>"},{"location":"ja/explanation/#_10","title":"\u53c2\u8003\u6587\u732e","text":"<ol> <li>Smith, J. O. (2011). Spectral Audio Signal Processing. W3K Publishing.</li> <li>M\u00fcller, M. (2015). Fundamentals of Music Processing: Audio, Analysis, Algorithms, Applications. Springer.</li> <li>Z\u00f6lzer, U. (2008). Digital Audio Signal Processing. Wiley.</li> </ol>"},{"location":"ja/how_to/","title":"\u30af\u30c3\u30af\u30d6\u30c3\u30af\uff08\u7528\u9014\u5225\u30ec\u30b7\u30d4\u96c6\uff09","text":"<p>\u3053\u306e\u30bb\u30af\u30b7\u30e7\u30f3\u3067\u306f\u3001Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u4f7f\u7528\u3057\u305f\u69d8\u3005\u306a\u5b9f\u8df5\u7684\u306a\u30bf\u30b9\u30af\u306e\u4f8b\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"ja/how_to/#_2","title":"\u57fa\u672c\u7684\u306a\u97f3\u58f0\u5206\u6790","text":"<ul> <li>\u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u306e\u57fa\u672c\u60c5\u5831\u3092\u53d6\u5f97\u3059\u308b</li> <li>\u97f3\u58f0\u306e\u5468\u6ce2\u6570\u30b9\u30da\u30af\u30c8\u30eb\u3092\u5206\u6790\u3059\u308b</li> <li>RMS\u30ec\u30d9\u30eb\u3084\u30d4\u30fc\u30af\u30ec\u30d9\u30eb\u306a\u3069\u306e\u97f3\u91cf\u7279\u6027\u3092\u6e2c\u5b9a\u3059\u308b</li> </ul>"},{"location":"ja/how_to/#_3","title":"\u4fe1\u53f7\u51e6\u7406","text":"<ul> <li>\u30ed\u30fc\u30d1\u30b9/\u30cf\u30a4\u30d1\u30b9/\u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3092\u9069\u7528\u3059\u308b</li> <li>\u7279\u5b9a\u5468\u6ce2\u6570\u5e2f\u57df\u306e\u97f3\u91cf\u3092\u8abf\u6574\u3059\u308b\uff08\u30a4\u30b3\u30e9\u30a4\u30b6\u30fc\uff09</li> <li>\u30ce\u30a4\u30ba\u9664\u53bb\u3092\u884c\u3046</li> <li>\u97f3\u58f0\u306e\u30d4\u30c3\u30c1\u3092\u5909\u66f4\u3059\u308b</li> </ul>"},{"location":"ja/how_to/#_4","title":"\u97f3\u58f0\u30c7\u30fc\u30bf\u306e\u64cd\u4f5c","text":"<ul> <li>\u8907\u6570\u306e\u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u3092\u9023\u7d50\u3059\u308b</li> <li>\u7279\u5b9a\u306e\u90e8\u5206\u3092\u5207\u308a\u51fa\u3059</li> <li>\u97f3\u58f0\u3092\u30d5\u30a7\u30fc\u30c9\u30a4\u30f3/\u30d5\u30a7\u30fc\u30c9\u30a2\u30a6\u30c8\u3055\u305b\u308b</li> <li>\u7570\u306a\u308b\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u9593\u3067\u5909\u63db\u3059\u308b</li> </ul>"},{"location":"ja/how_to/#_5","title":"\u7279\u6b8a\u52b9\u679c","text":"<ul> <li>\u30ea\u30d0\u30fc\u30d6\uff08\u6b8b\u97ff\uff09\u52b9\u679c\u3092\u8ffd\u52a0\u3059\u308b</li> <li>\u30a8\u30b3\u30fc\u52b9\u679c\u3092\u8ffd\u52a0\u3059\u308b</li> <li>\u30c7\u30a3\u30b9\u30c8\u30fc\u30b7\u30e7\u30f3\u52b9\u679c\u3092\u9069\u7528\u3059\u308b</li> </ul>"},{"location":"ja/how_to/#_6","title":"\u9ad8\u5ea6\u306a\u5fdc\u7528","text":"<ul> <li>\u97f3\u58f0\u8a8d\u8b58\u524d\u51e6\u7406\u3068\u3057\u3066\u4f7f\u7528\u3059\u308b</li> <li>\u5927\u898f\u6a21\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3092\u52b9\u7387\u7684\u306b\u51e6\u7406\u3059\u308b</li> <li>\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u51e6\u7406\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u3092\u69cb\u7bc9\u3059\u308b</li> </ul>"},{"location":"ja/how_to/#_7","title":"\u30ab\u30b9\u30bf\u30e0\u51e6\u7406\u306e\u8ffd\u52a0","text":"<ul> <li>\u72ec\u81ea\u306e\u30d5\u30a3\u30eb\u30bf\u3092\u5b9a\u7fa9\u3059\u308b</li> <li>\u65b0\u3057\u3044\u51e6\u7406\u95a2\u6570\u3092\u5b9f\u88c5\u3059\u308b</li> <li>wandas\u3068\u4ed6\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u9023\u643a\u3055\u305b\u308b</li> </ul> <p>\u30d2\u30f3\u30c8</p> <p>\u5404\u30ec\u30b7\u30d4\u306f\u72ec\u7acb\u3057\u3066\u304a\u308a\u3001\u5fc5\u8981\u306b\u5fdc\u3058\u3066\u53c2\u7167\u3067\u304d\u307e\u3059\u3002\u57fa\u672c\u7684\u306a\u4f7f\u3044\u65b9\u304c\u308f\u304b\u3089\u306a\u3044\u5834\u5408\u306f\u3001\u307e\u305a\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3092\u3054\u89a7\u304f\u3060\u3055\u3044\u3002</p>"},{"location":"ja/tutorial/","title":"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb","text":"<p>\u3053\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3067\u306f\u3001Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u57fa\u672c\u7684\u306a\u4f7f\u3044\u65b9\u30925\u5206\u3067\u5b66\u3079\u307e\u3059\u3002</p>"},{"location":"ja/tutorial/#_2","title":"\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb","text":"<pre><code>pip install wandas\n</code></pre>"},{"location":"ja/tutorial/#_3","title":"\u57fa\u672c\u7684\u306a\u4f7f\u3044\u65b9","text":""},{"location":"ja/tutorial/#1","title":"1. \u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u30a4\u30f3\u30dd\u30fc\u30c8","text":"<pre><code>import wandas as wd\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"ja/tutorial/#2","title":"2. \u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f","text":"<pre><code># WAV\u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u3080\naudio = wd.io.read_wav(\"path/to/audio.wav\")\nprint(f\"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8: {audio.sampling_rate} Hz\")\nprint(f\"\u30c1\u30e3\u30f3\u30cd\u30eb\u6570: {len(audio)}\")\n</code></pre>"},{"location":"ja/tutorial/#3","title":"3. \u4fe1\u53f7\u306e\u53ef\u8996\u5316","text":"<pre><code># \u6ce2\u5f62\u3092\u8868\u793a\naudio.plot()\nplt.show()\n</code></pre>"},{"location":"ja/tutorial/#4","title":"4. \u57fa\u672c\u7684\u306a\u4fe1\u53f7\u51e6\u7406","text":"<pre><code># \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3092\u9069\u7528\uff081kHz\u4ee5\u4e0b\u306e\u5468\u6ce2\u6570\u3092\u901a\u904e\uff09\nfiltered = audio.filter(lowpass=1000)\n\n# \u7d50\u679c\u3092\u53ef\u8996\u5316\u3057\u3066\u6bd4\u8f03\nfig, axes = plt.subplots(2, 1, figsize=(10, 6))\naudio.plot(ax=axes[0], title=\"\u30aa\u30ea\u30b8\u30ca\u30eb\u4fe1\u53f7\")\nfiltered.plot(ax=axes[1], title=\"\u30d5\u30a3\u30eb\u30bf\u5f8c\u306e\u4fe1\u53f7\")\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"ja/tutorial/#5","title":"5. \u51e6\u7406\u7d50\u679c\u306e\u4fdd\u5b58","text":"<pre><code># \u51e6\u7406\u3057\u305f\u4fe1\u53f7\u3092WAV\u30d5\u30a1\u30a4\u30eb\u3068\u3057\u3066\u4fdd\u5b58\nwd.io.write_wav(filtered, \"filtered_audio.wav\")\n</code></pre>"},{"location":"ja/tutorial/#_4","title":"\u6b21\u306e\u30b9\u30c6\u30c3\u30d7","text":"<ul> <li>\u30af\u30c3\u30af\u30d6\u30c3\u30af \u3067\u69d8\u3005\u306a\u5fdc\u7528\u4f8b\u3092\u78ba\u8a8d\u3059\u308b</li> <li>API\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9 \u3067\u8a73\u7d30\u306a\u6a5f\u80fd\u3092\u8abf\u3079\u308b</li> <li>\u7406\u8ad6\u80cc\u666f \u3067\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u8a2d\u8a08\u601d\u60f3\u3092\u7406\u89e3\u3059\u308b</li> </ul>"},{"location":"en/en/","title":"Wandas: Waveform Analysis Data Structures","text":"<p>Wandas is an open-source library for efficient signal analysis in Python. Wandas provides comprehensive functionality for signal processing and seamless integration with Matplotlib.</p>"},{"location":"en/en/#features","title":"Features","text":"<ul> <li>Comprehensive Signal Processing Functions: Easily perform basic signal processing operations including filtering, Fourier transforms, and STFT</li> <li>Integration with Visualization Libraries: Seamlessly integrate with Matplotlib for easy data visualization</li> <li>Lazy Evaluation: Efficiently process large data using dask</li> <li>Various Analysis Tools: Frequency analysis, octave band analysis, time-frequency analysis, and more</li> </ul>"},{"location":"en/en/#usage-examples","title":"Usage Examples","text":""},{"location":"en/en/#loading-and-visualizing-audio-files","title":"Loading and Visualizing Audio Files","text":"<pre><code>import wandas as wd\n\ncf = wd.read_wav(\"data/sample.wav\")\ncf.describe()\n</code></pre>"},{"location":"en/en/#filtering","title":"Filtering","text":"<pre><code>signal = wd.generate_sin(freqs=[5000, 1000], duration=1)\n# Apply low pass filter\nsignal.low_pass_filter(cutoff=1000).fft().plot()\n</code></pre> <p>For detailed documentation and usage examples, see the Tutorial and Cookbook.</p>"},{"location":"en/en/#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Tutorial - 5-minute getting started guide</li> <li>Cookbook - Recipe collection for common tasks</li> <li>API Reference - Detailed API specifications</li> <li>Theory &amp; Architecture - Design philosophy and algorithm explanations</li> <li>Contributing Guide - Rules and methods for contribution</li> </ul>"},{"location":"en/en/#license","title":"License","text":"<p>This project is released under the MIT License.</p>"},{"location":"en/en/contributing/","title":"Contributing Guide","text":"<p>Thank you for your interest in contributing to the Wandas project. This guide explains how to contribute to the project.</p>"},{"location":"en/en/contributing/#types-of-contributions","title":"Types of Contributions","text":"<p>You can contribute to the Wandas project in the following ways:</p> <ul> <li>Bug reports and feature requests</li> <li>Documentation improvements</li> <li>Bug fixes</li> <li>New feature implementations</li> <li>Test additions and improvements</li> <li>Performance optimizations</li> </ul>"},{"location":"en/en/contributing/#setting-up-the-development-environment","title":"Setting Up the Development Environment","text":""},{"location":"en/en/contributing/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/yourusername/wandas.git\ncd wandas\n</code></pre>"},{"location":"en/en/contributing/#2-set-up-a-virtual-environment-and-install-dependencies","title":"2. Set Up a Virtual Environment and Install Dependencies","text":"<pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip install -e \".[dev]\"\n</code></pre>"},{"location":"en/en/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"en/en/contributing/#1-create-a-new-branch","title":"1. Create a New Branch","text":"<p>Create a new branch for new features or bug fixes:</p> <pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/issue-description\n</code></pre>"},{"location":"en/en/contributing/#2-code-style","title":"2. Code Style","text":"<p>Follow the PEP 8 style guide for code. We use the following tools to ensure code quality:</p> <ul> <li>Ruff: Code linter and formatter</li> <li>mypy: Static type checking</li> </ul> <p>Before committing your code, run the following commands to check your code style:</p> <pre><code># Linting\nruff check wandas tests\n\n# Type checking\nmypy wandas tests\n</code></pre>"},{"location":"en/en/contributing/#3-testing","title":"3. Testing","text":"<p>Always add tests for new features or bug fixes. Tests are run using <code>pytest</code>:</p> <pre><code>pytest\n</code></pre> <p>To generate a coverage report:</p> <pre><code>pytest --cov=wandas tests/\n</code></pre>"},{"location":"en/en/contributing/#4-documentation","title":"4. Documentation","text":"<p>Code changes require documentation updates:</p> <ul> <li>Write NumPy-style docstrings for functions and classes</li> <li>Update or add appropriate documentation pages (tutorials, how-tos, API reference) for new features</li> <li>Add sample code to the <code>examples/</code> directory as needed</li> </ul> <p>To build and check the documentation:</p> <pre><code>cd docs\nmkdocs serve\n</code></pre> <p>Then visit http://localhost:8000 in your browser to check.</p>"},{"location":"en/en/contributing/#5-creating-a-pull-request","title":"5. Creating a Pull Request","text":"<p>Once your changes are complete, create a pull request (PR):</p> <ol> <li>Commit your changes and push to the remote repository</li> </ol> <pre><code>git add .\ngit commit -m \"Descriptive commit message\"\ngit push origin your-branch-name\n</code></pre> <ol> <li>Create a pull request on the GitHub repository page</li> <li>In the PR description, include what was changed, what issues were resolved, and how to test it</li> </ol>"},{"location":"en/en/contributing/#review-process","title":"Review Process","text":"<p>All PRs are reviewed through the following process:</p> <ol> <li>Automated CI tests must pass</li> <li>Code review by at least one maintainer</li> <li>Requested changes and responses as needed</li> <li>Merge approval</li> </ol>"},{"location":"en/en/contributing/#communication","title":"Communication","text":"<p>You can communicate for questions or discussions through:</p> <ul> <li>GitHub Issues: Bug reports and feature requests</li> <li>GitHub Discussions: General questions and discussions</li> <li>Project mailing list (if available)</li> </ul>"},{"location":"en/en/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>All participants in the project are expected to follow the Code of Conduct. Treat other contributors with respect and engage in cooperative and constructive communication.</p>"},{"location":"en/en/api/","title":"API Reference","text":"<p>This section provides detailed references for all modules, classes, and methods in the Wandas library. It includes documentation automatically generated from the library's source code.</p>"},{"location":"en/en/api/#core-components","title":"Core Components","text":""},{"location":"en/en/api/#baseframe","title":"BaseFrame","text":"<p>The <code>BaseFrame</code> class is the basic data structure unit of Wandas.</p> <pre><code>from wandas.core.base_frame import BaseFrame\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for all signal frame types.</p> <p>This class provides the common interface and functionality for all frame types used in signal processing. It implements basic operations like indexing, iteration, and data manipulation that are shared across all frame types.</p>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The signal data to process. Must be a dask array. sampling_rate : float     The sampling rate of the signal in Hz. label : str, optional     A label for the frame. If not provided, defaults to \"unnamed_frame\". metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame--attributes","title":"Attributes","text":"<p>sampling_rate : float     The sampling rate of the signal in Hz. label : str     The label of the frame. metadata : dict     Additional metadata for the frame. operation_history : list[dict]     History of operations performed on this frame.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>class BaseFrame(ABC, Generic[T]):\n    \"\"\"\n    Abstract base class for all signal frame types.\n\n    This class provides the common interface and functionality for all frame types\n    used in signal processing. It implements basic operations like indexing, iteration,\n    and data manipulation that are shared across all frame types.\n\n    Parameters\n    ----------\n    data : DaArray\n        The signal data to process. Must be a dask array.\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str, optional\n        A label for the frame. If not provided, defaults to \"unnamed_frame\".\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str\n        The label of the frame.\n    metadata : dict\n        Additional metadata for the frame.\n    operation_history : list[dict]\n        History of operations performed on this frame.\n    \"\"\"\n\n    _data: DaArray\n    sampling_rate: float\n    label: str\n    metadata: dict[str, Any]\n    operation_history: list[dict[str, Any]]\n    _channel_metadata: list[ChannelMetadata]\n    _previous: Optional[\"BaseFrame[Any]\"]\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ):\n        self._data = data.rechunk(chunks=-1)  # type: ignore [unused-ignore]\n        if self._data.ndim == 1:\n            self._data = self._data.reshape((1, -1))\n        self.sampling_rate = sampling_rate\n        self.label = label or \"unnamed_frame\"\n        self.metadata = metadata or {}\n        self.operation_history = operation_history or []\n        self._previous = previous\n\n        if channel_metadata:\n            self._channel_metadata = copy.deepcopy(channel_metadata)\n        else:\n            self._channel_metadata = [\n                ChannelMetadata(label=f\"ch{i}\", unit=\"\", extra={})\n                for i in range(self._n_channels)\n            ]\n\n        try:\n            # Display information for newer dask versions\n            logger.debug(f\"Dask graph layers: {list(self._data.dask.layers.keys())}\")\n            logger.debug(\n                f\"Dask graph dependencies: {len(self._data.dask.dependencies)}\"\n            )\n        except Exception as e:\n            logger.debug(f\"Dask graph visualization details unavailable: {e}\")\n\n    @property\n    @abstractmethod\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n\n    @property\n    def n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return len(self)\n\n    @property\n    def channels(self) -&gt; list[ChannelMetadata]:\n        \"\"\"Property to access channel metadata.\"\"\"\n        return self._channel_metadata\n\n    @property\n    def previous(self) -&gt; Optional[\"BaseFrame[Any]\"]:\n        \"\"\"\n        Returns the previous frame.\n        \"\"\"\n        return self._previous\n\n    def get_channel(self: S, channel_idx: int) -&gt; S:\n        n_channels = len(self)\n        if channel_idx &lt; 0 or channel_idx &gt;= n_channels:\n            range_max = n_channels - 1\n            raise ValueError(\n                f\"Channel index out of range: {channel_idx} \"\n                f\"(valid range: 0-{range_max})\"\n            )\n        logger.debug(f\"Extracting channel index={channel_idx} (lazy operation).\")\n        channel_data = self._data[channel_idx : channel_idx + 1]\n\n        return self._create_new_instance(\n            data=channel_data,\n            operation_history=self.operation_history,\n            channel_metadata=[self._channel_metadata[channel_idx]],\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Returns the number of channels.\n        \"\"\"\n        return len(self._channel_metadata)\n\n    def __iter__(self: S) -&gt; Iterator[S]:\n        for idx in range(len(self)):\n            yield self[idx]\n\n    def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n        \"\"\"\n        Method to get a channel by name or index.\n\n        Parameters\n        ----------\n        key : str, int, slice, or tuple of slices\n            Channel name (label) or index number.\n\n        Returns\n        -------\n        BaseFrame\n            The corresponding channel.\n\n        Raises\n        ------\n        ValueError\n            If the key length is invalid for the shape.\n        IndexError\n            If the channel index is out of range.\n        TypeError\n            If the key type is invalid.\n        \"\"\"\n        if isinstance(key, str):\n            index = self.label2index(key)\n            return self.get_channel(index)\n\n        elif isinstance(key, tuple):\n            # When key is a tuple, treat the first element as an index\n            if len(key) &gt; len(self.shape):\n                raise ValueError(\n                    f\"Invalid key length: {len(key)} for shape {self.shape}\"\n                )\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key[0]]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, slice):\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, numbers.Integral):\n            # Access by index number\n            if key &lt; 0 or key &gt;= len(self):\n                raise IndexError(f\"Channel index {key} out of range.\")\n            return self.get_channel(key)\n        else:\n            raise TypeError(\n                f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n            )\n\n    def label2index(self, label: str) -&gt; int:\n        \"\"\"\n        Get the index from a channel label.\n\n        Parameters\n        ----------\n        label : str\n            Channel label.\n\n        Returns\n        -------\n        int\n            Corresponding index.\n\n        Raises\n        ------\n        KeyError\n            If the channel label is not found.\n        \"\"\"\n        for idx, ch in enumerate(self._channel_metadata):\n            if ch.label == label:\n                return idx\n        raise KeyError(f\"Channel label '{label}' not found.\")\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        _shape: tuple[int, ...] = self._data.shape\n        return _shape\n\n    @property\n    def data(self) -&gt; T:\n        \"\"\"\n        Returns the computed data.\n        Calculation is executed the first time this is accessed.\n        \"\"\"\n        return self.compute()\n\n    @property\n    def labels(self) -&gt; list[str]:\n        \"\"\"Get a list of all channel labels.\"\"\"\n        return [ch.label for ch in self._channel_metadata]\n\n    def compute(self) -&gt; T:\n        \"\"\"\n        Compute and return the data.\n        This method materializes lazily computed data into a concrete NumPy array.\n\n        Returns\n        -------\n        NDArrayReal\n            The computed data.\n\n        Raises\n        ------\n        ValueError\n            If the computed result is not a NumPy array.\n        \"\"\"\n        logger.debug(\n            \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n        )\n        result = self._data.compute()\n\n        if not isinstance(result, np.ndarray):\n            raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n        logger.debug(f\"Computation complete, result shape: {result.shape}\")\n        return cast(T, result)\n\n    @abstractmethod\n    def plot(\n        self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n    ) -&gt; Union[Axes, Iterator[Axes]]:\n        \"\"\"Plot the data\"\"\"\n        pass\n\n    def persist(self: S) -&gt; S:\n        \"\"\"Persist the data in memory\"\"\"\n        persisted_data = self._data.persist()\n        return self._create_new_instance(data=persisted_data)\n\n    @abstractmethod\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Abstract method for derived classes to provide\n        additional initialization arguments.\n        \"\"\"\n        pass\n\n    def _create_new_instance(self: S, data: DaArray, **kwargs: Any) -&gt; S:\n        \"\"\"\n        Create a new channel instance based on an existing channel.\n        Keyword arguments can override or extend the original attributes.\n        \"\"\"\n\n        sampling_rate = kwargs.pop(\"sampling_rate\", self.sampling_rate)\n        # if not isinstance(sampling_rate, int):\n        #     raise TypeError(\"Sampling rate must be an integer\")\n\n        label = kwargs.pop(\"label\", self.label)\n        if not isinstance(label, str):\n            raise TypeError(\"Label must be a string\")\n\n        metadata = kwargs.pop(\"metadata\", copy.deepcopy(self.metadata))\n        if not isinstance(metadata, dict):\n            raise TypeError(\"Metadata must be a dictionary\")\n\n        # Get additional initialization arguments from derived classes\n        additional_kwargs = self._get_additional_init_kwargs()\n        kwargs.update(additional_kwargs)\n\n        return type(self)(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            previous=self,\n            **kwargs,\n        )\n\n    def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n        \"\"\"Implicit conversion to NumPy array\"\"\"\n        result = self.compute()\n        if dtype is not None:\n            return result.astype(dtype)\n        return result\n\n    def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n        \"\"\"Visualize the computation graph and save it to a file\"\"\"\n        try:\n            filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n            self._data.visualize(filename=filename)\n            return filename\n        except Exception as e:\n            logger.warning(f\"Failed to visualize the graph: {e}\")\n            return None\n\n    @abstractmethod\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"Basic implementation of binary operations\"\"\"\n        # Basic logic\n        # Actual implementation is left to derived classes\n        pass\n\n    def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Addition operator\"\"\"\n        return self._binary_op(other, lambda x, y: x + y, \"+\")\n\n    def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Subtraction operator\"\"\"\n        return self._binary_op(other, lambda x, y: x - y, \"-\")\n\n    def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Multiplication operator\"\"\"\n        return self._binary_op(other, lambda x, y: x * y, \"*\")\n\n    def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Division operator\"\"\"\n        return self._binary_op(other, lambda x, y: x / y, \"/\")\n\n    def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Apply a named operation.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters to pass to the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        # Apply the operation through abstract method\n        return self._apply_operation_impl(operation_name, **params)\n\n    @abstractmethod\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"Implementation of operation application\"\"\"\n        pass\n\n    def debug_info(self) -&gt; None:\n        \"\"\"Output detailed debug information\"\"\"\n        logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n        logger.debug(f\"Label: {self.label}\")\n        logger.debug(f\"Shape: {self.shape}\")\n        logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n        logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n        self._debug_info_impl()\n        logger.debug(\"=== End Debug Info ===\")\n\n    def _debug_info_impl(self) -&gt; None:\n        \"\"\"Implement derived class-specific debug information\"\"\"\n        pass\n</code></pre>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.channels","title":"<code>channels</code>  <code>property</code>","text":"<p>Property to access channel metadata.</p>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.data","title":"<code>data</code>  <code>property</code>","text":"<p>Returns the computed data. Calculation is executed the first time this is accessed.</p>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>Get a list of all channel labels.</p>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.n_channels","title":"<code>n_channels</code>  <code>property</code>","text":"<p>Returns the number of channels.</p>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.previous","title":"<code>previous</code>  <code>property</code>","text":"<p>Returns the previous frame.</p>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.__add__","title":"<code>__add__(other)</code>","text":"<p>Addition operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Addition operator\"\"\"\n    return self._binary_op(other, lambda x, y: x + y, \"+\")\n</code></pre>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.__array__","title":"<code>__array__(dtype=None)</code>","text":"<p>Implicit conversion to NumPy array</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n    \"\"\"Implicit conversion to NumPy array\"\"\"\n    result = self.compute()\n    if dtype is not None:\n        return result.astype(dtype)\n    return result\n</code></pre>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Method to get a channel by name or index.</p>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.__getitem__--parameters","title":"Parameters","text":"<p>key : str, int, slice, or tuple of slices     Channel name (label) or index number.</p>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.__getitem__--returns","title":"Returns","text":"<p>BaseFrame     The corresponding channel.</p>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.__getitem__--raises","title":"Raises","text":"<p>ValueError     If the key length is invalid for the shape. IndexError     If the channel index is out of range. TypeError     If the key type is invalid.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n    \"\"\"\n    Method to get a channel by name or index.\n\n    Parameters\n    ----------\n    key : str, int, slice, or tuple of slices\n        Channel name (label) or index number.\n\n    Returns\n    -------\n    BaseFrame\n        The corresponding channel.\n\n    Raises\n    ------\n    ValueError\n        If the key length is invalid for the shape.\n    IndexError\n        If the channel index is out of range.\n    TypeError\n        If the key type is invalid.\n    \"\"\"\n    if isinstance(key, str):\n        index = self.label2index(key)\n        return self.get_channel(index)\n\n    elif isinstance(key, tuple):\n        # When key is a tuple, treat the first element as an index\n        if len(key) &gt; len(self.shape):\n            raise ValueError(\n                f\"Invalid key length: {len(key)} for shape {self.shape}\"\n            )\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key[0]]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, slice):\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, numbers.Integral):\n        # Access by index number\n        if key &lt; 0 or key &gt;= len(self):\n            raise IndexError(f\"Channel index {key} out of range.\")\n        return self.get_channel(key)\n    else:\n        raise TypeError(\n            f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n        )\n</code></pre>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of channels.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of channels.\n    \"\"\"\n    return len(self._channel_metadata)\n</code></pre>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplication operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Multiplication operator\"\"\"\n    return self._binary_op(other, lambda x, y: x * y, \"*\")\n</code></pre>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtraction operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Subtraction operator\"\"\"\n    return self._binary_op(other, lambda x, y: x - y, \"-\")\n</code></pre>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Division operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Division operator\"\"\"\n    return self._binary_op(other, lambda x, y: x / y, \"/\")\n</code></pre>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.apply_operation","title":"<code>apply_operation(operation_name, **params)</code>","text":"<p>Apply a named operation.</p>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.apply_operation--parameters","title":"Parameters","text":"<p>operation_name : str     Name of the operation to apply. **params : Any     Parameters to pass to the operation.</p>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.apply_operation--returns","title":"Returns","text":"<p>S     A new instance with the operation applied.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n    \"\"\"\n    Apply a named operation.\n\n    Parameters\n    ----------\n    operation_name : str\n        Name of the operation to apply.\n    **params : Any\n        Parameters to pass to the operation.\n\n    Returns\n    -------\n    S\n        A new instance with the operation applied.\n    \"\"\"\n    # Apply the operation through abstract method\n    return self._apply_operation_impl(operation_name, **params)\n</code></pre>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.compute","title":"<code>compute()</code>","text":"<p>Compute and return the data. This method materializes lazily computed data into a concrete NumPy array.</p>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.compute--returns","title":"Returns","text":"<p>NDArrayReal     The computed data.</p>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.compute--raises","title":"Raises","text":"<p>ValueError     If the computed result is not a NumPy array.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def compute(self) -&gt; T:\n    \"\"\"\n    Compute and return the data.\n    This method materializes lazily computed data into a concrete NumPy array.\n\n    Returns\n    -------\n    NDArrayReal\n        The computed data.\n\n    Raises\n    ------\n    ValueError\n        If the computed result is not a NumPy array.\n    \"\"\"\n    logger.debug(\n        \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n    )\n    result = self._data.compute()\n\n    if not isinstance(result, np.ndarray):\n        raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n    logger.debug(f\"Computation complete, result shape: {result.shape}\")\n    return cast(T, result)\n</code></pre>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.debug_info","title":"<code>debug_info()</code>","text":"<p>Output detailed debug information</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def debug_info(self) -&gt; None:\n    \"\"\"Output detailed debug information\"\"\"\n    logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n    logger.debug(f\"Label: {self.label}\")\n    logger.debug(f\"Shape: {self.shape}\")\n    logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n    logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n    self._debug_info_impl()\n    logger.debug(\"=== End Debug Info ===\")\n</code></pre>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.label2index","title":"<code>label2index(label)</code>","text":"<p>Get the index from a channel label.</p>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.label2index--parameters","title":"Parameters","text":"<p>label : str     Channel label.</p>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.label2index--returns","title":"Returns","text":"<p>int     Corresponding index.</p>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.label2index--raises","title":"Raises","text":"<p>KeyError     If the channel label is not found.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def label2index(self, label: str) -&gt; int:\n    \"\"\"\n    Get the index from a channel label.\n\n    Parameters\n    ----------\n    label : str\n        Channel label.\n\n    Returns\n    -------\n    int\n        Corresponding index.\n\n    Raises\n    ------\n    KeyError\n        If the channel label is not found.\n    \"\"\"\n    for idx, ch in enumerate(self._channel_metadata):\n        if ch.label == label:\n            return idx\n    raise KeyError(f\"Channel label '{label}' not found.\")\n</code></pre>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.persist","title":"<code>persist()</code>","text":"<p>Persist the data in memory</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def persist(self: S) -&gt; S:\n    \"\"\"Persist the data in memory\"\"\"\n    persisted_data = self._data.persist()\n    return self._create_new_instance(data=persisted_data)\n</code></pre>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.plot","title":"<code>plot(plot_type='default', ax=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Plot the data</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>@abstractmethod\ndef plot(\n    self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n) -&gt; Union[Axes, Iterator[Axes]]:\n    \"\"\"Plot the data\"\"\"\n    pass\n</code></pre>"},{"location":"en/en/api/#wandas.core.base_frame.BaseFrame.visualize_graph","title":"<code>visualize_graph(filename=None)</code>","text":"<p>Visualize the computation graph and save it to a file</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"Visualize the computation graph and save it to a file\"\"\"\n    try:\n        filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n        self._data.visualize(filename=filename)\n        return filename\n    except Exception as e:\n        logger.warning(f\"Failed to visualize the graph: {e}\")\n        return None\n</code></pre>"},{"location":"en/en/api/#frame-module","title":"Frame Module","text":""},{"location":"en/en/api/#channelframe","title":"ChannelFrame","text":"<p><code>ChannelFrame</code> is a class that handles time-domain signal data.</p> <pre><code>from wandas.frames.channel import ChannelFrame\n</code></pre> <p>You can also import it directly:</p> <pre><code>import wandas\n# Use it as follows\nframe = wandas.read_wav(\"audio.wav\")\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Channel-based data frame for handling audio signals and time series data.</p> <p>This frame represents channel-based data such as audio signals and time series data, with each channel containing data samples in the time domain.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>class ChannelFrame(BaseFrame[NDArrayReal]):\n    \"\"\"Channel-based data frame for handling audio signals and time series data.\n\n    This frame represents channel-based data such as audio signals and time series data,\n    with each channel containing data samples in the time domain.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"Initialize a ChannelFrame.\n\n        Args:\n            data: Dask array containing channel data.\n            Shape should be (n_channels, n_samples).\n            sampling_rate: The sampling rate of the data in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            operation_history: History of operations applied to the frame.\n            channel_metadata: Metadata for each channel.\n            previous: Reference to the previous frame in the processing chain.\n\n        Raises:\n            ValueError: If data has more than 2 dimensions.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return self.shape[-2]\n\n    @property\n    def time(self) -&gt; NDArrayReal:\n        \"\"\"Get time array for the signal.\n\n        Returns:\n            Array of time points in seconds.\n        \"\"\"\n        return np.arange(self.n_samples) / self.sampling_rate\n\n    @property\n    def n_samples(self) -&gt; int:\n        \"\"\"Returns the number of samples.\"\"\"\n        n: int = self._data.shape[-1]\n        return n\n\n    @property\n    def duration(self) -&gt; float:\n        \"\"\"Returns the duration in seconds.\"\"\"\n        return self.n_samples / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # Apply processing to data\n        processed_data = operation.process(self._data)\n\n        # Update metadata\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        if operation_name == \"resampling\":\n            # For resampling, update sampling rate\n            return self._create_new_instance(\n                sampling_rate=params[\"target_sr\"],\n                data=processed_data,\n                metadata=new_metadata,\n                operation_history=new_history,\n            )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Common implementation for binary operations\n        - utilizing dask's lazy evaluation.\n\n        Args:\n            other: Right operand for the operation.\n            op: Function to execute the operation (e.g., lambda a, b: a + b).\n            symbol: Symbolic representation of the operation (e.g., '+').\n\n        Returns:\n            A new channel containing the operation result (lazy execution).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, ChannelFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Perform operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other._data)\n\n            # Merge channel metadata\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # Perform operation with scalar, NumPy array, or other types\n        else:\n            # Apply operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other)\n\n            # Operand display string\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # Check for dask.array.Array\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # Update channel metadata\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n                previous=self,\n            )\n\n    def add(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        snr: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Add another signal or value to the current signal.\n\n        If SNR is specified, performs addition with consideration for\n        signal-to-noise ratio.\n\n        Args:\n            other: Signal or value to add.\n            snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n                other signal based on this SNR.\n                self is treated as the signal, and other as the noise.\n\n        Returns:\n            A new channel frame containing the addition result (lazy execution).\n        \"\"\"\n        logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n        # Special processing when SNR is specified\n        if snr is not None:\n            # First convert other to ChannelFrame if it's not\n            if not isinstance(other, ChannelFrame):\n                if isinstance(other, np.ndarray):\n                    other = ChannelFrame.from_numpy(\n                        other, self.sampling_rate, label=\"array_data\"\n                    )\n                elif isinstance(other, (int, float)):\n                    # For scalar values, simply add (ignore SNR)\n                    return self + other\n                else:\n                    raise TypeError(\n                        \"Addition target with SNR must be a ChannelFrame or \"\n                        f\"NumPy array: {type(other)}\"\n                    )\n\n            # Check if sampling rates match\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Apply addition operation with SNR adjustment\n            return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n        # Execute normal addition if SNR is not specified\n        return self + other\n\n    def plot(\n        self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Plot the frame data.\n\n        Args:\n            plot_type: Type of plot. Default is \"waveform\".\n            ax: Optional matplotlib axes for plotting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        plot_strategy = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def rms_plot(\n        self,\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = True,\n        Aw: bool = False,  # noqa: N803\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Generate an RMS plot.\n\n        Args:\n            ax: Optional matplotlib axes for plotting.\n            title: Title for the plot.\n            overlay: Whether to overlay the plot on the existing axis.\n            Aw: Apply A-weighting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        kwargs = kwargs or {}\n        ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n        rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n        return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n\n    def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n        \"\"\"Display visual and audio representation of the frame.\n\n        Args:\n            normalize: Whether to normalize the audio data for playback.\n            **kwargs: Additional parameters for visualization.\n        \"\"\"\n        if \"axis_config\" in kwargs:\n            logger.warning(\n                \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            axis_config = kwargs[\"axis_config\"]\n            if \"time_plot\" in axis_config:\n                kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n            if \"freq_plot\" in axis_config:\n                if \"xlim\" in axis_config[\"freq_plot\"]:\n                    vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                    kwargs[\"vmin\"] = vlim[0]\n                    kwargs[\"vmax\"] = vlim[1]\n                if \"ylim\" in axis_config[\"freq_plot\"]:\n                    ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                    kwargs[\"ylim\"] = ylim\n\n        if \"cbar_config\" in kwargs:\n            logger.warning(\n                \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            cbar_config = kwargs[\"cbar_config\"]\n            if \"vmin\" in cbar_config:\n                kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n            if \"vmax\" in cbar_config:\n                kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n        for ch in self:\n            ax: Axes\n            _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n            if isinstance(_ax, Iterator):\n                ax = next(iter(_ax))\n            elif isinstance(_ax, Axes):\n                ax = _ax\n            else:\n                raise TypeError(\n                    f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n                )\n            # Ignore type checks for display and Audio\n            display(ax.figure)  # type: ignore\n            plt.close(ax.figure)  # type: ignore\n            display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n\n    @classmethod\n    def from_numpy(\n        cls,\n        data: NDArrayReal,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        ch_labels: Optional[list[str]] = None,\n        ch_units: Optional[Union[list[str], str]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        Args:\n            data: NumPy array containing channel data.\n            sampling_rate: The sampling rate in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            ch_labels: Labels for each channel.\n            ch_units: Units for each channel.\n\n        Returns:\n            A new ChannelFrame containing the NumPy data.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n\n        # Convert NumPy array to dask array\n        dask_data = da_from_array(data)\n        cf = ChannelFrame(\n            data=dask_data,\n            sampling_rate=sampling_rate,\n            label=label or \"numpy_data\",\n        )\n        if metadata is not None:\n            cf.metadata = metadata\n        if ch_labels is not None:\n            if len(ch_labels) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel labels does not match the number of channels\"\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        if ch_units is not None:\n            if isinstance(ch_units, str):\n                ch_units = [ch_units] * cf.n_channels\n\n            if len(ch_units) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel units does not match the number of channels\"\n                )\n            for i in range(len(ch_units)):\n                cf._channel_metadata[i].unit = ch_units[i]\n\n        return cf\n\n    @classmethod\n    def from_ndarray(\n        cls,\n        array: NDArrayReal,\n        sampling_rate: float,\n        labels: Optional[list[str]] = None,\n        unit: Optional[Union[list[str], str]] = None,\n        frame_label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        This method is deprecated. Use from_numpy instead.\n\n        Args:\n            array: Signal data. Each row corresponds to a channel.\n            sampling_rate: Sampling rate (Hz).\n            labels: Labels for each channel.\n            unit: Unit of the signal.\n            frame_label: Label for the frame.\n            metadata: Optional metadata dictionary.\n\n        Returns:\n            A new ChannelFrame containing the data.\n        \"\"\"\n        # Redirect to from_numpy for compatibility\n        # However, from_ndarray is deprecated\n        logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n        return cls.from_numpy(\n            data=array,\n            sampling_rate=sampling_rate,\n            label=frame_label,\n            metadata=metadata,\n            ch_labels=labels,\n            ch_units=unit,\n        )\n\n    @classmethod\n    def from_file(\n        cls,\n        path: Union[str, Path],\n        channel: Optional[Union[int, list[int]]] = None,\n        start: Optional[float] = None,\n        end: Optional[float] = None,\n        chunk_size: Optional[int] = None,\n        ch_labels: Optional[list[str]] = None,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from an audio file.\n\n        Args:\n            path: Path to the audio file.\n            channel: Channel(s) to load.\n            start: Start time in seconds.\n            end: End time in seconds.\n            chunk_size: Chunk size for processing.\n            Specifies the splitting size for lazy processing.\n            ch_labels: Labels for each channel.\n            **kwargs: Additional arguments passed to the file reader.\n\n        Returns:\n            A new ChannelFrame containing the loaded audio data.\n\n        Raises:\n            ValueError: If channel selection is invalid.\n            TypeError: If channel parameter type is invalid.\n            FileNotFoundError: If the file doesn't exist.\n        \"\"\"\n        from .channel import ChannelFrame\n\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"File not found: {path}\")\n\n        # Get file reader\n        reader = get_file_reader(path)\n\n        # Get file info\n        info = reader.get_file_info(path, **kwargs)\n        sr = info[\"samplerate\"]\n        n_channels = info[\"channels\"]\n        n_frames = info[\"frames\"]\n        ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n        logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n        # Channel selection processing\n        all_channels = list(range(n_channels))\n\n        if channel is None:\n            channels_to_load = all_channels\n            logger.debug(f\"Will load all channels: {channels_to_load}\")\n        elif isinstance(channel, int):\n            if channel &lt; 0 or channel &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n            channels_to_load = [channel]\n            logger.debug(f\"Will load single channel: {channel}\")\n        elif isinstance(channel, (list, tuple)):\n            for ch in channel:\n                if ch &lt; 0 or ch &gt;= n_channels:\n                    raise ValueError(\n                        f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                    )\n            channels_to_load = list(channel)\n            logger.debug(f\"Will load specific channels: {channels_to_load}\")\n        else:\n            raise TypeError(\"channel must be int, list, or None\")\n\n        # Index calculation\n        start_idx = 0 if start is None else max(0, int(start * sr))\n        end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n        frames_to_read = end_idx - start_idx\n\n        logger.debug(\n            f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n            f\"start_idx={start_idx}, end_idx={end_idx}\"\n        )\n\n        # Settings for lazy loading\n        expected_shape = (len(channels_to_load), frames_to_read)\n\n        # Define the loading function using the file reader\n        def _load_audio() -&gt; NDArrayReal:\n            logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n            # Use the reader to get audio data with parameters\n            out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n            if not isinstance(out, np.ndarray):\n                raise ValueError(\"Unexpected data type after reading file\")\n            return out\n\n        logger.debug(\n            f\"Creating delayed dask task with expected shape: {expected_shape}\"\n        )\n\n        # Create delayed operation\n        delayed_data = dask_delayed(_load_audio)()\n        logger.debug(\"Wrapping delayed function in dask array\")\n\n        # Create dask array from delayed computation\n        dask_array = da_from_delayed(\n            delayed_data, shape=expected_shape, dtype=np.float32\n        )\n\n        if chunk_size is not None:\n            if chunk_size &lt;= 0:\n                raise ValueError(\"Chunk size must be a positive integer\")\n            logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n            dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n        logger.debug(\n            \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n        )\n\n        cf = ChannelFrame(\n            data=dask_array,\n            sampling_rate=sr,\n            label=path.stem,\n            metadata={\n                \"filename\": str(path),\n            },\n        )\n        if ch_labels is not None:\n            if len(ch_labels) != len(cf):\n                raise ValueError(\n                    \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        return cf\n\n    @classmethod\n    def read_wav(\n        cls, filename: str, labels: Optional[list[str]] = None\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a WAV file.\n\n        Args:\n            filename: Path to the WAV file.\n            labels: Labels to set for each channel.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(filename, ch_labels=labels)\n        return cf\n\n    @classmethod\n    def read_csv(\n        cls,\n        filename: str,\n        time_column: Union[int, str] = 0,\n        labels: Optional[list[str]] = None,\n        delimiter: str = \",\",\n        header: Optional[int] = 0,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a CSV file.\n\n        Args:\n            filename: Path to the CSV file.\n            time_column: Index or name of the time column.\n            labels: Labels to set for each channel.\n            delimiter: Delimiter character.\n            header: Row number to use as header.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(\n            filename,\n            ch_labels=labels,\n            time_column=time_column,\n            delimiter=delimiter,\n            header=header,\n        )\n        return cf\n\n    def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n        \"\"\"Save the audio data to a file.\n\n        Args:\n            path: Path to save the file.\n            format: File format. If None, determined from file extension.\n        \"\"\"\n        logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n        data = self.compute()\n        data = data.T\n        if data.shape[1] == 1:\n            data = data.squeeze(axis=1)\n        sf.write(str(path), data, int(self.sampling_rate), format=format)\n        logger.debug(f\"Save complete: {path}\")\n\n    def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a high-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n\n    def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a low-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n\n    def normalize(\n        self, target_level: float = -20, channel_wise: bool = True\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Normalize the signal level.\n\n        This method adjusts the signal amplitude to reach a target RMS level.\n\n        Args:\n            target_level: Target RMS level in dB. Default is -20.\n            channel_wise: If True, normalize each channel independently.\n                If False, apply the same scaling to all channels.\n\n        Returns:\n            A new ChannelFrame containing the normalized signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n        )\n        return self.apply_operation(\n            \"normalize\", target_level=target_level, channel_wise=channel_wise\n        )\n\n    def a_weighting(self) -&gt; \"ChannelFrame\":\n        \"\"\"Apply A-weighting filter to the signal.\n\n        A-weighting adjusts the frequency response to approximate human hearing\n        perception, following IEC 61672-1:2013 standard.\n\n        Returns:\n            A new ChannelFrame with A-weighted signal.\n        \"\"\"\n        return self.apply_operation(\"a_weighting\")\n\n    def hpss_harmonic(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract harmonic components using HPSS\n         (Harmonic-Percussive Source Separation).\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_harmonic\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def hpss_percussive(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract percussive components using HPSS\n        (Harmonic-Percussive Source Separation).\n\n        This method separates the percussive (tonal) components from the signal.\n\n        Args:\n            kernel_size: Median filter size for HPSS.\n            power: Exponent for the Weiner filter used in HPSS.\n            margin: Margin size for the separation.\n\n        Returns:\n            A new ChannelFrame containing the harmonic components.\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_percussive\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def resampling(\n        self,\n        target_sr: float,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Resample audio data.\n\n        Parameters\n        ----------\n        target_sr : float\n            Target sampling rate (Hz)\n        resample_type : str, optional\n            Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n        **kwargs : dict\n            Additional resampling parameters\n\n        Returns\n        -------\n        ChannelFrame\n            Resampled channel frame\n        \"\"\"\n        return self.apply_operation(\n            \"resampling\",\n            target_sr=target_sr,\n            **kwargs,\n        )\n\n    def abs(self) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the absolute value of the signal.\n\n        Returns:\n            A new ChannelFrame containing the absolute values.\n        \"\"\"\n        return self.apply_operation(\"abs\")\n\n    def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the power of the signal.\n\n        Args:\n            exponent: The exponent to raise the signal to. Default is 2.0.\n\n        Returns:\n            A new ChannelFrame containing the signal raised to the power.\n        \"\"\"\n        return self.apply_operation(\"power\", exponent=exponent)\n\n    def trim(\n        self,\n        start: float = 0,\n        end: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Trim the signal to specified time range.\n\n        Args:\n            start: Start time in seconds.\n            end: End time in seconds.\n\n        Returns:\n            A new ChannelFrame with trimmed signal.\n\n        Raises:\n            ValueError: If end time is before start time.\n        \"\"\"\n        if end is None:\n            end = self.duration\n        if start &gt; end:\n            raise ValueError(\"start must be less than end\")\n        # Apply trim operation\n        return self.apply_operation(\"trim\", start=start, end=end)\n\n    def rms_trend(\n        self,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the RMS trend of the signal.\n\n        This method computes the root mean square value over sliding windows.\n\n        Args:\n            frame_length: The size of the sliding window in samples. Default is 2048.\n            hop_length: The hop length between windows in samples. Default is 512.\n            dB: Whether to return the RMS values in decibels. Default is False.\n            Aw: Whether to apply A-weighting. Default is False.\n\n        Returns:\n            A new ChannelFrame containing the RMS trend.\n        \"\"\"\n        cf = self.apply_operation(\n            \"rms_trend\",\n            frame_length=frame_length,\n            hop_length=hop_length,\n            ref=[ch.ref for ch in self._channel_metadata],\n            dB=dB,\n            Aw=Aw,\n        )\n        cf.sampling_rate = self.sampling_rate / hop_length\n        return cf\n\n    def sum(self) -&gt; \"ChannelFrame\":\n        \"\"\"Sum all channels.\n\n        Returns:\n            A new ChannelFrame with summed signal.\n        \"\"\"\n        return self.apply_operation(\"sum\")\n\n    def mean(self) -&gt; \"ChannelFrame\":\n        \"\"\"Average all channels.\n\n        Returns:\n            A new ChannelFrame with averaged signal.\n        \"\"\"\n        return self.apply_operation(\"mean\")\n\n    def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate channel differences relative to a reference channel.\n\n        Args:\n            other_channel: Reference channel index or label. Default is 0.\n\n        Returns:\n            A new ChannelFrame with channel differences.\n        \"\"\"\n        if isinstance(other_channel, str):\n            return self.apply_operation(\n                \"channel_difference\", other_channel=self.label2index(other_channel)\n            )\n        return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n\n    def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n        \"\"\"Compute Fast Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is next power of 2 of data length.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectralFrame containing the FFT results.\n        \"\"\"\n        from ..processing.time_series import FFT\n        from .spectral import SpectralFrame\n\n        params = {\"n_fft\": n_fft, \"window\": window}\n        operation_name = \"fft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"FFT\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        if n_fft is None:\n            is_even = spectrum_data.shape[-1] % 2 == 0\n            _n_fft = (\n                spectrum_data.shape[-1] * 2 - 2\n                if is_even\n                else spectrum_data.shape[-1] * 2 - 1\n            )\n        else:\n            _n_fft = n_fft\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=_n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def welch(\n        self,\n        n_fft: Optional[int] = None,\n        hop_length: Optional[int] = None,\n        win_length: int = 2048,\n        window: str = \"hann\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute power spectral density using Welch's method.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the power spectral density.\n        \"\"\"\n        from ..processing.time_series import Welch\n        from .spectral import SpectralFrame\n\n        params = dict(\n            n_fft=n_fft or win_length,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            average=average,\n        )\n        operation_name = \"welch\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Welch\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"welch\", \"params\": params},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def noct_spectrum(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"Compute N-octave band spectrum.\n\n        Args:\n            fmin: Minimum center frequency in Hz. Default is 20 Hz.\n            fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n            n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n            G: Reference gain in dB. Default is 10 dB.\n            fr: Reference frequency in Hz. Default is 1000 Hz.\n\n        Returns:\n            A NOctFrame containing the N-octave band spectrum.\n        \"\"\"\n        from ..processing.time_series import NOctSpectrum\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_spectrum\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSpectrum\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_spectrum\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def stft(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"Compute Short-Time Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectrogramFrame containing the STFT results.\n        \"\"\"\n        from ..processing.time_series import STFT, create_operation\n        from .spectrogram import SpectrogramFrame\n\n        # Set hop length and window length\n        _hop_length = hop_length if hop_length is not None else n_fft // 4\n        _win_length = win_length if win_length is not None else n_fft\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": _hop_length,\n            \"win_length\": _win_length,\n            \"window\": window,\n        }\n        operation_name = \"stft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"STFT\", operation)\n\n        # Apply processing to data\n        spectrogram_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n\n        # Create new instance\n        return SpectrogramFrame(\n            data=spectrogram_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=n_fft,\n            hop_length=_hop_length,\n            win_length=_win_length,\n            window=window,\n            label=f\"stft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def coherence(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute magnitude squared coherence.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n        Returns:\n            A SpectralFrame containing the magnitude squared coherence.\n        \"\"\"\n        from ..processing.time_series import Coherence, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n        }\n        operation_name = \"coherence\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Coherence\", operation)\n\n        # Apply processing to data\n        coherence_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=coherence_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Coherence of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def csd(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute cross-spectral density matrix.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the cross-spectral density matrix.\n        \"\"\"\n        from ..processing.time_series import CSD, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"csd\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"CSD\", operation)\n\n        # Apply processing to data\n        csd_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=csd_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def transfer_function(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute transfer function matrix.\n\n        The transfer function characterizes the signal transmission properties\n        between channels in the frequency domain, representing the input-output\n        relationship of a system.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the transfer function matrix.\n        \"\"\"\n        from ..processing.time_series import TransferFunction, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"transfer_function\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"TransferFunction\", operation)\n\n        # Apply processing to data\n        tf_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=tf_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Transfer function of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"Provide additional initialization arguments required for ChannelFrame.\"\"\"\n        return {}\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Returns the duration in seconds.</p>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>Returns the number of samples.</p>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.time","title":"<code>time</code>  <code>property</code>","text":"<p>Get time array for the signal.</p> <p>Returns:</p> Type Description <code>NDArrayReal</code> <p>Array of time points in seconds.</p>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.__init__","title":"<code>__init__(data, sampling_rate, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a ChannelFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>Dask array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate of the data in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>operation_history</code> <code>Optional[list[dict[str, Any]]]</code> <p>History of operations applied to the frame.</p> <code>None</code> <code>channel_metadata</code> <code>Optional[list[ChannelMetadata]]</code> <p>Metadata for each channel.</p> <code>None</code> <code>previous</code> <code>Optional[BaseFrame[Any]]</code> <p>Reference to the previous frame in the processing chain.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has more than 2 dimensions.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"Initialize a ChannelFrame.\n\n    Args:\n        data: Dask array containing channel data.\n        Shape should be (n_channels, n_samples).\n        sampling_rate: The sampling rate of the data in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        operation_history: History of operations applied to the frame.\n        channel_metadata: Metadata for each channel.\n        previous: Reference to the previous frame in the processing chain.\n\n    Raises:\n        ValueError: If data has more than 2 dimensions.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.a_weighting","title":"<code>a_weighting()</code>","text":"<p>Apply A-weighting filter to the signal.</p> <p>A-weighting adjusts the frequency response to approximate human hearing perception, following IEC 61672-1:2013 standard.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with A-weighted signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def a_weighting(self) -&gt; \"ChannelFrame\":\n    \"\"\"Apply A-weighting filter to the signal.\n\n    A-weighting adjusts the frequency response to approximate human hearing\n    perception, following IEC 61672-1:2013 standard.\n\n    Returns:\n        A new ChannelFrame with A-weighted signal.\n    \"\"\"\n    return self.apply_operation(\"a_weighting\")\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.abs","title":"<code>abs()</code>","text":"<p>Calculate the absolute value of the signal.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the absolute values.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def abs(self) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the absolute value of the signal.\n\n    Returns:\n        A new ChannelFrame containing the absolute values.\n    \"\"\"\n    return self.apply_operation(\"abs\")\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.add","title":"<code>add(other, snr=None)</code>","text":"<p>Add another signal or value to the current signal.</p> <p>If SNR is specified, performs addition with consideration for signal-to-noise ratio.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[ChannelFrame, int, float, NDArrayReal, Array]</code> <p>Signal or value to add.</p> required <code>snr</code> <code>Optional[float]</code> <p>Signal-to-noise ratio (dB). If specified, adjusts the scale of the other signal based on this SNR. self is treated as the signal, and other as the noise.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new channel frame containing the addition result (lazy execution).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def add(\n    self,\n    other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n    snr: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Add another signal or value to the current signal.\n\n    If SNR is specified, performs addition with consideration for\n    signal-to-noise ratio.\n\n    Args:\n        other: Signal or value to add.\n        snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n            other signal based on this SNR.\n            self is treated as the signal, and other as the noise.\n\n    Returns:\n        A new channel frame containing the addition result (lazy execution).\n    \"\"\"\n    logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n    # Special processing when SNR is specified\n    if snr is not None:\n        # First convert other to ChannelFrame if it's not\n        if not isinstance(other, ChannelFrame):\n            if isinstance(other, np.ndarray):\n                other = ChannelFrame.from_numpy(\n                    other, self.sampling_rate, label=\"array_data\"\n                )\n            elif isinstance(other, (int, float)):\n                # For scalar values, simply add (ignore SNR)\n                return self + other\n            else:\n                raise TypeError(\n                    \"Addition target with SNR must be a ChannelFrame or \"\n                    f\"NumPy array: {type(other)}\"\n                )\n\n        # Check if sampling rates match\n        if self.sampling_rate != other.sampling_rate:\n            raise ValueError(\n                \"Sampling rates do not match. Cannot perform operation.\"\n            )\n\n        # Apply addition operation with SNR adjustment\n        return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n    # Execute normal addition if SNR is not specified\n    return self + other\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.channel_difference","title":"<code>channel_difference(other_channel=0)</code>","text":"<p>Calculate channel differences relative to a reference channel.</p> <p>Parameters:</p> Name Type Description Default <code>other_channel</code> <code>Union[int, str]</code> <p>Reference channel index or label. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with channel differences.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate channel differences relative to a reference channel.\n\n    Args:\n        other_channel: Reference channel index or label. Default is 0.\n\n    Returns:\n        A new ChannelFrame with channel differences.\n    \"\"\"\n    if isinstance(other_channel, str):\n        return self.apply_operation(\n            \"channel_difference\", other_channel=self.label2index(other_channel)\n        )\n    return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.coherence","title":"<code>coherence(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant')</code>","text":"<p>Compute magnitude squared coherence.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the magnitude squared coherence.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def coherence(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute magnitude squared coherence.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n    Returns:\n        A SpectralFrame containing the magnitude squared coherence.\n    \"\"\"\n    from ..processing.time_series import Coherence, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n    }\n    operation_name = \"coherence\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Coherence\", operation)\n\n    # Apply processing to data\n    coherence_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=coherence_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Coherence of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.csd","title":"<code>csd(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute cross-spectral density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the cross-spectral density matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def csd(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute cross-spectral density matrix.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the cross-spectral density matrix.\n    \"\"\"\n    from ..processing.time_series import CSD, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"csd\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"CSD\", operation)\n\n    # Apply processing to data\n    csd_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=csd_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.describe","title":"<code>describe(normalize=True, **kwargs)</code>","text":"<p>Display visual and audio representation of the frame.</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>Whether to normalize the audio data for playback.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for visualization.</p> <code>{}</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n    \"\"\"Display visual and audio representation of the frame.\n\n    Args:\n        normalize: Whether to normalize the audio data for playback.\n        **kwargs: Additional parameters for visualization.\n    \"\"\"\n    if \"axis_config\" in kwargs:\n        logger.warning(\n            \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        axis_config = kwargs[\"axis_config\"]\n        if \"time_plot\" in axis_config:\n            kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n        if \"freq_plot\" in axis_config:\n            if \"xlim\" in axis_config[\"freq_plot\"]:\n                vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                kwargs[\"vmin\"] = vlim[0]\n                kwargs[\"vmax\"] = vlim[1]\n            if \"ylim\" in axis_config[\"freq_plot\"]:\n                ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                kwargs[\"ylim\"] = ylim\n\n    if \"cbar_config\" in kwargs:\n        logger.warning(\n            \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        cbar_config = kwargs[\"cbar_config\"]\n        if \"vmin\" in cbar_config:\n            kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n        if \"vmax\" in cbar_config:\n            kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n    for ch in self:\n        ax: Axes\n        _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n        if isinstance(_ax, Iterator):\n            ax = next(iter(_ax))\n        elif isinstance(_ax, Axes):\n            ax = _ax\n        else:\n            raise TypeError(\n                f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n            )\n        # Ignore type checks for display and Audio\n        display(ax.figure)  # type: ignore\n        plt.close(ax.figure)  # type: ignore\n        display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.fft","title":"<code>fft(n_fft=None, window='hann')</code>","text":"<p>Compute Fast Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is next power of 2 of data length.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the FFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n    \"\"\"Compute Fast Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is next power of 2 of data length.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectralFrame containing the FFT results.\n    \"\"\"\n    from ..processing.time_series import FFT\n    from .spectral import SpectralFrame\n\n    params = {\"n_fft\": n_fft, \"window\": window}\n    operation_name = \"fft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"FFT\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    if n_fft is None:\n        is_even = spectrum_data.shape[-1] % 2 == 0\n        _n_fft = (\n            spectrum_data.shape[-1] * 2 - 2\n            if is_even\n            else spectrum_data.shape[-1] * 2 - 1\n        )\n    else:\n        _n_fft = n_fft\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=_n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.from_file","title":"<code>from_file(path, channel=None, start=None, end=None, chunk_size=None, ch_labels=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from an audio file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the audio file.</p> required <code>channel</code> <code>Optional[Union[int, list[int]]]</code> <p>Channel(s) to load.</p> <code>None</code> <code>start</code> <code>Optional[float]</code> <p>Start time in seconds.</p> <code>None</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <code>chunk_size</code> <code>Optional[int]</code> <p>Chunk size for processing.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the file reader.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the loaded audio data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If channel selection is invalid.</p> <code>TypeError</code> <p>If channel parameter type is invalid.</p> <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    path: Union[str, Path],\n    channel: Optional[Union[int, list[int]]] = None,\n    start: Optional[float] = None,\n    end: Optional[float] = None,\n    chunk_size: Optional[int] = None,\n    ch_labels: Optional[list[str]] = None,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from an audio file.\n\n    Args:\n        path: Path to the audio file.\n        channel: Channel(s) to load.\n        start: Start time in seconds.\n        end: End time in seconds.\n        chunk_size: Chunk size for processing.\n        Specifies the splitting size for lazy processing.\n        ch_labels: Labels for each channel.\n        **kwargs: Additional arguments passed to the file reader.\n\n    Returns:\n        A new ChannelFrame containing the loaded audio data.\n\n    Raises:\n        ValueError: If channel selection is invalid.\n        TypeError: If channel parameter type is invalid.\n        FileNotFoundError: If the file doesn't exist.\n    \"\"\"\n    from .channel import ChannelFrame\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    # Get file reader\n    reader = get_file_reader(path)\n\n    # Get file info\n    info = reader.get_file_info(path, **kwargs)\n    sr = info[\"samplerate\"]\n    n_channels = info[\"channels\"]\n    n_frames = info[\"frames\"]\n    ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n    logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n    # Channel selection processing\n    all_channels = list(range(n_channels))\n\n    if channel is None:\n        channels_to_load = all_channels\n        logger.debug(f\"Will load all channels: {channels_to_load}\")\n    elif isinstance(channel, int):\n        if channel &lt; 0 or channel &gt;= n_channels:\n            raise ValueError(\n                f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n            )\n        channels_to_load = [channel]\n        logger.debug(f\"Will load single channel: {channel}\")\n    elif isinstance(channel, (list, tuple)):\n        for ch in channel:\n            if ch &lt; 0 or ch &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n        channels_to_load = list(channel)\n        logger.debug(f\"Will load specific channels: {channels_to_load}\")\n    else:\n        raise TypeError(\"channel must be int, list, or None\")\n\n    # Index calculation\n    start_idx = 0 if start is None else max(0, int(start * sr))\n    end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n    frames_to_read = end_idx - start_idx\n\n    logger.debug(\n        f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n        f\"start_idx={start_idx}, end_idx={end_idx}\"\n    )\n\n    # Settings for lazy loading\n    expected_shape = (len(channels_to_load), frames_to_read)\n\n    # Define the loading function using the file reader\n    def _load_audio() -&gt; NDArrayReal:\n        logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n        # Use the reader to get audio data with parameters\n        out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n        if not isinstance(out, np.ndarray):\n            raise ValueError(\"Unexpected data type after reading file\")\n        return out\n\n    logger.debug(\n        f\"Creating delayed dask task with expected shape: {expected_shape}\"\n    )\n\n    # Create delayed operation\n    delayed_data = dask_delayed(_load_audio)()\n    logger.debug(\"Wrapping delayed function in dask array\")\n\n    # Create dask array from delayed computation\n    dask_array = da_from_delayed(\n        delayed_data, shape=expected_shape, dtype=np.float32\n    )\n\n    if chunk_size is not None:\n        if chunk_size &lt;= 0:\n            raise ValueError(\"Chunk size must be a positive integer\")\n        logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n        dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n    logger.debug(\n        \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n    )\n\n    cf = ChannelFrame(\n        data=dask_array,\n        sampling_rate=sr,\n        label=path.stem,\n        metadata={\n            \"filename\": str(path),\n        },\n    )\n    if ch_labels is not None:\n        if len(ch_labels) != len(cf):\n            raise ValueError(\n                \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    return cf\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.from_ndarray","title":"<code>from_ndarray(array, sampling_rate, labels=None, unit=None, frame_label=None, metadata=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>This method is deprecated. Use from_numpy instead.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>NDArrayReal</code> <p>Signal data. Each row corresponds to a channel.</p> required <code>sampling_rate</code> <code>float</code> <p>Sampling rate (Hz).</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>unit</code> <code>Optional[Union[list[str], str]]</code> <p>Unit of the signal.</p> <code>None</code> <code>frame_label</code> <code>Optional[str]</code> <p>Label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_ndarray(\n    cls,\n    array: NDArrayReal,\n    sampling_rate: float,\n    labels: Optional[list[str]] = None,\n    unit: Optional[Union[list[str], str]] = None,\n    frame_label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    This method is deprecated. Use from_numpy instead.\n\n    Args:\n        array: Signal data. Each row corresponds to a channel.\n        sampling_rate: Sampling rate (Hz).\n        labels: Labels for each channel.\n        unit: Unit of the signal.\n        frame_label: Label for the frame.\n        metadata: Optional metadata dictionary.\n\n    Returns:\n        A new ChannelFrame containing the data.\n    \"\"\"\n    # Redirect to from_numpy for compatibility\n    # However, from_ndarray is deprecated\n    logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n    return cls.from_numpy(\n        data=array,\n        sampling_rate=sampling_rate,\n        label=frame_label,\n        metadata=metadata,\n        ch_labels=labels,\n        ch_units=unit,\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.from_numpy","title":"<code>from_numpy(data, sampling_rate, label=None, metadata=None, ch_labels=None, ch_units=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArrayReal</code> <p>NumPy array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>ch_units</code> <code>Optional[Union[list[str], str]]</code> <p>Units for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the NumPy data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_numpy(\n    cls,\n    data: NDArrayReal,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    ch_labels: Optional[list[str]] = None,\n    ch_units: Optional[Union[list[str], str]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    Args:\n        data: NumPy array containing channel data.\n        sampling_rate: The sampling rate in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        ch_labels: Labels for each channel.\n        ch_units: Units for each channel.\n\n    Returns:\n        A new ChannelFrame containing the NumPy data.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n\n    # Convert NumPy array to dask array\n    dask_data = da_from_array(data)\n    cf = ChannelFrame(\n        data=dask_data,\n        sampling_rate=sampling_rate,\n        label=label or \"numpy_data\",\n    )\n    if metadata is not None:\n        cf.metadata = metadata\n    if ch_labels is not None:\n        if len(ch_labels) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel labels does not match the number of channels\"\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    if ch_units is not None:\n        if isinstance(ch_units, str):\n            ch_units = [ch_units] * cf.n_channels\n\n        if len(ch_units) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel units does not match the number of channels\"\n            )\n        for i in range(len(ch_units)):\n            cf._channel_metadata[i].unit = ch_units[i]\n\n    return cf\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.high_pass_filter","title":"<code>high_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a high-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a high-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.hpss_harmonic","title":"<code>hpss_harmonic(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract harmonic components using HPSS  (Harmonic-Percussive Source Separation).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_harmonic(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract harmonic components using HPSS\n     (Harmonic-Percussive Source Separation).\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_harmonic\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.hpss_percussive","title":"<code>hpss_percussive(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract percussive components using HPSS (Harmonic-Percussive Source Separation).</p> <p>This method separates the percussive (tonal) components from the signal.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Union[_IntLike_co, tuple[_IntLike_co, _IntLike_co], list[_IntLike_co]]</code> <p>Median filter size for HPSS.</p> <code>31</code> <code>power</code> <code>float</code> <p>Exponent for the Weiner filter used in HPSS.</p> <code>2</code> <code>margin</code> <code>Union[_FloatLike_co, tuple[_FloatLike_co, _FloatLike_co], list[_FloatLike_co]]</code> <p>Margin size for the separation.</p> <code>1</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the harmonic components.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_percussive(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract percussive components using HPSS\n    (Harmonic-Percussive Source Separation).\n\n    This method separates the percussive (tonal) components from the signal.\n\n    Args:\n        kernel_size: Median filter size for HPSS.\n        power: Exponent for the Weiner filter used in HPSS.\n        margin: Margin size for the separation.\n\n    Returns:\n        A new ChannelFrame containing the harmonic components.\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_percussive\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.low_pass_filter","title":"<code>low_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a low-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a low-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.mean","title":"<code>mean()</code>","text":"<p>Average all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with averaged signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def mean(self) -&gt; \"ChannelFrame\":\n    \"\"\"Average all channels.\n\n    Returns:\n        A new ChannelFrame with averaged signal.\n    \"\"\"\n    return self.apply_operation(\"mean\")\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.noct_spectrum","title":"<code>noct_spectrum(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Compute N-octave band spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>fmin</code> <code>float</code> <p>Minimum center frequency in Hz. Default is 20 Hz.</p> required <code>fmax</code> <code>float</code> <p>Maximum center frequency in Hz. Default is 20000 Hz.</p> required <code>n</code> <code>int</code> <p>Band division (1 for octave, 3 for 1/3 octave). Default is 3.</p> <code>3</code> <code>G</code> <code>int</code> <p>Reference gain in dB. Default is 10 dB.</p> <code>10</code> <code>fr</code> <code>int</code> <p>Reference frequency in Hz. Default is 1000 Hz.</p> <code>1000</code> <p>Returns:</p> Type Description <code>NOctFrame</code> <p>A NOctFrame containing the N-octave band spectrum.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def noct_spectrum(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"Compute N-octave band spectrum.\n\n    Args:\n        fmin: Minimum center frequency in Hz. Default is 20 Hz.\n        fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n        n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n        G: Reference gain in dB. Default is 10 dB.\n        fr: Reference frequency in Hz. Default is 1000 Hz.\n\n    Returns:\n        A NOctFrame containing the N-octave band spectrum.\n    \"\"\"\n    from ..processing.time_series import NOctSpectrum\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_spectrum\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSpectrum\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_spectrum\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.normalize","title":"<code>normalize(target_level=-20, channel_wise=True)</code>","text":"<p>Normalize the signal level.</p> <p>This method adjusts the signal amplitude to reach a target RMS level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target RMS level in dB. Default is -20.</p> <code>-20</code> <code>channel_wise</code> <code>bool</code> <p>If True, normalize each channel independently. If False, apply the same scaling to all channels.</p> <code>True</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the normalized signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def normalize(\n    self, target_level: float = -20, channel_wise: bool = True\n) -&gt; \"ChannelFrame\":\n    \"\"\"Normalize the signal level.\n\n    This method adjusts the signal amplitude to reach a target RMS level.\n\n    Args:\n        target_level: Target RMS level in dB. Default is -20.\n        channel_wise: If True, normalize each channel independently.\n            If False, apply the same scaling to all channels.\n\n    Returns:\n        A new ChannelFrame containing the normalized signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n    )\n    return self.apply_operation(\n        \"normalize\", target_level=target_level, channel_wise=channel_wise\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.plot","title":"<code>plot(plot_type='waveform', ax=None, **kwargs)</code>","text":"<p>Plot the frame data.</p> <p>Parameters:</p> Name Type Description Default <code>plot_type</code> <code>str</code> <p>Type of plot. Default is \"waveform\".</p> <code>'waveform'</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def plot(\n    self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Plot the frame data.\n\n    Args:\n        plot_type: Type of plot. Default is \"waveform\".\n        ax: Optional matplotlib axes for plotting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    plot_strategy = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.power","title":"<code>power(exponent=2.0)</code>","text":"<p>Calculate the power of the signal.</p> <p>Parameters:</p> Name Type Description Default <code>exponent</code> <code>float</code> <p>The exponent to raise the signal to. Default is 2.0.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the signal raised to the power.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the power of the signal.\n\n    Args:\n        exponent: The exponent to raise the signal to. Default is 2.0.\n\n    Returns:\n        A new ChannelFrame containing the signal raised to the power.\n    \"\"\"\n    return self.apply_operation(\"power\", exponent=exponent)\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.read_csv","title":"<code>read_csv(filename, time_column=0, labels=None, delimiter=',', header=0)</code>  <code>classmethod</code>","text":"<p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.read_wav","title":"<code>read_wav(filename, labels=None)</code>  <code>classmethod</code>","text":"<p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.resampling","title":"<code>resampling(target_sr, **kwargs)</code>","text":"<p>Resample audio data.</p>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.resampling--parameters","title":"Parameters","text":"<p>target_sr : float     Target sampling rate (Hz) resample_type : str, optional     Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.) **kwargs : dict     Additional resampling parameters</p>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.resampling--returns","title":"Returns","text":"<p>ChannelFrame     Resampled channel frame</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def resampling(\n    self,\n    target_sr: float,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Resample audio data.\n\n    Parameters\n    ----------\n    target_sr : float\n        Target sampling rate (Hz)\n    resample_type : str, optional\n        Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n    **kwargs : dict\n        Additional resampling parameters\n\n    Returns\n    -------\n    ChannelFrame\n        Resampled channel frame\n    \"\"\"\n    return self.apply_operation(\n        \"resampling\",\n        target_sr=target_sr,\n        **kwargs,\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.rms_plot","title":"<code>rms_plot(ax=None, title=None, overlay=True, Aw=False, **kwargs)</code>","text":"<p>Generate an RMS plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title for the plot.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay the plot on the existing axis.</p> <code>True</code> <code>Aw</code> <code>bool</code> <p>Apply A-weighting.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_plot(\n    self,\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = True,\n    Aw: bool = False,  # noqa: N803\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Generate an RMS plot.\n\n    Args:\n        ax: Optional matplotlib axes for plotting.\n        title: Title for the plot.\n        overlay: Whether to overlay the plot on the existing axis.\n        Aw: Apply A-weighting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    kwargs = kwargs or {}\n    ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n    rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n    return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.rms_trend","title":"<code>rms_trend(frame_length=2048, hop_length=512, dB=False, Aw=False)</code>","text":"<p>Calculate the RMS trend of the signal.</p> <p>This method computes the root mean square value over sliding windows.</p> <p>Parameters:</p> Name Type Description Default <code>frame_length</code> <code>int</code> <p>The size of the sliding window in samples. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>int</code> <p>The hop length between windows in samples. Default is 512.</p> <code>512</code> <code>dB</code> <code>bool</code> <p>Whether to return the RMS values in decibels. Default is False.</p> <code>False</code> <code>Aw</code> <code>bool</code> <p>Whether to apply A-weighting. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the RMS trend.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_trend(\n    self,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the RMS trend of the signal.\n\n    This method computes the root mean square value over sliding windows.\n\n    Args:\n        frame_length: The size of the sliding window in samples. Default is 2048.\n        hop_length: The hop length between windows in samples. Default is 512.\n        dB: Whether to return the RMS values in decibels. Default is False.\n        Aw: Whether to apply A-weighting. Default is False.\n\n    Returns:\n        A new ChannelFrame containing the RMS trend.\n    \"\"\"\n    cf = self.apply_operation(\n        \"rms_trend\",\n        frame_length=frame_length,\n        hop_length=hop_length,\n        ref=[ch.ref for ch in self._channel_metadata],\n        dB=dB,\n        Aw=Aw,\n    )\n    cf.sampling_rate = self.sampling_rate / hop_length\n    return cf\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.save","title":"<code>save(path, format=None)</code>","text":"<p>Save the audio data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n    data = self.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    sf.write(str(path), data, int(self.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {path}\")\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.stft","title":"<code>stft(n_fft=2048, hop_length=None, win_length=None, window='hann')</code>","text":"<p>Compute Short-Time Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectrogramFrame</code> <p>A SpectrogramFrame containing the STFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def stft(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n) -&gt; \"SpectrogramFrame\":\n    \"\"\"Compute Short-Time Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectrogramFrame containing the STFT results.\n    \"\"\"\n    from ..processing.time_series import STFT, create_operation\n    from .spectrogram import SpectrogramFrame\n\n    # Set hop length and window length\n    _hop_length = hop_length if hop_length is not None else n_fft // 4\n    _win_length = win_length if win_length is not None else n_fft\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": _hop_length,\n        \"win_length\": _win_length,\n        \"window\": window,\n    }\n    operation_name = \"stft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"STFT\", operation)\n\n    # Apply processing to data\n    spectrogram_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n\n    # Create new instance\n    return SpectrogramFrame(\n        data=spectrogram_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=n_fft,\n        hop_length=_hop_length,\n        win_length=_win_length,\n        window=window,\n        label=f\"stft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.sum","title":"<code>sum()</code>","text":"<p>Sum all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with summed signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def sum(self) -&gt; \"ChannelFrame\":\n    \"\"\"Sum all channels.\n\n    Returns:\n        A new ChannelFrame with summed signal.\n    \"\"\"\n    return self.apply_operation(\"sum\")\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.transfer_function","title":"<code>transfer_function(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute transfer function matrix.</p> <p>The transfer function characterizes the signal transmission properties between channels in the frequency domain, representing the input-output relationship of a system.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the transfer function matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def transfer_function(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute transfer function matrix.\n\n    The transfer function characterizes the signal transmission properties\n    between channels in the frequency domain, representing the input-output\n    relationship of a system.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the transfer function matrix.\n    \"\"\"\n    from ..processing.time_series import TransferFunction, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"transfer_function\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"TransferFunction\", operation)\n\n    # Apply processing to data\n    tf_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=tf_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Transfer function of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.trim","title":"<code>trim(start=0, end=None)</code>","text":"<p>Trim the signal to specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>Start time in seconds.</p> <code>0</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with trimmed signal.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If end time is before start time.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def trim(\n    self,\n    start: float = 0,\n    end: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Trim the signal to specified time range.\n\n    Args:\n        start: Start time in seconds.\n        end: End time in seconds.\n\n    Returns:\n        A new ChannelFrame with trimmed signal.\n\n    Raises:\n        ValueError: If end time is before start time.\n    \"\"\"\n    if end is None:\n        end = self.duration\n    if start &gt; end:\n        raise ValueError(\"start must be less than end\")\n    # Apply trim operation\n    return self.apply_operation(\"trim\", start=start, end=end)\n</code></pre>"},{"location":"en/en/api/#wandas.frames.channel.ChannelFrame.welch","title":"<code>welch(n_fft=None, hop_length=None, win_length=2048, window='hann', average='mean')</code>","text":"<p>Compute power spectral density using Welch's method.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is 2048.</p> <code>None</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>int</code> <p>Length of window. Default is n_fft.</p> <code>2048</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the power spectral density.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def welch(\n    self,\n    n_fft: Optional[int] = None,\n    hop_length: Optional[int] = None,\n    win_length: int = 2048,\n    window: str = \"hann\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute power spectral density using Welch's method.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the power spectral density.\n    \"\"\"\n    from ..processing.time_series import Welch\n    from .spectral import SpectralFrame\n\n    params = dict(\n        n_fft=n_fft or win_length,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        average=average,\n    )\n    operation_name = \"welch\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Welch\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"welch\", \"params\": params},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/en/api/#inputoutput-io","title":"Input/Output (I/O)","text":"<p>Wandas provides various methods to read audio files and CSV files.</p>"},{"location":"en/en/api/#wav-file-operations","title":"WAV File Operations","text":"<pre><code># Reading WAV files\nfrom wandas.frames.channel import ChannelFrame\nframe = ChannelFrame.read_wav(\"audio.wav\")\n\n# Or using direct import\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")\n\n# Writing WAV files\nframe.save(\"output.wav\")\n</code></pre> <p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre> <p>Save the audio data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n    data = self.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    sf.write(str(path), data, int(self.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {path}\")\n</code></pre>"},{"location":"en/en/api/#csv-file-operations","title":"CSV File Operations","text":"<pre><code># Reading CSV files\nfrom wandas.frames.channel import ChannelFrame\nframe = ChannelFrame.read_csv(\"data.csv\")\n\n# Or using direct import\nimport wandas\nframe = wandas.read_csv(\"data.csv\")\n</code></pre> <p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"en/en/api/#signal-processing","title":"Signal Processing","text":"<p>Wandas provides various signal processing functions.</p>"},{"location":"en/en/api/#wandas.processing.time_series.ABS","title":"<code>ABS</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Absolute value operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ABS(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Absolute value operation\"\"\"\n\n    name = \"abs\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize absolute value operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        return da.abs(data)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.ABS.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize absolute value operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.ABS.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize absolute value operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.AWeighting","title":"<code>AWeighting</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>A-weighting filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AWeighting(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"A-weighting filter operation\"\"\"\n\n    name = \"a_weighting\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize A-weighting filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for A-weighting filter\"\"\"\n        logger.debug(f\"Applying A-weighting to array with shape: {x.shape}\")\n        result = A_weight(x, self.sampling_rate)\n\n        # Handle case where A_weight returns a tuple\n        if isinstance(result, tuple):\n            # Use the first element of the tuple\n            result = result[0]\n\n        logger.debug(\n            f\"A-weighting applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.AWeighting.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize A-weighting filter</p>"},{"location":"en/en/api/#wandas.processing.time_series.AWeighting.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize A-weighting filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.AddWithSNR","title":"<code>AddWithSNR</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Addition operation considering SNR</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AddWithSNR(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Addition operation considering SNR\"\"\"\n\n    name = \"add_with_snr\"\n\n    def __init__(self, sampling_rate: float, other: DaArray, snr: float):\n        \"\"\"\n        Initialize addition operation considering SNR\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        other : DaArray\n            Noise signal to add (channel-frame format)\n        snr : float\n            Signal-to-noise ratio (dB)\n        \"\"\"\n        super().__init__(sampling_rate, other=other, snr=snr)\n\n        self.other = other\n        self.snr = snr\n        logger.debug(f\"Initialized AddWithSNR operation with SNR: {snr} dB\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape (same as input)\n        \"\"\"\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Perform addition processing considering SNR\"\"\"\n        logger.debug(f\"Applying SNR-based addition with shape: {x.shape}\")\n        other: NDArrayReal = self.other.compute()\n\n        # Use multi-channel versions of calculate_rms and calculate_desired_noise_rms\n        clean_rms = util.calculate_rms(x)\n        other_rms = util.calculate_rms(other)\n\n        # Adjust noise gain based on specified SNR (apply per channel)\n        desired_noise_rms = util.calculate_desired_noise_rms(clean_rms, self.snr)\n\n        # Apply gain per channel using broadcasting\n        gain = desired_noise_rms / other_rms\n        # Add adjusted noise to signal\n        result: NDArrayReal = x + other * gain\n        return result\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.AddWithSNR.__init__","title":"<code>__init__(sampling_rate, other, snr)</code>","text":"<p>Initialize addition operation considering SNR</p>"},{"location":"en/en/api/#wandas.processing.time_series.AddWithSNR.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) other : DaArray     Noise signal to add (channel-frame format) snr : float     Signal-to-noise ratio (dB)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, other: DaArray, snr: float):\n    \"\"\"\n    Initialize addition operation considering SNR\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    other : DaArray\n        Noise signal to add (channel-frame format)\n    snr : float\n        Signal-to-noise ratio (dB)\n    \"\"\"\n    super().__init__(sampling_rate, other=other, snr=snr)\n\n    self.other = other\n    self.snr = snr\n    logger.debug(f\"Initialized AddWithSNR operation with SNR: {snr} dB\")\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.AddWithSNR.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.AddWithSNR.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/en/api/#wandas.processing.time_series.AddWithSNR.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (same as input)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape (same as input)\n    \"\"\"\n    return input_shape\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.AudioOperation","title":"<code>AudioOperation</code>","text":"<p>               Bases: <code>Generic[InputArrayType, OutputArrayType]</code></p> <p>Abstract base class for audio processing operations.</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AudioOperation(Generic[InputArrayType, OutputArrayType]):\n    \"\"\"Abstract base class for audio processing operations.\"\"\"\n\n    # Class variable: operation name\n    name: ClassVar[str]\n\n    def __init__(self, sampling_rate: float, **params: Any):\n        \"\"\"\n        Initialize AudioOperation.\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        **params : Any\n            Operation-specific parameters\n        \"\"\"\n        self.sampling_rate = sampling_rate\n        self.params = params\n\n        # Validate parameters during initialization\n        self.validate_params()\n\n        # Create processor function (lazy initialization possible)\n        self._setup_processor()\n\n        logger.debug(\n            f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n        )\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n        pass\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up processor function (implemented by subclasses)\"\"\"\n        pass\n\n    def _process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function (implemented by subclasses)\"\"\"\n        # Default is no-op function\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    @dask.delayed  # type: ignore [misc, unused-ignore]\n    def process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n        # Default is no-op function\n        logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n        return self._process_array(x)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation (implemented by subclasses)\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        \"\"\"\n        Execute operation and return result\n        data shape is (channels, samples)\n        \"\"\"\n        # Add task as delayed processing\n        logger.debug(\"Adding delayed operation to computation graph\")\n        delayed_result = self.process_array(data)\n        # Convert delayed result to dask array and return\n        output_shape = self.calculate_output_shape(data.shape)\n        return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.AudioOperation.__init__","title":"<code>__init__(sampling_rate, **params)</code>","text":"<p>Initialize AudioOperation.</p>"},{"location":"en/en/api/#wandas.processing.time_series.AudioOperation.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) **params : Any     Operation-specific parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, **params: Any):\n    \"\"\"\n    Initialize AudioOperation.\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    **params : Any\n        Operation-specific parameters\n    \"\"\"\n    self.sampling_rate = sampling_rate\n    self.params = params\n\n    # Validate parameters during initialization\n    self.validate_params()\n\n    # Create processor function (lazy initialization possible)\n    self._setup_processor()\n\n    logger.debug(\n        f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.AudioOperation.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation (implemented by subclasses)</p>"},{"location":"en/en/api/#wandas.processing.time_series.AudioOperation.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/en/api/#wandas.processing.time_series.AudioOperation.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation (implemented by subclasses)\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.AudioOperation.process","title":"<code>process(data)</code>","text":"<p>Execute operation and return result data shape is (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    \"\"\"\n    Execute operation and return result\n    data shape is (channels, samples)\n    \"\"\"\n    # Add task as delayed processing\n    logger.debug(\"Adding delayed operation to computation graph\")\n    delayed_result = self.process_array(data)\n    # Convert delayed result to dask array and return\n    output_shape = self.calculate_output_shape(data.shape)\n    return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.AudioOperation.process_array","title":"<code>process_array(x)</code>","text":"<p>Processing function wrapped with @dask.delayed</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>@dask.delayed  # type: ignore [misc, unused-ignore]\ndef process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n    \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n    # Default is no-op function\n    logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n    return self._process_array(x)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.AudioOperation.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters (raises exception if invalid)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n    pass\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.CSD","title":"<code>CSD</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Cross-spectral density estimation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class CSD(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Cross-spectral density estimation operation\"\"\"\n\n    name = \"csd\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n        scaling: str,\n        average: str,\n    ):\n        \"\"\"\n        Initialize cross-spectral density estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        scaling : str\n            Type of scaling\n        average : str\n            Method of averaging\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        self.scaling = scaling\n        self.average = average\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n            scaling=scaling,\n            average=average,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Processor function for cross-spectral density estimation operation\"\"\"\n        logger.debug(f\"Applying CSD estimation to array with shape: {x.shape}\")\n        from scipy import signal as ss\n\n        # Calculate all combinations using scipy's csd function\n        _, csd_result = ss.csd(\n            x=x[:, np.newaxis],\n            y=x[np.newaxis, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n        )\n\n        # Reshape result to (n_channels * n_channels, n_freqs)\n        result: NDArrayComplex = csd_result.transpose(1, 0, 2).reshape(\n            -1, csd_result.shape[-1]\n        )\n\n        logger.debug(f\"CSD estimation applied, result shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.CSD.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend, scaling, average)</code>","text":"<p>Initialize cross-spectral density estimation operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.CSD.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend scaling : str     Type of scaling average : str     Method of averaging</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n    scaling: str,\n    average: str,\n):\n    \"\"\"\n    Initialize cross-spectral density estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    scaling : str\n        Type of scaling\n    average : str\n        Method of averaging\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    self.scaling = scaling\n    self.average = average\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n        scaling=scaling,\n        average=average,\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.CSD.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.CSD.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/en/api/#wandas.processing.time_series.CSD.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.ChannelDifference","title":"<code>ChannelDifference</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Channel difference calculation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ChannelDifference(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Channel difference calculation operation\"\"\"\n\n    name = \"channel_difference\"\n    other_channel: int\n\n    def __init__(self, sampling_rate: float, other_channel: int = 0):\n        \"\"\"\n        Initialize channel difference calculation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        other_channel : int\n            Channel to calculate difference with, default is 0\n        \"\"\"\n        self.other_channel = other_channel\n        super().__init__(sampling_rate, other_channel=other_channel)\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        result = data - data[self.other_channel]\n        return result\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.ChannelDifference.__init__","title":"<code>__init__(sampling_rate, other_channel=0)</code>","text":"<p>Initialize channel difference calculation</p>"},{"location":"en/en/api/#wandas.processing.time_series.ChannelDifference.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) other_channel : int     Channel to calculate difference with, default is 0</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, other_channel: int = 0):\n    \"\"\"\n    Initialize channel difference calculation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    other_channel : int\n        Channel to calculate difference with, default is 0\n    \"\"\"\n    self.other_channel = other_channel\n    super().__init__(sampling_rate, other_channel=other_channel)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.Coherence","title":"<code>Coherence</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Coherence estimation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Coherence(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Coherence estimation operation\"\"\"\n\n    name = \"coherence\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n    ):\n        \"\"\"\n        Initialize coherence estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Processor function for coherence estimation operation\"\"\"\n        logger.debug(f\"Applying coherence estimation to array with shape: {x.shape}\")\n        from scipy import signal as ss\n\n        _, coh = ss.coherence(\n            x=x[:, np.newaxis],\n            y=x[np.newaxis, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n        )\n\n        # Reshape result to (n_channels * n_channels, n_freqs)\n        result: NDArrayReal = coh.transpose(1, 0, 2).reshape(-1, coh.shape[-1])\n\n        logger.debug(f\"Coherence estimation applied, result shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.Coherence.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend)</code>","text":"<p>Initialize coherence estimation operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.Coherence.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n):\n    \"\"\"\n    Initialize coherence estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.Coherence.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.Coherence.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/en/api/#wandas.processing.time_series.Coherence.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.FFT","title":"<code>FFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>FFT (Fast Fourier Transform) operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class FFT(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"FFT (Fast Fourier Transform) operation\"\"\"\n\n    name = \"fft\"\n    n_fft: Optional[int]\n    window: str\n\n    def __init__(\n        self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n    ):\n        \"\"\"\n        Initialize FFT operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int, optional\n            FFT size, default is None (determined by input size)\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(sampling_rate, n_fft=n_fft, window=window)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        \u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059\n\n        Parameters\n        ----------\n        input_shape : tuple\n            \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)\n\n        Returns\n        -------\n        tuple\n            \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)\n        \"\"\"\n        n_freqs = self.n_fft // 2 + 1 if self.n_fft else input_shape[-1] // 2 + 1\n        return (*input_shape[:-1], n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"FFT\u64cd\u4f5c\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u95a2\u6570\u3092\u4f5c\u6210\"\"\"\n        from scipy.signal import get_window\n\n        win = get_window(self.window, x.shape[-1])\n        x = x * win\n        result: NDArrayComplex = np.fft.rfft(x, n=self.n_fft, axis=-1)\n        result[..., 1:-1] *= 2.0\n        # \u7a93\u95a2\u6570\u88dc\u6b63\n        scaling_factor = np.sum(win)\n        result = result / scaling_factor\n        return result\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.FFT.__init__","title":"<code>__init__(sampling_rate, n_fft=None, window='hann')</code>","text":"<p>Initialize FFT operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.FFT.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int, optional     FFT size, default is None (determined by input size) window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n):\n    \"\"\"\n    Initialize FFT operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int, optional\n        FFT size, default is None (determined by input size)\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(sampling_rate, n_fft=n_fft, window=window)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.FFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>\u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059</p>"},{"location":"en/en/api/#wandas.processing.time_series.FFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)</p>"},{"location":"en/en/api/#wandas.processing.time_series.FFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    \u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059\n\n    Parameters\n    ----------\n    input_shape : tuple\n        \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)\n\n    Returns\n    -------\n    tuple\n        \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)\n    \"\"\"\n    n_freqs = self.n_fft // 2 + 1 if self.n_fft else input_shape[-1] // 2 + 1\n    return (*input_shape[:-1], n_freqs)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.HighPassFilter","title":"<code>HighPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>High-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HighPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"High-pass filter operation\"\"\"\n\n    name = \"highpass_filter\"\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize high-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            limit = self.sampling_rate / 2\n            raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up high-pass filter processor\"\"\"\n        # Calculate filter coefficients (once) - safely retrieve from instance variables\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"high\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Highpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying highpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.HighPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize high-pass filter</p>"},{"location":"en/en/api/#wandas.processing.time_series.HighPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize high-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.HighPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        limit = self.sampling_rate / 2\n        raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.HpssHarmonic","title":"<code>HpssHarmonic</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>HPSS Harmonic operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HpssHarmonic(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"HPSS Harmonic operation\"\"\"\n\n    name = \"hpss_harmonic\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize HPSS Harmonic\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        self.kwargs = kwargs\n        super().__init__(sampling_rate, **kwargs)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for HPSS Harmonic\"\"\"\n        logger.debug(f\"Applying HPSS Harmonic to array with shape: {x.shape}\")\n        result = librosa.effects.harmonic(x, **self.kwargs)\n        logger.debug(\n            f\"HPSS Harmonic applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.HpssHarmonic.__init__","title":"<code>__init__(sampling_rate, **kwargs)</code>","text":"<p>Initialize HPSS Harmonic</p>"},{"location":"en/en/api/#wandas.processing.time_series.HpssHarmonic.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize HPSS Harmonic\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    self.kwargs = kwargs\n    super().__init__(sampling_rate, **kwargs)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.HpssPercussive","title":"<code>HpssPercussive</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>HPSS Percussive operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HpssPercussive(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"HPSS Percussive operation\"\"\"\n\n    name = \"hpss_percussive\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize HPSS Percussive\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        self.kwargs = kwargs\n        super().__init__(sampling_rate, **kwargs)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for HPSS Percussive\"\"\"\n        logger.debug(f\"Applying HPSS Percussive to array with shape: {x.shape}\")\n        result = librosa.effects.percussive(x, **self.kwargs)\n        logger.debug(\n            f\"HPSS Percussive applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.HpssPercussive.__init__","title":"<code>__init__(sampling_rate, **kwargs)</code>","text":"<p>Initialize HPSS Percussive</p>"},{"location":"en/en/api/#wandas.processing.time_series.HpssPercussive.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize HPSS Percussive\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    self.kwargs = kwargs\n    super().__init__(sampling_rate, **kwargs)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.IFFT","title":"<code>IFFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayComplex, NDArrayReal]</code></p> <p>IFFT (Inverse Fast Fourier Transform) operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class IFFT(AudioOperation[NDArrayComplex, NDArrayReal]):\n    \"\"\"IFFT (Inverse Fast Fourier Transform) operation\"\"\"\n\n    name = \"ifft\"\n    n_fft: Optional[int]\n    window: str\n\n    def __init__(\n        self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n    ):\n        \"\"\"\n        Initialize IFFT operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : Optional[int], optional\n            IFFT size, default is None (determined based on input size)\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(sampling_rate, n_fft=n_fft, window=window)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, freqs)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, samples)\n        \"\"\"\n        n_samples = 2 * (input_shape[-1] - 1) if self.n_fft is None else self.n_fft\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayComplex) -&gt; NDArrayReal:\n        \"\"\"Create processor function for IFFT operation\"\"\"\n        logger.debug(f\"Applying IFFT to array with shape: {x.shape}\")\n\n        # Restore frequency component scaling (remove the 2.0 multiplier applied in FFT)\n        _x = x.copy()\n        _x[..., 1:-1] /= 2.0\n\n        # Execute IFFT\n        result: NDArrayReal = np.fft.irfft(_x, n=self.n_fft, axis=-1)\n\n        # Window function correction (inverse of FFT operation)\n        from scipy.signal import get_window\n\n        win = get_window(self.window, result.shape[-1])\n\n        # Correct the FFT window function scaling\n        scaling_factor = np.sum(win) / result.shape[-1]\n        result = result / scaling_factor\n\n        logger.debug(f\"IFFT applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.IFFT.__init__","title":"<code>__init__(sampling_rate, n_fft=None, window='hann')</code>","text":"<p>Initialize IFFT operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.IFFT.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : Optional[int], optional     IFFT size, default is None (determined based on input size) window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n):\n    \"\"\"\n    Initialize IFFT operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : Optional[int], optional\n        IFFT size, default is None (determined based on input size)\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(sampling_rate, n_fft=n_fft, window=window)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.IFFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.IFFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, freqs)</p>"},{"location":"en/en/api/#wandas.processing.time_series.IFFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, freqs)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, samples)\n    \"\"\"\n    n_samples = 2 * (input_shape[-1] - 1) if self.n_fft is None else self.n_fft\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.ISTFT","title":"<code>ISTFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayComplex, NDArrayReal]</code></p> <p>Inverse Short-Time Fourier Transform operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ISTFT(AudioOperation[NDArrayComplex, NDArrayReal]):\n    \"\"\"Inverse Short-Time Fourier Transform operation\"\"\"\n\n    name = \"istft\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        length: Optional[int] = None,\n    ):\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.length = length\n\n        # Instantiate ShortTimeFFT for ISTFT calculation\n        self.SFT = ShortTimeFFT(\n            win=get_window(window, self.win_length),\n            hop=self.hop_length,\n            fs=sampling_rate,\n            mfft=self.n_fft,\n            scale_to=\"magnitude\",  # Consistent scaling with STFT\n        )\n\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n            length=length,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, freqs, time_frames)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, samples)\n        \"\"\"\n        k0: int = 0\n        q_max = input_shape[-1] + self.SFT.p_min\n        k_max = (q_max - 1) * self.SFT.hop + self.SFT.m_num - self.SFT.m_num_mid\n        k_q0, k_q1 = self.SFT.nearest_k_p(k0), self.SFT.nearest_k_p(k_max, left=False)\n        n_pts = k_q1 - k_q0 + self.SFT.m_num - self.SFT.m_num_mid\n\n        return input_shape[:-2] + (n_pts,)\n\n    def _process_array(self, x: NDArrayComplex) -&gt; NDArrayReal:\n        \"\"\"\n        Apply SciPy ISTFT processing to multiple channels at once using ShortTimeFFT\"\"\"\n        logger.debug(\n            f\"Applying SciPy ISTFT (ShortTimeFFT) to array with shape: {x.shape}\"\n        )\n\n        # Convert 2D input to 3D (assume single channel)\n        if x.ndim == 2:\n            x = x.reshape(1, *x.shape)\n\n        # Adjust scaling back if STFT applied factor of 2\n        _x = np.copy(x)\n        _x[..., 1:-1, :] /= 2.0\n\n        # Apply ISTFT using the ShortTimeFFT instance\n        result: NDArrayReal = self.SFT.istft(_x)\n\n        # Trim to desired length if specified\n        if self.length is not None:\n            result = result[..., : self.length]\n\n        logger.debug(\n            f\"ShortTimeFFT applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.ISTFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.ISTFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, freqs, time_frames)</p>"},{"location":"en/en/api/#wandas.processing.time_series.ISTFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, freqs, time_frames)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, samples)\n    \"\"\"\n    k0: int = 0\n    q_max = input_shape[-1] + self.SFT.p_min\n    k_max = (q_max - 1) * self.SFT.hop + self.SFT.m_num - self.SFT.m_num_mid\n    k_q0, k_q1 = self.SFT.nearest_k_p(k0), self.SFT.nearest_k_p(k_max, left=False)\n    n_pts = k_q1 - k_q0 + self.SFT.m_num - self.SFT.m_num_mid\n\n    return input_shape[:-2] + (n_pts,)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.LowPassFilter","title":"<code>LowPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Low-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class LowPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Low-pass filter operation\"\"\"\n\n    name = \"lowpass_filter\"\n    a: NDArrayReal\n    b: NDArrayReal\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize low-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            raise ValueError(\n                f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n            )\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up low-pass filter processor\"\"\"\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"low\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Lowpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying lowpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.LowPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize low-pass filter</p>"},{"location":"en/en/api/#wandas.processing.time_series.LowPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize low-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.LowPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        raise ValueError(\n            f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n        )\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.Mean","title":"<code>Mean</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Mean calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Mean(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Mean calculation\"\"\"\n\n    name = \"mean\"\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # Use Dask's aggregate function directly without map_blocks\n        return data.mean(axis=0, keepdims=True)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.NOctSpectrum","title":"<code>NOctSpectrum</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>N-octave spectrum operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class NOctSpectrum(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"N-octave spectrum operation\"\"\"\n\n    name = \"noct_spectrum\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ):\n        \"\"\"\n        Initialize N-octave spectrum\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        fmin : float\n            Minimum frequency (Hz)\n        fmax : float\n            Maximum frequency (Hz)\n        n : int, optional\n            Number of octave divisions, default is 3\n        G : int, optional\n            Reference level, default is 10\n        fr : int, optional\n            Reference frequency, default is 1000\n        \"\"\"\n        super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n        self.fmin = fmin\n        self.fmax = fmax\n        self.n = n\n        self.G = G\n        self.fr = fr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate output shape for octave spectrum\n        _, fpref = _center_freq(\n            fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n        )\n        return (input_shape[0], fpref.shape[0])\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for octave spectrum\"\"\"\n        logger.debug(f\"Applying NoctSpectrum to array with shape: {x.shape}\")\n        spec, _ = noct_spectrum(\n            sig=x.T,\n            fs=self.sampling_rate,\n            fmin=self.fmin,\n            fmax=self.fmax,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        if spec.ndim == 1:\n            # Add channel dimension for 1D\n            spec = np.expand_dims(spec, axis=0)\n        else:\n            spec = spec.T\n        logger.debug(f\"NoctSpectrum applied, returning result with shape: {spec.shape}\")\n        return np.array(spec)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.NOctSpectrum.__init__","title":"<code>__init__(sampling_rate, fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Initialize N-octave spectrum</p>"},{"location":"en/en/api/#wandas.processing.time_series.NOctSpectrum.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) fmin : float     Minimum frequency (Hz) fmax : float     Maximum frequency (Hz) n : int, optional     Number of octave divisions, default is 3 G : int, optional     Reference level, default is 10 fr : int, optional     Reference frequency, default is 1000</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n):\n    \"\"\"\n    Initialize N-octave spectrum\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    fmin : float\n        Minimum frequency (Hz)\n    fmax : float\n        Maximum frequency (Hz)\n    n : int, optional\n        Number of octave divisions, default is 3\n    G : int, optional\n        Reference level, default is 10\n    fr : int, optional\n        Reference frequency, default is 1000\n    \"\"\"\n    super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n    self.fmin = fmin\n    self.fmax = fmax\n    self.n = n\n    self.G = G\n    self.fr = fr\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.NOctSpectrum.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.NOctSpectrum.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/en/api/#wandas.processing.time_series.NOctSpectrum.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate output shape for octave spectrum\n    _, fpref = _center_freq(\n        fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n    )\n    return (input_shape[0], fpref.shape[0])\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.NOctSynthesis","title":"<code>NOctSynthesis</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Octave synthesis operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class NOctSynthesis(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Octave synthesis operation\"\"\"\n\n    name = \"noct_synthesis\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ):\n        \"\"\"\n        Initialize octave synthesis\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        fmin : float\n            Minimum frequency (Hz)\n        fmax : float\n            Maximum frequency (Hz)\n        n : int, optional\n            Number of octave divisions, default is 3\n        G : int, optional\n            Reference level, default is 10\n        fr : int, optional\n            Reference frequency, default is 1000\n        \"\"\"\n        super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n\n        self.fmin = fmin\n        self.fmax = fmax\n        self.n = n\n        self.G = G\n        self.fr = fr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate output shape for octave spectrum\n        _, fpref = _center_freq(\n            fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n        )\n        return (input_shape[0], fpref.shape[0])\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for octave synthesis\"\"\"\n        logger.debug(f\"Applying NoctSynthesis to array with shape: {x.shape}\")\n        # Calculate n from shape[-1]\n        n = x.shape[-1]  # Calculate n from shape[-1]\n        if n % 2 == 0:\n            n = n * 2 - 1\n        else:\n            n = (n - 1) * 2\n        freqs = np.fft.rfftfreq(n, d=1 / self.sampling_rate)\n        result, _ = noct_synthesis(\n            spectrum=np.abs(x).T,\n            freqs=freqs,\n            fmin=self.fmin,\n            fmax=self.fmax,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        result = result.T\n        logger.debug(\n            f\"NoctSynthesis applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.NOctSynthesis.__init__","title":"<code>__init__(sampling_rate, fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Initialize octave synthesis</p>"},{"location":"en/en/api/#wandas.processing.time_series.NOctSynthesis.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) fmin : float     Minimum frequency (Hz) fmax : float     Maximum frequency (Hz) n : int, optional     Number of octave divisions, default is 3 G : int, optional     Reference level, default is 10 fr : int, optional     Reference frequency, default is 1000</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n):\n    \"\"\"\n    Initialize octave synthesis\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    fmin : float\n        Minimum frequency (Hz)\n    fmax : float\n        Maximum frequency (Hz)\n    n : int, optional\n        Number of octave divisions, default is 3\n    G : int, optional\n        Reference level, default is 10\n    fr : int, optional\n        Reference frequency, default is 1000\n    \"\"\"\n    super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n\n    self.fmin = fmin\n    self.fmax = fmax\n    self.n = n\n    self.G = G\n    self.fr = fr\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.NOctSynthesis.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.NOctSynthesis.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/en/api/#wandas.processing.time_series.NOctSynthesis.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate output shape for octave spectrum\n    _, fpref = _center_freq(\n        fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n    )\n    return (input_shape[0], fpref.shape[0])\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.Power","title":"<code>Power</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Power operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Power(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Power operation\"\"\"\n\n    name = \"power\"\n\n    def __init__(self, sampling_rate: float, exponent: float):\n        \"\"\"\n        Initialize power operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        exponent : float\n            Power exponent\n        \"\"\"\n        super().__init__(sampling_rate)\n        self.exp = exponent\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        return da.power(data, self.exp)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.Power.__init__","title":"<code>__init__(sampling_rate, exponent)</code>","text":"<p>Initialize power operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.Power.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) exponent : float     Power exponent</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, exponent: float):\n    \"\"\"\n    Initialize power operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    exponent : float\n        Power exponent\n    \"\"\"\n    super().__init__(sampling_rate)\n    self.exp = exponent\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.ReSampling","title":"<code>ReSampling</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Resampling operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ReSampling(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Resampling operation\"\"\"\n\n    name = \"resampling\"\n\n    def __init__(self, sampling_rate: float, target_sr: float):\n        \"\"\"\n        Initialize resampling operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        target_sampling_rate : float\n            Target sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate, target_sr=target_sr)\n        self.target_sr = target_sr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after resampling\n        ratio = float(self.target_sr) / float(self.sampling_rate)\n        n_samples = int(np.ceil(input_shape[-1] * ratio))\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for resampling operation\"\"\"\n        logger.debug(f\"Applying resampling to array with shape: {x.shape}\")\n        result = librosa.resample(\n            x, orig_sr=self.sampling_rate, target_sr=self.target_sr\n        )\n        logger.debug(f\"Resampling applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.ReSampling.__init__","title":"<code>__init__(sampling_rate, target_sr)</code>","text":"<p>Initialize resampling operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.ReSampling.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) target_sampling_rate : float     Target sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, target_sr: float):\n    \"\"\"\n    Initialize resampling operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    target_sampling_rate : float\n        Target sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate, target_sr=target_sr)\n    self.target_sr = target_sr\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.ReSampling.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.ReSampling.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/en/api/#wandas.processing.time_series.ReSampling.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after resampling\n    ratio = float(self.target_sr) / float(self.sampling_rate)\n    n_samples = int(np.ceil(input_shape[-1] * ratio))\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.RmsTrend","title":"<code>RmsTrend</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>RMS calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class RmsTrend(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"RMS calculation\"\"\"\n\n    name = \"rms_trend\"\n    frame_length: int\n    hop_length: int\n    Aw: bool\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        ref: Union[list[float], float] = 1.0,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; None:\n        \"\"\"\n        Initialize RMS calculation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        frame_length : int\n            Frame length, default is 2048\n        hop_length : int\n            Hop length, default is 512\n        ref : Union[list[float], float]\n            Reference value(s) for dB calculation\n        dB : bool\n            Whether to convert to decibels\n        Aw : bool\n            Whether to apply A-weighting before RMS calculation\n        \"\"\"\n        self.frame_length = frame_length\n        self.hop_length = hop_length\n        self.dB = dB\n        self.Aw = Aw\n        self.ref = np.array(ref if isinstance(ref, list) else [ref])\n        super().__init__(\n            sampling_rate,\n            frame_length=frame_length,\n            hop_length=hop_length,\n            dB=dB,\n            Aw=Aw,\n            ref=self.ref,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, frames)\n        \"\"\"\n        n_frames = librosa.feature.rms(\n            y=np.ones((1, input_shape[-1])),\n            frame_length=self.frame_length,\n            hop_length=self.hop_length,\n        ).shape[-1]\n        return (*input_shape[:-1], n_frames)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for RMS calculation\"\"\"\n        logger.debug(f\"Applying RMS to array with shape: {x.shape}\")\n\n        if self.Aw:\n            # Apply A-weighting\n            _x = A_weight(x, self.sampling_rate)\n            if isinstance(_x, np.ndarray):\n                # A_weight\u304c\u30bf\u30d7\u30eb\u3092\u8fd4\u3059\u5834\u5408\u3001\u6700\u521d\u306e\u8981\u7d20\u3092\u4f7f\u7528\n                x = _x\n            elif isinstance(_x, tuple):\n                # Use the first element if A_weight returns a tuple\n                x = _x[0]\n            else:\n                raise ValueError(\"A_weighting returned an unexpected type.\")\n\n        # Calculate RMS\n        result = librosa.feature.rms(\n            y=x, frame_length=self.frame_length, hop_length=self.hop_length\n        )[..., 0, :]\n\n        if self.dB:\n            # Convert to dB\n            result = 20 * np.log10(\n                np.maximum(result / self.ref[..., np.newaxis], 1e-12)\n            )\n        #\n        logger.debug(f\"RMS applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.RmsTrend.__init__","title":"<code>__init__(sampling_rate, frame_length=2048, hop_length=512, ref=1.0, dB=False, Aw=False)</code>","text":"<p>Initialize RMS calculation</p>"},{"location":"en/en/api/#wandas.processing.time_series.RmsTrend.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) frame_length : int     Frame length, default is 2048 hop_length : int     Hop length, default is 512 ref : Union[list[float], float]     Reference value(s) for dB calculation dB : bool     Whether to convert to decibels Aw : bool     Whether to apply A-weighting before RMS calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    ref: Union[list[float], float] = 1.0,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; None:\n    \"\"\"\n    Initialize RMS calculation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    frame_length : int\n        Frame length, default is 2048\n    hop_length : int\n        Hop length, default is 512\n    ref : Union[list[float], float]\n        Reference value(s) for dB calculation\n    dB : bool\n        Whether to convert to decibels\n    Aw : bool\n        Whether to apply A-weighting before RMS calculation\n    \"\"\"\n    self.frame_length = frame_length\n    self.hop_length = hop_length\n    self.dB = dB\n    self.Aw = Aw\n    self.ref = np.array(ref if isinstance(ref, list) else [ref])\n    super().__init__(\n        sampling_rate,\n        frame_length=frame_length,\n        hop_length=hop_length,\n        dB=dB,\n        Aw=Aw,\n        ref=self.ref,\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.RmsTrend.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.RmsTrend.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/en/api/#wandas.processing.time_series.RmsTrend.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, frames)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, frames)\n    \"\"\"\n    n_frames = librosa.feature.rms(\n        y=np.ones((1, input_shape[-1])),\n        frame_length=self.frame_length,\n        hop_length=self.hop_length,\n    ).shape[-1]\n    return (*input_shape[:-1], n_frames)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.STFT","title":"<code>STFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Short-Time Fourier Transform operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class STFT(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Short-Time Fourier Transform operation\"\"\"\n\n    name = \"stft\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ):\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.noverlap = (\n            self.win_length - self.hop_length if hop_length is not None else None\n        )\n        self.window = window\n\n        self.SFT = ShortTimeFFT(\n            win=get_window(window, self.win_length),\n            hop=self.hop_length,\n            fs=sampling_rate,\n            mfft=self.n_fft,\n            scale_to=\"magnitude\",\n        )\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        n_samples = input_shape[-1]\n        n_f = len(self.SFT.f)\n        n_t = len(self.SFT.t(n_samples))\n        return (input_shape[0], n_f, n_t)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Apply SciPy STFT processing to multiple channels at once\"\"\"\n        logger.debug(f\"Applying SciPy STFT to array with shape: {x.shape}\")\n\n        # Convert 1D input to 2D\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n\n        # Apply STFT to all channels at once\n        result: NDArrayComplex = self.SFT.stft(x)\n        result[..., 1:-1, :] *= 2.0\n        logger.debug(f\"SciPy STFT applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.STFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.STFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/en/api/#wandas.processing.time_series.STFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    n_samples = input_shape[-1]\n    n_f = len(self.SFT.f)\n    n_t = len(self.SFT.t(n_samples))\n    return (input_shape[0], n_f, n_t)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.Sum","title":"<code>Sum</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Sum calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Sum(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Sum calculation\"\"\"\n\n    name = \"sum\"\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # Use Dask's aggregate function directly without map_blocks\n        return data.sum(axis=0, keepdims=True)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.TransferFunction","title":"<code>TransferFunction</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Transfer function estimation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class TransferFunction(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Transfer function estimation operation\"\"\"\n\n    name = \"transfer_function\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ):\n        \"\"\"\n        Initialize transfer function estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        scaling : str\n            Type of scaling\n        average : str\n            Method of averaging\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        self.scaling = scaling\n        self.average = average\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n            scaling=scaling,\n            average=average,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Processor function for transfer function estimation operation\"\"\"\n        logger.debug(\n            f\"Applying transfer function estimation to array with shape: {x.shape}\"\n        )\n        from scipy import signal as ss\n\n        # Calculate cross-spectral density between all channels\n        f, p_yx = ss.csd(\n            x=x[:, np.newaxis, :],\n            y=x[np.newaxis, :, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n            axis=-1,\n        )\n        # p_yx shape: (num_channels, num_channels, num_frequencies)\n\n        # Calculate power spectral density for each channel\n        f, p_xx = ss.welch(\n            x=x,\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n            axis=-1,\n        )\n        # p_xx shape: (num_channels, num_frequencies)\n\n        # Calculate transfer function H(f) = P_yx / P_xx\n        h_f = p_yx / p_xx[np.newaxis, :, :]\n        result: NDArrayComplex = h_f.transpose(1, 0, 2).reshape(-1, h_f.shape[-1])\n\n        logger.debug(\n            f\"Transfer function estimation applied, result shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.TransferFunction.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend, scaling='spectrum', average='mean')</code>","text":"<p>Initialize transfer function estimation operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.TransferFunction.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend scaling : str     Type of scaling average : str     Method of averaging</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n):\n    \"\"\"\n    Initialize transfer function estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    scaling : str\n        Type of scaling\n    average : str\n        Method of averaging\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    self.scaling = scaling\n    self.average = average\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n        scaling=scaling,\n        average=average,\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.TransferFunction.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.TransferFunction.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/en/api/#wandas.processing.time_series.TransferFunction.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.Trim","title":"<code>Trim</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Trimming operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Trim(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Trimming operation\"\"\"\n\n    name = \"trim\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        start: float,\n        end: float,\n    ):\n        \"\"\"\n        Initialize trimming operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        start : float\n            Start time for trimming (seconds)\n        end : float\n            End time for trimming (seconds)\n        \"\"\"\n        super().__init__(sampling_rate, start=start, end=end)\n        self.start = start\n        self.end = end\n        self.start_sample = int(start * sampling_rate)\n        self.end_sample = int(end * sampling_rate)\n        logger.debug(\n            f\"Initialized Trim operation with start: {self.start}, end: {self.end}\"\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after trimming\n        # Exclude parts where there is no signal\n        end_sample = min(self.end_sample, input_shape[-1])\n        n_samples = end_sample - self.start_sample\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for trimming operation\"\"\"\n        logger.debug(f\"Applying trim to array with shape: {x.shape}\")\n        # Apply trimming\n        result = x[..., self.start_sample : self.end_sample]\n        logger.debug(f\"Trim applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.Trim.__init__","title":"<code>__init__(sampling_rate, start, end)</code>","text":"<p>Initialize trimming operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.Trim.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) start : float     Start time for trimming (seconds) end : float     End time for trimming (seconds)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    start: float,\n    end: float,\n):\n    \"\"\"\n    Initialize trimming operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    start : float\n        Start time for trimming (seconds)\n    end : float\n        End time for trimming (seconds)\n    \"\"\"\n    super().__init__(sampling_rate, start=start, end=end)\n    self.start = start\n    self.end = end\n    self.start_sample = int(start * sampling_rate)\n    self.end_sample = int(end * sampling_rate)\n    logger.debug(\n        f\"Initialized Trim operation with start: {self.start}, end: {self.end}\"\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.Trim.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.Trim.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/en/api/#wandas.processing.time_series.Trim.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after trimming\n    # Exclude parts where there is no signal\n    end_sample = min(self.end_sample, input_shape[-1])\n    n_samples = end_sample - self.start_sample\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.Welch","title":"<code>Welch</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Welch</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Welch(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Welch\"\"\"\n\n    name = \"welch\"\n    n_fft: int\n    window: str\n    hop_length: Optional[int]\n    win_length: Optional[int]\n    average: str\n    detrend: str\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        average: str = \"mean\",\n        detrend: str = \"constant\",\n    ):\n        \"\"\"\n        Initialize Welch operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int, optional\n            FFT size, default is 2048\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.noverlap = (\n            self.win_length - self.hop_length if hop_length is not None else None\n        )\n        self.window = window\n        self.average = average\n        self.detrend = detrend\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n            average=average,\n            detrend=detrend,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, freqs)\n        \"\"\"\n        n_freqs = self.n_fft // 2 + 1\n        return (*input_shape[:-1], n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for Welch operation\"\"\"\n        from scipy import signal as ss\n\n        _, result = ss.welch(\n            x,\n            nperseg=self.win_length,\n            noverlap=self.noverlap,\n            nfft=self.n_fft,\n            window=self.window,\n            average=self.average,\n            detrend=self.detrend,\n            scaling=\"spectrum\",\n        )\n\n        if not isinstance(x, np.ndarray):\n            # Trigger computation for Dask array\n            raise ValueError(\n                \"Welch operation requires a Dask array, but received a non-ndarray.\"\n            )\n        return np.array(result)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.Welch.__init__","title":"<code>__init__(sampling_rate, n_fft=2048, hop_length=None, win_length=None, window='hann', average='mean', detrend='constant')</code>","text":"<p>Initialize Welch operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.Welch.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int, optional     FFT size, default is 2048 window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    average: str = \"mean\",\n    detrend: str = \"constant\",\n):\n    \"\"\"\n    Initialize Welch operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int, optional\n        FFT size, default is 2048\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.noverlap = (\n        self.win_length - self.hop_length if hop_length is not None else None\n    )\n    self.window = window\n    self.average = average\n    self.detrend = detrend\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        win_length=self.win_length,\n        hop_length=self.hop_length,\n        window=window,\n        average=average,\n        detrend=detrend,\n    )\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.Welch.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/en/api/#wandas.processing.time_series.Welch.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/en/api/#wandas.processing.time_series.Welch.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, freqs)\n    \"\"\"\n    n_freqs = self.n_fft // 2 + 1\n    return (*input_shape[:-1], n_freqs)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.create_operation","title":"<code>create_operation(name, sampling_rate, **params)</code>","text":"<p>Create operation instance from name and parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def create_operation(\n    name: str, sampling_rate: float, **params: Any\n) -&gt; AudioOperation[Any, Any]:\n    \"\"\"Create operation instance from name and parameters\"\"\"\n    operation_class = get_operation(name)\n    return operation_class(sampling_rate, **params)\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.get_operation","title":"<code>get_operation(name)</code>","text":"<p>Get operation class by name</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def get_operation(name: str) -&gt; type[AudioOperation[Any, Any]]:\n    \"\"\"Get operation class by name\"\"\"\n    if name not in _OPERATION_REGISTRY:\n        raise ValueError(f\"Unknown operation type: {name}\")\n    return _OPERATION_REGISTRY[name]\n</code></pre>"},{"location":"en/en/api/#wandas.processing.time_series.register_operation","title":"<code>register_operation(operation_class)</code>","text":"<p>Register a new operation type</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def register_operation(operation_class: type) -&gt; None:\n    \"\"\"Register a new operation type\"\"\"\n\n    if not issubclass(operation_class, AudioOperation):\n        raise TypeError(\"Strategy class must inherit from AudioOperation.\")\n    if inspect.isabstract(operation_class):\n        raise TypeError(\"Cannot register abstract AudioOperation class.\")\n\n    _OPERATION_REGISTRY[operation_class.name] = operation_class\n</code></pre>"},{"location":"en/en/api/#utilities","title":"Utilities","text":""},{"location":"en/en/api/core/","title":"Core Module","text":"<p>This page explains the core module of Wandas. The core module provides the basic data structures and functionality of Wandas.</p>"},{"location":"en/en/api/core/#baseframe","title":"BaseFrame","text":"<p><code>BaseFrame</code> is the base class for all frame classes in Wandas. You don't instantiate this class directly but use it through derived classes (like ChannelFrame).</p> <pre><code>from wandas.core.base_frame import BaseFrame\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for all signal frame types.</p> <p>This class provides the common interface and functionality for all frame types used in signal processing. It implements basic operations like indexing, iteration, and data manipulation that are shared across all frame types.</p>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The signal data to process. Must be a dask array. sampling_rate : float     The sampling rate of the signal in Hz. label : str, optional     A label for the frame. If not provided, defaults to \"unnamed_frame\". metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame--attributes","title":"Attributes","text":"<p>sampling_rate : float     The sampling rate of the signal in Hz. label : str     The label of the frame. metadata : dict     Additional metadata for the frame. operation_history : list[dict]     History of operations performed on this frame.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>class BaseFrame(ABC, Generic[T]):\n    \"\"\"\n    Abstract base class for all signal frame types.\n\n    This class provides the common interface and functionality for all frame types\n    used in signal processing. It implements basic operations like indexing, iteration,\n    and data manipulation that are shared across all frame types.\n\n    Parameters\n    ----------\n    data : DaArray\n        The signal data to process. Must be a dask array.\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str, optional\n        A label for the frame. If not provided, defaults to \"unnamed_frame\".\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str\n        The label of the frame.\n    metadata : dict\n        Additional metadata for the frame.\n    operation_history : list[dict]\n        History of operations performed on this frame.\n    \"\"\"\n\n    _data: DaArray\n    sampling_rate: float\n    label: str\n    metadata: dict[str, Any]\n    operation_history: list[dict[str, Any]]\n    _channel_metadata: list[ChannelMetadata]\n    _previous: Optional[\"BaseFrame[Any]\"]\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ):\n        self._data = data.rechunk(chunks=-1)  # type: ignore [unused-ignore]\n        if self._data.ndim == 1:\n            self._data = self._data.reshape((1, -1))\n        self.sampling_rate = sampling_rate\n        self.label = label or \"unnamed_frame\"\n        self.metadata = metadata or {}\n        self.operation_history = operation_history or []\n        self._previous = previous\n\n        if channel_metadata:\n            self._channel_metadata = copy.deepcopy(channel_metadata)\n        else:\n            self._channel_metadata = [\n                ChannelMetadata(label=f\"ch{i}\", unit=\"\", extra={})\n                for i in range(self._n_channels)\n            ]\n\n        try:\n            # Display information for newer dask versions\n            logger.debug(f\"Dask graph layers: {list(self._data.dask.layers.keys())}\")\n            logger.debug(\n                f\"Dask graph dependencies: {len(self._data.dask.dependencies)}\"\n            )\n        except Exception as e:\n            logger.debug(f\"Dask graph visualization details unavailable: {e}\")\n\n    @property\n    @abstractmethod\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n\n    @property\n    def n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return len(self)\n\n    @property\n    def channels(self) -&gt; list[ChannelMetadata]:\n        \"\"\"Property to access channel metadata.\"\"\"\n        return self._channel_metadata\n\n    @property\n    def previous(self) -&gt; Optional[\"BaseFrame[Any]\"]:\n        \"\"\"\n        Returns the previous frame.\n        \"\"\"\n        return self._previous\n\n    def get_channel(self: S, channel_idx: int) -&gt; S:\n        n_channels = len(self)\n        if channel_idx &lt; 0 or channel_idx &gt;= n_channels:\n            range_max = n_channels - 1\n            raise ValueError(\n                f\"Channel index out of range: {channel_idx} \"\n                f\"(valid range: 0-{range_max})\"\n            )\n        logger.debug(f\"Extracting channel index={channel_idx} (lazy operation).\")\n        channel_data = self._data[channel_idx : channel_idx + 1]\n\n        return self._create_new_instance(\n            data=channel_data,\n            operation_history=self.operation_history,\n            channel_metadata=[self._channel_metadata[channel_idx]],\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Returns the number of channels.\n        \"\"\"\n        return len(self._channel_metadata)\n\n    def __iter__(self: S) -&gt; Iterator[S]:\n        for idx in range(len(self)):\n            yield self[idx]\n\n    def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n        \"\"\"\n        Method to get a channel by name or index.\n\n        Parameters\n        ----------\n        key : str, int, slice, or tuple of slices\n            Channel name (label) or index number.\n\n        Returns\n        -------\n        BaseFrame\n            The corresponding channel.\n\n        Raises\n        ------\n        ValueError\n            If the key length is invalid for the shape.\n        IndexError\n            If the channel index is out of range.\n        TypeError\n            If the key type is invalid.\n        \"\"\"\n        if isinstance(key, str):\n            index = self.label2index(key)\n            return self.get_channel(index)\n\n        elif isinstance(key, tuple):\n            # When key is a tuple, treat the first element as an index\n            if len(key) &gt; len(self.shape):\n                raise ValueError(\n                    f\"Invalid key length: {len(key)} for shape {self.shape}\"\n                )\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key[0]]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, slice):\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, numbers.Integral):\n            # Access by index number\n            if key &lt; 0 or key &gt;= len(self):\n                raise IndexError(f\"Channel index {key} out of range.\")\n            return self.get_channel(key)\n        else:\n            raise TypeError(\n                f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n            )\n\n    def label2index(self, label: str) -&gt; int:\n        \"\"\"\n        Get the index from a channel label.\n\n        Parameters\n        ----------\n        label : str\n            Channel label.\n\n        Returns\n        -------\n        int\n            Corresponding index.\n\n        Raises\n        ------\n        KeyError\n            If the channel label is not found.\n        \"\"\"\n        for idx, ch in enumerate(self._channel_metadata):\n            if ch.label == label:\n                return idx\n        raise KeyError(f\"Channel label '{label}' not found.\")\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        _shape: tuple[int, ...] = self._data.shape\n        return _shape\n\n    @property\n    def data(self) -&gt; T:\n        \"\"\"\n        Returns the computed data.\n        Calculation is executed the first time this is accessed.\n        \"\"\"\n        return self.compute()\n\n    @property\n    def labels(self) -&gt; list[str]:\n        \"\"\"Get a list of all channel labels.\"\"\"\n        return [ch.label for ch in self._channel_metadata]\n\n    def compute(self) -&gt; T:\n        \"\"\"\n        Compute and return the data.\n        This method materializes lazily computed data into a concrete NumPy array.\n\n        Returns\n        -------\n        NDArrayReal\n            The computed data.\n\n        Raises\n        ------\n        ValueError\n            If the computed result is not a NumPy array.\n        \"\"\"\n        logger.debug(\n            \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n        )\n        result = self._data.compute()\n\n        if not isinstance(result, np.ndarray):\n            raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n        logger.debug(f\"Computation complete, result shape: {result.shape}\")\n        return cast(T, result)\n\n    @abstractmethod\n    def plot(\n        self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n    ) -&gt; Union[Axes, Iterator[Axes]]:\n        \"\"\"Plot the data\"\"\"\n        pass\n\n    def persist(self: S) -&gt; S:\n        \"\"\"Persist the data in memory\"\"\"\n        persisted_data = self._data.persist()\n        return self._create_new_instance(data=persisted_data)\n\n    @abstractmethod\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Abstract method for derived classes to provide\n        additional initialization arguments.\n        \"\"\"\n        pass\n\n    def _create_new_instance(self: S, data: DaArray, **kwargs: Any) -&gt; S:\n        \"\"\"\n        Create a new channel instance based on an existing channel.\n        Keyword arguments can override or extend the original attributes.\n        \"\"\"\n\n        sampling_rate = kwargs.pop(\"sampling_rate\", self.sampling_rate)\n        # if not isinstance(sampling_rate, int):\n        #     raise TypeError(\"Sampling rate must be an integer\")\n\n        label = kwargs.pop(\"label\", self.label)\n        if not isinstance(label, str):\n            raise TypeError(\"Label must be a string\")\n\n        metadata = kwargs.pop(\"metadata\", copy.deepcopy(self.metadata))\n        if not isinstance(metadata, dict):\n            raise TypeError(\"Metadata must be a dictionary\")\n\n        # Get additional initialization arguments from derived classes\n        additional_kwargs = self._get_additional_init_kwargs()\n        kwargs.update(additional_kwargs)\n\n        return type(self)(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            previous=self,\n            **kwargs,\n        )\n\n    def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n        \"\"\"Implicit conversion to NumPy array\"\"\"\n        result = self.compute()\n        if dtype is not None:\n            return result.astype(dtype)\n        return result\n\n    def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n        \"\"\"Visualize the computation graph and save it to a file\"\"\"\n        try:\n            filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n            self._data.visualize(filename=filename)\n            return filename\n        except Exception as e:\n            logger.warning(f\"Failed to visualize the graph: {e}\")\n            return None\n\n    @abstractmethod\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"Basic implementation of binary operations\"\"\"\n        # Basic logic\n        # Actual implementation is left to derived classes\n        pass\n\n    def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Addition operator\"\"\"\n        return self._binary_op(other, lambda x, y: x + y, \"+\")\n\n    def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Subtraction operator\"\"\"\n        return self._binary_op(other, lambda x, y: x - y, \"-\")\n\n    def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Multiplication operator\"\"\"\n        return self._binary_op(other, lambda x, y: x * y, \"*\")\n\n    def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Division operator\"\"\"\n        return self._binary_op(other, lambda x, y: x / y, \"/\")\n\n    def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Apply a named operation.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters to pass to the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        # Apply the operation through abstract method\n        return self._apply_operation_impl(operation_name, **params)\n\n    @abstractmethod\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"Implementation of operation application\"\"\"\n        pass\n\n    def debug_info(self) -&gt; None:\n        \"\"\"Output detailed debug information\"\"\"\n        logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n        logger.debug(f\"Label: {self.label}\")\n        logger.debug(f\"Shape: {self.shape}\")\n        logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n        logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n        self._debug_info_impl()\n        logger.debug(\"=== End Debug Info ===\")\n\n    def _debug_info_impl(self) -&gt; None:\n        \"\"\"Implement derived class-specific debug information\"\"\"\n        pass\n</code></pre>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.channels","title":"<code>channels</code>  <code>property</code>","text":"<p>Property to access channel metadata.</p>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.data","title":"<code>data</code>  <code>property</code>","text":"<p>Returns the computed data. Calculation is executed the first time this is accessed.</p>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>Get a list of all channel labels.</p>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.n_channels","title":"<code>n_channels</code>  <code>property</code>","text":"<p>Returns the number of channels.</p>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.previous","title":"<code>previous</code>  <code>property</code>","text":"<p>Returns the previous frame.</p>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.__add__","title":"<code>__add__(other)</code>","text":"<p>Addition operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Addition operator\"\"\"\n    return self._binary_op(other, lambda x, y: x + y, \"+\")\n</code></pre>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.__array__","title":"<code>__array__(dtype=None)</code>","text":"<p>Implicit conversion to NumPy array</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n    \"\"\"Implicit conversion to NumPy array\"\"\"\n    result = self.compute()\n    if dtype is not None:\n        return result.astype(dtype)\n    return result\n</code></pre>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Method to get a channel by name or index.</p>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.__getitem__--parameters","title":"Parameters","text":"<p>key : str, int, slice, or tuple of slices     Channel name (label) or index number.</p>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.__getitem__--returns","title":"Returns","text":"<p>BaseFrame     The corresponding channel.</p>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.__getitem__--raises","title":"Raises","text":"<p>ValueError     If the key length is invalid for the shape. IndexError     If the channel index is out of range. TypeError     If the key type is invalid.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n    \"\"\"\n    Method to get a channel by name or index.\n\n    Parameters\n    ----------\n    key : str, int, slice, or tuple of slices\n        Channel name (label) or index number.\n\n    Returns\n    -------\n    BaseFrame\n        The corresponding channel.\n\n    Raises\n    ------\n    ValueError\n        If the key length is invalid for the shape.\n    IndexError\n        If the channel index is out of range.\n    TypeError\n        If the key type is invalid.\n    \"\"\"\n    if isinstance(key, str):\n        index = self.label2index(key)\n        return self.get_channel(index)\n\n    elif isinstance(key, tuple):\n        # When key is a tuple, treat the first element as an index\n        if len(key) &gt; len(self.shape):\n            raise ValueError(\n                f\"Invalid key length: {len(key)} for shape {self.shape}\"\n            )\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key[0]]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, slice):\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, numbers.Integral):\n        # Access by index number\n        if key &lt; 0 or key &gt;= len(self):\n            raise IndexError(f\"Channel index {key} out of range.\")\n        return self.get_channel(key)\n    else:\n        raise TypeError(\n            f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n        )\n</code></pre>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of channels.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of channels.\n    \"\"\"\n    return len(self._channel_metadata)\n</code></pre>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplication operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Multiplication operator\"\"\"\n    return self._binary_op(other, lambda x, y: x * y, \"*\")\n</code></pre>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtraction operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Subtraction operator\"\"\"\n    return self._binary_op(other, lambda x, y: x - y, \"-\")\n</code></pre>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Division operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Division operator\"\"\"\n    return self._binary_op(other, lambda x, y: x / y, \"/\")\n</code></pre>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.apply_operation","title":"<code>apply_operation(operation_name, **params)</code>","text":"<p>Apply a named operation.</p>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.apply_operation--parameters","title":"Parameters","text":"<p>operation_name : str     Name of the operation to apply. **params : Any     Parameters to pass to the operation.</p>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.apply_operation--returns","title":"Returns","text":"<p>S     A new instance with the operation applied.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n    \"\"\"\n    Apply a named operation.\n\n    Parameters\n    ----------\n    operation_name : str\n        Name of the operation to apply.\n    **params : Any\n        Parameters to pass to the operation.\n\n    Returns\n    -------\n    S\n        A new instance with the operation applied.\n    \"\"\"\n    # Apply the operation through abstract method\n    return self._apply_operation_impl(operation_name, **params)\n</code></pre>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.compute","title":"<code>compute()</code>","text":"<p>Compute and return the data. This method materializes lazily computed data into a concrete NumPy array.</p>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.compute--returns","title":"Returns","text":"<p>NDArrayReal     The computed data.</p>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.compute--raises","title":"Raises","text":"<p>ValueError     If the computed result is not a NumPy array.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def compute(self) -&gt; T:\n    \"\"\"\n    Compute and return the data.\n    This method materializes lazily computed data into a concrete NumPy array.\n\n    Returns\n    -------\n    NDArrayReal\n        The computed data.\n\n    Raises\n    ------\n    ValueError\n        If the computed result is not a NumPy array.\n    \"\"\"\n    logger.debug(\n        \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n    )\n    result = self._data.compute()\n\n    if not isinstance(result, np.ndarray):\n        raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n    logger.debug(f\"Computation complete, result shape: {result.shape}\")\n    return cast(T, result)\n</code></pre>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.debug_info","title":"<code>debug_info()</code>","text":"<p>Output detailed debug information</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def debug_info(self) -&gt; None:\n    \"\"\"Output detailed debug information\"\"\"\n    logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n    logger.debug(f\"Label: {self.label}\")\n    logger.debug(f\"Shape: {self.shape}\")\n    logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n    logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n    self._debug_info_impl()\n    logger.debug(\"=== End Debug Info ===\")\n</code></pre>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.label2index","title":"<code>label2index(label)</code>","text":"<p>Get the index from a channel label.</p>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.label2index--parameters","title":"Parameters","text":"<p>label : str     Channel label.</p>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.label2index--returns","title":"Returns","text":"<p>int     Corresponding index.</p>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.label2index--raises","title":"Raises","text":"<p>KeyError     If the channel label is not found.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def label2index(self, label: str) -&gt; int:\n    \"\"\"\n    Get the index from a channel label.\n\n    Parameters\n    ----------\n    label : str\n        Channel label.\n\n    Returns\n    -------\n    int\n        Corresponding index.\n\n    Raises\n    ------\n    KeyError\n        If the channel label is not found.\n    \"\"\"\n    for idx, ch in enumerate(self._channel_metadata):\n        if ch.label == label:\n            return idx\n    raise KeyError(f\"Channel label '{label}' not found.\")\n</code></pre>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.persist","title":"<code>persist()</code>","text":"<p>Persist the data in memory</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def persist(self: S) -&gt; S:\n    \"\"\"Persist the data in memory\"\"\"\n    persisted_data = self._data.persist()\n    return self._create_new_instance(data=persisted_data)\n</code></pre>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.plot","title":"<code>plot(plot_type='default', ax=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Plot the data</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>@abstractmethod\ndef plot(\n    self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n) -&gt; Union[Axes, Iterator[Axes]]:\n    \"\"\"Plot the data\"\"\"\n    pass\n</code></pre>"},{"location":"en/en/api/core/#wandas.core.base_frame.BaseFrame.visualize_graph","title":"<code>visualize_graph(filename=None)</code>","text":"<p>Visualize the computation graph and save it to a file</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"Visualize the computation graph and save it to a file\"\"\"\n    try:\n        filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n        self._data.visualize(filename=filename)\n        return filename\n    except Exception as e:\n        logger.warning(f\"Failed to visualize the graph: {e}\")\n        return None\n</code></pre>"},{"location":"en/en/api/core/#channelmetadata","title":"ChannelMetadata","text":"<p><code>ChannelMetadata</code> is a class for managing metadata for each channel. It holds channel names, units, and other additional information.</p> <pre><code>from wandas.core.metadata import ChannelMetadata\n\n# Usage example\nmetadata = ChannelMetadata(label=\"Left Channel\", unit=\"dB\", extra={\"device\": \"Microphone\"})\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>Data class for storing channel metadata</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>class ChannelMetadata(BaseModel):\n    \"\"\"\n    Data class for storing channel metadata\n    \"\"\"\n\n    label: str = \"\"\n    unit: str = \"\"\n    ref: float = 1.0\n    # Additional metadata for extensibility\n    extra: dict[str, Any] = Field(default_factory=dict)\n\n    def __getitem__(self, key: str) -&gt; Any:\n        \"\"\"Provide dictionary-like behavior\"\"\"\n        if key == \"label\":\n            return self.label\n        elif key == \"unit\":\n            return self.unit\n        elif key == \"ref\":\n            return self.ref\n        else:\n            return self.extra.get(key)\n\n    def __setitem__(self, key: str, value: Any) -&gt; None:\n        \"\"\"Provide dictionary-like behavior\"\"\"\n        if key == \"label\":\n            self.label = value\n        elif key == \"unit\":\n            self.unit = value\n        elif key == \"ref\":\n            self.ref = value\n        else:\n            self.extra[key] = value\n\n    def to_json(self) -&gt; str:\n        \"\"\"Convert to JSON format\"\"\"\n        json_data: str = self.model_dump_json(indent=4)\n        return json_data\n\n    @classmethod\n    def from_json(cls, json_data: str) -&gt; \"ChannelMetadata\":\n        \"\"\"Convert from JSON format\"\"\"\n        root_model: ChannelMetadata = ChannelMetadata.model_validate_json(json_data)\n\n        return root_model\n</code></pre>"},{"location":"en/en/api/core/#wandas.core.metadata.ChannelMetadata.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Provide dictionary-like behavior</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Any:\n    \"\"\"Provide dictionary-like behavior\"\"\"\n    if key == \"label\":\n        return self.label\n    elif key == \"unit\":\n        return self.unit\n    elif key == \"ref\":\n        return self.ref\n    else:\n        return self.extra.get(key)\n</code></pre>"},{"location":"en/en/api/core/#wandas.core.metadata.ChannelMetadata.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Provide dictionary-like behavior</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def __setitem__(self, key: str, value: Any) -&gt; None:\n    \"\"\"Provide dictionary-like behavior\"\"\"\n    if key == \"label\":\n        self.label = value\n    elif key == \"unit\":\n        self.unit = value\n    elif key == \"ref\":\n        self.ref = value\n    else:\n        self.extra[key] = value\n</code></pre>"},{"location":"en/en/api/core/#wandas.core.metadata.ChannelMetadata.from_json","title":"<code>from_json(json_data)</code>  <code>classmethod</code>","text":"<p>Convert from JSON format</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>@classmethod\ndef from_json(cls, json_data: str) -&gt; \"ChannelMetadata\":\n    \"\"\"Convert from JSON format\"\"\"\n    root_model: ChannelMetadata = ChannelMetadata.model_validate_json(json_data)\n\n    return root_model\n</code></pre>"},{"location":"en/en/api/core/#wandas.core.metadata.ChannelMetadata.to_json","title":"<code>to_json()</code>","text":"<p>Convert to JSON format</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Convert to JSON format\"\"\"\n    json_data: str = self.model_dump_json(indent=4)\n    return json_data\n</code></pre>"},{"location":"en/en/api/frames/","title":"Frame Module","text":"<p>This page explains the frame modules in Wandas. The frame module includes various types of data frames.</p>"},{"location":"en/en/api/frames/#channelframe","title":"ChannelFrame","text":"<p><code>ChannelFrame</code> is a frame that handles time-domain signal data.</p> <pre><code>from wandas.frames.channel import ChannelFrame\n\n# Or\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")  # Returns a ChannelFrame instance\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Channel-based data frame for handling audio signals and time series data.</p> <p>This frame represents channel-based data such as audio signals and time series data, with each channel containing data samples in the time domain.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>class ChannelFrame(BaseFrame[NDArrayReal]):\n    \"\"\"Channel-based data frame for handling audio signals and time series data.\n\n    This frame represents channel-based data such as audio signals and time series data,\n    with each channel containing data samples in the time domain.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"Initialize a ChannelFrame.\n\n        Args:\n            data: Dask array containing channel data.\n            Shape should be (n_channels, n_samples).\n            sampling_rate: The sampling rate of the data in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            operation_history: History of operations applied to the frame.\n            channel_metadata: Metadata for each channel.\n            previous: Reference to the previous frame in the processing chain.\n\n        Raises:\n            ValueError: If data has more than 2 dimensions.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return self.shape[-2]\n\n    @property\n    def time(self) -&gt; NDArrayReal:\n        \"\"\"Get time array for the signal.\n\n        Returns:\n            Array of time points in seconds.\n        \"\"\"\n        return np.arange(self.n_samples) / self.sampling_rate\n\n    @property\n    def n_samples(self) -&gt; int:\n        \"\"\"Returns the number of samples.\"\"\"\n        n: int = self._data.shape[-1]\n        return n\n\n    @property\n    def duration(self) -&gt; float:\n        \"\"\"Returns the duration in seconds.\"\"\"\n        return self.n_samples / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # Apply processing to data\n        processed_data = operation.process(self._data)\n\n        # Update metadata\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        if operation_name == \"resampling\":\n            # For resampling, update sampling rate\n            return self._create_new_instance(\n                sampling_rate=params[\"target_sr\"],\n                data=processed_data,\n                metadata=new_metadata,\n                operation_history=new_history,\n            )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Common implementation for binary operations\n        - utilizing dask's lazy evaluation.\n\n        Args:\n            other: Right operand for the operation.\n            op: Function to execute the operation (e.g., lambda a, b: a + b).\n            symbol: Symbolic representation of the operation (e.g., '+').\n\n        Returns:\n            A new channel containing the operation result (lazy execution).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, ChannelFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Perform operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other._data)\n\n            # Merge channel metadata\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # Perform operation with scalar, NumPy array, or other types\n        else:\n            # Apply operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other)\n\n            # Operand display string\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # Check for dask.array.Array\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # Update channel metadata\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n                previous=self,\n            )\n\n    def add(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        snr: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Add another signal or value to the current signal.\n\n        If SNR is specified, performs addition with consideration for\n        signal-to-noise ratio.\n\n        Args:\n            other: Signal or value to add.\n            snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n                other signal based on this SNR.\n                self is treated as the signal, and other as the noise.\n\n        Returns:\n            A new channel frame containing the addition result (lazy execution).\n        \"\"\"\n        logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n        # Special processing when SNR is specified\n        if snr is not None:\n            # First convert other to ChannelFrame if it's not\n            if not isinstance(other, ChannelFrame):\n                if isinstance(other, np.ndarray):\n                    other = ChannelFrame.from_numpy(\n                        other, self.sampling_rate, label=\"array_data\"\n                    )\n                elif isinstance(other, (int, float)):\n                    # For scalar values, simply add (ignore SNR)\n                    return self + other\n                else:\n                    raise TypeError(\n                        \"Addition target with SNR must be a ChannelFrame or \"\n                        f\"NumPy array: {type(other)}\"\n                    )\n\n            # Check if sampling rates match\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Apply addition operation with SNR adjustment\n            return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n        # Execute normal addition if SNR is not specified\n        return self + other\n\n    def plot(\n        self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Plot the frame data.\n\n        Args:\n            plot_type: Type of plot. Default is \"waveform\".\n            ax: Optional matplotlib axes for plotting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        plot_strategy = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def rms_plot(\n        self,\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = True,\n        Aw: bool = False,  # noqa: N803\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Generate an RMS plot.\n\n        Args:\n            ax: Optional matplotlib axes for plotting.\n            title: Title for the plot.\n            overlay: Whether to overlay the plot on the existing axis.\n            Aw: Apply A-weighting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        kwargs = kwargs or {}\n        ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n        rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n        return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n\n    def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n        \"\"\"Display visual and audio representation of the frame.\n\n        Args:\n            normalize: Whether to normalize the audio data for playback.\n            **kwargs: Additional parameters for visualization.\n        \"\"\"\n        if \"axis_config\" in kwargs:\n            logger.warning(\n                \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            axis_config = kwargs[\"axis_config\"]\n            if \"time_plot\" in axis_config:\n                kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n            if \"freq_plot\" in axis_config:\n                if \"xlim\" in axis_config[\"freq_plot\"]:\n                    vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                    kwargs[\"vmin\"] = vlim[0]\n                    kwargs[\"vmax\"] = vlim[1]\n                if \"ylim\" in axis_config[\"freq_plot\"]:\n                    ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                    kwargs[\"ylim\"] = ylim\n\n        if \"cbar_config\" in kwargs:\n            logger.warning(\n                \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            cbar_config = kwargs[\"cbar_config\"]\n            if \"vmin\" in cbar_config:\n                kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n            if \"vmax\" in cbar_config:\n                kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n        for ch in self:\n            ax: Axes\n            _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n            if isinstance(_ax, Iterator):\n                ax = next(iter(_ax))\n            elif isinstance(_ax, Axes):\n                ax = _ax\n            else:\n                raise TypeError(\n                    f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n                )\n            # Ignore type checks for display and Audio\n            display(ax.figure)  # type: ignore\n            plt.close(ax.figure)  # type: ignore\n            display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n\n    @classmethod\n    def from_numpy(\n        cls,\n        data: NDArrayReal,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        ch_labels: Optional[list[str]] = None,\n        ch_units: Optional[Union[list[str], str]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        Args:\n            data: NumPy array containing channel data.\n            sampling_rate: The sampling rate in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            ch_labels: Labels for each channel.\n            ch_units: Units for each channel.\n\n        Returns:\n            A new ChannelFrame containing the NumPy data.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n\n        # Convert NumPy array to dask array\n        dask_data = da_from_array(data)\n        cf = ChannelFrame(\n            data=dask_data,\n            sampling_rate=sampling_rate,\n            label=label or \"numpy_data\",\n        )\n        if metadata is not None:\n            cf.metadata = metadata\n        if ch_labels is not None:\n            if len(ch_labels) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel labels does not match the number of channels\"\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        if ch_units is not None:\n            if isinstance(ch_units, str):\n                ch_units = [ch_units] * cf.n_channels\n\n            if len(ch_units) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel units does not match the number of channels\"\n                )\n            for i in range(len(ch_units)):\n                cf._channel_metadata[i].unit = ch_units[i]\n\n        return cf\n\n    @classmethod\n    def from_ndarray(\n        cls,\n        array: NDArrayReal,\n        sampling_rate: float,\n        labels: Optional[list[str]] = None,\n        unit: Optional[Union[list[str], str]] = None,\n        frame_label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        This method is deprecated. Use from_numpy instead.\n\n        Args:\n            array: Signal data. Each row corresponds to a channel.\n            sampling_rate: Sampling rate (Hz).\n            labels: Labels for each channel.\n            unit: Unit of the signal.\n            frame_label: Label for the frame.\n            metadata: Optional metadata dictionary.\n\n        Returns:\n            A new ChannelFrame containing the data.\n        \"\"\"\n        # Redirect to from_numpy for compatibility\n        # However, from_ndarray is deprecated\n        logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n        return cls.from_numpy(\n            data=array,\n            sampling_rate=sampling_rate,\n            label=frame_label,\n            metadata=metadata,\n            ch_labels=labels,\n            ch_units=unit,\n        )\n\n    @classmethod\n    def from_file(\n        cls,\n        path: Union[str, Path],\n        channel: Optional[Union[int, list[int]]] = None,\n        start: Optional[float] = None,\n        end: Optional[float] = None,\n        chunk_size: Optional[int] = None,\n        ch_labels: Optional[list[str]] = None,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from an audio file.\n\n        Args:\n            path: Path to the audio file.\n            channel: Channel(s) to load.\n            start: Start time in seconds.\n            end: End time in seconds.\n            chunk_size: Chunk size for processing.\n            Specifies the splitting size for lazy processing.\n            ch_labels: Labels for each channel.\n            **kwargs: Additional arguments passed to the file reader.\n\n        Returns:\n            A new ChannelFrame containing the loaded audio data.\n\n        Raises:\n            ValueError: If channel selection is invalid.\n            TypeError: If channel parameter type is invalid.\n            FileNotFoundError: If the file doesn't exist.\n        \"\"\"\n        from .channel import ChannelFrame\n\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"File not found: {path}\")\n\n        # Get file reader\n        reader = get_file_reader(path)\n\n        # Get file info\n        info = reader.get_file_info(path, **kwargs)\n        sr = info[\"samplerate\"]\n        n_channels = info[\"channels\"]\n        n_frames = info[\"frames\"]\n        ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n        logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n        # Channel selection processing\n        all_channels = list(range(n_channels))\n\n        if channel is None:\n            channels_to_load = all_channels\n            logger.debug(f\"Will load all channels: {channels_to_load}\")\n        elif isinstance(channel, int):\n            if channel &lt; 0 or channel &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n            channels_to_load = [channel]\n            logger.debug(f\"Will load single channel: {channel}\")\n        elif isinstance(channel, (list, tuple)):\n            for ch in channel:\n                if ch &lt; 0 or ch &gt;= n_channels:\n                    raise ValueError(\n                        f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                    )\n            channels_to_load = list(channel)\n            logger.debug(f\"Will load specific channels: {channels_to_load}\")\n        else:\n            raise TypeError(\"channel must be int, list, or None\")\n\n        # Index calculation\n        start_idx = 0 if start is None else max(0, int(start * sr))\n        end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n        frames_to_read = end_idx - start_idx\n\n        logger.debug(\n            f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n            f\"start_idx={start_idx}, end_idx={end_idx}\"\n        )\n\n        # Settings for lazy loading\n        expected_shape = (len(channels_to_load), frames_to_read)\n\n        # Define the loading function using the file reader\n        def _load_audio() -&gt; NDArrayReal:\n            logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n            # Use the reader to get audio data with parameters\n            out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n            if not isinstance(out, np.ndarray):\n                raise ValueError(\"Unexpected data type after reading file\")\n            return out\n\n        logger.debug(\n            f\"Creating delayed dask task with expected shape: {expected_shape}\"\n        )\n\n        # Create delayed operation\n        delayed_data = dask_delayed(_load_audio)()\n        logger.debug(\"Wrapping delayed function in dask array\")\n\n        # Create dask array from delayed computation\n        dask_array = da_from_delayed(\n            delayed_data, shape=expected_shape, dtype=np.float32\n        )\n\n        if chunk_size is not None:\n            if chunk_size &lt;= 0:\n                raise ValueError(\"Chunk size must be a positive integer\")\n            logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n            dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n        logger.debug(\n            \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n        )\n\n        cf = ChannelFrame(\n            data=dask_array,\n            sampling_rate=sr,\n            label=path.stem,\n            metadata={\n                \"filename\": str(path),\n            },\n        )\n        if ch_labels is not None:\n            if len(ch_labels) != len(cf):\n                raise ValueError(\n                    \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        return cf\n\n    @classmethod\n    def read_wav(\n        cls, filename: str, labels: Optional[list[str]] = None\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a WAV file.\n\n        Args:\n            filename: Path to the WAV file.\n            labels: Labels to set for each channel.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(filename, ch_labels=labels)\n        return cf\n\n    @classmethod\n    def read_csv(\n        cls,\n        filename: str,\n        time_column: Union[int, str] = 0,\n        labels: Optional[list[str]] = None,\n        delimiter: str = \",\",\n        header: Optional[int] = 0,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a CSV file.\n\n        Args:\n            filename: Path to the CSV file.\n            time_column: Index or name of the time column.\n            labels: Labels to set for each channel.\n            delimiter: Delimiter character.\n            header: Row number to use as header.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(\n            filename,\n            ch_labels=labels,\n            time_column=time_column,\n            delimiter=delimiter,\n            header=header,\n        )\n        return cf\n\n    def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n        \"\"\"Save the audio data to a file.\n\n        Args:\n            path: Path to save the file.\n            format: File format. If None, determined from file extension.\n        \"\"\"\n        logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n        data = self.compute()\n        data = data.T\n        if data.shape[1] == 1:\n            data = data.squeeze(axis=1)\n        sf.write(str(path), data, int(self.sampling_rate), format=format)\n        logger.debug(f\"Save complete: {path}\")\n\n    def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a high-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n\n    def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a low-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n\n    def normalize(\n        self, target_level: float = -20, channel_wise: bool = True\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Normalize the signal level.\n\n        This method adjusts the signal amplitude to reach a target RMS level.\n\n        Args:\n            target_level: Target RMS level in dB. Default is -20.\n            channel_wise: If True, normalize each channel independently.\n                If False, apply the same scaling to all channels.\n\n        Returns:\n            A new ChannelFrame containing the normalized signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n        )\n        return self.apply_operation(\n            \"normalize\", target_level=target_level, channel_wise=channel_wise\n        )\n\n    def a_weighting(self) -&gt; \"ChannelFrame\":\n        \"\"\"Apply A-weighting filter to the signal.\n\n        A-weighting adjusts the frequency response to approximate human hearing\n        perception, following IEC 61672-1:2013 standard.\n\n        Returns:\n            A new ChannelFrame with A-weighted signal.\n        \"\"\"\n        return self.apply_operation(\"a_weighting\")\n\n    def hpss_harmonic(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract harmonic components using HPSS\n         (Harmonic-Percussive Source Separation).\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_harmonic\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def hpss_percussive(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract percussive components using HPSS\n        (Harmonic-Percussive Source Separation).\n\n        This method separates the percussive (tonal) components from the signal.\n\n        Args:\n            kernel_size: Median filter size for HPSS.\n            power: Exponent for the Weiner filter used in HPSS.\n            margin: Margin size for the separation.\n\n        Returns:\n            A new ChannelFrame containing the harmonic components.\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_percussive\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def resampling(\n        self,\n        target_sr: float,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Resample audio data.\n\n        Parameters\n        ----------\n        target_sr : float\n            Target sampling rate (Hz)\n        resample_type : str, optional\n            Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n        **kwargs : dict\n            Additional resampling parameters\n\n        Returns\n        -------\n        ChannelFrame\n            Resampled channel frame\n        \"\"\"\n        return self.apply_operation(\n            \"resampling\",\n            target_sr=target_sr,\n            **kwargs,\n        )\n\n    def abs(self) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the absolute value of the signal.\n\n        Returns:\n            A new ChannelFrame containing the absolute values.\n        \"\"\"\n        return self.apply_operation(\"abs\")\n\n    def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the power of the signal.\n\n        Args:\n            exponent: The exponent to raise the signal to. Default is 2.0.\n\n        Returns:\n            A new ChannelFrame containing the signal raised to the power.\n        \"\"\"\n        return self.apply_operation(\"power\", exponent=exponent)\n\n    def trim(\n        self,\n        start: float = 0,\n        end: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Trim the signal to specified time range.\n\n        Args:\n            start: Start time in seconds.\n            end: End time in seconds.\n\n        Returns:\n            A new ChannelFrame with trimmed signal.\n\n        Raises:\n            ValueError: If end time is before start time.\n        \"\"\"\n        if end is None:\n            end = self.duration\n        if start &gt; end:\n            raise ValueError(\"start must be less than end\")\n        # Apply trim operation\n        return self.apply_operation(\"trim\", start=start, end=end)\n\n    def rms_trend(\n        self,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the RMS trend of the signal.\n\n        This method computes the root mean square value over sliding windows.\n\n        Args:\n            frame_length: The size of the sliding window in samples. Default is 2048.\n            hop_length: The hop length between windows in samples. Default is 512.\n            dB: Whether to return the RMS values in decibels. Default is False.\n            Aw: Whether to apply A-weighting. Default is False.\n\n        Returns:\n            A new ChannelFrame containing the RMS trend.\n        \"\"\"\n        cf = self.apply_operation(\n            \"rms_trend\",\n            frame_length=frame_length,\n            hop_length=hop_length,\n            ref=[ch.ref for ch in self._channel_metadata],\n            dB=dB,\n            Aw=Aw,\n        )\n        cf.sampling_rate = self.sampling_rate / hop_length\n        return cf\n\n    def sum(self) -&gt; \"ChannelFrame\":\n        \"\"\"Sum all channels.\n\n        Returns:\n            A new ChannelFrame with summed signal.\n        \"\"\"\n        return self.apply_operation(\"sum\")\n\n    def mean(self) -&gt; \"ChannelFrame\":\n        \"\"\"Average all channels.\n\n        Returns:\n            A new ChannelFrame with averaged signal.\n        \"\"\"\n        return self.apply_operation(\"mean\")\n\n    def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate channel differences relative to a reference channel.\n\n        Args:\n            other_channel: Reference channel index or label. Default is 0.\n\n        Returns:\n            A new ChannelFrame with channel differences.\n        \"\"\"\n        if isinstance(other_channel, str):\n            return self.apply_operation(\n                \"channel_difference\", other_channel=self.label2index(other_channel)\n            )\n        return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n\n    def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n        \"\"\"Compute Fast Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is next power of 2 of data length.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectralFrame containing the FFT results.\n        \"\"\"\n        from ..processing.time_series import FFT\n        from .spectral import SpectralFrame\n\n        params = {\"n_fft\": n_fft, \"window\": window}\n        operation_name = \"fft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"FFT\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        if n_fft is None:\n            is_even = spectrum_data.shape[-1] % 2 == 0\n            _n_fft = (\n                spectrum_data.shape[-1] * 2 - 2\n                if is_even\n                else spectrum_data.shape[-1] * 2 - 1\n            )\n        else:\n            _n_fft = n_fft\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=_n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def welch(\n        self,\n        n_fft: Optional[int] = None,\n        hop_length: Optional[int] = None,\n        win_length: int = 2048,\n        window: str = \"hann\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute power spectral density using Welch's method.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the power spectral density.\n        \"\"\"\n        from ..processing.time_series import Welch\n        from .spectral import SpectralFrame\n\n        params = dict(\n            n_fft=n_fft or win_length,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            average=average,\n        )\n        operation_name = \"welch\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Welch\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"welch\", \"params\": params},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def noct_spectrum(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"Compute N-octave band spectrum.\n\n        Args:\n            fmin: Minimum center frequency in Hz. Default is 20 Hz.\n            fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n            n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n            G: Reference gain in dB. Default is 10 dB.\n            fr: Reference frequency in Hz. Default is 1000 Hz.\n\n        Returns:\n            A NOctFrame containing the N-octave band spectrum.\n        \"\"\"\n        from ..processing.time_series import NOctSpectrum\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_spectrum\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSpectrum\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_spectrum\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def stft(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"Compute Short-Time Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectrogramFrame containing the STFT results.\n        \"\"\"\n        from ..processing.time_series import STFT, create_operation\n        from .spectrogram import SpectrogramFrame\n\n        # Set hop length and window length\n        _hop_length = hop_length if hop_length is not None else n_fft // 4\n        _win_length = win_length if win_length is not None else n_fft\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": _hop_length,\n            \"win_length\": _win_length,\n            \"window\": window,\n        }\n        operation_name = \"stft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"STFT\", operation)\n\n        # Apply processing to data\n        spectrogram_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n\n        # Create new instance\n        return SpectrogramFrame(\n            data=spectrogram_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=n_fft,\n            hop_length=_hop_length,\n            win_length=_win_length,\n            window=window,\n            label=f\"stft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def coherence(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute magnitude squared coherence.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n        Returns:\n            A SpectralFrame containing the magnitude squared coherence.\n        \"\"\"\n        from ..processing.time_series import Coherence, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n        }\n        operation_name = \"coherence\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Coherence\", operation)\n\n        # Apply processing to data\n        coherence_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=coherence_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Coherence of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def csd(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute cross-spectral density matrix.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the cross-spectral density matrix.\n        \"\"\"\n        from ..processing.time_series import CSD, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"csd\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"CSD\", operation)\n\n        # Apply processing to data\n        csd_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=csd_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def transfer_function(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute transfer function matrix.\n\n        The transfer function characterizes the signal transmission properties\n        between channels in the frequency domain, representing the input-output\n        relationship of a system.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the transfer function matrix.\n        \"\"\"\n        from ..processing.time_series import TransferFunction, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"transfer_function\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"TransferFunction\", operation)\n\n        # Apply processing to data\n        tf_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=tf_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Transfer function of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"Provide additional initialization arguments required for ChannelFrame.\"\"\"\n        return {}\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Returns the duration in seconds.</p>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>Returns the number of samples.</p>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.time","title":"<code>time</code>  <code>property</code>","text":"<p>Get time array for the signal.</p> <p>Returns:</p> Type Description <code>NDArrayReal</code> <p>Array of time points in seconds.</p>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.__init__","title":"<code>__init__(data, sampling_rate, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a ChannelFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>Dask array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate of the data in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>operation_history</code> <code>Optional[list[dict[str, Any]]]</code> <p>History of operations applied to the frame.</p> <code>None</code> <code>channel_metadata</code> <code>Optional[list[ChannelMetadata]]</code> <p>Metadata for each channel.</p> <code>None</code> <code>previous</code> <code>Optional[BaseFrame[Any]]</code> <p>Reference to the previous frame in the processing chain.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has more than 2 dimensions.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"Initialize a ChannelFrame.\n\n    Args:\n        data: Dask array containing channel data.\n        Shape should be (n_channels, n_samples).\n        sampling_rate: The sampling rate of the data in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        operation_history: History of operations applied to the frame.\n        channel_metadata: Metadata for each channel.\n        previous: Reference to the previous frame in the processing chain.\n\n    Raises:\n        ValueError: If data has more than 2 dimensions.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.a_weighting","title":"<code>a_weighting()</code>","text":"<p>Apply A-weighting filter to the signal.</p> <p>A-weighting adjusts the frequency response to approximate human hearing perception, following IEC 61672-1:2013 standard.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with A-weighted signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def a_weighting(self) -&gt; \"ChannelFrame\":\n    \"\"\"Apply A-weighting filter to the signal.\n\n    A-weighting adjusts the frequency response to approximate human hearing\n    perception, following IEC 61672-1:2013 standard.\n\n    Returns:\n        A new ChannelFrame with A-weighted signal.\n    \"\"\"\n    return self.apply_operation(\"a_weighting\")\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.abs","title":"<code>abs()</code>","text":"<p>Calculate the absolute value of the signal.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the absolute values.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def abs(self) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the absolute value of the signal.\n\n    Returns:\n        A new ChannelFrame containing the absolute values.\n    \"\"\"\n    return self.apply_operation(\"abs\")\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.add","title":"<code>add(other, snr=None)</code>","text":"<p>Add another signal or value to the current signal.</p> <p>If SNR is specified, performs addition with consideration for signal-to-noise ratio.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[ChannelFrame, int, float, NDArrayReal, Array]</code> <p>Signal or value to add.</p> required <code>snr</code> <code>Optional[float]</code> <p>Signal-to-noise ratio (dB). If specified, adjusts the scale of the other signal based on this SNR. self is treated as the signal, and other as the noise.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new channel frame containing the addition result (lazy execution).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def add(\n    self,\n    other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n    snr: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Add another signal or value to the current signal.\n\n    If SNR is specified, performs addition with consideration for\n    signal-to-noise ratio.\n\n    Args:\n        other: Signal or value to add.\n        snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n            other signal based on this SNR.\n            self is treated as the signal, and other as the noise.\n\n    Returns:\n        A new channel frame containing the addition result (lazy execution).\n    \"\"\"\n    logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n    # Special processing when SNR is specified\n    if snr is not None:\n        # First convert other to ChannelFrame if it's not\n        if not isinstance(other, ChannelFrame):\n            if isinstance(other, np.ndarray):\n                other = ChannelFrame.from_numpy(\n                    other, self.sampling_rate, label=\"array_data\"\n                )\n            elif isinstance(other, (int, float)):\n                # For scalar values, simply add (ignore SNR)\n                return self + other\n            else:\n                raise TypeError(\n                    \"Addition target with SNR must be a ChannelFrame or \"\n                    f\"NumPy array: {type(other)}\"\n                )\n\n        # Check if sampling rates match\n        if self.sampling_rate != other.sampling_rate:\n            raise ValueError(\n                \"Sampling rates do not match. Cannot perform operation.\"\n            )\n\n        # Apply addition operation with SNR adjustment\n        return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n    # Execute normal addition if SNR is not specified\n    return self + other\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.channel_difference","title":"<code>channel_difference(other_channel=0)</code>","text":"<p>Calculate channel differences relative to a reference channel.</p> <p>Parameters:</p> Name Type Description Default <code>other_channel</code> <code>Union[int, str]</code> <p>Reference channel index or label. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with channel differences.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate channel differences relative to a reference channel.\n\n    Args:\n        other_channel: Reference channel index or label. Default is 0.\n\n    Returns:\n        A new ChannelFrame with channel differences.\n    \"\"\"\n    if isinstance(other_channel, str):\n        return self.apply_operation(\n            \"channel_difference\", other_channel=self.label2index(other_channel)\n        )\n    return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.coherence","title":"<code>coherence(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant')</code>","text":"<p>Compute magnitude squared coherence.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the magnitude squared coherence.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def coherence(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute magnitude squared coherence.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n    Returns:\n        A SpectralFrame containing the magnitude squared coherence.\n    \"\"\"\n    from ..processing.time_series import Coherence, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n    }\n    operation_name = \"coherence\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Coherence\", operation)\n\n    # Apply processing to data\n    coherence_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=coherence_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Coherence of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.csd","title":"<code>csd(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute cross-spectral density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the cross-spectral density matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def csd(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute cross-spectral density matrix.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the cross-spectral density matrix.\n    \"\"\"\n    from ..processing.time_series import CSD, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"csd\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"CSD\", operation)\n\n    # Apply processing to data\n    csd_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=csd_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.describe","title":"<code>describe(normalize=True, **kwargs)</code>","text":"<p>Display visual and audio representation of the frame.</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>Whether to normalize the audio data for playback.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for visualization.</p> <code>{}</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n    \"\"\"Display visual and audio representation of the frame.\n\n    Args:\n        normalize: Whether to normalize the audio data for playback.\n        **kwargs: Additional parameters for visualization.\n    \"\"\"\n    if \"axis_config\" in kwargs:\n        logger.warning(\n            \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        axis_config = kwargs[\"axis_config\"]\n        if \"time_plot\" in axis_config:\n            kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n        if \"freq_plot\" in axis_config:\n            if \"xlim\" in axis_config[\"freq_plot\"]:\n                vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                kwargs[\"vmin\"] = vlim[0]\n                kwargs[\"vmax\"] = vlim[1]\n            if \"ylim\" in axis_config[\"freq_plot\"]:\n                ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                kwargs[\"ylim\"] = ylim\n\n    if \"cbar_config\" in kwargs:\n        logger.warning(\n            \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        cbar_config = kwargs[\"cbar_config\"]\n        if \"vmin\" in cbar_config:\n            kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n        if \"vmax\" in cbar_config:\n            kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n    for ch in self:\n        ax: Axes\n        _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n        if isinstance(_ax, Iterator):\n            ax = next(iter(_ax))\n        elif isinstance(_ax, Axes):\n            ax = _ax\n        else:\n            raise TypeError(\n                f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n            )\n        # Ignore type checks for display and Audio\n        display(ax.figure)  # type: ignore\n        plt.close(ax.figure)  # type: ignore\n        display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.fft","title":"<code>fft(n_fft=None, window='hann')</code>","text":"<p>Compute Fast Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is next power of 2 of data length.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the FFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n    \"\"\"Compute Fast Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is next power of 2 of data length.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectralFrame containing the FFT results.\n    \"\"\"\n    from ..processing.time_series import FFT\n    from .spectral import SpectralFrame\n\n    params = {\"n_fft\": n_fft, \"window\": window}\n    operation_name = \"fft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"FFT\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    if n_fft is None:\n        is_even = spectrum_data.shape[-1] % 2 == 0\n        _n_fft = (\n            spectrum_data.shape[-1] * 2 - 2\n            if is_even\n            else spectrum_data.shape[-1] * 2 - 1\n        )\n    else:\n        _n_fft = n_fft\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=_n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.from_file","title":"<code>from_file(path, channel=None, start=None, end=None, chunk_size=None, ch_labels=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from an audio file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the audio file.</p> required <code>channel</code> <code>Optional[Union[int, list[int]]]</code> <p>Channel(s) to load.</p> <code>None</code> <code>start</code> <code>Optional[float]</code> <p>Start time in seconds.</p> <code>None</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <code>chunk_size</code> <code>Optional[int]</code> <p>Chunk size for processing.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the file reader.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the loaded audio data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If channel selection is invalid.</p> <code>TypeError</code> <p>If channel parameter type is invalid.</p> <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    path: Union[str, Path],\n    channel: Optional[Union[int, list[int]]] = None,\n    start: Optional[float] = None,\n    end: Optional[float] = None,\n    chunk_size: Optional[int] = None,\n    ch_labels: Optional[list[str]] = None,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from an audio file.\n\n    Args:\n        path: Path to the audio file.\n        channel: Channel(s) to load.\n        start: Start time in seconds.\n        end: End time in seconds.\n        chunk_size: Chunk size for processing.\n        Specifies the splitting size for lazy processing.\n        ch_labels: Labels for each channel.\n        **kwargs: Additional arguments passed to the file reader.\n\n    Returns:\n        A new ChannelFrame containing the loaded audio data.\n\n    Raises:\n        ValueError: If channel selection is invalid.\n        TypeError: If channel parameter type is invalid.\n        FileNotFoundError: If the file doesn't exist.\n    \"\"\"\n    from .channel import ChannelFrame\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    # Get file reader\n    reader = get_file_reader(path)\n\n    # Get file info\n    info = reader.get_file_info(path, **kwargs)\n    sr = info[\"samplerate\"]\n    n_channels = info[\"channels\"]\n    n_frames = info[\"frames\"]\n    ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n    logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n    # Channel selection processing\n    all_channels = list(range(n_channels))\n\n    if channel is None:\n        channels_to_load = all_channels\n        logger.debug(f\"Will load all channels: {channels_to_load}\")\n    elif isinstance(channel, int):\n        if channel &lt; 0 or channel &gt;= n_channels:\n            raise ValueError(\n                f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n            )\n        channels_to_load = [channel]\n        logger.debug(f\"Will load single channel: {channel}\")\n    elif isinstance(channel, (list, tuple)):\n        for ch in channel:\n            if ch &lt; 0 or ch &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n        channels_to_load = list(channel)\n        logger.debug(f\"Will load specific channels: {channels_to_load}\")\n    else:\n        raise TypeError(\"channel must be int, list, or None\")\n\n    # Index calculation\n    start_idx = 0 if start is None else max(0, int(start * sr))\n    end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n    frames_to_read = end_idx - start_idx\n\n    logger.debug(\n        f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n        f\"start_idx={start_idx}, end_idx={end_idx}\"\n    )\n\n    # Settings for lazy loading\n    expected_shape = (len(channels_to_load), frames_to_read)\n\n    # Define the loading function using the file reader\n    def _load_audio() -&gt; NDArrayReal:\n        logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n        # Use the reader to get audio data with parameters\n        out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n        if not isinstance(out, np.ndarray):\n            raise ValueError(\"Unexpected data type after reading file\")\n        return out\n\n    logger.debug(\n        f\"Creating delayed dask task with expected shape: {expected_shape}\"\n    )\n\n    # Create delayed operation\n    delayed_data = dask_delayed(_load_audio)()\n    logger.debug(\"Wrapping delayed function in dask array\")\n\n    # Create dask array from delayed computation\n    dask_array = da_from_delayed(\n        delayed_data, shape=expected_shape, dtype=np.float32\n    )\n\n    if chunk_size is not None:\n        if chunk_size &lt;= 0:\n            raise ValueError(\"Chunk size must be a positive integer\")\n        logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n        dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n    logger.debug(\n        \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n    )\n\n    cf = ChannelFrame(\n        data=dask_array,\n        sampling_rate=sr,\n        label=path.stem,\n        metadata={\n            \"filename\": str(path),\n        },\n    )\n    if ch_labels is not None:\n        if len(ch_labels) != len(cf):\n            raise ValueError(\n                \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    return cf\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.from_ndarray","title":"<code>from_ndarray(array, sampling_rate, labels=None, unit=None, frame_label=None, metadata=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>This method is deprecated. Use from_numpy instead.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>NDArrayReal</code> <p>Signal data. Each row corresponds to a channel.</p> required <code>sampling_rate</code> <code>float</code> <p>Sampling rate (Hz).</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>unit</code> <code>Optional[Union[list[str], str]]</code> <p>Unit of the signal.</p> <code>None</code> <code>frame_label</code> <code>Optional[str]</code> <p>Label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_ndarray(\n    cls,\n    array: NDArrayReal,\n    sampling_rate: float,\n    labels: Optional[list[str]] = None,\n    unit: Optional[Union[list[str], str]] = None,\n    frame_label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    This method is deprecated. Use from_numpy instead.\n\n    Args:\n        array: Signal data. Each row corresponds to a channel.\n        sampling_rate: Sampling rate (Hz).\n        labels: Labels for each channel.\n        unit: Unit of the signal.\n        frame_label: Label for the frame.\n        metadata: Optional metadata dictionary.\n\n    Returns:\n        A new ChannelFrame containing the data.\n    \"\"\"\n    # Redirect to from_numpy for compatibility\n    # However, from_ndarray is deprecated\n    logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n    return cls.from_numpy(\n        data=array,\n        sampling_rate=sampling_rate,\n        label=frame_label,\n        metadata=metadata,\n        ch_labels=labels,\n        ch_units=unit,\n    )\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.from_numpy","title":"<code>from_numpy(data, sampling_rate, label=None, metadata=None, ch_labels=None, ch_units=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArrayReal</code> <p>NumPy array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>ch_units</code> <code>Optional[Union[list[str], str]]</code> <p>Units for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the NumPy data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_numpy(\n    cls,\n    data: NDArrayReal,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    ch_labels: Optional[list[str]] = None,\n    ch_units: Optional[Union[list[str], str]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    Args:\n        data: NumPy array containing channel data.\n        sampling_rate: The sampling rate in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        ch_labels: Labels for each channel.\n        ch_units: Units for each channel.\n\n    Returns:\n        A new ChannelFrame containing the NumPy data.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n\n    # Convert NumPy array to dask array\n    dask_data = da_from_array(data)\n    cf = ChannelFrame(\n        data=dask_data,\n        sampling_rate=sampling_rate,\n        label=label or \"numpy_data\",\n    )\n    if metadata is not None:\n        cf.metadata = metadata\n    if ch_labels is not None:\n        if len(ch_labels) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel labels does not match the number of channels\"\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    if ch_units is not None:\n        if isinstance(ch_units, str):\n            ch_units = [ch_units] * cf.n_channels\n\n        if len(ch_units) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel units does not match the number of channels\"\n            )\n        for i in range(len(ch_units)):\n            cf._channel_metadata[i].unit = ch_units[i]\n\n    return cf\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.high_pass_filter","title":"<code>high_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a high-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a high-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.hpss_harmonic","title":"<code>hpss_harmonic(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract harmonic components using HPSS  (Harmonic-Percussive Source Separation).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_harmonic(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract harmonic components using HPSS\n     (Harmonic-Percussive Source Separation).\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_harmonic\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.hpss_percussive","title":"<code>hpss_percussive(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract percussive components using HPSS (Harmonic-Percussive Source Separation).</p> <p>This method separates the percussive (tonal) components from the signal.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Union[_IntLike_co, tuple[_IntLike_co, _IntLike_co], list[_IntLike_co]]</code> <p>Median filter size for HPSS.</p> <code>31</code> <code>power</code> <code>float</code> <p>Exponent for the Weiner filter used in HPSS.</p> <code>2</code> <code>margin</code> <code>Union[_FloatLike_co, tuple[_FloatLike_co, _FloatLike_co], list[_FloatLike_co]]</code> <p>Margin size for the separation.</p> <code>1</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the harmonic components.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_percussive(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract percussive components using HPSS\n    (Harmonic-Percussive Source Separation).\n\n    This method separates the percussive (tonal) components from the signal.\n\n    Args:\n        kernel_size: Median filter size for HPSS.\n        power: Exponent for the Weiner filter used in HPSS.\n        margin: Margin size for the separation.\n\n    Returns:\n        A new ChannelFrame containing the harmonic components.\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_percussive\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.low_pass_filter","title":"<code>low_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a low-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a low-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.mean","title":"<code>mean()</code>","text":"<p>Average all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with averaged signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def mean(self) -&gt; \"ChannelFrame\":\n    \"\"\"Average all channels.\n\n    Returns:\n        A new ChannelFrame with averaged signal.\n    \"\"\"\n    return self.apply_operation(\"mean\")\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.noct_spectrum","title":"<code>noct_spectrum(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Compute N-octave band spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>fmin</code> <code>float</code> <p>Minimum center frequency in Hz. Default is 20 Hz.</p> required <code>fmax</code> <code>float</code> <p>Maximum center frequency in Hz. Default is 20000 Hz.</p> required <code>n</code> <code>int</code> <p>Band division (1 for octave, 3 for 1/3 octave). Default is 3.</p> <code>3</code> <code>G</code> <code>int</code> <p>Reference gain in dB. Default is 10 dB.</p> <code>10</code> <code>fr</code> <code>int</code> <p>Reference frequency in Hz. Default is 1000 Hz.</p> <code>1000</code> <p>Returns:</p> Type Description <code>NOctFrame</code> <p>A NOctFrame containing the N-octave band spectrum.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def noct_spectrum(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"Compute N-octave band spectrum.\n\n    Args:\n        fmin: Minimum center frequency in Hz. Default is 20 Hz.\n        fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n        n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n        G: Reference gain in dB. Default is 10 dB.\n        fr: Reference frequency in Hz. Default is 1000 Hz.\n\n    Returns:\n        A NOctFrame containing the N-octave band spectrum.\n    \"\"\"\n    from ..processing.time_series import NOctSpectrum\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_spectrum\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSpectrum\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_spectrum\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.normalize","title":"<code>normalize(target_level=-20, channel_wise=True)</code>","text":"<p>Normalize the signal level.</p> <p>This method adjusts the signal amplitude to reach a target RMS level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target RMS level in dB. Default is -20.</p> <code>-20</code> <code>channel_wise</code> <code>bool</code> <p>If True, normalize each channel independently. If False, apply the same scaling to all channels.</p> <code>True</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the normalized signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def normalize(\n    self, target_level: float = -20, channel_wise: bool = True\n) -&gt; \"ChannelFrame\":\n    \"\"\"Normalize the signal level.\n\n    This method adjusts the signal amplitude to reach a target RMS level.\n\n    Args:\n        target_level: Target RMS level in dB. Default is -20.\n        channel_wise: If True, normalize each channel independently.\n            If False, apply the same scaling to all channels.\n\n    Returns:\n        A new ChannelFrame containing the normalized signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n    )\n    return self.apply_operation(\n        \"normalize\", target_level=target_level, channel_wise=channel_wise\n    )\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.plot","title":"<code>plot(plot_type='waveform', ax=None, **kwargs)</code>","text":"<p>Plot the frame data.</p> <p>Parameters:</p> Name Type Description Default <code>plot_type</code> <code>str</code> <p>Type of plot. Default is \"waveform\".</p> <code>'waveform'</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def plot(\n    self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Plot the frame data.\n\n    Args:\n        plot_type: Type of plot. Default is \"waveform\".\n        ax: Optional matplotlib axes for plotting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    plot_strategy = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.power","title":"<code>power(exponent=2.0)</code>","text":"<p>Calculate the power of the signal.</p> <p>Parameters:</p> Name Type Description Default <code>exponent</code> <code>float</code> <p>The exponent to raise the signal to. Default is 2.0.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the signal raised to the power.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the power of the signal.\n\n    Args:\n        exponent: The exponent to raise the signal to. Default is 2.0.\n\n    Returns:\n        A new ChannelFrame containing the signal raised to the power.\n    \"\"\"\n    return self.apply_operation(\"power\", exponent=exponent)\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.read_csv","title":"<code>read_csv(filename, time_column=0, labels=None, delimiter=',', header=0)</code>  <code>classmethod</code>","text":"<p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.read_wav","title":"<code>read_wav(filename, labels=None)</code>  <code>classmethod</code>","text":"<p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.resampling","title":"<code>resampling(target_sr, **kwargs)</code>","text":"<p>Resample audio data.</p>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.resampling--parameters","title":"Parameters","text":"<p>target_sr : float     Target sampling rate (Hz) resample_type : str, optional     Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.) **kwargs : dict     Additional resampling parameters</p>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.resampling--returns","title":"Returns","text":"<p>ChannelFrame     Resampled channel frame</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def resampling(\n    self,\n    target_sr: float,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Resample audio data.\n\n    Parameters\n    ----------\n    target_sr : float\n        Target sampling rate (Hz)\n    resample_type : str, optional\n        Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n    **kwargs : dict\n        Additional resampling parameters\n\n    Returns\n    -------\n    ChannelFrame\n        Resampled channel frame\n    \"\"\"\n    return self.apply_operation(\n        \"resampling\",\n        target_sr=target_sr,\n        **kwargs,\n    )\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.rms_plot","title":"<code>rms_plot(ax=None, title=None, overlay=True, Aw=False, **kwargs)</code>","text":"<p>Generate an RMS plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title for the plot.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay the plot on the existing axis.</p> <code>True</code> <code>Aw</code> <code>bool</code> <p>Apply A-weighting.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_plot(\n    self,\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = True,\n    Aw: bool = False,  # noqa: N803\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Generate an RMS plot.\n\n    Args:\n        ax: Optional matplotlib axes for plotting.\n        title: Title for the plot.\n        overlay: Whether to overlay the plot on the existing axis.\n        Aw: Apply A-weighting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    kwargs = kwargs or {}\n    ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n    rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n    return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.rms_trend","title":"<code>rms_trend(frame_length=2048, hop_length=512, dB=False, Aw=False)</code>","text":"<p>Calculate the RMS trend of the signal.</p> <p>This method computes the root mean square value over sliding windows.</p> <p>Parameters:</p> Name Type Description Default <code>frame_length</code> <code>int</code> <p>The size of the sliding window in samples. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>int</code> <p>The hop length between windows in samples. Default is 512.</p> <code>512</code> <code>dB</code> <code>bool</code> <p>Whether to return the RMS values in decibels. Default is False.</p> <code>False</code> <code>Aw</code> <code>bool</code> <p>Whether to apply A-weighting. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the RMS trend.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_trend(\n    self,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the RMS trend of the signal.\n\n    This method computes the root mean square value over sliding windows.\n\n    Args:\n        frame_length: The size of the sliding window in samples. Default is 2048.\n        hop_length: The hop length between windows in samples. Default is 512.\n        dB: Whether to return the RMS values in decibels. Default is False.\n        Aw: Whether to apply A-weighting. Default is False.\n\n    Returns:\n        A new ChannelFrame containing the RMS trend.\n    \"\"\"\n    cf = self.apply_operation(\n        \"rms_trend\",\n        frame_length=frame_length,\n        hop_length=hop_length,\n        ref=[ch.ref for ch in self._channel_metadata],\n        dB=dB,\n        Aw=Aw,\n    )\n    cf.sampling_rate = self.sampling_rate / hop_length\n    return cf\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.save","title":"<code>save(path, format=None)</code>","text":"<p>Save the audio data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n    data = self.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    sf.write(str(path), data, int(self.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {path}\")\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.stft","title":"<code>stft(n_fft=2048, hop_length=None, win_length=None, window='hann')</code>","text":"<p>Compute Short-Time Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectrogramFrame</code> <p>A SpectrogramFrame containing the STFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def stft(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n) -&gt; \"SpectrogramFrame\":\n    \"\"\"Compute Short-Time Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectrogramFrame containing the STFT results.\n    \"\"\"\n    from ..processing.time_series import STFT, create_operation\n    from .spectrogram import SpectrogramFrame\n\n    # Set hop length and window length\n    _hop_length = hop_length if hop_length is not None else n_fft // 4\n    _win_length = win_length if win_length is not None else n_fft\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": _hop_length,\n        \"win_length\": _win_length,\n        \"window\": window,\n    }\n    operation_name = \"stft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"STFT\", operation)\n\n    # Apply processing to data\n    spectrogram_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n\n    # Create new instance\n    return SpectrogramFrame(\n        data=spectrogram_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=n_fft,\n        hop_length=_hop_length,\n        win_length=_win_length,\n        window=window,\n        label=f\"stft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.sum","title":"<code>sum()</code>","text":"<p>Sum all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with summed signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def sum(self) -&gt; \"ChannelFrame\":\n    \"\"\"Sum all channels.\n\n    Returns:\n        A new ChannelFrame with summed signal.\n    \"\"\"\n    return self.apply_operation(\"sum\")\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.transfer_function","title":"<code>transfer_function(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute transfer function matrix.</p> <p>The transfer function characterizes the signal transmission properties between channels in the frequency domain, representing the input-output relationship of a system.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the transfer function matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def transfer_function(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute transfer function matrix.\n\n    The transfer function characterizes the signal transmission properties\n    between channels in the frequency domain, representing the input-output\n    relationship of a system.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the transfer function matrix.\n    \"\"\"\n    from ..processing.time_series import TransferFunction, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"transfer_function\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"TransferFunction\", operation)\n\n    # Apply processing to data\n    tf_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=tf_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Transfer function of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.trim","title":"<code>trim(start=0, end=None)</code>","text":"<p>Trim the signal to specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>Start time in seconds.</p> <code>0</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with trimmed signal.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If end time is before start time.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def trim(\n    self,\n    start: float = 0,\n    end: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Trim the signal to specified time range.\n\n    Args:\n        start: Start time in seconds.\n        end: End time in seconds.\n\n    Returns:\n        A new ChannelFrame with trimmed signal.\n\n    Raises:\n        ValueError: If end time is before start time.\n    \"\"\"\n    if end is None:\n        end = self.duration\n    if start &gt; end:\n        raise ValueError(\"start must be less than end\")\n    # Apply trim operation\n    return self.apply_operation(\"trim\", start=start, end=end)\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.channel.ChannelFrame.welch","title":"<code>welch(n_fft=None, hop_length=None, win_length=2048, window='hann', average='mean')</code>","text":"<p>Compute power spectral density using Welch's method.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is 2048.</p> <code>None</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>int</code> <p>Length of window. Default is n_fft.</p> <code>2048</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the power spectral density.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def welch(\n    self,\n    n_fft: Optional[int] = None,\n    hop_length: Optional[int] = None,\n    win_length: int = 2048,\n    window: str = \"hann\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute power spectral density using Welch's method.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the power spectral density.\n    \"\"\"\n    from ..processing.time_series import Welch\n    from .spectral import SpectralFrame\n\n    params = dict(\n        n_fft=n_fft or win_length,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        average=average,\n    )\n    operation_name = \"welch\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Welch\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"welch\", \"params\": params},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/en/api/frames/#spectralframe","title":"SpectralFrame","text":"<p><code>SpectralFrame</code> is a frame that handles frequency-domain data.</p> <pre><code>from wandas.frames.spectral import SpectralFrame\n\n# Or convert from ChannelFrame\nchannel_frame = wandas.read_wav(\"audio.wav\")\nspectral_frame = channel_frame.to_spectral()\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayComplex]</code></p> <p>Class for handling frequency-domain signal data.</p> <p>This class represents spectral data, providing methods for spectral analysis, manipulation, and visualization. It handles complex-valued frequency domain data obtained through operations like FFT.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The spectral data. Must be a dask array with shape:     - (channels, frequency_bins) for multi-channel data     - (frequency_bins,) for single-channel data, which will be       reshaped to (1, frequency_bins) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. n_fft : int     The FFT size used to generate this spectral data. window : str, default=\"hann\"     The window function used in the FFT. label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame--attributes","title":"Attributes","text":"<p>magnitude : NDArrayReal     The magnitude spectrum of the data. phase : NDArrayReal     The phase spectrum in radians. power : NDArrayReal     The power spectrum (magnitude squared). dB : NDArrayReal     The spectrum in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrum in decibels. freqs : NDArrayReal     The frequency axis values in Hz.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame--examples","title":"Examples","text":"<p>Create a SpectralFrame from FFT:</p> <p>signal = ChannelFrame.from_numpy(data, sampling_rate=44100) spectrum = signal.fft(n_fft=2048)</p> <p>Plot the magnitude spectrum:</p> <p>spectrum.plot()</p> <p>Perform binary operations:</p> <p>scaled = spectrum * 2.0 summed = spectrum1 + spectrum2  # Must have matching sampling rates</p> <p>Convert back to time domain:</p> <p>time_signal = spectrum.ifft()</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame--notes","title":"Notes","text":"<ul> <li>All operations are performed lazily using dask arrays for efficient memory usage.</li> <li>Binary operations (+, -, *, /) can be performed between SpectralFrames or with   scalar values.</li> <li>The class maintains the processing history and metadata through all operations.</li> </ul> Source code in <code>wandas/frames/spectral.py</code> <pre><code>class SpectralFrame(BaseFrame[NDArrayComplex]):\n    \"\"\"\n    Class for handling frequency-domain signal data.\n\n    This class represents spectral data, providing methods for spectral analysis,\n    manipulation, and visualization. It handles complex-valued frequency domain data\n    obtained through operations like FFT.\n\n    Parameters\n    ----------\n    data : DaArray\n        The spectral data. Must be a dask array with shape:\n        - (channels, frequency_bins) for multi-channel data\n        - (frequency_bins,) for single-channel data, which will be\n          reshaped to (1, frequency_bins)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    n_fft : int\n        The FFT size used to generate this spectral data.\n    window : str, default=\"hann\"\n        The window function used in the FFT.\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    magnitude : NDArrayReal\n        The magnitude spectrum of the data.\n    phase : NDArrayReal\n        The phase spectrum in radians.\n    power : NDArrayReal\n        The power spectrum (magnitude squared).\n    dB : NDArrayReal\n        The spectrum in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrum in decibels.\n    freqs : NDArrayReal\n        The frequency axis values in Hz.\n\n    Examples\n    --------\n    Create a SpectralFrame from FFT:\n    &gt;&gt;&gt; signal = ChannelFrame.from_numpy(data, sampling_rate=44100)\n    &gt;&gt;&gt; spectrum = signal.fft(n_fft=2048)\n\n    Plot the magnitude spectrum:\n    &gt;&gt;&gt; spectrum.plot()\n\n    Perform binary operations:\n    &gt;&gt;&gt; scaled = spectrum * 2.0\n    &gt;&gt;&gt; summed = spectrum1 + spectrum2  # Must have matching sampling rates\n\n    Convert back to time domain:\n    &gt;&gt;&gt; time_signal = spectrum.ifft()\n\n    Notes\n    -----\n    - All operations are performed lazily using dask arrays for efficient memory usage.\n    - Binary operations (+, -, *, /) can be performed between SpectralFrames or with\n      scalar values.\n    - The class maintains the processing history and metadata through all operations.\n    \"\"\"\n\n    n_fft: int\n    window: str\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        n_fft: int,\n        window: str = \"hann\",\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306f1\u6b21\u5143\u307e\u305f\u306f2\u6b21\u5143\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u5f62\u72b6: {data.shape}\"\n            )\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def magnitude(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the magnitude spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The absolute values of the complex spectrum.\n        \"\"\"\n        return np.abs(self.data)\n\n    @property\n    def phase(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the phase spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The phase angles of the complex spectrum in radians.\n        \"\"\"\n        return np.angle(self.data)\n\n    @property\n    def power(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the power spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The squared magnitude spectrum.\n        \"\"\"\n        return self.magnitude**2\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrum in decibels.\n\n        The reference values are taken from channel metadata. If no reference\n        is specified, uses 1.0.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrum in dB relative to channel references.\n        \"\"\"\n        mag: NDArrayReal = self.magnitude\n        ref_values: NDArrayReal = np.array([ch.ref for ch in self._channel_metadata])\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(mag / ref_values[:, np.newaxis], 1e-12)\n        )\n\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrum in decibels.\n\n        Applies A-weighting filter to the spectrum for better correlation with\n        perceived loudness.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrum in dB.\n        \"\"\"\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels.\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the frequency axis values in Hz.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of frequency values corresponding to each frequency bin.\n        \"\"\"\n        return np.fft.rfftfreq(self.n_fft, 1.0 / self.sampling_rate)\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Implementation of operation application for spectral data.\n\n        This internal method handles the application of various operations to\n        spectral data, maintaining lazy evaluation through dask.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters for the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        processed_data = operation.process(self._data)\n\n        # \u30e1\u30bf\u30c7\u30fc\u30bf\u66f4\u65b0\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\n            \"SpectralFrame\", int, float, complex, NDArrayComplex, NDArrayReal, \"DaArray\"\n        ],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"\n        Common implementation for binary operations.\n\n        This method handles binary operations between SpectralFrames and various types\n        of operands, maintaining lazy evaluation through dask arrays.\n\n        Parameters\n        ----------\n        other : Union[SpectralFrame, int, float, complex,\n                        NDArrayComplex, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation (e.g., lambda a, b: a + b)\n        symbol : str\n            String representation of the operation (e.g., '+')\n\n        Returns\n        -------\n        SpectralFrame\n            A new SpectralFrame containing the result of the operation.\n\n        Raises\n        ------\n        ValueError\n            If attempting to operate with a SpectralFrame\n            with a different sampling rate.\n        \"\"\"\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, SpectralFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u304c\u4e00\u81f4\u3057\u3066\u3044\u307e\u305b\u3093\u3002\u6f14\u7b97\u3067\u304d\u307e\u305b\u3093\u3002\"\n                )\n\n            # dask array\u3092\u76f4\u63a5\u6f14\u7b97\uff08\u9045\u5ef6\u5b9f\u884c\u3092\u7dad\u6301\uff09\n            result_data = op(self._data, other._data)\n\n            # \u30c1\u30e3\u30cd\u30eb\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u7d50\u5408\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return SpectralFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # \u30b9\u30ab\u30e9\u30fc\u3001NumPy\u914d\u5217\u3001\u307e\u305f\u306f\u4ed6\u306e\u30bf\u30a4\u30d7\u3068\u306e\u6f14\u7b97\n        else:\n            # dask array\u306b\u76f4\u63a5\u6f14\u7b97\u3092\u9069\u7528\uff08\u9045\u5ef6\u5b9f\u884c\u3092\u7dad\u6301\uff09\n            result_data = op(self._data, other)\n\n            # \u30aa\u30da\u30e9\u30f3\u30c9\u306e\u8868\u793a\u7528\u6587\u5b57\u5217\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, complex):\n                other_str = f\"complex({other.real}, {other.imag})\"\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # dask.array.Array\u306e\u30c1\u30a7\u30c3\u30af\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # \u30c1\u30e3\u30cd\u30eb\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u66f4\u65b0\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return SpectralFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n            )\n\n    def plot(\n        self,\n        plot_type: str = \"frequency\",\n        ax: Optional[\"Axes\"] = None,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the spectral data using various visualization strategies.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"frequency\"\n            Type of plot to create. Options include:\n            - \"frequency\": Standard frequency plot\n            - \"matrix\": Matrix plot for comparing channels\n            - Other types as defined by available plot strategies\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - title: Plot title\n            - xlabel, ylabel: Axis labels\n            - vmin, vmax: Value limits for plots\n            - cmap: Colormap name\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def ifft(self) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.\n\n        This method transforms the frequency-domain data back to the time domain using\n        the inverse FFT operation. The window function used in the forward FFT is\n        taken into account to ensure proper reconstruction.\n\n        Returns\n        -------\n        ChannelFrame\n            A new ChannelFrame containing the time-domain signal.\n        \"\"\"\n        from ..processing.time_series import IFFT, create_operation\n        from .channel import ChannelFrame\n\n        params = {\"n_fft\": self.n_fft, \"window\": self.window}\n        operation_name = \"ifft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"IFFT\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        time_series = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        return ChannelFrame(\n            data=time_series,\n            sampling_rate=self.sampling_rate,\n            label=f\"ifft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        SpectralFrame \u306b\u5fc5\u8981\u306a\u8ffd\u52a0\u306e\u521d\u671f\u5316\u5f15\u6570\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments for SpectralFrame.\n        \"\"\"\n        return {\n            \"n_fft\": self.n_fft,\n            \"window\": self.window,\n        }\n\n    def noct_synthesis(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"\n        Synthesize N-octave band spectrum.\n\n        This method combines frequency components into N-octave bands according to\n        standard acoustical band definitions. This is commonly used in noise and\n        vibration analysis.\n\n        Parameters\n        ----------\n        fmin : float\n            Lower frequency bound in Hz.\n        fmax : float\n            Upper frequency bound in Hz.\n        n : int, default=3\n            Number of bands per octave (e.g., 3 for third-octave bands).\n        G : int, default=10\n            Reference band number.\n        fr : int, default=1000\n            Reference frequency in Hz.\n\n        Returns\n        -------\n        NOctFrame\n            A new NOctFrame containing the N-octave band spectrum.\n\n        Raises\n        ------\n        ValueError\n            If the sampling rate is not 48000 Hz, which is required for this operation.\n        \"\"\"\n        if self.sampling_rate != 48000:\n            raise ValueError(\n                \"noct_synthesis\u306f48000Hz\u306e\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u3067\u306e\u307f\u4f7f\u7528\u3067\u304d\u307e\u3059\u3002\"\n            )\n        from ..processing.time_series import NOctSynthesis\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_synthesis\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSynthesis\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_synthesis\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def plot_matrix(\n        self,\n        plot_type: str = \"matrix\",\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot channel relationships in matrix format.\n\n        This method creates a matrix plot showing relationships between channels,\n        such as coherence, transfer functions, or cross-spectral density.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"matrix\"\n            Type of matrix plot to create.\n        **kwargs : dict\n            Additional plot parameters:\n            - vmin, vmax: Color scale limits\n            - cmap: Colormap name\n            - title: Plot title\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrum in decibels.</p> <p>The reference values are taken from channel metadata. If no reference is specified, uses 1.0.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrum in dB relative to channel references.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrum in decibels.</p> <p>Applies A-weighting filter to the spectrum for better correlation with perceived loudness.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrum in dB.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the frequency axis values in Hz.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of frequency values corresponding to each frequency bin.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.magnitude","title":"<code>magnitude</code>  <code>property</code>","text":"<p>Get the magnitude spectrum.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.magnitude--returns","title":"Returns","text":"<p>NDArrayReal     The absolute values of the complex spectrum.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.phase","title":"<code>phase</code>  <code>property</code>","text":"<p>Get the phase spectrum.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.phase--returns","title":"Returns","text":"<p>NDArrayReal     The phase angles of the complex spectrum in radians.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.power","title":"<code>power</code>  <code>property</code>","text":"<p>Get the power spectrum.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.power--returns","title":"Returns","text":"<p>NDArrayReal     The squared magnitude spectrum.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.ifft","title":"<code>ifft()</code>","text":"<p>Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.</p> <p>This method transforms the frequency-domain data back to the time domain using the inverse FFT operation. The window function used in the forward FFT is taken into account to ensure proper reconstruction.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.ifft--returns","title":"Returns","text":"<p>ChannelFrame     A new ChannelFrame containing the time-domain signal.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def ifft(self) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.\n\n    This method transforms the frequency-domain data back to the time domain using\n    the inverse FFT operation. The window function used in the forward FFT is\n    taken into account to ensure proper reconstruction.\n\n    Returns\n    -------\n    ChannelFrame\n        A new ChannelFrame containing the time-domain signal.\n    \"\"\"\n    from ..processing.time_series import IFFT, create_operation\n    from .channel import ChannelFrame\n\n    params = {\"n_fft\": self.n_fft, \"window\": self.window}\n    operation_name = \"ifft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"IFFT\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    time_series = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    return ChannelFrame(\n        data=time_series,\n        sampling_rate=self.sampling_rate,\n        label=f\"ifft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis","title":"<code>noct_synthesis(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Synthesize N-octave band spectrum.</p> <p>This method combines frequency components into N-octave bands according to standard acoustical band definitions. This is commonly used in noise and vibration analysis.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--parameters","title":"Parameters","text":"<p>fmin : float     Lower frequency bound in Hz. fmax : float     Upper frequency bound in Hz. n : int, default=3     Number of bands per octave (e.g., 3 for third-octave bands). G : int, default=10     Reference band number. fr : int, default=1000     Reference frequency in Hz.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--returns","title":"Returns","text":"<p>NOctFrame     A new NOctFrame containing the N-octave band spectrum.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--raises","title":"Raises","text":"<p>ValueError     If the sampling rate is not 48000 Hz, which is required for this operation.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def noct_synthesis(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"\n    Synthesize N-octave band spectrum.\n\n    This method combines frequency components into N-octave bands according to\n    standard acoustical band definitions. This is commonly used in noise and\n    vibration analysis.\n\n    Parameters\n    ----------\n    fmin : float\n        Lower frequency bound in Hz.\n    fmax : float\n        Upper frequency bound in Hz.\n    n : int, default=3\n        Number of bands per octave (e.g., 3 for third-octave bands).\n    G : int, default=10\n        Reference band number.\n    fr : int, default=1000\n        Reference frequency in Hz.\n\n    Returns\n    -------\n    NOctFrame\n        A new NOctFrame containing the N-octave band spectrum.\n\n    Raises\n    ------\n    ValueError\n        If the sampling rate is not 48000 Hz, which is required for this operation.\n    \"\"\"\n    if self.sampling_rate != 48000:\n        raise ValueError(\n            \"noct_synthesis\u306f48000Hz\u306e\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u3067\u306e\u307f\u4f7f\u7528\u3067\u304d\u307e\u3059\u3002\"\n        )\n    from ..processing.time_series import NOctSynthesis\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_synthesis\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSynthesis\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_synthesis\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.plot","title":"<code>plot(plot_type='frequency', ax=None, **kwargs)</code>","text":"<p>Plot the spectral data using various visualization strategies.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"frequency\"     Type of plot to create. Options include:     - \"frequency\": Standard frequency plot     - \"matrix\": Matrix plot for comparing channels     - Other types as defined by available plot strategies ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - title: Plot title     - xlabel, ylabel: Axis labels     - vmin, vmax: Value limits for plots     - cmap: Colormap name     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def plot(\n    self,\n    plot_type: str = \"frequency\",\n    ax: Optional[\"Axes\"] = None,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the spectral data using various visualization strategies.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"frequency\"\n        Type of plot to create. Options include:\n        - \"frequency\": Standard frequency plot\n        - \"matrix\": Matrix plot for comparing channels\n        - Other types as defined by available plot strategies\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - title: Plot title\n        - xlabel, ylabel: Axis labels\n        - vmin, vmax: Value limits for plots\n        - cmap: Colormap name\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix","title":"<code>plot_matrix(plot_type='matrix', **kwargs)</code>","text":"<p>Plot channel relationships in matrix format.</p> <p>This method creates a matrix plot showing relationships between channels, such as coherence, transfer functions, or cross-spectral density.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"matrix\"     Type of matrix plot to create. **kwargs : dict     Additional plot parameters:     - vmin, vmax: Color scale limits     - cmap: Colormap name     - title: Plot title</p>"},{"location":"en/en/api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def plot_matrix(\n    self,\n    plot_type: str = \"matrix\",\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot channel relationships in matrix format.\n\n    This method creates a matrix plot showing relationships between channels,\n    such as coherence, transfer functions, or cross-spectral density.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"matrix\"\n        Type of matrix plot to create.\n    **kwargs : dict\n        Additional plot parameters:\n        - vmin, vmax: Color scale limits\n        - cmap: Colormap name\n        - title: Plot title\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/en/api/frames/#spectrogramframe","title":"SpectrogramFrame","text":"<p><code>SpectrogramFrame</code> is a frame that handles time-frequency representation (spectrogram) data.</p> <pre><code>from wandas.frames.spectrogram import SpectrogramFrame\n\n# Or convert from ChannelFrame\nchannel_frame = wandas.read_wav(\"audio.wav\")\nspectrogram_frame = channel_frame.to_spectrogram()\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayComplex]</code></p> <p>Class for handling time-frequency domain data (spectrograms).</p> <p>This class represents spectrogram data obtained through Short-Time Fourier Transform (STFT) or similar time-frequency analysis methods. It provides methods for visualization, manipulation, and conversion back to time domain.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The spectrogram data. Must be a dask array with shape:     - (channels, frequency_bins, time_frames) for multi-channel data     - (frequency_bins, time_frames) for single-channel data, which will be       reshaped to (1, frequency_bins, time_frames) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. n_fft : int     The FFT size used to generate this spectrogram. hop_length : int     Number of samples between successive frames. win_length : int, optional     The window length in samples. If None, defaults to n_fft. window : str, default=\"hann\"     The window function to use (e.g., \"hann\", \"hamming\", \"blackman\"). label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame--attributes","title":"Attributes","text":"<p>magnitude : NDArrayReal     The magnitude spectrogram. phase : NDArrayReal     The phase spectrogram in radians. power : NDArrayReal     The power spectrogram. dB : NDArrayReal     The spectrogram in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrogram in decibels. n_frames : int     Number of time frames. n_freq_bins : int     Number of frequency bins. freqs : NDArrayReal     The frequency axis values in Hz. times : NDArrayReal     The time axis values in seconds.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame--examples","title":"Examples","text":"<p>Create a spectrogram from a time-domain signal:</p> <p>signal = ChannelFrame.from_wav(\"audio.wav\") spectrogram = signal.stft(n_fft=2048, hop_length=512)</p> <p>Extract a specific time frame:</p> <p>frame_at_1s = spectrogram.get_frame_at(int(1.0 * sampling_rate / hop_length))</p> <p>Convert back to time domain:</p> <p>reconstructed = spectrogram.to_channel_frame()</p> <p>Plot the spectrogram:</p> <p>spectrogram.plot()</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>class SpectrogramFrame(BaseFrame[NDArrayComplex]):\n    \"\"\"\n    Class for handling time-frequency domain data (spectrograms).\n\n    This class represents spectrogram data obtained through\n    Short-Time Fourier Transform (STFT)\n    or similar time-frequency analysis methods. It provides methods for visualization,\n    manipulation, and conversion back to time domain.\n\n    Parameters\n    ----------\n    data : DaArray\n        The spectrogram data. Must be a dask array with shape:\n        - (channels, frequency_bins, time_frames) for multi-channel data\n        - (frequency_bins, time_frames) for single-channel data, which will be\n          reshaped to (1, frequency_bins, time_frames)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    n_fft : int\n        The FFT size used to generate this spectrogram.\n    hop_length : int\n        Number of samples between successive frames.\n    win_length : int, optional\n        The window length in samples. If None, defaults to n_fft.\n    window : str, default=\"hann\"\n        The window function to use (e.g., \"hann\", \"hamming\", \"blackman\").\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    magnitude : NDArrayReal\n        The magnitude spectrogram.\n    phase : NDArrayReal\n        The phase spectrogram in radians.\n    power : NDArrayReal\n        The power spectrogram.\n    dB : NDArrayReal\n        The spectrogram in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrogram in decibels.\n    n_frames : int\n        Number of time frames.\n    n_freq_bins : int\n        Number of frequency bins.\n    freqs : NDArrayReal\n        The frequency axis values in Hz.\n    times : NDArrayReal\n        The time axis values in seconds.\n\n    Examples\n    --------\n    Create a spectrogram from a time-domain signal:\n    &gt;&gt;&gt; signal = ChannelFrame.from_wav(\"audio.wav\")\n    &gt;&gt;&gt; spectrogram = signal.stft(n_fft=2048, hop_length=512)\n\n    Extract a specific time frame:\n    &gt;&gt;&gt; frame_at_1s = spectrogram.get_frame_at(int(1.0 * sampling_rate / hop_length))\n\n    Convert back to time domain:\n    &gt;&gt;&gt; reconstructed = spectrogram.to_channel_frame()\n\n    Plot the spectrogram:\n    &gt;&gt;&gt; spectrogram.plot()\n    \"\"\"\n\n    n_fft: int\n    hop_length: int\n    win_length: int\n    window: str\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        if data.ndim == 2:\n            data = da.expand_dims(data, axis=0)  # type: ignore [unused-ignore]\n        elif data.ndim != 3:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306f2\u6b21\u5143\u307e\u305f\u306f3\u6b21\u5143\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u5f62\u72b6: {data.shape}\"\n            )\n        if not data.shape[-2] == n_fft // 2 + 1:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u304c\u7121\u52b9\u3067\u3059\u3002\u5468\u6ce2\u6570\u30d3\u30f3\u6570\u306f {n_fft // 2 + 1} \u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\"  # noqa: E501\n            )\n\n        self.n_fft = n_fft\n        self.hop_length = hop_length\n        self.win_length = win_length if win_length is not None else n_fft\n        self.window = window\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def magnitude(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the magnitude spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The absolute values of the complex spectrogram.\n        \"\"\"\n        return np.abs(self.data)\n\n    @property\n    def phase(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the phase spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The phase angles of the complex spectrogram in radians.\n        \"\"\"\n        return np.angle(self.data)\n\n    @property\n    def power(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the power spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The squared magnitude of the complex spectrogram.\n        \"\"\"\n        return np.abs(self.data) ** 2\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrogram in decibels relative to each channel's reference value.\n\n        The reference value for each channel is specified in its metadata.\n        A minimum value of -120 dB is enforced to avoid numerical issues.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrogram in decibels.\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        ref = np.array([ch.ref for ch in self._channel_metadata])\n        # dB\u5909\u63db\n        # 0\u9664\u7b97\u3092\u907f\u3051\u308b\u305f\u3081\u306b\u3001\u6700\u5927\u5024\u30681e-12\u306e\u3044\u305a\u308c\u304b\u3092\u4f7f\u7528\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(self.magnitude / ref[..., np.newaxis, np.newaxis], 1e-12)\n        )\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrogram in decibels.\n\n        A-weighting applies a frequency-dependent weighting filter that approximates\n        the human ear's response. This is particularly useful for analyzing noise\n        and acoustic measurements.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrogram in decibels.\n        \"\"\"\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted[:, np.newaxis]  # \u5468\u6ce2\u6570\u8ef8\u306b\u6cbf\u3063\u3066\u30d6\u30ed\u30fc\u30c9\u30ad\u30e3\u30b9\u30c8\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels.\n        \"\"\"\n        return self.shape[0]\n\n    @property\n    def n_frames(self) -&gt; int:\n        \"\"\"\n        Get the number of time frames.\n\n        Returns\n        -------\n        int\n            The number of time frames in the spectrogram.\n        \"\"\"\n        return self.shape[-1]\n\n    @property\n    def n_freq_bins(self) -&gt; int:\n        \"\"\"\n        Get the number of frequency bins.\n\n        Returns\n        -------\n        int\n            The number of frequency bins (n_fft // 2 + 1).\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the frequency axis values in Hz.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of frequency values corresponding to each frequency bin.\n        \"\"\"\n        return np.fft.rfftfreq(self.n_fft, 1.0 / self.sampling_rate)\n\n    @property\n    def times(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the time axis values in seconds.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of time values corresponding to each time frame.\n        \"\"\"\n        return np.arange(self.n_frames) * self.hop_length / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Implementation of operation application for spectrogram data.\n\n        This internal method handles the application of various operations to\n        spectrogram data, maintaining lazy evaluation through dask.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters for the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from wandas.processing.time_series import create_operation\n\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        processed_data = operation.process(self._data)\n\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\n            \"SpectrogramFrame\",\n            int,\n            float,\n            complex,\n            NDArrayComplex,\n            NDArrayReal,\n            \"DaArray\",\n        ],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"\n        Common implementation for binary operations.\n\n        This method handles binary operations between\n        SpectrogramFrames and various types\n        of operands, maintaining lazy evaluation through dask arrays.\n\n        Parameters\n        ----------\n        other : Union[SpectrogramFrame, int, float, complex,\n            NDArrayComplex, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation (e.g., lambda a, b: a + b)\n        symbol : str\n            String representation of the operation (e.g., '+')\n\n        Returns\n        -------\n        SpectrogramFrame\n            A new SpectrogramFrame containing the result of the operation.\n\n        Raises\n        ------\n        ValueError\n            If attempting to operate with a SpectrogramFrame\n            with a different sampling rate.\n        \"\"\"\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        if isinstance(other, SpectrogramFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u304c\u4e00\u81f4\u3057\u3066\u3044\u307e\u305b\u3093\u3002\u6f14\u7b97\u3067\u304d\u307e\u305b\u3093\u3002\"\n                )\n\n            result_data = op(self._data, other._data)\n\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return SpectrogramFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                hop_length=self.hop_length,\n                win_length=self.win_length,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n        else:\n            result_data = op(self._data, other)\n\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, complex):\n                other_str = f\"complex({other.real}, {other.imag})\"\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return SpectrogramFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                hop_length=self.hop_length,\n                win_length=self.win_length,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n            )\n\n    def plot(\n        self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the spectrogram using various visualization strategies.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"spectrogram\"\n            Type of plot to create.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - vmin, vmax: Colormap scaling\n            - cmap: Colormap name\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectrogramFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def plot_Aw(  # noqa: N802\n        self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the A-weighted spectrogram.\n\n        A convenience method that calls plot() with Aw=True, applying A-weighting\n        to the spectrogram before plotting.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"spectrogram\"\n            Type of plot to create.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to plot().\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot.\n        \"\"\"\n        return self.plot(plot_type=plot_type, ax=ax, Aw=True, **kwargs)\n\n    def get_frame_at(self, time_idx: int) -&gt; \"SpectralFrame\":\n        \"\"\"\n        Extract spectral data at a specific time frame.\n\n        Parameters\n        ----------\n        time_idx : int\n            Index of the time frame to extract.\n\n        Returns\n        -------\n        SpectralFrame\n            A new SpectralFrame containing the spectral data at the specified time.\n\n        Raises\n        ------\n        IndexError\n            If time_idx is out of range.\n        \"\"\"\n        from wandas.frames.spectral import SpectralFrame\n\n        if time_idx &lt; 0 or time_idx &gt;= self.n_frames:\n            raise IndexError(\n                f\"\u6642\u9593\u30a4\u30f3\u30c7\u30c3\u30af\u30b9 {time_idx} \u304c\u7bc4\u56f2\u5916\u3067\u3059\u3002\u6709\u52b9\u7bc4\u56f2: 0-{self.n_frames - 1}\"  # noqa: E501\n            )\n\n        frame_data = self._data[..., time_idx]\n\n        return SpectralFrame(\n            data=frame_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=self.n_fft,\n            window=self.window,\n            label=f\"{self.label} (Frame {time_idx}, Time {self.times[time_idx]:.3f}s)\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def to_channel_frame(self) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Convert the spectrogram back to time domain using inverse STFT.\n\n        This method performs an inverse Short-Time Fourier Transform (ISTFT) to\n        reconstruct the time-domain signal from the spectrogram.\n\n        Returns\n        -------\n        ChannelFrame\n            A new ChannelFrame containing the reconstructed time-domain signal.\n        \"\"\"\n        from wandas.frames.channel import ChannelFrame\n        from wandas.processing.time_series import ISTFT, create_operation\n\n        params = {\n            \"n_fft\": self.n_fft,\n            \"hop_length\": self.hop_length,\n            \"win_length\": self.win_length,\n            \"window\": self.window,\n        }\n        operation_name = \"istft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"ISTFT\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        time_series = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n\n        # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        return ChannelFrame(\n            data=time_series,\n            sampling_rate=self.sampling_rate,\n            label=f\"istft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get additional initialization arguments for SpectrogramFrame.\n\n        This internal method provides the additional initialization arguments\n        required by SpectrogramFrame beyond those required by BaseFrame.\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments.\n        \"\"\"\n        return {\n            \"n_fft\": self.n_fft,\n            \"hop_length\": self.hop_length,\n            \"win_length\": self.win_length,\n            \"window\": self.window,\n        }\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrogram in decibels relative to each channel's reference value.</p> <p>The reference value for each channel is specified in its metadata. A minimum value of -120 dB is enforced to avoid numerical issues.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrogram in decibels.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrogram in decibels.</p> <p>A-weighting applies a frequency-dependent weighting filter that approximates the human ear's response. This is particularly useful for analyzing noise and acoustic measurements.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrogram in decibels.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the frequency axis values in Hz.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of frequency values corresponding to each frequency bin.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.magnitude","title":"<code>magnitude</code>  <code>property</code>","text":"<p>Get the magnitude spectrogram.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.magnitude--returns","title":"Returns","text":"<p>NDArrayReal     The absolute values of the complex spectrogram.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_frames","title":"<code>n_frames</code>  <code>property</code>","text":"<p>Get the number of time frames.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_frames--returns","title":"Returns","text":"<p>int     The number of time frames in the spectrogram.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_freq_bins","title":"<code>n_freq_bins</code>  <code>property</code>","text":"<p>Get the number of frequency bins.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_freq_bins--returns","title":"Returns","text":"<p>int     The number of frequency bins (n_fft // 2 + 1).</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.phase","title":"<code>phase</code>  <code>property</code>","text":"<p>Get the phase spectrogram.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.phase--returns","title":"Returns","text":"<p>NDArrayReal     The phase angles of the complex spectrogram in radians.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.power","title":"<code>power</code>  <code>property</code>","text":"<p>Get the power spectrogram.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.power--returns","title":"Returns","text":"<p>NDArrayReal     The squared magnitude of the complex spectrogram.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.times","title":"<code>times</code>  <code>property</code>","text":"<p>Get the time axis values in seconds.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.times--returns","title":"Returns","text":"<p>NDArrayReal     Array of time values corresponding to each time frame.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at","title":"<code>get_frame_at(time_idx)</code>","text":"<p>Extract spectral data at a specific time frame.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--parameters","title":"Parameters","text":"<p>time_idx : int     Index of the time frame to extract.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--returns","title":"Returns","text":"<p>SpectralFrame     A new SpectralFrame containing the spectral data at the specified time.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--raises","title":"Raises","text":"<p>IndexError     If time_idx is out of range.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def get_frame_at(self, time_idx: int) -&gt; \"SpectralFrame\":\n    \"\"\"\n    Extract spectral data at a specific time frame.\n\n    Parameters\n    ----------\n    time_idx : int\n        Index of the time frame to extract.\n\n    Returns\n    -------\n    SpectralFrame\n        A new SpectralFrame containing the spectral data at the specified time.\n\n    Raises\n    ------\n    IndexError\n        If time_idx is out of range.\n    \"\"\"\n    from wandas.frames.spectral import SpectralFrame\n\n    if time_idx &lt; 0 or time_idx &gt;= self.n_frames:\n        raise IndexError(\n            f\"\u6642\u9593\u30a4\u30f3\u30c7\u30c3\u30af\u30b9 {time_idx} \u304c\u7bc4\u56f2\u5916\u3067\u3059\u3002\u6709\u52b9\u7bc4\u56f2: 0-{self.n_frames - 1}\"  # noqa: E501\n        )\n\n    frame_data = self._data[..., time_idx]\n\n    return SpectralFrame(\n        data=frame_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=self.n_fft,\n        window=self.window,\n        label=f\"{self.label} (Frame {time_idx}, Time {self.times[time_idx]:.3f}s)\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot","title":"<code>plot(plot_type='spectrogram', ax=None, **kwargs)</code>","text":"<p>Plot the spectrogram using various visualization strategies.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"spectrogram\"     Type of plot to create. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - vmin, vmax: Colormap scaling     - cmap: Colormap name     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def plot(\n    self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the spectrogram using various visualization strategies.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"spectrogram\"\n        Type of plot to create.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - vmin, vmax: Colormap scaling\n        - cmap: Colormap name\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectrogramFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw","title":"<code>plot_Aw(plot_type='spectrogram', ax=None, **kwargs)</code>","text":"<p>Plot the A-weighted spectrogram.</p> <p>A convenience method that calls plot() with Aw=True, applying A-weighting to the spectrogram before plotting.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"spectrogram\"     Type of plot to create. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to plot().</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def plot_Aw(  # noqa: N802\n    self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the A-weighted spectrogram.\n\n    A convenience method that calls plot() with Aw=True, applying A-weighting\n    to the spectrogram before plotting.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"spectrogram\"\n        Type of plot to create.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to plot().\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot.\n    \"\"\"\n    return self.plot(plot_type=plot_type, ax=ax, Aw=True, **kwargs)\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.to_channel_frame","title":"<code>to_channel_frame()</code>","text":"<p>Convert the spectrogram back to time domain using inverse STFT.</p> <p>This method performs an inverse Short-Time Fourier Transform (ISTFT) to reconstruct the time-domain signal from the spectrogram.</p>"},{"location":"en/en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.to_channel_frame--returns","title":"Returns","text":"<p>ChannelFrame     A new ChannelFrame containing the reconstructed time-domain signal.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def to_channel_frame(self) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Convert the spectrogram back to time domain using inverse STFT.\n\n    This method performs an inverse Short-Time Fourier Transform (ISTFT) to\n    reconstruct the time-domain signal from the spectrogram.\n\n    Returns\n    -------\n    ChannelFrame\n        A new ChannelFrame containing the reconstructed time-domain signal.\n    \"\"\"\n    from wandas.frames.channel import ChannelFrame\n    from wandas.processing.time_series import ISTFT, create_operation\n\n    params = {\n        \"n_fft\": self.n_fft,\n        \"hop_length\": self.hop_length,\n        \"win_length\": self.win_length,\n        \"window\": self.window,\n    }\n    operation_name = \"istft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"ISTFT\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    time_series = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n    )\n\n    # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    return ChannelFrame(\n        data=time_series,\n        sampling_rate=self.sampling_rate,\n        label=f\"istft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/en/api/frames/#noctframe","title":"NOctFrame","text":"<p><code>NOctFrame</code> is a frame that handles N-octave analysis data.</p> <pre><code>from wandas.frames.noct import NOctFrame\n\n# Or convert from ChannelFrame\nchannel_frame = wandas.read_wav(\"audio.wav\")\nnoct_frame = channel_frame.to_noct()\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Class for handling N-octave band analysis data.</p> <p>This class represents frequency data analyzed in fractional octave bands, typically used in acoustic and vibration analysis. It handles real-valued data representing energy or power in each frequency band, following standard acoustical band definitions.</p>"},{"location":"en/en/api/frames/#wandas.frames.noct.NOctFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The N-octave band data. Must be a dask array with shape:     - (channels, frequency_bins) for multi-channel data     - (frequency_bins,) for single-channel data, which will be       reshaped to (1, frequency_bins) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. fmin : float, default=0     Lower frequency bound in Hz. fmax : float, default=0     Upper frequency bound in Hz. n : int, default=3     Number of bands per octave (e.g., 3 for third-octave bands). G : int, default=10     Reference band number according to IEC 61260-1:2014. fr : int, default=1000     Reference frequency in Hz, typically 1000 Hz for acoustic analysis. label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/en/api/frames/#wandas.frames.noct.NOctFrame--attributes","title":"Attributes","text":"<p>freqs : NDArrayReal     The center frequencies of each band in Hz, calculated according to     the standard fractional octave band definitions. dB : NDArrayReal     The spectrum in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrum in decibels, applying frequency weighting     for better correlation with perceived loudness. fmin : float     Lower frequency bound in Hz. fmax : float     Upper frequency bound in Hz. n : int     Number of bands per octave. G : int     Reference band number. fr : int     Reference frequency in Hz.</p>"},{"location":"en/en/api/frames/#wandas.frames.noct.NOctFrame--examples","title":"Examples","text":"<p>Create an N-octave band spectrum from a time-domain signal:</p> <p>signal = ChannelFrame.from_wav(\"audio.wav\") spectrum = signal.noct_spectrum(fmin=20, fmax=20000, n=3)</p> <p>Plot the N-octave band spectrum:</p> <p>spectrum.plot()</p> <p>Plot with A-weighting applied:</p> <p>spectrum.plot(Aw=True)</p>"},{"location":"en/en/api/frames/#wandas.frames.noct.NOctFrame--notes","title":"Notes","text":"<ul> <li>Binary operations (addition, multiplication, etc.) are not currently   supported for N-octave band data.</li> <li>The actual frequency bands are determined by the parameters n, G, and fr   according to IEC 61260-1:2014 standard for fractional octave band filters.</li> <li>The class follows acoustic standards for band definitions and analysis,   making it suitable for noise measurements and sound level analysis.</li> <li>A-weighting is available for better correlation with human hearing   perception, following IEC 61672-1:2013.</li> </ul> Source code in <code>wandas/frames/noct.py</code> <pre><code>class NOctFrame(BaseFrame[NDArrayReal]):\n    \"\"\"\n    Class for handling N-octave band analysis data.\n\n    This class represents frequency data analyzed in fractional octave bands,\n    typically used in acoustic and vibration analysis. It handles real-valued\n    data representing energy or power in each frequency band, following standard\n    acoustical band definitions.\n\n    Parameters\n    ----------\n    data : DaArray\n        The N-octave band data. Must be a dask array with shape:\n        - (channels, frequency_bins) for multi-channel data\n        - (frequency_bins,) for single-channel data, which will be\n          reshaped to (1, frequency_bins)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    fmin : float, default=0\n        Lower frequency bound in Hz.\n    fmax : float, default=0\n        Upper frequency bound in Hz.\n    n : int, default=3\n        Number of bands per octave (e.g., 3 for third-octave bands).\n    G : int, default=10\n        Reference band number according to IEC 61260-1:2014.\n    fr : int, default=1000\n        Reference frequency in Hz, typically 1000 Hz for acoustic analysis.\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    freqs : NDArrayReal\n        The center frequencies of each band in Hz, calculated according to\n        the standard fractional octave band definitions.\n    dB : NDArrayReal\n        The spectrum in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrum in decibels, applying frequency weighting\n        for better correlation with perceived loudness.\n    fmin : float\n        Lower frequency bound in Hz.\n    fmax : float\n        Upper frequency bound in Hz.\n    n : int\n        Number of bands per octave.\n    G : int\n        Reference band number.\n    fr : int\n        Reference frequency in Hz.\n\n    Examples\n    --------\n    Create an N-octave band spectrum from a time-domain signal:\n    &gt;&gt;&gt; signal = ChannelFrame.from_wav(\"audio.wav\")\n    &gt;&gt;&gt; spectrum = signal.noct_spectrum(fmin=20, fmax=20000, n=3)\n\n    Plot the N-octave band spectrum:\n    &gt;&gt;&gt; spectrum.plot()\n\n    Plot with A-weighting applied:\n    &gt;&gt;&gt; spectrum.plot(Aw=True)\n\n    Notes\n    -----\n    - Binary operations (addition, multiplication, etc.) are not currently\n      supported for N-octave band data.\n    - The actual frequency bands are determined by the parameters n, G, and fr\n      according to IEC 61260-1:2014 standard for fractional octave band filters.\n    - The class follows acoustic standards for band definitions and analysis,\n      making it suitable for noise measurements and sound level analysis.\n    - A-weighting is available for better correlation with human hearing\n      perception, following IEC 61672-1:2013.\n    \"\"\"\n\n    fmin: float\n    fmax: float\n    n: int\n    G: int\n    fr: int\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        fmin: float = 0,\n        fmax: float = 0,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a NOctFrame instance.\n\n        Sets up N-octave band analysis parameters and prepares the frame for\n        storing band-filtered data. Data shape is validated to ensure compatibility\n        with N-octave band analysis.\n\n        See class docstring for parameter descriptions.\n        \"\"\"\n        self.n = n\n        self.G = G\n        self.fr = fr\n        self.fmin = fmin\n        self.fmax = fmax\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrum in decibels relative to each channel's reference value.\n\n        The reference value for each channel is specified in its metadata.\n        A minimum value of -120 dB is enforced to avoid numerical issues.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrum in decibels. Shape matches the input data shape:\n            (channels, frequency_bins).\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        ref = np.array([ch.ref for ch in self._channel_metadata])\n        # dB\u5909\u63db\n        # 0\u9664\u7b97\u3092\u907f\u3051\u308b\u305f\u3081\u306b\u3001\u6700\u5927\u5024\u30681e-12\u306e\u3044\u305a\u308c\u304b\u3092\u4f7f\u7528\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(self.data / ref[..., np.newaxis], 1e-12)\n        )\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrum in decibels.\n\n        A-weighting applies a frequency-dependent weighting filter that approximates\n        the human ear's response to different frequencies. This is particularly useful\n        for analyzing noise and acoustic measurements as it provides a better\n        correlation with perceived loudness.\n\n        The weighting is applied according to IEC 61672-1:2013 standard.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrum in decibels. Shape matches the input data shape:\n            (channels, frequency_bins).\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels in the N-octave band data.\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the center frequencies of each band in Hz.\n\n        These frequencies are calculated based on the N-octave band parameters\n        (n, G, fr) and the frequency bounds (fmin, fmax) according to\n        IEC 61260-1:2014 standard for fractional octave band filters.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of center frequencies for each frequency band.\n\n        Raises\n        ------\n        ValueError\n            If the center frequencies cannot be calculated or the result\n            is not a numpy array.\n        \"\"\"\n        _, freqs = _center_freq(\n            fmax=self.fmax,\n            fmin=self.fmin,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        if isinstance(freqs, np.ndarray):\n            return freqs\n        else:\n            raise ValueError(\"freqs is not numpy array.\")\n\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"\n        Binary operations are not currently supported for N-octave band data.\n\n        Parameters\n        ----------\n        other : Union[S, int, float, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation.\n        symbol : str\n            String representation of the operation (e.g., '+', '-', '*', '/').\n\n        Raises\n        ------\n        NotImplementedError\n            Always raises this error as operations are not implemented\n            for N-octave band data.\n        \"\"\"\n        raise NotImplementedError(\n            f\"Operation {symbol} is not implemented for NOctFrame.\"\n        )\n        return self\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        \u9045\u5ef6\u8a55\u4fa1\u3092\u4f7f\u7528\u3057\u3066\u64cd\u4f5c\u3092\u9069\u7528\u3057\u307e\u3059\u3002\n        \"\"\"\n        # \u9045\u5ef6\u8a55\u4fa1\u3092\u4f7f\u7528\u3057\u3066\u64cd\u4f5c\u3092\u9069\u7528\n        raise NotImplementedError(\n            f\"Operation {operation_name} is not implemented for NOctFrame.\"\n        )\n        return self\n\n    def plot(\n        self, plot_type: str = \"noct\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the N-octave band data using various visualization strategies.\n\n        Supports standard plotting configurations for acoustic analysis,\n        including decibel scales and A-weighting.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"noct\"\n            Type of plot to create. The default \"noct\" type creates a bar plot\n            suitable for displaying N-octave band data.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n            - title: Plot title\n            - xlabel, ylabel: Axis labels\n            - xscale: Set to \"log\" for logarithmic frequency axis\n            - grid: Whether to show grid lines\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[NOctFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get additional initialization arguments for NOctFrame.\n\n        This internal method provides the additional initialization arguments\n        required by NOctFrame beyond those required by BaseFrame. These include\n        the N-octave band analysis parameters that define the frequency bands.\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments specific to NOctFrame:\n            - n: Number of bands per octave\n            - G: Reference band number\n            - fr: Reference frequency\n            - fmin: Lower frequency bound\n            - fmax: Upper frequency bound\n        \"\"\"\n        return {\n            \"n\": self.n,\n            \"G\": self.G,\n            \"fr\": self.fr,\n            \"fmin\": self.fmin,\n            \"fmax\": self.fmax,\n        }\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.noct.NOctFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrum in decibels relative to each channel's reference value.</p> <p>The reference value for each channel is specified in its metadata. A minimum value of -120 dB is enforced to avoid numerical issues.</p>"},{"location":"en/en/api/frames/#wandas.frames.noct.NOctFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrum in decibels. Shape matches the input data shape:     (channels, frequency_bins).</p>"},{"location":"en/en/api/frames/#wandas.frames.noct.NOctFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrum in decibels.</p> <p>A-weighting applies a frequency-dependent weighting filter that approximates the human ear's response to different frequencies. This is particularly useful for analyzing noise and acoustic measurements as it provides a better correlation with perceived loudness.</p> <p>The weighting is applied according to IEC 61672-1:2013 standard.</p>"},{"location":"en/en/api/frames/#wandas.frames.noct.NOctFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrum in decibels. Shape matches the input data shape:     (channels, frequency_bins).</p>"},{"location":"en/en/api/frames/#wandas.frames.noct.NOctFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the center frequencies of each band in Hz.</p> <p>These frequencies are calculated based on the N-octave band parameters (n, G, fr) and the frequency bounds (fmin, fmax) according to IEC 61260-1:2014 standard for fractional octave band filters.</p>"},{"location":"en/en/api/frames/#wandas.frames.noct.NOctFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of center frequencies for each frequency band.</p>"},{"location":"en/en/api/frames/#wandas.frames.noct.NOctFrame.freqs--raises","title":"Raises","text":"<p>ValueError     If the center frequencies cannot be calculated or the result     is not a numpy array.</p>"},{"location":"en/en/api/frames/#wandas.frames.noct.NOctFrame.__init__","title":"<code>__init__(data, sampling_rate, fmin=0, fmax=0, n=3, G=10, fr=1000, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a NOctFrame instance.</p> <p>Sets up N-octave band analysis parameters and prepares the frame for storing band-filtered data. Data shape is validated to ensure compatibility with N-octave band analysis.</p> <p>See class docstring for parameter descriptions.</p> Source code in <code>wandas/frames/noct.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    fmin: float = 0,\n    fmax: float = 0,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a NOctFrame instance.\n\n    Sets up N-octave band analysis parameters and prepares the frame for\n    storing band-filtered data. Data shape is validated to ensure compatibility\n    with N-octave band analysis.\n\n    See class docstring for parameter descriptions.\n    \"\"\"\n    self.n = n\n    self.G = G\n    self.fr = fr\n    self.fmin = fmin\n    self.fmax = fmax\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"en/en/api/frames/#wandas.frames.noct.NOctFrame.plot","title":"<code>plot(plot_type='noct', ax=None, **kwargs)</code>","text":"<p>Plot the N-octave band data using various visualization strategies.</p> <p>Supports standard plotting configurations for acoustic analysis, including decibel scales and A-weighting.</p>"},{"location":"en/en/api/frames/#wandas.frames.noct.NOctFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"noct\"     Type of plot to create. The default \"noct\" type creates a bar plot     suitable for displaying N-octave band data. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting     - title: Plot title     - xlabel, ylabel: Axis labels     - xscale: Set to \"log\" for logarithmic frequency axis     - grid: Whether to show grid lines</p>"},{"location":"en/en/api/frames/#wandas.frames.noct.NOctFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/noct.py</code> <pre><code>def plot(\n    self, plot_type: str = \"noct\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the N-octave band data using various visualization strategies.\n\n    Supports standard plotting configurations for acoustic analysis,\n    including decibel scales and A-weighting.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"noct\"\n        Type of plot to create. The default \"noct\" type creates a bar plot\n        suitable for displaying N-octave band data.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n        - title: Plot title\n        - xlabel, ylabel: Axis labels\n        - xscale: Set to \"log\" for logarithmic frequency axis\n        - grid: Whether to show grid lines\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[NOctFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/en/api/processing/","title":"Processing Module","text":"<p>This page explains the processing module of Wandas. The processing module provides various processing functions for time-series data.</p>"},{"location":"en/en/api/processing/#time-series-processing","title":"Time Series Processing","text":"<p>These are processing functions for time-series data. These functions are typically used through <code>ChannelFrame</code> methods.</p> <pre><code># Common usage\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")\nfiltered_frame = frame.filter(cutoff=1000, filter_type=\"lowpass\")\nresampled_frame = frame.resample(target_rate=16000)\n</code></pre>"},{"location":"en/en/api/processing/#key-processing-classes","title":"Key Processing Classes","text":"<p>The filtering and other signal processing functions are internally implemented by the following classes:</p> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>High-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HighPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"High-pass filter operation\"\"\"\n\n    name = \"highpass_filter\"\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize high-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            limit = self.sampling_rate / 2\n            raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up high-pass filter processor\"\"\"\n        # Calculate filter coefficients (once) - safely retrieve from instance variables\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"high\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Highpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying highpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Low-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class LowPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Low-pass filter operation\"\"\"\n\n    name = \"lowpass_filter\"\n    a: NDArrayReal\n    b: NDArrayReal\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize low-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            raise ValueError(\n                f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n            )\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up low-pass filter processor\"\"\"\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"low\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Lowpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying lowpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Resampling operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ReSampling(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Resampling operation\"\"\"\n\n    name = \"resampling\"\n\n    def __init__(self, sampling_rate: float, target_sr: float):\n        \"\"\"\n        Initialize resampling operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        target_sampling_rate : float\n            Target sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate, target_sr=target_sr)\n        self.target_sr = target_sr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after resampling\n        ratio = float(self.target_sr) / float(self.sampling_rate)\n        n_samples = int(np.ceil(input_shape[-1] * ratio))\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for resampling operation\"\"\"\n        logger.debug(f\"Applying resampling to array with shape: {x.shape}\")\n        result = librosa.resample(\n            x, orig_sr=self.sampling_rate, target_sr=self.target_sr\n        )\n        logger.debug(f\"Resampling applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>A-weighting filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AWeighting(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"A-weighting filter operation\"\"\"\n\n    name = \"a_weighting\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize A-weighting filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for A-weighting filter\"\"\"\n        logger.debug(f\"Applying A-weighting to array with shape: {x.shape}\")\n        result = A_weight(x, self.sampling_rate)\n\n        # Handle case where A_weight returns a tuple\n        if isinstance(result, tuple):\n            # Use the first element of the tuple\n            result = result[0]\n\n        logger.debug(\n            f\"A-weighting applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"en/en/api/processing/#wandas.processing.time_series.HighPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize high-pass filter</p>"},{"location":"en/en/api/processing/#wandas.processing.time_series.HighPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize high-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/en/api/processing/#wandas.processing.time_series.HighPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        limit = self.sampling_rate / 2\n        raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n</code></pre>"},{"location":"en/en/api/processing/#wandas.processing.time_series.LowPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize low-pass filter</p>"},{"location":"en/en/api/processing/#wandas.processing.time_series.LowPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize low-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/en/api/processing/#wandas.processing.time_series.LowPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        raise ValueError(\n            f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n        )\n</code></pre>"},{"location":"en/en/api/processing/#wandas.processing.time_series.ReSampling.__init__","title":"<code>__init__(sampling_rate, target_sr)</code>","text":"<p>Initialize resampling operation</p>"},{"location":"en/en/api/processing/#wandas.processing.time_series.ReSampling.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) target_sampling_rate : float     Target sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, target_sr: float):\n    \"\"\"\n    Initialize resampling operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    target_sampling_rate : float\n        Target sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate, target_sr=target_sr)\n    self.target_sr = target_sr\n</code></pre>"},{"location":"en/en/api/processing/#wandas.processing.time_series.ReSampling.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/en/api/processing/#wandas.processing.time_series.ReSampling.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/en/api/processing/#wandas.processing.time_series.ReSampling.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after resampling\n    ratio = float(self.target_sr) / float(self.sampling_rate)\n    n_samples = int(np.ceil(input_shape[-1] * ratio))\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"en/en/api/processing/#wandas.processing.time_series.AWeighting.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize A-weighting filter</p>"},{"location":"en/en/api/processing/#wandas.processing.time_series.AWeighting.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize A-weighting filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"en/en/api/processing/#audiooperation","title":"AudioOperation","text":"<p>The <code>AudioOperation</code> class enables abstraction and chaining of audio processing operations.</p> <pre><code>from wandas.processing.time_series import AudioOperation\n\n# Usage example\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")\n\n# Chain multiple processing steps\noperation = (\n    AudioOperation()\n    .add_step(\"filter\", cutoff=1000, filter_type=\"lowpass\")\n    .add_step(\"normalize\")\n)\n\n# Apply the processing\nprocessed_frame = operation.apply(frame)\n</code></pre> <p>               Bases: <code>Generic[InputArrayType, OutputArrayType]</code></p> <p>Abstract base class for audio processing operations.</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AudioOperation(Generic[InputArrayType, OutputArrayType]):\n    \"\"\"Abstract base class for audio processing operations.\"\"\"\n\n    # Class variable: operation name\n    name: ClassVar[str]\n\n    def __init__(self, sampling_rate: float, **params: Any):\n        \"\"\"\n        Initialize AudioOperation.\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        **params : Any\n            Operation-specific parameters\n        \"\"\"\n        self.sampling_rate = sampling_rate\n        self.params = params\n\n        # Validate parameters during initialization\n        self.validate_params()\n\n        # Create processor function (lazy initialization possible)\n        self._setup_processor()\n\n        logger.debug(\n            f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n        )\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n        pass\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up processor function (implemented by subclasses)\"\"\"\n        pass\n\n    def _process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function (implemented by subclasses)\"\"\"\n        # Default is no-op function\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    @dask.delayed  # type: ignore [misc, unused-ignore]\n    def process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n        # Default is no-op function\n        logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n        return self._process_array(x)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation (implemented by subclasses)\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        \"\"\"\n        Execute operation and return result\n        data shape is (channels, samples)\n        \"\"\"\n        # Add task as delayed processing\n        logger.debug(\"Adding delayed operation to computation graph\")\n        delayed_result = self.process_array(data)\n        # Convert delayed result to dask array and return\n        output_shape = self.calculate_output_shape(data.shape)\n        return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"en/en/api/processing/#wandas.processing.time_series.AudioOperation.__init__","title":"<code>__init__(sampling_rate, **params)</code>","text":"<p>Initialize AudioOperation.</p>"},{"location":"en/en/api/processing/#wandas.processing.time_series.AudioOperation.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) **params : Any     Operation-specific parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, **params: Any):\n    \"\"\"\n    Initialize AudioOperation.\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    **params : Any\n        Operation-specific parameters\n    \"\"\"\n    self.sampling_rate = sampling_rate\n    self.params = params\n\n    # Validate parameters during initialization\n    self.validate_params()\n\n    # Create processor function (lazy initialization possible)\n    self._setup_processor()\n\n    logger.debug(\n        f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n    )\n</code></pre>"},{"location":"en/en/api/processing/#wandas.processing.time_series.AudioOperation.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation (implemented by subclasses)</p>"},{"location":"en/en/api/processing/#wandas.processing.time_series.AudioOperation.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/en/api/processing/#wandas.processing.time_series.AudioOperation.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation (implemented by subclasses)\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"en/en/api/processing/#wandas.processing.time_series.AudioOperation.process","title":"<code>process(data)</code>","text":"<p>Execute operation and return result data shape is (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    \"\"\"\n    Execute operation and return result\n    data shape is (channels, samples)\n    \"\"\"\n    # Add task as delayed processing\n    logger.debug(\"Adding delayed operation to computation graph\")\n    delayed_result = self.process_array(data)\n    # Convert delayed result to dask array and return\n    output_shape = self.calculate_output_shape(data.shape)\n    return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"en/en/api/processing/#wandas.processing.time_series.AudioOperation.process_array","title":"<code>process_array(x)</code>","text":"<p>Processing function wrapped with @dask.delayed</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>@dask.delayed  # type: ignore [misc, unused-ignore]\ndef process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n    \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n    # Default is no-op function\n    logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n    return self._process_array(x)\n</code></pre>"},{"location":"en/en/api/processing/#wandas.processing.time_series.AudioOperation.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters (raises exception if invalid)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n    pass\n</code></pre>"},{"location":"en/en/explanation/","title":"Theory Background and Architecture","text":"<p>This section explains the design philosophy, internal architecture, and theoretical background used in the Wandas library.</p>"},{"location":"en/en/explanation/#design-philosophy","title":"Design Philosophy","text":"<p>Wandas is developed based on the following design principles:</p> <ol> <li>Intuitive API Design - Consistent interface that users can easily use</li> <li>Efficient Memory Usage - Memory-efficient implementation suitable for processing large-scale data</li> <li>Extensibility - Expandable architecture that makes it easy to add new features and algorithms</li> <li>Scientific Accuracy - Accurate implementation based on acoustic signal processing theory</li> </ol>"},{"location":"en/en/explanation/#core-architecture","title":"Core Architecture","text":""},{"location":"en/en/explanation/#data-model","title":"Data Model","text":"<p>The central data model of the Wandas library is hierarchically structured:</p> <pre><code>BaseChannel (base class)\n \u251c\u2500\u2500 Channel (time-domain signal)\n \u2502    \u2514\u2500\u2500 FrequencyChannel (frequency-domain signal)\n \u2502         \u2514\u2500\u2500 TimeFrequencyChannel (time-frequency domain signal)\n \u2514\u2500\u2500 ChannelFrame (container for multiple channels)\n      \u251c\u2500\u2500 FileFrame (file-based multiple channels)\n      \u2514\u2500\u2500 FrequencyChannelFrame (multiple channels in frequency domain)\n</code></pre> <p>Responsibilities of each class:</p> <ul> <li>BaseChannel: Base class for all channels. Provides basic functionality for data access and metadata management</li> <li>Channel: Implements time-domain signal data and processing methods</li> <li>FrequencyChannel: Implements FFT-based frequency-domain data and processing</li> <li>TimeFrequencyChannel: Implements time-frequency domain representations such as Short-Time Fourier Transform (STFT)</li> <li>ChannelFrame: Manages multiple channels and enables batch processing</li> </ul>"},{"location":"en/en/explanation/#data-processing-flow","title":"Data Processing Flow","text":"<ol> <li>Input Stage: Generate <code>Channel</code> or <code>ChannelFrame</code> objects from files such as WAV and CSV</li> <li>Processing Stage: Apply processing such as filtering and resampling</li> <li>Analysis Stage: Analyze signal characteristics (spectrum, level, etc.)</li> <li>Output Stage: Save processing results to files or visualize as graphs</li> </ol>"},{"location":"en/en/explanation/#implementation-details","title":"Implementation Details","text":""},{"location":"en/en/explanation/#memory-efficiency","title":"Memory Efficiency","text":"<p>Wandas ensures memory efficiency for handling large audio data through the following methods:</p> <ul> <li>Lazy Evaluation: A mechanism that delays calculations until needed</li> <li>Memory Mapping: Access to large files without loading them entirely into memory</li> <li>Dask and H5PY: Utilizing libraries suitable for large-scale data processing</li> </ul>"},{"location":"en/en/explanation/#signal-processing-algorithms","title":"Signal Processing Algorithms","text":"<p>Wandas implements signal processing algorithms such as:</p> <ul> <li>Digital Filters: IIR/FIR filters such as Butterworth filters</li> <li>Spectral Analysis: Frequency analysis based on Fast Fourier Transform (FFT)</li> <li>Time-Frequency Analysis: Short-Time Fourier Transform (STFT), spectrograms</li> <li>Statistical Analysis: Calculation of signal characteristics such as RMS, peak values, crest factor</li> </ul>"},{"location":"en/en/explanation/#performance-considerations","title":"Performance Considerations","text":"<p>Performance considerations when using Wandas:</p> <ul> <li>When processing large amounts of data, consider processing in chunks</li> <li>When building complex processing chains, improve performance by caching intermediate results</li> <li>Multi-channel processing efficiently utilizes multi-core processors</li> </ul>"},{"location":"en/en/explanation/#references","title":"References","text":"<ol> <li>Smith, J. O. (2011). Spectral Audio Signal Processing. W3K Publishing.</li> <li>M\u00fcller, M. (2015). Fundamentals of Music Processing: Audio, Analysis, Algorithms, Applications. Springer.</li> <li>Z\u00f6lzer, U. (2008). Digital Audio Signal Processing. Wiley.</li> </ol>"},{"location":"en/en/how_to/","title":"Cookbook (Use Case Recipes)","text":"<p>This section provides examples of various practical tasks using the Wandas library.</p>"},{"location":"en/en/how_to/#basic-audio-analysis","title":"Basic Audio Analysis","text":"<ul> <li>Get basic information from audio files</li> <li>Analyze the frequency spectrum of audio</li> <li>Measure volume characteristics such as RMS level and peak level</li> </ul>"},{"location":"en/en/how_to/#signal-processing","title":"Signal Processing","text":"<ul> <li>Apply low-pass/high-pass/band-pass filters</li> <li>Adjust the volume of specific frequency bands (equalizer)</li> <li>Perform noise reduction</li> <li>Change the pitch of audio</li> </ul>"},{"location":"en/en/how_to/#audio-data-manipulation","title":"Audio Data Manipulation","text":"<ul> <li>Concatenate multiple audio files</li> <li>Extract specific parts</li> <li>Apply fade-in/fade-out to audio</li> <li>Convert between different formats</li> </ul>"},{"location":"en/en/how_to/#special-effects","title":"Special Effects","text":"<ul> <li>Add reverb effects</li> <li>Add echo effects</li> <li>Apply distortion effects</li> </ul>"},{"location":"en/en/how_to/#advanced-applications","title":"Advanced Applications","text":"<ul> <li>Use as preprocessing for speech recognition</li> <li>Efficiently process large datasets</li> <li>Build real-time processing pipelines</li> </ul>"},{"location":"en/en/how_to/#adding-custom-processing","title":"Adding Custom Processing","text":"<ul> <li>Define your own filters</li> <li>Implement new processing functions</li> <li>Integrate wandas with other libraries</li> </ul> <p>Tip</p> <p>Each recipe is independent and can be referenced as needed. If you don't understand the basic usage, please see the Tutorial first.</p>"},{"location":"en/en/tutorial/","title":"Tutorial","text":"<p>This tutorial will teach you the basics of the Wandas library in 5 minutes.</p>"},{"location":"en/en/tutorial/#installation","title":"Installation","text":"<pre><code>pip install wandas\n</code></pre>"},{"location":"en/en/tutorial/#basic-usage","title":"Basic Usage","text":""},{"location":"en/en/tutorial/#1-import-the-library","title":"1. Import the Library","text":"<pre><code>import wandas as wd\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"en/en/tutorial/#2-load-audio-files","title":"2. Load Audio Files","text":"<pre><code># Load a WAV file\naudio = wd.io.read_wav(\"path/to/audio.wav\")\nprint(f\"Sampling rate: {audio.sampling_rate} Hz\")\nprint(f\"Number of channels: {len(audio)}\")\n</code></pre>"},{"location":"en/en/tutorial/#3-visualize-signals","title":"3. Visualize Signals","text":"<pre><code># Display waveform\naudio.plot()\nplt.show()\n</code></pre>"},{"location":"en/en/tutorial/#4-basic-signal-processing","title":"4. Basic Signal Processing","text":"<pre><code># Apply a low-pass filter (passing frequencies below 1kHz)\nfiltered = audio.filter(lowpass=1000)\n\n# Visualize and compare results\nfig, axes = plt.subplots(2, 1, figsize=(10, 6))\naudio.plot(ax=axes[0], title=\"Original Signal\")\nfiltered.plot(ax=axes[1], title=\"Filtered Signal\")\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"en/en/tutorial/#5-save-processing-results","title":"5. Save Processing Results","text":"<pre><code># Save the processed signal as a WAV file\nwd.io.write_wav(filtered, \"filtered_audio.wav\")\n</code></pre>"},{"location":"en/en/tutorial/#next-steps","title":"Next Steps","text":"<ul> <li>Check out various applications in the Cookbook</li> <li>Look up detailed functions in the API Reference</li> <li>Understand the library's design philosophy in the Theory Background</li> </ul>"},{"location":"en/ja/","title":"Wandas: Waveform Analysis Data Structures","text":"<p>Wandas \u306f\u3001Python\u306b\u3088\u308b\u52b9\u7387\u7684\u306a\u4fe1\u53f7\u89e3\u6790\u306e\u305f\u3081\u306e\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3059\u3002Wandas \u306f\u3001\u4fe1\u53f7\u51e6\u7406\u306e\u305f\u3081\u306e\u5305\u62ec\u7684\u306a\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u3001Matplotlib\u3068\u306e\u30b7\u30fc\u30e0\u30ec\u30b9\u306a\u7d71\u5408\u3092\u5b9f\u73fe\u3057\u3066\u3044\u307e\u3059\u3002</p>"},{"location":"en/ja/#_1","title":"\u6a5f\u80fd","text":"<ul> <li>\u5305\u62ec\u7684\u306a\u4fe1\u53f7\u51e6\u7406\u6a5f\u80fd: \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3001\u30d5\u30fc\u30ea\u30a8\u5909\u63db\u3001STFT\u306a\u3069\u3001\u57fa\u672c\u7684\u306a\u4fe1\u53f7\u51e6\u7406\u64cd\u4f5c\u3092\u7c21\u5358\u306b\u5b9f\u884c\u53ef\u80fd</li> <li>\u53ef\u8996\u5316\u30e9\u30a4\u30d6\u30e9\u30ea\u3068\u306e\u7d71\u5408: Matplotlib\u3068\u30b7\u30fc\u30e0\u30ec\u30b9\u306b\u7d71\u5408\u3057\u3066\u30c7\u30fc\u30bf\u3092\u7c21\u5358\u306b\u53ef\u8996\u5316\u53ef\u80fd</li> <li>\u9045\u5ef6\u8a55\u4fa1: dask\u3092\u6d3b\u7528\u3057\u305f\u52b9\u7387\u7684\u306a\u5927\u898f\u6a21\u30c7\u30fc\u30bf\u51e6\u7406</li> <li>\u591a\u69d8\u306a\u5206\u6790\u30c4\u30fc\u30eb: \u5468\u6ce2\u6570\u5206\u6790\u3001\u30aa\u30af\u30bf\u30fc\u30d6\u30d0\u30f3\u30c9\u5206\u6790\u3001\u6642\u9593-\u5468\u6ce2\u6570\u5206\u6790\u306a\u3069</li> </ul>"},{"location":"en/ja/#_2","title":"\u4f7f\u7528\u4f8b","text":""},{"location":"en/ja/#_3","title":"\u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\u3068\u53ef\u8996\u5316","text":"<pre><code>import wandas as wd\n\n# docs/docs/ja/index.md \u304b\u3089\u306e\u76f8\u5bfe\u30d1\u30b9\u3067\u30b5\u30f3\u30d7\u30eb\u30c7\u30fc\u30bf\u3092\u6307\u5b9a\n# \u5b9f\u969b\u306e\u4f7f\u7528\u6642\u306f\u9069\u5207\u306a\u30d1\u30b9\u306b\u5909\u66f4\u3057\u3066\u304f\u3060\u3055\u3044\n# cf = wd.read_wav(\"../../examples/data/summer_streets1.wav\")\n# cf.describe()\n</code></pre>"},{"location":"en/ja/#_4","title":"\u30d5\u30a3\u30eb\u30bf\u51e6\u7406","text":"<pre><code># import wandas as wd\n# import numpy as np\n# signal = wd.generate_sin(freqs=[5000, 1000], duration=1)\n# \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3092\u9069\u7528\n# filtered_signal = signal.low_pass_filter(cutoff=1000)\n# filtered_signal.fft().plot()\n</code></pre> <p>\u8a73\u7d30\u306a\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3084\u4f7f\u7528\u4f8b\u306b\u3064\u3044\u3066\u306f\u3001\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3084\u30af\u30c3\u30af\u30d6\u30c3\u30af\u3092\u3054\u89a7\u304f\u3060\u3055\u3044\u3002</p>"},{"location":"en/ja/#_5","title":"\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u69cb\u6210","text":"<ul> <li>\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb - 5\u5206\u3067\u59cb\u3081\u3089\u308c\u308b\u5165\u9580\u30ac\u30a4\u30c9</li> <li>\u30af\u30c3\u30af\u30d6\u30c3\u30af - \u4e00\u822c\u7684\u306a\u30bf\u30b9\u30af\u306e\u30ec\u30b7\u30d4\u96c6</li> <li>API\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9 - \u8a73\u7d30\u306aAPI\u4ed5\u69d8</li> <li>\u7406\u8ad6\u80cc\u666f/\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3 - \u8a2d\u8a08\u601d\u60f3\u3068\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u89e3\u8aac</li> <li>\u8ca2\u732e\u30ac\u30a4\u30c9 - \u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30b7\u30e7\u30f3\u306e\u30eb\u30fc\u30eb\u3068\u65b9\u6cd5</li> </ul>"},{"location":"en/ja/#_6","title":"\u30e9\u30a4\u30bb\u30f3\u30b9","text":"<p>\u3053\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306f MIT\u30e9\u30a4\u30bb\u30f3\u30b9 \u306e\u4e0b\u3067\u516c\u958b\u3055\u308c\u3066\u3044\u307e\u3059\u3002</p>"},{"location":"en/ja/contributing/","title":"\u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30b7\u30e7\u30f3\u30ac\u30a4\u30c9","text":"<p>Wandas\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3078\u306e\u8ca2\u732e\u306b\u8208\u5473\u3092\u6301\u3063\u3066\u3044\u305f\u3060\u304d\u3042\u308a\u304c\u3068\u3046\u3054\u3056\u3044\u307e\u3059\u3002\u3053\u306e\u30ac\u30a4\u30c9\u3067\u306f\u3001\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30c8\u3059\u308b\u65b9\u6cd5\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002</p>"},{"location":"en/ja/contributing/#_2","title":"\u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30b7\u30e7\u30f3\u306e\u7a2e\u985e","text":"<p>\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u5f62\u3067Wandas\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u8ca2\u732e\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff1a</p> <ul> <li>\u30d0\u30b0\u5831\u544a\u3084\u6a5f\u80fd\u30ea\u30af\u30a8\u30b9\u30c8</li> <li>\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306e\u6539\u5584</li> <li>\u30d0\u30b0\u4fee\u6b63</li> <li>\u65b0\u6a5f\u80fd\u306e\u5b9f\u88c5</li> <li>\u30c6\u30b9\u30c8\u306e\u8ffd\u52a0\u3084\u6539\u5584</li> <li>\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u306e\u6700\u9069\u5316</li> </ul>"},{"location":"en/ja/contributing/#_3","title":"\u958b\u767a\u74b0\u5883\u306e\u30bb\u30c3\u30c8\u30a2\u30c3\u30d7","text":""},{"location":"en/ja/contributing/#1","title":"1. \u30ea\u30dd\u30b8\u30c8\u30ea\u306e\u30af\u30ed\u30fc\u30f3","text":"<pre><code>git clone https://github.com/yourusername/wandas.git\ncd wandas\n</code></pre>"},{"location":"en/ja/contributing/#2","title":"2. \u4eee\u60f3\u74b0\u5883\u306e\u30bb\u30c3\u30c8\u30a2\u30c3\u30d7\u3068\u4f9d\u5b58\u95a2\u4fc2\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb","text":"<pre><code>python -m venv venv\nsource venv/bin/activate  # Windows\u306e\u5834\u5408: venv\\Scripts\\activate\npip install -e \".[dev]\"\n</code></pre>"},{"location":"en/ja/contributing/#_4","title":"\u958b\u767a\u30ef\u30fc\u30af\u30d5\u30ed\u30fc","text":""},{"location":"en/ja/contributing/#1_1","title":"1. \u65b0\u3057\u3044\u30d6\u30e9\u30f3\u30c1\u306e\u4f5c\u6210","text":"<p>\u65b0\u3057\u3044\u6a5f\u80fd\u3084\u30d0\u30b0\u4fee\u6b63\u306b\u306f\u3001\u65b0\u3057\u3044\u30d6\u30e9\u30f3\u30c1\u3092\u4f5c\u6210\u3057\u3066\u304f\u3060\u3055\u3044\uff1a</p> <pre><code>git checkout -b feature/your-feature-name\n# \u307e\u305f\u306f\ngit checkout -b fix/issue-description\n</code></pre>"},{"location":"en/ja/contributing/#2_1","title":"2. \u30b3\u30fc\u30c9\u30b9\u30bf\u30a4\u30eb","text":"<p>\u30b3\u30fc\u30c9\u306fPEP 8\u30b9\u30bf\u30a4\u30eb\u30ac\u30a4\u30c9\u306b\u5f93\u3063\u3066\u304f\u3060\u3055\u3044\u3002\u30b3\u30fc\u30c9\u306e\u54c1\u8cea\u3092\u78ba\u4fdd\u3059\u308b\u305f\u3081\u306b\u3001\u4ee5\u4e0b\u306e\u30c4\u30fc\u30eb\u3092\u4f7f\u7528\u3057\u3066\u3044\u307e\u3059\uff1a</p> <ul> <li>Ruff: \u30b3\u30fc\u30c9\u30ea\u30f3\u30bf\u30fc\u3068\u30d5\u30a9\u30fc\u30de\u30c3\u30bf\u30fc</li> <li>mypy: \u9759\u7684\u578b\u30c1\u30a7\u30c3\u30af</li> </ul> <p>\u30b3\u30fc\u30c9\u3092\u30b3\u30df\u30c3\u30c8\u3059\u308b\u524d\u306b\u3001\u4ee5\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u3066\u30b3\u30fc\u30c9\u30b9\u30bf\u30a4\u30eb\u3092\u30c1\u30a7\u30c3\u30af\u3057\u3066\u304f\u3060\u3055\u3044\uff1a</p> <pre><code># \u30ea\u30f3\u30c6\u30a3\u30f3\u30b0\nruff check wandas tests\n\n# \u578b\u30c1\u30a7\u30c3\u30af\nmypy wandas tests\n</code></pre>"},{"location":"en/ja/contributing/#3","title":"3. \u30c6\u30b9\u30c8","text":"<p>\u65b0\u3057\u3044\u6a5f\u80fd\u3084\u30d0\u30b0\u4fee\u6b63\u306b\u306f\u3001\u5fc5\u305a\u30c6\u30b9\u30c8\u3092\u8ffd\u52a0\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u30c6\u30b9\u30c8\u306f<code>pytest</code>\u3092\u4f7f\u7528\u3057\u3066\u5b9f\u884c\u3057\u307e\u3059\uff1a</p> <pre><code>pytest\n</code></pre> <p>\u30ab\u30d0\u30ec\u30c3\u30b8\u30ec\u30dd\u30fc\u30c8\u3092\u751f\u6210\u3059\u308b\u306b\u306f\uff1a</p> <pre><code>pytest --cov=wandas tests/\n</code></pre>"},{"location":"en/ja/contributing/#4","title":"4. \u30c9\u30ad\u30e5\u30e1\u30f3\u30c8","text":"<p>\u30b3\u30fc\u30c9\u306e\u5909\u66f4\u306b\u306f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306e\u66f4\u65b0\u304c\u5fc5\u8981\u3067\u3059\uff1a</p> <ul> <li>\u95a2\u6570\u3084\u30af\u30e9\u30b9\u306b\u306fNumPy\u5f62\u5f0f\u306edocstring\u3092\u8a18\u8ff0</li> <li>\u65b0\u3057\u3044\u6a5f\u80fd\u306b\u3064\u3044\u3066\u306f\u3001\u9069\u5207\u306a\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u30da\u30fc\u30b8\uff08\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3001\u30cf\u30a6\u30c4\u30fc\u3001API\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\uff09\u3092\u66f4\u65b0\u307e\u305f\u306f\u8ffd\u52a0</li> <li>\u5fc5\u8981\u306b\u5fdc\u3058\u3066\u3001<code>examples/</code>\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3092\u8ffd\u52a0</li> </ul> <p>\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3092\u30d3\u30eb\u30c9\u3057\u3066\u78ba\u8a8d\u3059\u308b\u306b\u306f\uff1a</p> <pre><code>cd docs\nmkdocs serve\n</code></pre> <p>\u305d\u306e\u5f8c\u3001\u30d6\u30e9\u30a6\u30b6\u3067 http://localhost:8000 \u306b\u30a2\u30af\u30bb\u30b9\u3057\u3066\u78ba\u8a8d\u3067\u304d\u307e\u3059\u3002</p>"},{"location":"en/ja/contributing/#5","title":"5. \u30d7\u30eb\u30ea\u30af\u30a8\u30b9\u30c8\u306e\u4f5c\u6210","text":"<p>\u5909\u66f4\u304c\u5b8c\u4e86\u3057\u305f\u3089\u3001\u30d7\u30eb\u30ea\u30af\u30a8\u30b9\u30c8\uff08PR\uff09\u3092\u4f5c\u6210\u3057\u3066\u304f\u3060\u3055\u3044\uff1a</p> <ol> <li> <p>\u5909\u66f4\u3092\u30b3\u30df\u30c3\u30c8\u3057\u3001\u30ea\u30e2\u30fc\u30c8\u30ea\u30dd\u30b8\u30c8\u30ea\u306b\u30d7\u30c3\u30b7\u30e5    <pre><code>git add .\ngit commit -m \"\u8aac\u660e\u7684\u306a\u30b3\u30df\u30c3\u30c8\u30e1\u30c3\u30bb\u30fc\u30b8\"\ngit push origin your-branch-name\n</code></pre></p> </li> <li> <p>GitHub\u30ea\u30dd\u30b8\u30c8\u30ea\u30da\u30fc\u30b8\u3067\u30d7\u30eb\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u4f5c\u6210</p> </li> <li>PR\u306e\u8aac\u660e\u306b\u306f\u3001\u5909\u66f4\u5185\u5bb9\u3001\u89e3\u6c7a\u3057\u305f\u554f\u984c\u3001\u30c6\u30b9\u30c8\u65b9\u6cd5\u306a\u3069\u3092\u8a18\u8f09</li> </ol>"},{"location":"en/ja/contributing/#_5","title":"\u30ec\u30d3\u30e5\u30fc\u30d7\u30ed\u30bb\u30b9","text":"<p>\u3059\u3079\u3066\u306ePR\u306f\u4ee5\u4e0b\u306e\u30d7\u30ed\u30bb\u30b9\u3067\u30ec\u30d3\u30e5\u30fc\u3055\u308c\u307e\u3059\uff1a</p> <ol> <li>\u81ea\u52d5CI\u30c6\u30b9\u30c8\u304c\u6210\u529f\u3059\u308b\u3053\u3068</li> <li>\u5c11\u306a\u304f\u3068\u30821\u4eba\u306e\u30e1\u30f3\u30c6\u30ca\u306b\u3088\u308b\u30b3\u30fc\u30c9\u30ec\u30d3\u30e5\u30fc</li> <li>\u5fc5\u8981\u306b\u5fdc\u3058\u3066\u5909\u66f4\u306e\u4f9d\u983c\u3068\u5bfe\u5fdc</li> <li>\u30de\u30fc\u30b8\u627f\u8a8d</li> </ol>"},{"location":"en/ja/contributing/#_6","title":"\u30b3\u30df\u30e5\u30cb\u30b1\u30fc\u30b7\u30e7\u30f3","text":"<p>\u8cea\u554f\u3084\u8b70\u8ad6\u304c\u3042\u308c\u3070\u3001\u4ee5\u4e0b\u306e\u65b9\u6cd5\u3067\u30b3\u30df\u30e5\u30cb\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u53d6\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff1a</p> <ul> <li>GitHub Issues: \u30d0\u30b0\u5831\u544a\u3084\u6a5f\u80fd\u30ea\u30af\u30a8\u30b9\u30c8</li> <li>GitHub Discussions: \u4e00\u822c\u7684\u306a\u8cea\u554f\u3084\u8b70\u8ad6</li> <li>\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306e\u30e1\u30fc\u30ea\u30f3\u30b0\u30ea\u30b9\u30c8\uff08\u3042\u308b\u5834\u5408\uff09</li> </ul>"},{"location":"en/ja/contributing/#_7","title":"\u884c\u52d5\u898f\u7bc4","text":"<p>\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u53c2\u52a0\u3059\u308b\u3059\u3079\u3066\u306e\u4eba\u306f\u3001\u884c\u52d5\u898f\u7bc4\u306b\u5f93\u3046\u3053\u3068\u304c\u671f\u5f85\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u4ed6\u306e\u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30bf\u30fc\u306b\u5bfe\u3057\u3066\u656c\u610f\u3092\u6301\u3063\u3066\u63a5\u3057\u3001\u5354\u529b\u7684\u3067\u5efa\u8a2d\u7684\u306a\u30b3\u30df\u30e5\u30cb\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u5fc3\u304c\u3051\u3066\u304f\u3060\u3055\u3044\u3002</p>"},{"location":"en/ja/api/","title":"API\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9","text":"<p>\u3053\u306e\u30bb\u30af\u30b7\u30e7\u30f3\u3067\u306f\u3001Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u5168\u3066\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3001\u30af\u30e9\u30b9\u3001\u30e1\u30bd\u30c3\u30c9\u306e\u8a73\u7d30\u306a\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u304b\u3089\u81ea\u52d5\u7684\u306b\u751f\u6210\u3055\u308c\u305f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3092\u542b\u3093\u3067\u3044\u307e\u3059\u3002</p>"},{"location":"en/ja/api/#_1","title":"\u30b3\u30a2\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8","text":""},{"location":"en/ja/api/#baseframe","title":"BaseFrame","text":"<p><code>BaseFrame</code>\u30af\u30e9\u30b9\u306fWandas\u306e\u57fa\u672c\u5358\u4f4d\u3068\u306a\u308b\u30c7\u30fc\u30bf\u69cb\u9020\u3067\u3059\u3002</p> <pre><code>from wandas.core.base_frame import BaseFrame\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for all signal frame types.</p> <p>This class provides the common interface and functionality for all frame types used in signal processing. It implements basic operations like indexing, iteration, and data manipulation that are shared across all frame types.</p>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The signal data to process. Must be a dask array. sampling_rate : float     The sampling rate of the signal in Hz. label : str, optional     A label for the frame. If not provided, defaults to \"unnamed_frame\". metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame--attributes","title":"Attributes","text":"<p>sampling_rate : float     The sampling rate of the signal in Hz. label : str     The label of the frame. metadata : dict     Additional metadata for the frame. operation_history : list[dict]     History of operations performed on this frame.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>class BaseFrame(ABC, Generic[T]):\n    \"\"\"\n    Abstract base class for all signal frame types.\n\n    This class provides the common interface and functionality for all frame types\n    used in signal processing. It implements basic operations like indexing, iteration,\n    and data manipulation that are shared across all frame types.\n\n    Parameters\n    ----------\n    data : DaArray\n        The signal data to process. Must be a dask array.\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str, optional\n        A label for the frame. If not provided, defaults to \"unnamed_frame\".\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str\n        The label of the frame.\n    metadata : dict\n        Additional metadata for the frame.\n    operation_history : list[dict]\n        History of operations performed on this frame.\n    \"\"\"\n\n    _data: DaArray\n    sampling_rate: float\n    label: str\n    metadata: dict[str, Any]\n    operation_history: list[dict[str, Any]]\n    _channel_metadata: list[ChannelMetadata]\n    _previous: Optional[\"BaseFrame[Any]\"]\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ):\n        self._data = data.rechunk(chunks=-1)  # type: ignore [unused-ignore]\n        if self._data.ndim == 1:\n            self._data = self._data.reshape((1, -1))\n        self.sampling_rate = sampling_rate\n        self.label = label or \"unnamed_frame\"\n        self.metadata = metadata or {}\n        self.operation_history = operation_history or []\n        self._previous = previous\n\n        if channel_metadata:\n            self._channel_metadata = copy.deepcopy(channel_metadata)\n        else:\n            self._channel_metadata = [\n                ChannelMetadata(label=f\"ch{i}\", unit=\"\", extra={})\n                for i in range(self._n_channels)\n            ]\n\n        try:\n            # Display information for newer dask versions\n            logger.debug(f\"Dask graph layers: {list(self._data.dask.layers.keys())}\")\n            logger.debug(\n                f\"Dask graph dependencies: {len(self._data.dask.dependencies)}\"\n            )\n        except Exception as e:\n            logger.debug(f\"Dask graph visualization details unavailable: {e}\")\n\n    @property\n    @abstractmethod\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n\n    @property\n    def n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return len(self)\n\n    @property\n    def channels(self) -&gt; list[ChannelMetadata]:\n        \"\"\"Property to access channel metadata.\"\"\"\n        return self._channel_metadata\n\n    @property\n    def previous(self) -&gt; Optional[\"BaseFrame[Any]\"]:\n        \"\"\"\n        Returns the previous frame.\n        \"\"\"\n        return self._previous\n\n    def get_channel(self: S, channel_idx: int) -&gt; S:\n        n_channels = len(self)\n        if channel_idx &lt; 0 or channel_idx &gt;= n_channels:\n            range_max = n_channels - 1\n            raise ValueError(\n                f\"Channel index out of range: {channel_idx} \"\n                f\"(valid range: 0-{range_max})\"\n            )\n        logger.debug(f\"Extracting channel index={channel_idx} (lazy operation).\")\n        channel_data = self._data[channel_idx : channel_idx + 1]\n\n        return self._create_new_instance(\n            data=channel_data,\n            operation_history=self.operation_history,\n            channel_metadata=[self._channel_metadata[channel_idx]],\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Returns the number of channels.\n        \"\"\"\n        return len(self._channel_metadata)\n\n    def __iter__(self: S) -&gt; Iterator[S]:\n        for idx in range(len(self)):\n            yield self[idx]\n\n    def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n        \"\"\"\n        Method to get a channel by name or index.\n\n        Parameters\n        ----------\n        key : str, int, slice, or tuple of slices\n            Channel name (label) or index number.\n\n        Returns\n        -------\n        BaseFrame\n            The corresponding channel.\n\n        Raises\n        ------\n        ValueError\n            If the key length is invalid for the shape.\n        IndexError\n            If the channel index is out of range.\n        TypeError\n            If the key type is invalid.\n        \"\"\"\n        if isinstance(key, str):\n            index = self.label2index(key)\n            return self.get_channel(index)\n\n        elif isinstance(key, tuple):\n            # When key is a tuple, treat the first element as an index\n            if len(key) &gt; len(self.shape):\n                raise ValueError(\n                    f\"Invalid key length: {len(key)} for shape {self.shape}\"\n                )\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key[0]]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, slice):\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, numbers.Integral):\n            # Access by index number\n            if key &lt; 0 or key &gt;= len(self):\n                raise IndexError(f\"Channel index {key} out of range.\")\n            return self.get_channel(key)\n        else:\n            raise TypeError(\n                f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n            )\n\n    def label2index(self, label: str) -&gt; int:\n        \"\"\"\n        Get the index from a channel label.\n\n        Parameters\n        ----------\n        label : str\n            Channel label.\n\n        Returns\n        -------\n        int\n            Corresponding index.\n\n        Raises\n        ------\n        KeyError\n            If the channel label is not found.\n        \"\"\"\n        for idx, ch in enumerate(self._channel_metadata):\n            if ch.label == label:\n                return idx\n        raise KeyError(f\"Channel label '{label}' not found.\")\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        _shape: tuple[int, ...] = self._data.shape\n        return _shape\n\n    @property\n    def data(self) -&gt; T:\n        \"\"\"\n        Returns the computed data.\n        Calculation is executed the first time this is accessed.\n        \"\"\"\n        return self.compute()\n\n    @property\n    def labels(self) -&gt; list[str]:\n        \"\"\"Get a list of all channel labels.\"\"\"\n        return [ch.label for ch in self._channel_metadata]\n\n    def compute(self) -&gt; T:\n        \"\"\"\n        Compute and return the data.\n        This method materializes lazily computed data into a concrete NumPy array.\n\n        Returns\n        -------\n        NDArrayReal\n            The computed data.\n\n        Raises\n        ------\n        ValueError\n            If the computed result is not a NumPy array.\n        \"\"\"\n        logger.debug(\n            \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n        )\n        result = self._data.compute()\n\n        if not isinstance(result, np.ndarray):\n            raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n        logger.debug(f\"Computation complete, result shape: {result.shape}\")\n        return cast(T, result)\n\n    @abstractmethod\n    def plot(\n        self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n    ) -&gt; Union[Axes, Iterator[Axes]]:\n        \"\"\"Plot the data\"\"\"\n        pass\n\n    def persist(self: S) -&gt; S:\n        \"\"\"Persist the data in memory\"\"\"\n        persisted_data = self._data.persist()\n        return self._create_new_instance(data=persisted_data)\n\n    @abstractmethod\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Abstract method for derived classes to provide\n        additional initialization arguments.\n        \"\"\"\n        pass\n\n    def _create_new_instance(self: S, data: DaArray, **kwargs: Any) -&gt; S:\n        \"\"\"\n        Create a new channel instance based on an existing channel.\n        Keyword arguments can override or extend the original attributes.\n        \"\"\"\n\n        sampling_rate = kwargs.pop(\"sampling_rate\", self.sampling_rate)\n        # if not isinstance(sampling_rate, int):\n        #     raise TypeError(\"Sampling rate must be an integer\")\n\n        label = kwargs.pop(\"label\", self.label)\n        if not isinstance(label, str):\n            raise TypeError(\"Label must be a string\")\n\n        metadata = kwargs.pop(\"metadata\", copy.deepcopy(self.metadata))\n        if not isinstance(metadata, dict):\n            raise TypeError(\"Metadata must be a dictionary\")\n\n        # Get additional initialization arguments from derived classes\n        additional_kwargs = self._get_additional_init_kwargs()\n        kwargs.update(additional_kwargs)\n\n        return type(self)(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            previous=self,\n            **kwargs,\n        )\n\n    def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n        \"\"\"Implicit conversion to NumPy array\"\"\"\n        result = self.compute()\n        if dtype is not None:\n            return result.astype(dtype)\n        return result\n\n    def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n        \"\"\"Visualize the computation graph and save it to a file\"\"\"\n        try:\n            filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n            self._data.visualize(filename=filename)\n            return filename\n        except Exception as e:\n            logger.warning(f\"Failed to visualize the graph: {e}\")\n            return None\n\n    @abstractmethod\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"Basic implementation of binary operations\"\"\"\n        # Basic logic\n        # Actual implementation is left to derived classes\n        pass\n\n    def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Addition operator\"\"\"\n        return self._binary_op(other, lambda x, y: x + y, \"+\")\n\n    def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Subtraction operator\"\"\"\n        return self._binary_op(other, lambda x, y: x - y, \"-\")\n\n    def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Multiplication operator\"\"\"\n        return self._binary_op(other, lambda x, y: x * y, \"*\")\n\n    def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Division operator\"\"\"\n        return self._binary_op(other, lambda x, y: x / y, \"/\")\n\n    def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Apply a named operation.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters to pass to the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        # Apply the operation through abstract method\n        return self._apply_operation_impl(operation_name, **params)\n\n    @abstractmethod\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"Implementation of operation application\"\"\"\n        pass\n\n    def debug_info(self) -&gt; None:\n        \"\"\"Output detailed debug information\"\"\"\n        logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n        logger.debug(f\"Label: {self.label}\")\n        logger.debug(f\"Shape: {self.shape}\")\n        logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n        logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n        self._debug_info_impl()\n        logger.debug(\"=== End Debug Info ===\")\n\n    def _debug_info_impl(self) -&gt; None:\n        \"\"\"Implement derived class-specific debug information\"\"\"\n        pass\n</code></pre>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.channels","title":"<code>channels</code>  <code>property</code>","text":"<p>Property to access channel metadata.</p>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.data","title":"<code>data</code>  <code>property</code>","text":"<p>Returns the computed data. Calculation is executed the first time this is accessed.</p>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>Get a list of all channel labels.</p>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.n_channels","title":"<code>n_channels</code>  <code>property</code>","text":"<p>Returns the number of channels.</p>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.previous","title":"<code>previous</code>  <code>property</code>","text":"<p>Returns the previous frame.</p>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.__add__","title":"<code>__add__(other)</code>","text":"<p>Addition operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Addition operator\"\"\"\n    return self._binary_op(other, lambda x, y: x + y, \"+\")\n</code></pre>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.__array__","title":"<code>__array__(dtype=None)</code>","text":"<p>Implicit conversion to NumPy array</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n    \"\"\"Implicit conversion to NumPy array\"\"\"\n    result = self.compute()\n    if dtype is not None:\n        return result.astype(dtype)\n    return result\n</code></pre>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Method to get a channel by name or index.</p>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.__getitem__--parameters","title":"Parameters","text":"<p>key : str, int, slice, or tuple of slices     Channel name (label) or index number.</p>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.__getitem__--returns","title":"Returns","text":"<p>BaseFrame     The corresponding channel.</p>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.__getitem__--raises","title":"Raises","text":"<p>ValueError     If the key length is invalid for the shape. IndexError     If the channel index is out of range. TypeError     If the key type is invalid.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n    \"\"\"\n    Method to get a channel by name or index.\n\n    Parameters\n    ----------\n    key : str, int, slice, or tuple of slices\n        Channel name (label) or index number.\n\n    Returns\n    -------\n    BaseFrame\n        The corresponding channel.\n\n    Raises\n    ------\n    ValueError\n        If the key length is invalid for the shape.\n    IndexError\n        If the channel index is out of range.\n    TypeError\n        If the key type is invalid.\n    \"\"\"\n    if isinstance(key, str):\n        index = self.label2index(key)\n        return self.get_channel(index)\n\n    elif isinstance(key, tuple):\n        # When key is a tuple, treat the first element as an index\n        if len(key) &gt; len(self.shape):\n            raise ValueError(\n                f\"Invalid key length: {len(key)} for shape {self.shape}\"\n            )\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key[0]]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, slice):\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, numbers.Integral):\n        # Access by index number\n        if key &lt; 0 or key &gt;= len(self):\n            raise IndexError(f\"Channel index {key} out of range.\")\n        return self.get_channel(key)\n    else:\n        raise TypeError(\n            f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n        )\n</code></pre>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of channels.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of channels.\n    \"\"\"\n    return len(self._channel_metadata)\n</code></pre>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplication operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Multiplication operator\"\"\"\n    return self._binary_op(other, lambda x, y: x * y, \"*\")\n</code></pre>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtraction operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Subtraction operator\"\"\"\n    return self._binary_op(other, lambda x, y: x - y, \"-\")\n</code></pre>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Division operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Division operator\"\"\"\n    return self._binary_op(other, lambda x, y: x / y, \"/\")\n</code></pre>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.apply_operation","title":"<code>apply_operation(operation_name, **params)</code>","text":"<p>Apply a named operation.</p>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.apply_operation--parameters","title":"Parameters","text":"<p>operation_name : str     Name of the operation to apply. **params : Any     Parameters to pass to the operation.</p>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.apply_operation--returns","title":"Returns","text":"<p>S     A new instance with the operation applied.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n    \"\"\"\n    Apply a named operation.\n\n    Parameters\n    ----------\n    operation_name : str\n        Name of the operation to apply.\n    **params : Any\n        Parameters to pass to the operation.\n\n    Returns\n    -------\n    S\n        A new instance with the operation applied.\n    \"\"\"\n    # Apply the operation through abstract method\n    return self._apply_operation_impl(operation_name, **params)\n</code></pre>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.compute","title":"<code>compute()</code>","text":"<p>Compute and return the data. This method materializes lazily computed data into a concrete NumPy array.</p>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.compute--returns","title":"Returns","text":"<p>NDArrayReal     The computed data.</p>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.compute--raises","title":"Raises","text":"<p>ValueError     If the computed result is not a NumPy array.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def compute(self) -&gt; T:\n    \"\"\"\n    Compute and return the data.\n    This method materializes lazily computed data into a concrete NumPy array.\n\n    Returns\n    -------\n    NDArrayReal\n        The computed data.\n\n    Raises\n    ------\n    ValueError\n        If the computed result is not a NumPy array.\n    \"\"\"\n    logger.debug(\n        \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n    )\n    result = self._data.compute()\n\n    if not isinstance(result, np.ndarray):\n        raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n    logger.debug(f\"Computation complete, result shape: {result.shape}\")\n    return cast(T, result)\n</code></pre>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.debug_info","title":"<code>debug_info()</code>","text":"<p>Output detailed debug information</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def debug_info(self) -&gt; None:\n    \"\"\"Output detailed debug information\"\"\"\n    logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n    logger.debug(f\"Label: {self.label}\")\n    logger.debug(f\"Shape: {self.shape}\")\n    logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n    logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n    self._debug_info_impl()\n    logger.debug(\"=== End Debug Info ===\")\n</code></pre>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.label2index","title":"<code>label2index(label)</code>","text":"<p>Get the index from a channel label.</p>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.label2index--parameters","title":"Parameters","text":"<p>label : str     Channel label.</p>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.label2index--returns","title":"Returns","text":"<p>int     Corresponding index.</p>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.label2index--raises","title":"Raises","text":"<p>KeyError     If the channel label is not found.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def label2index(self, label: str) -&gt; int:\n    \"\"\"\n    Get the index from a channel label.\n\n    Parameters\n    ----------\n    label : str\n        Channel label.\n\n    Returns\n    -------\n    int\n        Corresponding index.\n\n    Raises\n    ------\n    KeyError\n        If the channel label is not found.\n    \"\"\"\n    for idx, ch in enumerate(self._channel_metadata):\n        if ch.label == label:\n            return idx\n    raise KeyError(f\"Channel label '{label}' not found.\")\n</code></pre>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.persist","title":"<code>persist()</code>","text":"<p>Persist the data in memory</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def persist(self: S) -&gt; S:\n    \"\"\"Persist the data in memory\"\"\"\n    persisted_data = self._data.persist()\n    return self._create_new_instance(data=persisted_data)\n</code></pre>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.plot","title":"<code>plot(plot_type='default', ax=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Plot the data</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>@abstractmethod\ndef plot(\n    self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n) -&gt; Union[Axes, Iterator[Axes]]:\n    \"\"\"Plot the data\"\"\"\n    pass\n</code></pre>"},{"location":"en/ja/api/#wandas.core.base_frame.BaseFrame.visualize_graph","title":"<code>visualize_graph(filename=None)</code>","text":"<p>Visualize the computation graph and save it to a file</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"Visualize the computation graph and save it to a file\"\"\"\n    try:\n        filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n        self._data.visualize(filename=filename)\n        return filename\n    except Exception as e:\n        logger.warning(f\"Failed to visualize the graph: {e}\")\n        return None\n</code></pre>"},{"location":"en/ja/api/#_2","title":"\u30d5\u30ec\u30fc\u30e0\u30e2\u30b8\u30e5\u30fc\u30eb","text":""},{"location":"en/ja/api/#channelframe","title":"ChannelFrame","text":"<p><code>ChannelFrame</code>\u306f\u6642\u9593\u9818\u57df\u306e\u4fe1\u53f7\u30c7\u30fc\u30bf\u3092\u6271\u3046\u30af\u30e9\u30b9\u3067\u3059\u3002</p> <pre><code>from wandas.frames.channel import ChannelFrame\n</code></pre> <p>\u307e\u305f\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u76f4\u63a5\u30a4\u30f3\u30dd\u30fc\u30c8\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059\uff1a</p> <pre><code>import wandas\n# \u4ee5\u4e0b\u306e\u3088\u3046\u306b\u4f7f\u7528\u3067\u304d\u307e\u3059\nframe = wandas.read_wav(\"audio.wav\")\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Channel-based data frame for handling audio signals and time series data.</p> <p>This frame represents channel-based data such as audio signals and time series data, with each channel containing data samples in the time domain.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>class ChannelFrame(BaseFrame[NDArrayReal]):\n    \"\"\"Channel-based data frame for handling audio signals and time series data.\n\n    This frame represents channel-based data such as audio signals and time series data,\n    with each channel containing data samples in the time domain.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"Initialize a ChannelFrame.\n\n        Args:\n            data: Dask array containing channel data.\n            Shape should be (n_channels, n_samples).\n            sampling_rate: The sampling rate of the data in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            operation_history: History of operations applied to the frame.\n            channel_metadata: Metadata for each channel.\n            previous: Reference to the previous frame in the processing chain.\n\n        Raises:\n            ValueError: If data has more than 2 dimensions.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return self.shape[-2]\n\n    @property\n    def time(self) -&gt; NDArrayReal:\n        \"\"\"Get time array for the signal.\n\n        Returns:\n            Array of time points in seconds.\n        \"\"\"\n        return np.arange(self.n_samples) / self.sampling_rate\n\n    @property\n    def n_samples(self) -&gt; int:\n        \"\"\"Returns the number of samples.\"\"\"\n        n: int = self._data.shape[-1]\n        return n\n\n    @property\n    def duration(self) -&gt; float:\n        \"\"\"Returns the duration in seconds.\"\"\"\n        return self.n_samples / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # Apply processing to data\n        processed_data = operation.process(self._data)\n\n        # Update metadata\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        if operation_name == \"resampling\":\n            # For resampling, update sampling rate\n            return self._create_new_instance(\n                sampling_rate=params[\"target_sr\"],\n                data=processed_data,\n                metadata=new_metadata,\n                operation_history=new_history,\n            )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Common implementation for binary operations\n        - utilizing dask's lazy evaluation.\n\n        Args:\n            other: Right operand for the operation.\n            op: Function to execute the operation (e.g., lambda a, b: a + b).\n            symbol: Symbolic representation of the operation (e.g., '+').\n\n        Returns:\n            A new channel containing the operation result (lazy execution).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, ChannelFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Perform operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other._data)\n\n            # Merge channel metadata\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # Perform operation with scalar, NumPy array, or other types\n        else:\n            # Apply operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other)\n\n            # Operand display string\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # Check for dask.array.Array\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # Update channel metadata\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n                previous=self,\n            )\n\n    def add(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        snr: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Add another signal or value to the current signal.\n\n        If SNR is specified, performs addition with consideration for\n        signal-to-noise ratio.\n\n        Args:\n            other: Signal or value to add.\n            snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n                other signal based on this SNR.\n                self is treated as the signal, and other as the noise.\n\n        Returns:\n            A new channel frame containing the addition result (lazy execution).\n        \"\"\"\n        logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n        # Special processing when SNR is specified\n        if snr is not None:\n            # First convert other to ChannelFrame if it's not\n            if not isinstance(other, ChannelFrame):\n                if isinstance(other, np.ndarray):\n                    other = ChannelFrame.from_numpy(\n                        other, self.sampling_rate, label=\"array_data\"\n                    )\n                elif isinstance(other, (int, float)):\n                    # For scalar values, simply add (ignore SNR)\n                    return self + other\n                else:\n                    raise TypeError(\n                        \"Addition target with SNR must be a ChannelFrame or \"\n                        f\"NumPy array: {type(other)}\"\n                    )\n\n            # Check if sampling rates match\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Apply addition operation with SNR adjustment\n            return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n        # Execute normal addition if SNR is not specified\n        return self + other\n\n    def plot(\n        self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Plot the frame data.\n\n        Args:\n            plot_type: Type of plot. Default is \"waveform\".\n            ax: Optional matplotlib axes for plotting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        plot_strategy = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def rms_plot(\n        self,\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = True,\n        Aw: bool = False,  # noqa: N803\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Generate an RMS plot.\n\n        Args:\n            ax: Optional matplotlib axes for plotting.\n            title: Title for the plot.\n            overlay: Whether to overlay the plot on the existing axis.\n            Aw: Apply A-weighting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        kwargs = kwargs or {}\n        ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n        rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n        return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n\n    def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n        \"\"\"Display visual and audio representation of the frame.\n\n        Args:\n            normalize: Whether to normalize the audio data for playback.\n            **kwargs: Additional parameters for visualization.\n        \"\"\"\n        if \"axis_config\" in kwargs:\n            logger.warning(\n                \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            axis_config = kwargs[\"axis_config\"]\n            if \"time_plot\" in axis_config:\n                kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n            if \"freq_plot\" in axis_config:\n                if \"xlim\" in axis_config[\"freq_plot\"]:\n                    vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                    kwargs[\"vmin\"] = vlim[0]\n                    kwargs[\"vmax\"] = vlim[1]\n                if \"ylim\" in axis_config[\"freq_plot\"]:\n                    ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                    kwargs[\"ylim\"] = ylim\n\n        if \"cbar_config\" in kwargs:\n            logger.warning(\n                \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            cbar_config = kwargs[\"cbar_config\"]\n            if \"vmin\" in cbar_config:\n                kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n            if \"vmax\" in cbar_config:\n                kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n        for ch in self:\n            ax: Axes\n            _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n            if isinstance(_ax, Iterator):\n                ax = next(iter(_ax))\n            elif isinstance(_ax, Axes):\n                ax = _ax\n            else:\n                raise TypeError(\n                    f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n                )\n            # Ignore type checks for display and Audio\n            display(ax.figure)  # type: ignore\n            plt.close(ax.figure)  # type: ignore\n            display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n\n    @classmethod\n    def from_numpy(\n        cls,\n        data: NDArrayReal,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        ch_labels: Optional[list[str]] = None,\n        ch_units: Optional[Union[list[str], str]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        Args:\n            data: NumPy array containing channel data.\n            sampling_rate: The sampling rate in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            ch_labels: Labels for each channel.\n            ch_units: Units for each channel.\n\n        Returns:\n            A new ChannelFrame containing the NumPy data.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n\n        # Convert NumPy array to dask array\n        dask_data = da_from_array(data)\n        cf = ChannelFrame(\n            data=dask_data,\n            sampling_rate=sampling_rate,\n            label=label or \"numpy_data\",\n        )\n        if metadata is not None:\n            cf.metadata = metadata\n        if ch_labels is not None:\n            if len(ch_labels) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel labels does not match the number of channels\"\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        if ch_units is not None:\n            if isinstance(ch_units, str):\n                ch_units = [ch_units] * cf.n_channels\n\n            if len(ch_units) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel units does not match the number of channels\"\n                )\n            for i in range(len(ch_units)):\n                cf._channel_metadata[i].unit = ch_units[i]\n\n        return cf\n\n    @classmethod\n    def from_ndarray(\n        cls,\n        array: NDArrayReal,\n        sampling_rate: float,\n        labels: Optional[list[str]] = None,\n        unit: Optional[Union[list[str], str]] = None,\n        frame_label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        This method is deprecated. Use from_numpy instead.\n\n        Args:\n            array: Signal data. Each row corresponds to a channel.\n            sampling_rate: Sampling rate (Hz).\n            labels: Labels for each channel.\n            unit: Unit of the signal.\n            frame_label: Label for the frame.\n            metadata: Optional metadata dictionary.\n\n        Returns:\n            A new ChannelFrame containing the data.\n        \"\"\"\n        # Redirect to from_numpy for compatibility\n        # However, from_ndarray is deprecated\n        logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n        return cls.from_numpy(\n            data=array,\n            sampling_rate=sampling_rate,\n            label=frame_label,\n            metadata=metadata,\n            ch_labels=labels,\n            ch_units=unit,\n        )\n\n    @classmethod\n    def from_file(\n        cls,\n        path: Union[str, Path],\n        channel: Optional[Union[int, list[int]]] = None,\n        start: Optional[float] = None,\n        end: Optional[float] = None,\n        chunk_size: Optional[int] = None,\n        ch_labels: Optional[list[str]] = None,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from an audio file.\n\n        Args:\n            path: Path to the audio file.\n            channel: Channel(s) to load.\n            start: Start time in seconds.\n            end: End time in seconds.\n            chunk_size: Chunk size for processing.\n            Specifies the splitting size for lazy processing.\n            ch_labels: Labels for each channel.\n            **kwargs: Additional arguments passed to the file reader.\n\n        Returns:\n            A new ChannelFrame containing the loaded audio data.\n\n        Raises:\n            ValueError: If channel selection is invalid.\n            TypeError: If channel parameter type is invalid.\n            FileNotFoundError: If the file doesn't exist.\n        \"\"\"\n        from .channel import ChannelFrame\n\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"File not found: {path}\")\n\n        # Get file reader\n        reader = get_file_reader(path)\n\n        # Get file info\n        info = reader.get_file_info(path, **kwargs)\n        sr = info[\"samplerate\"]\n        n_channels = info[\"channels\"]\n        n_frames = info[\"frames\"]\n        ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n        logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n        # Channel selection processing\n        all_channels = list(range(n_channels))\n\n        if channel is None:\n            channels_to_load = all_channels\n            logger.debug(f\"Will load all channels: {channels_to_load}\")\n        elif isinstance(channel, int):\n            if channel &lt; 0 or channel &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n            channels_to_load = [channel]\n            logger.debug(f\"Will load single channel: {channel}\")\n        elif isinstance(channel, (list, tuple)):\n            for ch in channel:\n                if ch &lt; 0 or ch &gt;= n_channels:\n                    raise ValueError(\n                        f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                    )\n            channels_to_load = list(channel)\n            logger.debug(f\"Will load specific channels: {channels_to_load}\")\n        else:\n            raise TypeError(\"channel must be int, list, or None\")\n\n        # Index calculation\n        start_idx = 0 if start is None else max(0, int(start * sr))\n        end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n        frames_to_read = end_idx - start_idx\n\n        logger.debug(\n            f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n            f\"start_idx={start_idx}, end_idx={end_idx}\"\n        )\n\n        # Settings for lazy loading\n        expected_shape = (len(channels_to_load), frames_to_read)\n\n        # Define the loading function using the file reader\n        def _load_audio() -&gt; NDArrayReal:\n            logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n            # Use the reader to get audio data with parameters\n            out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n            if not isinstance(out, np.ndarray):\n                raise ValueError(\"Unexpected data type after reading file\")\n            return out\n\n        logger.debug(\n            f\"Creating delayed dask task with expected shape: {expected_shape}\"\n        )\n\n        # Create delayed operation\n        delayed_data = dask_delayed(_load_audio)()\n        logger.debug(\"Wrapping delayed function in dask array\")\n\n        # Create dask array from delayed computation\n        dask_array = da_from_delayed(\n            delayed_data, shape=expected_shape, dtype=np.float32\n        )\n\n        if chunk_size is not None:\n            if chunk_size &lt;= 0:\n                raise ValueError(\"Chunk size must be a positive integer\")\n            logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n            dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n        logger.debug(\n            \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n        )\n\n        cf = ChannelFrame(\n            data=dask_array,\n            sampling_rate=sr,\n            label=path.stem,\n            metadata={\n                \"filename\": str(path),\n            },\n        )\n        if ch_labels is not None:\n            if len(ch_labels) != len(cf):\n                raise ValueError(\n                    \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        return cf\n\n    @classmethod\n    def read_wav(\n        cls, filename: str, labels: Optional[list[str]] = None\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a WAV file.\n\n        Args:\n            filename: Path to the WAV file.\n            labels: Labels to set for each channel.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(filename, ch_labels=labels)\n        return cf\n\n    @classmethod\n    def read_csv(\n        cls,\n        filename: str,\n        time_column: Union[int, str] = 0,\n        labels: Optional[list[str]] = None,\n        delimiter: str = \",\",\n        header: Optional[int] = 0,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a CSV file.\n\n        Args:\n            filename: Path to the CSV file.\n            time_column: Index or name of the time column.\n            labels: Labels to set for each channel.\n            delimiter: Delimiter character.\n            header: Row number to use as header.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(\n            filename,\n            ch_labels=labels,\n            time_column=time_column,\n            delimiter=delimiter,\n            header=header,\n        )\n        return cf\n\n    def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n        \"\"\"Save the audio data to a file.\n\n        Args:\n            path: Path to save the file.\n            format: File format. If None, determined from file extension.\n        \"\"\"\n        logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n        data = self.compute()\n        data = data.T\n        if data.shape[1] == 1:\n            data = data.squeeze(axis=1)\n        sf.write(str(path), data, int(self.sampling_rate), format=format)\n        logger.debug(f\"Save complete: {path}\")\n\n    def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a high-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n\n    def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a low-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n\n    def normalize(\n        self, target_level: float = -20, channel_wise: bool = True\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Normalize the signal level.\n\n        This method adjusts the signal amplitude to reach a target RMS level.\n\n        Args:\n            target_level: Target RMS level in dB. Default is -20.\n            channel_wise: If True, normalize each channel independently.\n                If False, apply the same scaling to all channels.\n\n        Returns:\n            A new ChannelFrame containing the normalized signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n        )\n        return self.apply_operation(\n            \"normalize\", target_level=target_level, channel_wise=channel_wise\n        )\n\n    def a_weighting(self) -&gt; \"ChannelFrame\":\n        \"\"\"Apply A-weighting filter to the signal.\n\n        A-weighting adjusts the frequency response to approximate human hearing\n        perception, following IEC 61672-1:2013 standard.\n\n        Returns:\n            A new ChannelFrame with A-weighted signal.\n        \"\"\"\n        return self.apply_operation(\"a_weighting\")\n\n    def hpss_harmonic(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract harmonic components using HPSS\n         (Harmonic-Percussive Source Separation).\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_harmonic\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def hpss_percussive(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract percussive components using HPSS\n        (Harmonic-Percussive Source Separation).\n\n        This method separates the percussive (tonal) components from the signal.\n\n        Args:\n            kernel_size: Median filter size for HPSS.\n            power: Exponent for the Weiner filter used in HPSS.\n            margin: Margin size for the separation.\n\n        Returns:\n            A new ChannelFrame containing the harmonic components.\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_percussive\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def resampling(\n        self,\n        target_sr: float,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Resample audio data.\n\n        Parameters\n        ----------\n        target_sr : float\n            Target sampling rate (Hz)\n        resample_type : str, optional\n            Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n        **kwargs : dict\n            Additional resampling parameters\n\n        Returns\n        -------\n        ChannelFrame\n            Resampled channel frame\n        \"\"\"\n        return self.apply_operation(\n            \"resampling\",\n            target_sr=target_sr,\n            **kwargs,\n        )\n\n    def abs(self) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the absolute value of the signal.\n\n        Returns:\n            A new ChannelFrame containing the absolute values.\n        \"\"\"\n        return self.apply_operation(\"abs\")\n\n    def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the power of the signal.\n\n        Args:\n            exponent: The exponent to raise the signal to. Default is 2.0.\n\n        Returns:\n            A new ChannelFrame containing the signal raised to the power.\n        \"\"\"\n        return self.apply_operation(\"power\", exponent=exponent)\n\n    def trim(\n        self,\n        start: float = 0,\n        end: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Trim the signal to specified time range.\n\n        Args:\n            start: Start time in seconds.\n            end: End time in seconds.\n\n        Returns:\n            A new ChannelFrame with trimmed signal.\n\n        Raises:\n            ValueError: If end time is before start time.\n        \"\"\"\n        if end is None:\n            end = self.duration\n        if start &gt; end:\n            raise ValueError(\"start must be less than end\")\n        # Apply trim operation\n        return self.apply_operation(\"trim\", start=start, end=end)\n\n    def rms_trend(\n        self,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the RMS trend of the signal.\n\n        This method computes the root mean square value over sliding windows.\n\n        Args:\n            frame_length: The size of the sliding window in samples. Default is 2048.\n            hop_length: The hop length between windows in samples. Default is 512.\n            dB: Whether to return the RMS values in decibels. Default is False.\n            Aw: Whether to apply A-weighting. Default is False.\n\n        Returns:\n            A new ChannelFrame containing the RMS trend.\n        \"\"\"\n        cf = self.apply_operation(\n            \"rms_trend\",\n            frame_length=frame_length,\n            hop_length=hop_length,\n            ref=[ch.ref for ch in self._channel_metadata],\n            dB=dB,\n            Aw=Aw,\n        )\n        cf.sampling_rate = self.sampling_rate / hop_length\n        return cf\n\n    def sum(self) -&gt; \"ChannelFrame\":\n        \"\"\"Sum all channels.\n\n        Returns:\n            A new ChannelFrame with summed signal.\n        \"\"\"\n        return self.apply_operation(\"sum\")\n\n    def mean(self) -&gt; \"ChannelFrame\":\n        \"\"\"Average all channels.\n\n        Returns:\n            A new ChannelFrame with averaged signal.\n        \"\"\"\n        return self.apply_operation(\"mean\")\n\n    def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate channel differences relative to a reference channel.\n\n        Args:\n            other_channel: Reference channel index or label. Default is 0.\n\n        Returns:\n            A new ChannelFrame with channel differences.\n        \"\"\"\n        if isinstance(other_channel, str):\n            return self.apply_operation(\n                \"channel_difference\", other_channel=self.label2index(other_channel)\n            )\n        return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n\n    def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n        \"\"\"Compute Fast Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is next power of 2 of data length.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectralFrame containing the FFT results.\n        \"\"\"\n        from ..processing.time_series import FFT\n        from .spectral import SpectralFrame\n\n        params = {\"n_fft\": n_fft, \"window\": window}\n        operation_name = \"fft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"FFT\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        if n_fft is None:\n            is_even = spectrum_data.shape[-1] % 2 == 0\n            _n_fft = (\n                spectrum_data.shape[-1] * 2 - 2\n                if is_even\n                else spectrum_data.shape[-1] * 2 - 1\n            )\n        else:\n            _n_fft = n_fft\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=_n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def welch(\n        self,\n        n_fft: Optional[int] = None,\n        hop_length: Optional[int] = None,\n        win_length: int = 2048,\n        window: str = \"hann\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute power spectral density using Welch's method.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the power spectral density.\n        \"\"\"\n        from ..processing.time_series import Welch\n        from .spectral import SpectralFrame\n\n        params = dict(\n            n_fft=n_fft or win_length,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            average=average,\n        )\n        operation_name = \"welch\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Welch\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"welch\", \"params\": params},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def noct_spectrum(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"Compute N-octave band spectrum.\n\n        Args:\n            fmin: Minimum center frequency in Hz. Default is 20 Hz.\n            fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n            n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n            G: Reference gain in dB. Default is 10 dB.\n            fr: Reference frequency in Hz. Default is 1000 Hz.\n\n        Returns:\n            A NOctFrame containing the N-octave band spectrum.\n        \"\"\"\n        from ..processing.time_series import NOctSpectrum\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_spectrum\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSpectrum\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_spectrum\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def stft(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"Compute Short-Time Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectrogramFrame containing the STFT results.\n        \"\"\"\n        from ..processing.time_series import STFT, create_operation\n        from .spectrogram import SpectrogramFrame\n\n        # Set hop length and window length\n        _hop_length = hop_length if hop_length is not None else n_fft // 4\n        _win_length = win_length if win_length is not None else n_fft\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": _hop_length,\n            \"win_length\": _win_length,\n            \"window\": window,\n        }\n        operation_name = \"stft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"STFT\", operation)\n\n        # Apply processing to data\n        spectrogram_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n\n        # Create new instance\n        return SpectrogramFrame(\n            data=spectrogram_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=n_fft,\n            hop_length=_hop_length,\n            win_length=_win_length,\n            window=window,\n            label=f\"stft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def coherence(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute magnitude squared coherence.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n        Returns:\n            A SpectralFrame containing the magnitude squared coherence.\n        \"\"\"\n        from ..processing.time_series import Coherence, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n        }\n        operation_name = \"coherence\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Coherence\", operation)\n\n        # Apply processing to data\n        coherence_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=coherence_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Coherence of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def csd(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute cross-spectral density matrix.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the cross-spectral density matrix.\n        \"\"\"\n        from ..processing.time_series import CSD, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"csd\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"CSD\", operation)\n\n        # Apply processing to data\n        csd_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=csd_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def transfer_function(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute transfer function matrix.\n\n        The transfer function characterizes the signal transmission properties\n        between channels in the frequency domain, representing the input-output\n        relationship of a system.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the transfer function matrix.\n        \"\"\"\n        from ..processing.time_series import TransferFunction, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"transfer_function\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"TransferFunction\", operation)\n\n        # Apply processing to data\n        tf_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=tf_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Transfer function of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"Provide additional initialization arguments required for ChannelFrame.\"\"\"\n        return {}\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Returns the duration in seconds.</p>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>Returns the number of samples.</p>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.time","title":"<code>time</code>  <code>property</code>","text":"<p>Get time array for the signal.</p> <p>Returns:</p> Type Description <code>NDArrayReal</code> <p>Array of time points in seconds.</p>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.__init__","title":"<code>__init__(data, sampling_rate, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a ChannelFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>Dask array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate of the data in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>operation_history</code> <code>Optional[list[dict[str, Any]]]</code> <p>History of operations applied to the frame.</p> <code>None</code> <code>channel_metadata</code> <code>Optional[list[ChannelMetadata]]</code> <p>Metadata for each channel.</p> <code>None</code> <code>previous</code> <code>Optional[BaseFrame[Any]]</code> <p>Reference to the previous frame in the processing chain.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has more than 2 dimensions.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"Initialize a ChannelFrame.\n\n    Args:\n        data: Dask array containing channel data.\n        Shape should be (n_channels, n_samples).\n        sampling_rate: The sampling rate of the data in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        operation_history: History of operations applied to the frame.\n        channel_metadata: Metadata for each channel.\n        previous: Reference to the previous frame in the processing chain.\n\n    Raises:\n        ValueError: If data has more than 2 dimensions.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.a_weighting","title":"<code>a_weighting()</code>","text":"<p>Apply A-weighting filter to the signal.</p> <p>A-weighting adjusts the frequency response to approximate human hearing perception, following IEC 61672-1:2013 standard.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with A-weighted signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def a_weighting(self) -&gt; \"ChannelFrame\":\n    \"\"\"Apply A-weighting filter to the signal.\n\n    A-weighting adjusts the frequency response to approximate human hearing\n    perception, following IEC 61672-1:2013 standard.\n\n    Returns:\n        A new ChannelFrame with A-weighted signal.\n    \"\"\"\n    return self.apply_operation(\"a_weighting\")\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.abs","title":"<code>abs()</code>","text":"<p>Calculate the absolute value of the signal.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the absolute values.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def abs(self) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the absolute value of the signal.\n\n    Returns:\n        A new ChannelFrame containing the absolute values.\n    \"\"\"\n    return self.apply_operation(\"abs\")\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.add","title":"<code>add(other, snr=None)</code>","text":"<p>Add another signal or value to the current signal.</p> <p>If SNR is specified, performs addition with consideration for signal-to-noise ratio.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[ChannelFrame, int, float, NDArrayReal, Array]</code> <p>Signal or value to add.</p> required <code>snr</code> <code>Optional[float]</code> <p>Signal-to-noise ratio (dB). If specified, adjusts the scale of the other signal based on this SNR. self is treated as the signal, and other as the noise.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new channel frame containing the addition result (lazy execution).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def add(\n    self,\n    other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n    snr: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Add another signal or value to the current signal.\n\n    If SNR is specified, performs addition with consideration for\n    signal-to-noise ratio.\n\n    Args:\n        other: Signal or value to add.\n        snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n            other signal based on this SNR.\n            self is treated as the signal, and other as the noise.\n\n    Returns:\n        A new channel frame containing the addition result (lazy execution).\n    \"\"\"\n    logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n    # Special processing when SNR is specified\n    if snr is not None:\n        # First convert other to ChannelFrame if it's not\n        if not isinstance(other, ChannelFrame):\n            if isinstance(other, np.ndarray):\n                other = ChannelFrame.from_numpy(\n                    other, self.sampling_rate, label=\"array_data\"\n                )\n            elif isinstance(other, (int, float)):\n                # For scalar values, simply add (ignore SNR)\n                return self + other\n            else:\n                raise TypeError(\n                    \"Addition target with SNR must be a ChannelFrame or \"\n                    f\"NumPy array: {type(other)}\"\n                )\n\n        # Check if sampling rates match\n        if self.sampling_rate != other.sampling_rate:\n            raise ValueError(\n                \"Sampling rates do not match. Cannot perform operation.\"\n            )\n\n        # Apply addition operation with SNR adjustment\n        return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n    # Execute normal addition if SNR is not specified\n    return self + other\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.channel_difference","title":"<code>channel_difference(other_channel=0)</code>","text":"<p>Calculate channel differences relative to a reference channel.</p> <p>Parameters:</p> Name Type Description Default <code>other_channel</code> <code>Union[int, str]</code> <p>Reference channel index or label. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with channel differences.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate channel differences relative to a reference channel.\n\n    Args:\n        other_channel: Reference channel index or label. Default is 0.\n\n    Returns:\n        A new ChannelFrame with channel differences.\n    \"\"\"\n    if isinstance(other_channel, str):\n        return self.apply_operation(\n            \"channel_difference\", other_channel=self.label2index(other_channel)\n        )\n    return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.coherence","title":"<code>coherence(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant')</code>","text":"<p>Compute magnitude squared coherence.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the magnitude squared coherence.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def coherence(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute magnitude squared coherence.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n    Returns:\n        A SpectralFrame containing the magnitude squared coherence.\n    \"\"\"\n    from ..processing.time_series import Coherence, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n    }\n    operation_name = \"coherence\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Coherence\", operation)\n\n    # Apply processing to data\n    coherence_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=coherence_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Coherence of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.csd","title":"<code>csd(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute cross-spectral density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the cross-spectral density matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def csd(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute cross-spectral density matrix.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the cross-spectral density matrix.\n    \"\"\"\n    from ..processing.time_series import CSD, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"csd\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"CSD\", operation)\n\n    # Apply processing to data\n    csd_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=csd_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.describe","title":"<code>describe(normalize=True, **kwargs)</code>","text":"<p>Display visual and audio representation of the frame.</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>Whether to normalize the audio data for playback.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for visualization.</p> <code>{}</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n    \"\"\"Display visual and audio representation of the frame.\n\n    Args:\n        normalize: Whether to normalize the audio data for playback.\n        **kwargs: Additional parameters for visualization.\n    \"\"\"\n    if \"axis_config\" in kwargs:\n        logger.warning(\n            \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        axis_config = kwargs[\"axis_config\"]\n        if \"time_plot\" in axis_config:\n            kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n        if \"freq_plot\" in axis_config:\n            if \"xlim\" in axis_config[\"freq_plot\"]:\n                vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                kwargs[\"vmin\"] = vlim[0]\n                kwargs[\"vmax\"] = vlim[1]\n            if \"ylim\" in axis_config[\"freq_plot\"]:\n                ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                kwargs[\"ylim\"] = ylim\n\n    if \"cbar_config\" in kwargs:\n        logger.warning(\n            \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        cbar_config = kwargs[\"cbar_config\"]\n        if \"vmin\" in cbar_config:\n            kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n        if \"vmax\" in cbar_config:\n            kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n    for ch in self:\n        ax: Axes\n        _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n        if isinstance(_ax, Iterator):\n            ax = next(iter(_ax))\n        elif isinstance(_ax, Axes):\n            ax = _ax\n        else:\n            raise TypeError(\n                f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n            )\n        # Ignore type checks for display and Audio\n        display(ax.figure)  # type: ignore\n        plt.close(ax.figure)  # type: ignore\n        display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.fft","title":"<code>fft(n_fft=None, window='hann')</code>","text":"<p>Compute Fast Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is next power of 2 of data length.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the FFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n    \"\"\"Compute Fast Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is next power of 2 of data length.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectralFrame containing the FFT results.\n    \"\"\"\n    from ..processing.time_series import FFT\n    from .spectral import SpectralFrame\n\n    params = {\"n_fft\": n_fft, \"window\": window}\n    operation_name = \"fft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"FFT\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    if n_fft is None:\n        is_even = spectrum_data.shape[-1] % 2 == 0\n        _n_fft = (\n            spectrum_data.shape[-1] * 2 - 2\n            if is_even\n            else spectrum_data.shape[-1] * 2 - 1\n        )\n    else:\n        _n_fft = n_fft\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=_n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.from_file","title":"<code>from_file(path, channel=None, start=None, end=None, chunk_size=None, ch_labels=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from an audio file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the audio file.</p> required <code>channel</code> <code>Optional[Union[int, list[int]]]</code> <p>Channel(s) to load.</p> <code>None</code> <code>start</code> <code>Optional[float]</code> <p>Start time in seconds.</p> <code>None</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <code>chunk_size</code> <code>Optional[int]</code> <p>Chunk size for processing.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the file reader.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the loaded audio data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If channel selection is invalid.</p> <code>TypeError</code> <p>If channel parameter type is invalid.</p> <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    path: Union[str, Path],\n    channel: Optional[Union[int, list[int]]] = None,\n    start: Optional[float] = None,\n    end: Optional[float] = None,\n    chunk_size: Optional[int] = None,\n    ch_labels: Optional[list[str]] = None,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from an audio file.\n\n    Args:\n        path: Path to the audio file.\n        channel: Channel(s) to load.\n        start: Start time in seconds.\n        end: End time in seconds.\n        chunk_size: Chunk size for processing.\n        Specifies the splitting size for lazy processing.\n        ch_labels: Labels for each channel.\n        **kwargs: Additional arguments passed to the file reader.\n\n    Returns:\n        A new ChannelFrame containing the loaded audio data.\n\n    Raises:\n        ValueError: If channel selection is invalid.\n        TypeError: If channel parameter type is invalid.\n        FileNotFoundError: If the file doesn't exist.\n    \"\"\"\n    from .channel import ChannelFrame\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    # Get file reader\n    reader = get_file_reader(path)\n\n    # Get file info\n    info = reader.get_file_info(path, **kwargs)\n    sr = info[\"samplerate\"]\n    n_channels = info[\"channels\"]\n    n_frames = info[\"frames\"]\n    ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n    logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n    # Channel selection processing\n    all_channels = list(range(n_channels))\n\n    if channel is None:\n        channels_to_load = all_channels\n        logger.debug(f\"Will load all channels: {channels_to_load}\")\n    elif isinstance(channel, int):\n        if channel &lt; 0 or channel &gt;= n_channels:\n            raise ValueError(\n                f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n            )\n        channels_to_load = [channel]\n        logger.debug(f\"Will load single channel: {channel}\")\n    elif isinstance(channel, (list, tuple)):\n        for ch in channel:\n            if ch &lt; 0 or ch &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n        channels_to_load = list(channel)\n        logger.debug(f\"Will load specific channels: {channels_to_load}\")\n    else:\n        raise TypeError(\"channel must be int, list, or None\")\n\n    # Index calculation\n    start_idx = 0 if start is None else max(0, int(start * sr))\n    end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n    frames_to_read = end_idx - start_idx\n\n    logger.debug(\n        f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n        f\"start_idx={start_idx}, end_idx={end_idx}\"\n    )\n\n    # Settings for lazy loading\n    expected_shape = (len(channels_to_load), frames_to_read)\n\n    # Define the loading function using the file reader\n    def _load_audio() -&gt; NDArrayReal:\n        logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n        # Use the reader to get audio data with parameters\n        out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n        if not isinstance(out, np.ndarray):\n            raise ValueError(\"Unexpected data type after reading file\")\n        return out\n\n    logger.debug(\n        f\"Creating delayed dask task with expected shape: {expected_shape}\"\n    )\n\n    # Create delayed operation\n    delayed_data = dask_delayed(_load_audio)()\n    logger.debug(\"Wrapping delayed function in dask array\")\n\n    # Create dask array from delayed computation\n    dask_array = da_from_delayed(\n        delayed_data, shape=expected_shape, dtype=np.float32\n    )\n\n    if chunk_size is not None:\n        if chunk_size &lt;= 0:\n            raise ValueError(\"Chunk size must be a positive integer\")\n        logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n        dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n    logger.debug(\n        \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n    )\n\n    cf = ChannelFrame(\n        data=dask_array,\n        sampling_rate=sr,\n        label=path.stem,\n        metadata={\n            \"filename\": str(path),\n        },\n    )\n    if ch_labels is not None:\n        if len(ch_labels) != len(cf):\n            raise ValueError(\n                \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    return cf\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.from_ndarray","title":"<code>from_ndarray(array, sampling_rate, labels=None, unit=None, frame_label=None, metadata=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>This method is deprecated. Use from_numpy instead.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>NDArrayReal</code> <p>Signal data. Each row corresponds to a channel.</p> required <code>sampling_rate</code> <code>float</code> <p>Sampling rate (Hz).</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>unit</code> <code>Optional[Union[list[str], str]]</code> <p>Unit of the signal.</p> <code>None</code> <code>frame_label</code> <code>Optional[str]</code> <p>Label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_ndarray(\n    cls,\n    array: NDArrayReal,\n    sampling_rate: float,\n    labels: Optional[list[str]] = None,\n    unit: Optional[Union[list[str], str]] = None,\n    frame_label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    This method is deprecated. Use from_numpy instead.\n\n    Args:\n        array: Signal data. Each row corresponds to a channel.\n        sampling_rate: Sampling rate (Hz).\n        labels: Labels for each channel.\n        unit: Unit of the signal.\n        frame_label: Label for the frame.\n        metadata: Optional metadata dictionary.\n\n    Returns:\n        A new ChannelFrame containing the data.\n    \"\"\"\n    # Redirect to from_numpy for compatibility\n    # However, from_ndarray is deprecated\n    logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n    return cls.from_numpy(\n        data=array,\n        sampling_rate=sampling_rate,\n        label=frame_label,\n        metadata=metadata,\n        ch_labels=labels,\n        ch_units=unit,\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.from_numpy","title":"<code>from_numpy(data, sampling_rate, label=None, metadata=None, ch_labels=None, ch_units=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArrayReal</code> <p>NumPy array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>ch_units</code> <code>Optional[Union[list[str], str]]</code> <p>Units for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the NumPy data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_numpy(\n    cls,\n    data: NDArrayReal,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    ch_labels: Optional[list[str]] = None,\n    ch_units: Optional[Union[list[str], str]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    Args:\n        data: NumPy array containing channel data.\n        sampling_rate: The sampling rate in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        ch_labels: Labels for each channel.\n        ch_units: Units for each channel.\n\n    Returns:\n        A new ChannelFrame containing the NumPy data.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n\n    # Convert NumPy array to dask array\n    dask_data = da_from_array(data)\n    cf = ChannelFrame(\n        data=dask_data,\n        sampling_rate=sampling_rate,\n        label=label or \"numpy_data\",\n    )\n    if metadata is not None:\n        cf.metadata = metadata\n    if ch_labels is not None:\n        if len(ch_labels) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel labels does not match the number of channels\"\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    if ch_units is not None:\n        if isinstance(ch_units, str):\n            ch_units = [ch_units] * cf.n_channels\n\n        if len(ch_units) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel units does not match the number of channels\"\n            )\n        for i in range(len(ch_units)):\n            cf._channel_metadata[i].unit = ch_units[i]\n\n    return cf\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.high_pass_filter","title":"<code>high_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a high-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a high-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.hpss_harmonic","title":"<code>hpss_harmonic(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract harmonic components using HPSS  (Harmonic-Percussive Source Separation).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_harmonic(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract harmonic components using HPSS\n     (Harmonic-Percussive Source Separation).\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_harmonic\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.hpss_percussive","title":"<code>hpss_percussive(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract percussive components using HPSS (Harmonic-Percussive Source Separation).</p> <p>This method separates the percussive (tonal) components from the signal.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Union[_IntLike_co, tuple[_IntLike_co, _IntLike_co], list[_IntLike_co]]</code> <p>Median filter size for HPSS.</p> <code>31</code> <code>power</code> <code>float</code> <p>Exponent for the Weiner filter used in HPSS.</p> <code>2</code> <code>margin</code> <code>Union[_FloatLike_co, tuple[_FloatLike_co, _FloatLike_co], list[_FloatLike_co]]</code> <p>Margin size for the separation.</p> <code>1</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the harmonic components.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_percussive(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract percussive components using HPSS\n    (Harmonic-Percussive Source Separation).\n\n    This method separates the percussive (tonal) components from the signal.\n\n    Args:\n        kernel_size: Median filter size for HPSS.\n        power: Exponent for the Weiner filter used in HPSS.\n        margin: Margin size for the separation.\n\n    Returns:\n        A new ChannelFrame containing the harmonic components.\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_percussive\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.low_pass_filter","title":"<code>low_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a low-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a low-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.mean","title":"<code>mean()</code>","text":"<p>Average all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with averaged signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def mean(self) -&gt; \"ChannelFrame\":\n    \"\"\"Average all channels.\n\n    Returns:\n        A new ChannelFrame with averaged signal.\n    \"\"\"\n    return self.apply_operation(\"mean\")\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.noct_spectrum","title":"<code>noct_spectrum(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Compute N-octave band spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>fmin</code> <code>float</code> <p>Minimum center frequency in Hz. Default is 20 Hz.</p> required <code>fmax</code> <code>float</code> <p>Maximum center frequency in Hz. Default is 20000 Hz.</p> required <code>n</code> <code>int</code> <p>Band division (1 for octave, 3 for 1/3 octave). Default is 3.</p> <code>3</code> <code>G</code> <code>int</code> <p>Reference gain in dB. Default is 10 dB.</p> <code>10</code> <code>fr</code> <code>int</code> <p>Reference frequency in Hz. Default is 1000 Hz.</p> <code>1000</code> <p>Returns:</p> Type Description <code>NOctFrame</code> <p>A NOctFrame containing the N-octave band spectrum.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def noct_spectrum(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"Compute N-octave band spectrum.\n\n    Args:\n        fmin: Minimum center frequency in Hz. Default is 20 Hz.\n        fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n        n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n        G: Reference gain in dB. Default is 10 dB.\n        fr: Reference frequency in Hz. Default is 1000 Hz.\n\n    Returns:\n        A NOctFrame containing the N-octave band spectrum.\n    \"\"\"\n    from ..processing.time_series import NOctSpectrum\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_spectrum\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSpectrum\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_spectrum\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.normalize","title":"<code>normalize(target_level=-20, channel_wise=True)</code>","text":"<p>Normalize the signal level.</p> <p>This method adjusts the signal amplitude to reach a target RMS level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target RMS level in dB. Default is -20.</p> <code>-20</code> <code>channel_wise</code> <code>bool</code> <p>If True, normalize each channel independently. If False, apply the same scaling to all channels.</p> <code>True</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the normalized signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def normalize(\n    self, target_level: float = -20, channel_wise: bool = True\n) -&gt; \"ChannelFrame\":\n    \"\"\"Normalize the signal level.\n\n    This method adjusts the signal amplitude to reach a target RMS level.\n\n    Args:\n        target_level: Target RMS level in dB. Default is -20.\n        channel_wise: If True, normalize each channel independently.\n            If False, apply the same scaling to all channels.\n\n    Returns:\n        A new ChannelFrame containing the normalized signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n    )\n    return self.apply_operation(\n        \"normalize\", target_level=target_level, channel_wise=channel_wise\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.plot","title":"<code>plot(plot_type='waveform', ax=None, **kwargs)</code>","text":"<p>Plot the frame data.</p> <p>Parameters:</p> Name Type Description Default <code>plot_type</code> <code>str</code> <p>Type of plot. Default is \"waveform\".</p> <code>'waveform'</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def plot(\n    self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Plot the frame data.\n\n    Args:\n        plot_type: Type of plot. Default is \"waveform\".\n        ax: Optional matplotlib axes for plotting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    plot_strategy = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.power","title":"<code>power(exponent=2.0)</code>","text":"<p>Calculate the power of the signal.</p> <p>Parameters:</p> Name Type Description Default <code>exponent</code> <code>float</code> <p>The exponent to raise the signal to. Default is 2.0.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the signal raised to the power.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the power of the signal.\n\n    Args:\n        exponent: The exponent to raise the signal to. Default is 2.0.\n\n    Returns:\n        A new ChannelFrame containing the signal raised to the power.\n    \"\"\"\n    return self.apply_operation(\"power\", exponent=exponent)\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.read_csv","title":"<code>read_csv(filename, time_column=0, labels=None, delimiter=',', header=0)</code>  <code>classmethod</code>","text":"<p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.read_wav","title":"<code>read_wav(filename, labels=None)</code>  <code>classmethod</code>","text":"<p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.resampling","title":"<code>resampling(target_sr, **kwargs)</code>","text":"<p>Resample audio data.</p>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.resampling--parameters","title":"Parameters","text":"<p>target_sr : float     Target sampling rate (Hz) resample_type : str, optional     Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.) **kwargs : dict     Additional resampling parameters</p>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.resampling--returns","title":"Returns","text":"<p>ChannelFrame     Resampled channel frame</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def resampling(\n    self,\n    target_sr: float,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Resample audio data.\n\n    Parameters\n    ----------\n    target_sr : float\n        Target sampling rate (Hz)\n    resample_type : str, optional\n        Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n    **kwargs : dict\n        Additional resampling parameters\n\n    Returns\n    -------\n    ChannelFrame\n        Resampled channel frame\n    \"\"\"\n    return self.apply_operation(\n        \"resampling\",\n        target_sr=target_sr,\n        **kwargs,\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.rms_plot","title":"<code>rms_plot(ax=None, title=None, overlay=True, Aw=False, **kwargs)</code>","text":"<p>Generate an RMS plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title for the plot.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay the plot on the existing axis.</p> <code>True</code> <code>Aw</code> <code>bool</code> <p>Apply A-weighting.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_plot(\n    self,\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = True,\n    Aw: bool = False,  # noqa: N803\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Generate an RMS plot.\n\n    Args:\n        ax: Optional matplotlib axes for plotting.\n        title: Title for the plot.\n        overlay: Whether to overlay the plot on the existing axis.\n        Aw: Apply A-weighting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    kwargs = kwargs or {}\n    ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n    rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n    return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.rms_trend","title":"<code>rms_trend(frame_length=2048, hop_length=512, dB=False, Aw=False)</code>","text":"<p>Calculate the RMS trend of the signal.</p> <p>This method computes the root mean square value over sliding windows.</p> <p>Parameters:</p> Name Type Description Default <code>frame_length</code> <code>int</code> <p>The size of the sliding window in samples. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>int</code> <p>The hop length between windows in samples. Default is 512.</p> <code>512</code> <code>dB</code> <code>bool</code> <p>Whether to return the RMS values in decibels. Default is False.</p> <code>False</code> <code>Aw</code> <code>bool</code> <p>Whether to apply A-weighting. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the RMS trend.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_trend(\n    self,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the RMS trend of the signal.\n\n    This method computes the root mean square value over sliding windows.\n\n    Args:\n        frame_length: The size of the sliding window in samples. Default is 2048.\n        hop_length: The hop length between windows in samples. Default is 512.\n        dB: Whether to return the RMS values in decibels. Default is False.\n        Aw: Whether to apply A-weighting. Default is False.\n\n    Returns:\n        A new ChannelFrame containing the RMS trend.\n    \"\"\"\n    cf = self.apply_operation(\n        \"rms_trend\",\n        frame_length=frame_length,\n        hop_length=hop_length,\n        ref=[ch.ref for ch in self._channel_metadata],\n        dB=dB,\n        Aw=Aw,\n    )\n    cf.sampling_rate = self.sampling_rate / hop_length\n    return cf\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.save","title":"<code>save(path, format=None)</code>","text":"<p>Save the audio data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n    data = self.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    sf.write(str(path), data, int(self.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {path}\")\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.stft","title":"<code>stft(n_fft=2048, hop_length=None, win_length=None, window='hann')</code>","text":"<p>Compute Short-Time Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectrogramFrame</code> <p>A SpectrogramFrame containing the STFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def stft(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n) -&gt; \"SpectrogramFrame\":\n    \"\"\"Compute Short-Time Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectrogramFrame containing the STFT results.\n    \"\"\"\n    from ..processing.time_series import STFT, create_operation\n    from .spectrogram import SpectrogramFrame\n\n    # Set hop length and window length\n    _hop_length = hop_length if hop_length is not None else n_fft // 4\n    _win_length = win_length if win_length is not None else n_fft\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": _hop_length,\n        \"win_length\": _win_length,\n        \"window\": window,\n    }\n    operation_name = \"stft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"STFT\", operation)\n\n    # Apply processing to data\n    spectrogram_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n\n    # Create new instance\n    return SpectrogramFrame(\n        data=spectrogram_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=n_fft,\n        hop_length=_hop_length,\n        win_length=_win_length,\n        window=window,\n        label=f\"stft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.sum","title":"<code>sum()</code>","text":"<p>Sum all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with summed signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def sum(self) -&gt; \"ChannelFrame\":\n    \"\"\"Sum all channels.\n\n    Returns:\n        A new ChannelFrame with summed signal.\n    \"\"\"\n    return self.apply_operation(\"sum\")\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.transfer_function","title":"<code>transfer_function(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute transfer function matrix.</p> <p>The transfer function characterizes the signal transmission properties between channels in the frequency domain, representing the input-output relationship of a system.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the transfer function matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def transfer_function(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute transfer function matrix.\n\n    The transfer function characterizes the signal transmission properties\n    between channels in the frequency domain, representing the input-output\n    relationship of a system.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the transfer function matrix.\n    \"\"\"\n    from ..processing.time_series import TransferFunction, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"transfer_function\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"TransferFunction\", operation)\n\n    # Apply processing to data\n    tf_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=tf_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Transfer function of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.trim","title":"<code>trim(start=0, end=None)</code>","text":"<p>Trim the signal to specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>Start time in seconds.</p> <code>0</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with trimmed signal.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If end time is before start time.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def trim(\n    self,\n    start: float = 0,\n    end: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Trim the signal to specified time range.\n\n    Args:\n        start: Start time in seconds.\n        end: End time in seconds.\n\n    Returns:\n        A new ChannelFrame with trimmed signal.\n\n    Raises:\n        ValueError: If end time is before start time.\n    \"\"\"\n    if end is None:\n        end = self.duration\n    if start &gt; end:\n        raise ValueError(\"start must be less than end\")\n    # Apply trim operation\n    return self.apply_operation(\"trim\", start=start, end=end)\n</code></pre>"},{"location":"en/ja/api/#wandas.frames.channel.ChannelFrame.welch","title":"<code>welch(n_fft=None, hop_length=None, win_length=2048, window='hann', average='mean')</code>","text":"<p>Compute power spectral density using Welch's method.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is 2048.</p> <code>None</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>int</code> <p>Length of window. Default is n_fft.</p> <code>2048</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the power spectral density.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def welch(\n    self,\n    n_fft: Optional[int] = None,\n    hop_length: Optional[int] = None,\n    win_length: int = 2048,\n    window: str = \"hann\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute power spectral density using Welch's method.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the power spectral density.\n    \"\"\"\n    from ..processing.time_series import Welch\n    from .spectral import SpectralFrame\n\n    params = dict(\n        n_fft=n_fft or win_length,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        average=average,\n    )\n    operation_name = \"welch\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Welch\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"welch\", \"params\": params},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/ja/api/#io","title":"\u5165\u51fa\u529b (I/O)","text":"<p>Wandas\u3067\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u65b9\u6cd5\u3067\u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u3084CSV\u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u3080\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002</p>"},{"location":"en/ja/api/#wav","title":"WAV\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\u3068\u66f8\u304d\u8fbc\u307f","text":"<pre><code># WAV\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\nfrom wandas.frames.channel import ChannelFrame\nframe = ChannelFrame.read_wav(\"audio.wav\")\n\n# \u307e\u305f\u306f\u76f4\u63a5\u30a4\u30f3\u30dd\u30fc\u30c8\u3092\u4f7f\u7528\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")\n\n# WAV\u30d5\u30a1\u30a4\u30eb\u306e\u66f8\u304d\u8fbc\u307f\nframe.save(\"output.wav\")\n</code></pre> <p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre> <p>Save the audio data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n    data = self.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    sf.write(str(path), data, int(self.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {path}\")\n</code></pre>"},{"location":"en/ja/api/#csv","title":"CSV\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f","text":"<pre><code># CSV\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\nfrom wandas.frames.channel import ChannelFrame\nframe = ChannelFrame.read_csv(\"data.csv\")\n\n# \u307e\u305f\u306f\u76f4\u63a5\u30a4\u30f3\u30dd\u30fc\u30c8\u3092\u4f7f\u7528\nimport wandas\nframe = wandas.read_csv(\"data.csv\")\n</code></pre> <p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"en/ja/api/#_3","title":"\u4fe1\u53f7\u51e6\u7406","text":"<p>Wandas\u306f\u69d8\u3005\u306a\u4fe1\u53f7\u51e6\u7406\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"en/ja/api/#wandas.processing.time_series.ABS","title":"<code>ABS</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Absolute value operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ABS(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Absolute value operation\"\"\"\n\n    name = \"abs\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize absolute value operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        return da.abs(data)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.ABS.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize absolute value operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.ABS.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize absolute value operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.AWeighting","title":"<code>AWeighting</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>A-weighting filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AWeighting(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"A-weighting filter operation\"\"\"\n\n    name = \"a_weighting\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize A-weighting filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for A-weighting filter\"\"\"\n        logger.debug(f\"Applying A-weighting to array with shape: {x.shape}\")\n        result = A_weight(x, self.sampling_rate)\n\n        # Handle case where A_weight returns a tuple\n        if isinstance(result, tuple):\n            # Use the first element of the tuple\n            result = result[0]\n\n        logger.debug(\n            f\"A-weighting applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.AWeighting.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize A-weighting filter</p>"},{"location":"en/ja/api/#wandas.processing.time_series.AWeighting.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize A-weighting filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.AddWithSNR","title":"<code>AddWithSNR</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Addition operation considering SNR</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AddWithSNR(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Addition operation considering SNR\"\"\"\n\n    name = \"add_with_snr\"\n\n    def __init__(self, sampling_rate: float, other: DaArray, snr: float):\n        \"\"\"\n        Initialize addition operation considering SNR\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        other : DaArray\n            Noise signal to add (channel-frame format)\n        snr : float\n            Signal-to-noise ratio (dB)\n        \"\"\"\n        super().__init__(sampling_rate, other=other, snr=snr)\n\n        self.other = other\n        self.snr = snr\n        logger.debug(f\"Initialized AddWithSNR operation with SNR: {snr} dB\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape (same as input)\n        \"\"\"\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Perform addition processing considering SNR\"\"\"\n        logger.debug(f\"Applying SNR-based addition with shape: {x.shape}\")\n        other: NDArrayReal = self.other.compute()\n\n        # Use multi-channel versions of calculate_rms and calculate_desired_noise_rms\n        clean_rms = util.calculate_rms(x)\n        other_rms = util.calculate_rms(other)\n\n        # Adjust noise gain based on specified SNR (apply per channel)\n        desired_noise_rms = util.calculate_desired_noise_rms(clean_rms, self.snr)\n\n        # Apply gain per channel using broadcasting\n        gain = desired_noise_rms / other_rms\n        # Add adjusted noise to signal\n        result: NDArrayReal = x + other * gain\n        return result\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.AddWithSNR.__init__","title":"<code>__init__(sampling_rate, other, snr)</code>","text":"<p>Initialize addition operation considering SNR</p>"},{"location":"en/ja/api/#wandas.processing.time_series.AddWithSNR.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) other : DaArray     Noise signal to add (channel-frame format) snr : float     Signal-to-noise ratio (dB)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, other: DaArray, snr: float):\n    \"\"\"\n    Initialize addition operation considering SNR\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    other : DaArray\n        Noise signal to add (channel-frame format)\n    snr : float\n        Signal-to-noise ratio (dB)\n    \"\"\"\n    super().__init__(sampling_rate, other=other, snr=snr)\n\n    self.other = other\n    self.snr = snr\n    logger.debug(f\"Initialized AddWithSNR operation with SNR: {snr} dB\")\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.AddWithSNR.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.AddWithSNR.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/ja/api/#wandas.processing.time_series.AddWithSNR.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (same as input)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape (same as input)\n    \"\"\"\n    return input_shape\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.AudioOperation","title":"<code>AudioOperation</code>","text":"<p>               Bases: <code>Generic[InputArrayType, OutputArrayType]</code></p> <p>Abstract base class for audio processing operations.</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AudioOperation(Generic[InputArrayType, OutputArrayType]):\n    \"\"\"Abstract base class for audio processing operations.\"\"\"\n\n    # Class variable: operation name\n    name: ClassVar[str]\n\n    def __init__(self, sampling_rate: float, **params: Any):\n        \"\"\"\n        Initialize AudioOperation.\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        **params : Any\n            Operation-specific parameters\n        \"\"\"\n        self.sampling_rate = sampling_rate\n        self.params = params\n\n        # Validate parameters during initialization\n        self.validate_params()\n\n        # Create processor function (lazy initialization possible)\n        self._setup_processor()\n\n        logger.debug(\n            f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n        )\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n        pass\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up processor function (implemented by subclasses)\"\"\"\n        pass\n\n    def _process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function (implemented by subclasses)\"\"\"\n        # Default is no-op function\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    @dask.delayed  # type: ignore [misc, unused-ignore]\n    def process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n        # Default is no-op function\n        logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n        return self._process_array(x)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation (implemented by subclasses)\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        \"\"\"\n        Execute operation and return result\n        data shape is (channels, samples)\n        \"\"\"\n        # Add task as delayed processing\n        logger.debug(\"Adding delayed operation to computation graph\")\n        delayed_result = self.process_array(data)\n        # Convert delayed result to dask array and return\n        output_shape = self.calculate_output_shape(data.shape)\n        return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.AudioOperation.__init__","title":"<code>__init__(sampling_rate, **params)</code>","text":"<p>Initialize AudioOperation.</p>"},{"location":"en/ja/api/#wandas.processing.time_series.AudioOperation.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) **params : Any     Operation-specific parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, **params: Any):\n    \"\"\"\n    Initialize AudioOperation.\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    **params : Any\n        Operation-specific parameters\n    \"\"\"\n    self.sampling_rate = sampling_rate\n    self.params = params\n\n    # Validate parameters during initialization\n    self.validate_params()\n\n    # Create processor function (lazy initialization possible)\n    self._setup_processor()\n\n    logger.debug(\n        f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.AudioOperation.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation (implemented by subclasses)</p>"},{"location":"en/ja/api/#wandas.processing.time_series.AudioOperation.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/ja/api/#wandas.processing.time_series.AudioOperation.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation (implemented by subclasses)\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.AudioOperation.process","title":"<code>process(data)</code>","text":"<p>Execute operation and return result data shape is (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    \"\"\"\n    Execute operation and return result\n    data shape is (channels, samples)\n    \"\"\"\n    # Add task as delayed processing\n    logger.debug(\"Adding delayed operation to computation graph\")\n    delayed_result = self.process_array(data)\n    # Convert delayed result to dask array and return\n    output_shape = self.calculate_output_shape(data.shape)\n    return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.AudioOperation.process_array","title":"<code>process_array(x)</code>","text":"<p>Processing function wrapped with @dask.delayed</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>@dask.delayed  # type: ignore [misc, unused-ignore]\ndef process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n    \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n    # Default is no-op function\n    logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n    return self._process_array(x)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.AudioOperation.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters (raises exception if invalid)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n    pass\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.CSD","title":"<code>CSD</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Cross-spectral density estimation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class CSD(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Cross-spectral density estimation operation\"\"\"\n\n    name = \"csd\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n        scaling: str,\n        average: str,\n    ):\n        \"\"\"\n        Initialize cross-spectral density estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        scaling : str\n            Type of scaling\n        average : str\n            Method of averaging\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        self.scaling = scaling\n        self.average = average\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n            scaling=scaling,\n            average=average,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Processor function for cross-spectral density estimation operation\"\"\"\n        logger.debug(f\"Applying CSD estimation to array with shape: {x.shape}\")\n        from scipy import signal as ss\n\n        # Calculate all combinations using scipy's csd function\n        _, csd_result = ss.csd(\n            x=x[:, np.newaxis],\n            y=x[np.newaxis, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n        )\n\n        # Reshape result to (n_channels * n_channels, n_freqs)\n        result: NDArrayComplex = csd_result.transpose(1, 0, 2).reshape(\n            -1, csd_result.shape[-1]\n        )\n\n        logger.debug(f\"CSD estimation applied, result shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.CSD.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend, scaling, average)</code>","text":"<p>Initialize cross-spectral density estimation operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.CSD.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend scaling : str     Type of scaling average : str     Method of averaging</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n    scaling: str,\n    average: str,\n):\n    \"\"\"\n    Initialize cross-spectral density estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    scaling : str\n        Type of scaling\n    average : str\n        Method of averaging\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    self.scaling = scaling\n    self.average = average\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n        scaling=scaling,\n        average=average,\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.CSD.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.CSD.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/ja/api/#wandas.processing.time_series.CSD.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.ChannelDifference","title":"<code>ChannelDifference</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Channel difference calculation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ChannelDifference(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Channel difference calculation operation\"\"\"\n\n    name = \"channel_difference\"\n    other_channel: int\n\n    def __init__(self, sampling_rate: float, other_channel: int = 0):\n        \"\"\"\n        Initialize channel difference calculation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        other_channel : int\n            Channel to calculate difference with, default is 0\n        \"\"\"\n        self.other_channel = other_channel\n        super().__init__(sampling_rate, other_channel=other_channel)\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        result = data - data[self.other_channel]\n        return result\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.ChannelDifference.__init__","title":"<code>__init__(sampling_rate, other_channel=0)</code>","text":"<p>Initialize channel difference calculation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.ChannelDifference.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) other_channel : int     Channel to calculate difference with, default is 0</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, other_channel: int = 0):\n    \"\"\"\n    Initialize channel difference calculation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    other_channel : int\n        Channel to calculate difference with, default is 0\n    \"\"\"\n    self.other_channel = other_channel\n    super().__init__(sampling_rate, other_channel=other_channel)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.Coherence","title":"<code>Coherence</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Coherence estimation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Coherence(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Coherence estimation operation\"\"\"\n\n    name = \"coherence\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n    ):\n        \"\"\"\n        Initialize coherence estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Processor function for coherence estimation operation\"\"\"\n        logger.debug(f\"Applying coherence estimation to array with shape: {x.shape}\")\n        from scipy import signal as ss\n\n        _, coh = ss.coherence(\n            x=x[:, np.newaxis],\n            y=x[np.newaxis, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n        )\n\n        # Reshape result to (n_channels * n_channels, n_freqs)\n        result: NDArrayReal = coh.transpose(1, 0, 2).reshape(-1, coh.shape[-1])\n\n        logger.debug(f\"Coherence estimation applied, result shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.Coherence.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend)</code>","text":"<p>Initialize coherence estimation operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.Coherence.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n):\n    \"\"\"\n    Initialize coherence estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.Coherence.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.Coherence.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/ja/api/#wandas.processing.time_series.Coherence.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.FFT","title":"<code>FFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>FFT (Fast Fourier Transform) operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class FFT(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"FFT (Fast Fourier Transform) operation\"\"\"\n\n    name = \"fft\"\n    n_fft: Optional[int]\n    window: str\n\n    def __init__(\n        self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n    ):\n        \"\"\"\n        Initialize FFT operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int, optional\n            FFT size, default is None (determined by input size)\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(sampling_rate, n_fft=n_fft, window=window)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        \u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059\n\n        Parameters\n        ----------\n        input_shape : tuple\n            \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)\n\n        Returns\n        -------\n        tuple\n            \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)\n        \"\"\"\n        n_freqs = self.n_fft // 2 + 1 if self.n_fft else input_shape[-1] // 2 + 1\n        return (*input_shape[:-1], n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"FFT\u64cd\u4f5c\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u95a2\u6570\u3092\u4f5c\u6210\"\"\"\n        from scipy.signal import get_window\n\n        win = get_window(self.window, x.shape[-1])\n        x = x * win\n        result: NDArrayComplex = np.fft.rfft(x, n=self.n_fft, axis=-1)\n        result[..., 1:-1] *= 2.0\n        # \u7a93\u95a2\u6570\u88dc\u6b63\n        scaling_factor = np.sum(win)\n        result = result / scaling_factor\n        return result\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.FFT.__init__","title":"<code>__init__(sampling_rate, n_fft=None, window='hann')</code>","text":"<p>Initialize FFT operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.FFT.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int, optional     FFT size, default is None (determined by input size) window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n):\n    \"\"\"\n    Initialize FFT operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int, optional\n        FFT size, default is None (determined by input size)\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(sampling_rate, n_fft=n_fft, window=window)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.FFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>\u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059</p>"},{"location":"en/ja/api/#wandas.processing.time_series.FFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)</p>"},{"location":"en/ja/api/#wandas.processing.time_series.FFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    \u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059\n\n    Parameters\n    ----------\n    input_shape : tuple\n        \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)\n\n    Returns\n    -------\n    tuple\n        \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)\n    \"\"\"\n    n_freqs = self.n_fft // 2 + 1 if self.n_fft else input_shape[-1] // 2 + 1\n    return (*input_shape[:-1], n_freqs)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.HighPassFilter","title":"<code>HighPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>High-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HighPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"High-pass filter operation\"\"\"\n\n    name = \"highpass_filter\"\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize high-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            limit = self.sampling_rate / 2\n            raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up high-pass filter processor\"\"\"\n        # Calculate filter coefficients (once) - safely retrieve from instance variables\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"high\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Highpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying highpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.HighPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize high-pass filter</p>"},{"location":"en/ja/api/#wandas.processing.time_series.HighPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize high-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.HighPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        limit = self.sampling_rate / 2\n        raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.HpssHarmonic","title":"<code>HpssHarmonic</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>HPSS Harmonic operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HpssHarmonic(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"HPSS Harmonic operation\"\"\"\n\n    name = \"hpss_harmonic\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize HPSS Harmonic\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        self.kwargs = kwargs\n        super().__init__(sampling_rate, **kwargs)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for HPSS Harmonic\"\"\"\n        logger.debug(f\"Applying HPSS Harmonic to array with shape: {x.shape}\")\n        result = librosa.effects.harmonic(x, **self.kwargs)\n        logger.debug(\n            f\"HPSS Harmonic applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.HpssHarmonic.__init__","title":"<code>__init__(sampling_rate, **kwargs)</code>","text":"<p>Initialize HPSS Harmonic</p>"},{"location":"en/ja/api/#wandas.processing.time_series.HpssHarmonic.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize HPSS Harmonic\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    self.kwargs = kwargs\n    super().__init__(sampling_rate, **kwargs)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.HpssPercussive","title":"<code>HpssPercussive</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>HPSS Percussive operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HpssPercussive(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"HPSS Percussive operation\"\"\"\n\n    name = \"hpss_percussive\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize HPSS Percussive\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        self.kwargs = kwargs\n        super().__init__(sampling_rate, **kwargs)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for HPSS Percussive\"\"\"\n        logger.debug(f\"Applying HPSS Percussive to array with shape: {x.shape}\")\n        result = librosa.effects.percussive(x, **self.kwargs)\n        logger.debug(\n            f\"HPSS Percussive applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.HpssPercussive.__init__","title":"<code>__init__(sampling_rate, **kwargs)</code>","text":"<p>Initialize HPSS Percussive</p>"},{"location":"en/ja/api/#wandas.processing.time_series.HpssPercussive.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize HPSS Percussive\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    self.kwargs = kwargs\n    super().__init__(sampling_rate, **kwargs)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.IFFT","title":"<code>IFFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayComplex, NDArrayReal]</code></p> <p>IFFT (Inverse Fast Fourier Transform) operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class IFFT(AudioOperation[NDArrayComplex, NDArrayReal]):\n    \"\"\"IFFT (Inverse Fast Fourier Transform) operation\"\"\"\n\n    name = \"ifft\"\n    n_fft: Optional[int]\n    window: str\n\n    def __init__(\n        self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n    ):\n        \"\"\"\n        Initialize IFFT operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : Optional[int], optional\n            IFFT size, default is None (determined based on input size)\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(sampling_rate, n_fft=n_fft, window=window)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, freqs)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, samples)\n        \"\"\"\n        n_samples = 2 * (input_shape[-1] - 1) if self.n_fft is None else self.n_fft\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayComplex) -&gt; NDArrayReal:\n        \"\"\"Create processor function for IFFT operation\"\"\"\n        logger.debug(f\"Applying IFFT to array with shape: {x.shape}\")\n\n        # Restore frequency component scaling (remove the 2.0 multiplier applied in FFT)\n        _x = x.copy()\n        _x[..., 1:-1] /= 2.0\n\n        # Execute IFFT\n        result: NDArrayReal = np.fft.irfft(_x, n=self.n_fft, axis=-1)\n\n        # Window function correction (inverse of FFT operation)\n        from scipy.signal import get_window\n\n        win = get_window(self.window, result.shape[-1])\n\n        # Correct the FFT window function scaling\n        scaling_factor = np.sum(win) / result.shape[-1]\n        result = result / scaling_factor\n\n        logger.debug(f\"IFFT applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.IFFT.__init__","title":"<code>__init__(sampling_rate, n_fft=None, window='hann')</code>","text":"<p>Initialize IFFT operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.IFFT.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : Optional[int], optional     IFFT size, default is None (determined based on input size) window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n):\n    \"\"\"\n    Initialize IFFT operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : Optional[int], optional\n        IFFT size, default is None (determined based on input size)\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(sampling_rate, n_fft=n_fft, window=window)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.IFFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.IFFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, freqs)</p>"},{"location":"en/ja/api/#wandas.processing.time_series.IFFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, freqs)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, samples)\n    \"\"\"\n    n_samples = 2 * (input_shape[-1] - 1) if self.n_fft is None else self.n_fft\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.ISTFT","title":"<code>ISTFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayComplex, NDArrayReal]</code></p> <p>Inverse Short-Time Fourier Transform operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ISTFT(AudioOperation[NDArrayComplex, NDArrayReal]):\n    \"\"\"Inverse Short-Time Fourier Transform operation\"\"\"\n\n    name = \"istft\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        length: Optional[int] = None,\n    ):\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.length = length\n\n        # Instantiate ShortTimeFFT for ISTFT calculation\n        self.SFT = ShortTimeFFT(\n            win=get_window(window, self.win_length),\n            hop=self.hop_length,\n            fs=sampling_rate,\n            mfft=self.n_fft,\n            scale_to=\"magnitude\",  # Consistent scaling with STFT\n        )\n\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n            length=length,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, freqs, time_frames)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, samples)\n        \"\"\"\n        k0: int = 0\n        q_max = input_shape[-1] + self.SFT.p_min\n        k_max = (q_max - 1) * self.SFT.hop + self.SFT.m_num - self.SFT.m_num_mid\n        k_q0, k_q1 = self.SFT.nearest_k_p(k0), self.SFT.nearest_k_p(k_max, left=False)\n        n_pts = k_q1 - k_q0 + self.SFT.m_num - self.SFT.m_num_mid\n\n        return input_shape[:-2] + (n_pts,)\n\n    def _process_array(self, x: NDArrayComplex) -&gt; NDArrayReal:\n        \"\"\"\n        Apply SciPy ISTFT processing to multiple channels at once using ShortTimeFFT\"\"\"\n        logger.debug(\n            f\"Applying SciPy ISTFT (ShortTimeFFT) to array with shape: {x.shape}\"\n        )\n\n        # Convert 2D input to 3D (assume single channel)\n        if x.ndim == 2:\n            x = x.reshape(1, *x.shape)\n\n        # Adjust scaling back if STFT applied factor of 2\n        _x = np.copy(x)\n        _x[..., 1:-1, :] /= 2.0\n\n        # Apply ISTFT using the ShortTimeFFT instance\n        result: NDArrayReal = self.SFT.istft(_x)\n\n        # Trim to desired length if specified\n        if self.length is not None:\n            result = result[..., : self.length]\n\n        logger.debug(\n            f\"ShortTimeFFT applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.ISTFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.ISTFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, freqs, time_frames)</p>"},{"location":"en/ja/api/#wandas.processing.time_series.ISTFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, freqs, time_frames)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, samples)\n    \"\"\"\n    k0: int = 0\n    q_max = input_shape[-1] + self.SFT.p_min\n    k_max = (q_max - 1) * self.SFT.hop + self.SFT.m_num - self.SFT.m_num_mid\n    k_q0, k_q1 = self.SFT.nearest_k_p(k0), self.SFT.nearest_k_p(k_max, left=False)\n    n_pts = k_q1 - k_q0 + self.SFT.m_num - self.SFT.m_num_mid\n\n    return input_shape[:-2] + (n_pts,)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.LowPassFilter","title":"<code>LowPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Low-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class LowPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Low-pass filter operation\"\"\"\n\n    name = \"lowpass_filter\"\n    a: NDArrayReal\n    b: NDArrayReal\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize low-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            raise ValueError(\n                f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n            )\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up low-pass filter processor\"\"\"\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"low\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Lowpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying lowpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.LowPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize low-pass filter</p>"},{"location":"en/ja/api/#wandas.processing.time_series.LowPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize low-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.LowPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        raise ValueError(\n            f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n        )\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.Mean","title":"<code>Mean</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Mean calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Mean(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Mean calculation\"\"\"\n\n    name = \"mean\"\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # Use Dask's aggregate function directly without map_blocks\n        return data.mean(axis=0, keepdims=True)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.NOctSpectrum","title":"<code>NOctSpectrum</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>N-octave spectrum operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class NOctSpectrum(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"N-octave spectrum operation\"\"\"\n\n    name = \"noct_spectrum\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ):\n        \"\"\"\n        Initialize N-octave spectrum\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        fmin : float\n            Minimum frequency (Hz)\n        fmax : float\n            Maximum frequency (Hz)\n        n : int, optional\n            Number of octave divisions, default is 3\n        G : int, optional\n            Reference level, default is 10\n        fr : int, optional\n            Reference frequency, default is 1000\n        \"\"\"\n        super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n        self.fmin = fmin\n        self.fmax = fmax\n        self.n = n\n        self.G = G\n        self.fr = fr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate output shape for octave spectrum\n        _, fpref = _center_freq(\n            fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n        )\n        return (input_shape[0], fpref.shape[0])\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for octave spectrum\"\"\"\n        logger.debug(f\"Applying NoctSpectrum to array with shape: {x.shape}\")\n        spec, _ = noct_spectrum(\n            sig=x.T,\n            fs=self.sampling_rate,\n            fmin=self.fmin,\n            fmax=self.fmax,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        if spec.ndim == 1:\n            # Add channel dimension for 1D\n            spec = np.expand_dims(spec, axis=0)\n        else:\n            spec = spec.T\n        logger.debug(f\"NoctSpectrum applied, returning result with shape: {spec.shape}\")\n        return np.array(spec)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.NOctSpectrum.__init__","title":"<code>__init__(sampling_rate, fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Initialize N-octave spectrum</p>"},{"location":"en/ja/api/#wandas.processing.time_series.NOctSpectrum.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) fmin : float     Minimum frequency (Hz) fmax : float     Maximum frequency (Hz) n : int, optional     Number of octave divisions, default is 3 G : int, optional     Reference level, default is 10 fr : int, optional     Reference frequency, default is 1000</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n):\n    \"\"\"\n    Initialize N-octave spectrum\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    fmin : float\n        Minimum frequency (Hz)\n    fmax : float\n        Maximum frequency (Hz)\n    n : int, optional\n        Number of octave divisions, default is 3\n    G : int, optional\n        Reference level, default is 10\n    fr : int, optional\n        Reference frequency, default is 1000\n    \"\"\"\n    super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n    self.fmin = fmin\n    self.fmax = fmax\n    self.n = n\n    self.G = G\n    self.fr = fr\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.NOctSpectrum.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.NOctSpectrum.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/ja/api/#wandas.processing.time_series.NOctSpectrum.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate output shape for octave spectrum\n    _, fpref = _center_freq(\n        fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n    )\n    return (input_shape[0], fpref.shape[0])\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.NOctSynthesis","title":"<code>NOctSynthesis</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Octave synthesis operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class NOctSynthesis(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Octave synthesis operation\"\"\"\n\n    name = \"noct_synthesis\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ):\n        \"\"\"\n        Initialize octave synthesis\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        fmin : float\n            Minimum frequency (Hz)\n        fmax : float\n            Maximum frequency (Hz)\n        n : int, optional\n            Number of octave divisions, default is 3\n        G : int, optional\n            Reference level, default is 10\n        fr : int, optional\n            Reference frequency, default is 1000\n        \"\"\"\n        super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n\n        self.fmin = fmin\n        self.fmax = fmax\n        self.n = n\n        self.G = G\n        self.fr = fr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate output shape for octave spectrum\n        _, fpref = _center_freq(\n            fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n        )\n        return (input_shape[0], fpref.shape[0])\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for octave synthesis\"\"\"\n        logger.debug(f\"Applying NoctSynthesis to array with shape: {x.shape}\")\n        # Calculate n from shape[-1]\n        n = x.shape[-1]  # Calculate n from shape[-1]\n        if n % 2 == 0:\n            n = n * 2 - 1\n        else:\n            n = (n - 1) * 2\n        freqs = np.fft.rfftfreq(n, d=1 / self.sampling_rate)\n        result, _ = noct_synthesis(\n            spectrum=np.abs(x).T,\n            freqs=freqs,\n            fmin=self.fmin,\n            fmax=self.fmax,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        result = result.T\n        logger.debug(\n            f\"NoctSynthesis applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.NOctSynthesis.__init__","title":"<code>__init__(sampling_rate, fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Initialize octave synthesis</p>"},{"location":"en/ja/api/#wandas.processing.time_series.NOctSynthesis.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) fmin : float     Minimum frequency (Hz) fmax : float     Maximum frequency (Hz) n : int, optional     Number of octave divisions, default is 3 G : int, optional     Reference level, default is 10 fr : int, optional     Reference frequency, default is 1000</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n):\n    \"\"\"\n    Initialize octave synthesis\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    fmin : float\n        Minimum frequency (Hz)\n    fmax : float\n        Maximum frequency (Hz)\n    n : int, optional\n        Number of octave divisions, default is 3\n    G : int, optional\n        Reference level, default is 10\n    fr : int, optional\n        Reference frequency, default is 1000\n    \"\"\"\n    super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n\n    self.fmin = fmin\n    self.fmax = fmax\n    self.n = n\n    self.G = G\n    self.fr = fr\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.NOctSynthesis.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.NOctSynthesis.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/ja/api/#wandas.processing.time_series.NOctSynthesis.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate output shape for octave spectrum\n    _, fpref = _center_freq(\n        fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n    )\n    return (input_shape[0], fpref.shape[0])\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.Power","title":"<code>Power</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Power operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Power(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Power operation\"\"\"\n\n    name = \"power\"\n\n    def __init__(self, sampling_rate: float, exponent: float):\n        \"\"\"\n        Initialize power operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        exponent : float\n            Power exponent\n        \"\"\"\n        super().__init__(sampling_rate)\n        self.exp = exponent\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        return da.power(data, self.exp)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.Power.__init__","title":"<code>__init__(sampling_rate, exponent)</code>","text":"<p>Initialize power operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.Power.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) exponent : float     Power exponent</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, exponent: float):\n    \"\"\"\n    Initialize power operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    exponent : float\n        Power exponent\n    \"\"\"\n    super().__init__(sampling_rate)\n    self.exp = exponent\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.ReSampling","title":"<code>ReSampling</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Resampling operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ReSampling(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Resampling operation\"\"\"\n\n    name = \"resampling\"\n\n    def __init__(self, sampling_rate: float, target_sr: float):\n        \"\"\"\n        Initialize resampling operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        target_sampling_rate : float\n            Target sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate, target_sr=target_sr)\n        self.target_sr = target_sr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after resampling\n        ratio = float(self.target_sr) / float(self.sampling_rate)\n        n_samples = int(np.ceil(input_shape[-1] * ratio))\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for resampling operation\"\"\"\n        logger.debug(f\"Applying resampling to array with shape: {x.shape}\")\n        result = librosa.resample(\n            x, orig_sr=self.sampling_rate, target_sr=self.target_sr\n        )\n        logger.debug(f\"Resampling applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.ReSampling.__init__","title":"<code>__init__(sampling_rate, target_sr)</code>","text":"<p>Initialize resampling operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.ReSampling.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) target_sampling_rate : float     Target sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, target_sr: float):\n    \"\"\"\n    Initialize resampling operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    target_sampling_rate : float\n        Target sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate, target_sr=target_sr)\n    self.target_sr = target_sr\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.ReSampling.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.ReSampling.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/ja/api/#wandas.processing.time_series.ReSampling.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after resampling\n    ratio = float(self.target_sr) / float(self.sampling_rate)\n    n_samples = int(np.ceil(input_shape[-1] * ratio))\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.RmsTrend","title":"<code>RmsTrend</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>RMS calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class RmsTrend(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"RMS calculation\"\"\"\n\n    name = \"rms_trend\"\n    frame_length: int\n    hop_length: int\n    Aw: bool\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        ref: Union[list[float], float] = 1.0,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; None:\n        \"\"\"\n        Initialize RMS calculation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        frame_length : int\n            Frame length, default is 2048\n        hop_length : int\n            Hop length, default is 512\n        ref : Union[list[float], float]\n            Reference value(s) for dB calculation\n        dB : bool\n            Whether to convert to decibels\n        Aw : bool\n            Whether to apply A-weighting before RMS calculation\n        \"\"\"\n        self.frame_length = frame_length\n        self.hop_length = hop_length\n        self.dB = dB\n        self.Aw = Aw\n        self.ref = np.array(ref if isinstance(ref, list) else [ref])\n        super().__init__(\n            sampling_rate,\n            frame_length=frame_length,\n            hop_length=hop_length,\n            dB=dB,\n            Aw=Aw,\n            ref=self.ref,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, frames)\n        \"\"\"\n        n_frames = librosa.feature.rms(\n            y=np.ones((1, input_shape[-1])),\n            frame_length=self.frame_length,\n            hop_length=self.hop_length,\n        ).shape[-1]\n        return (*input_shape[:-1], n_frames)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for RMS calculation\"\"\"\n        logger.debug(f\"Applying RMS to array with shape: {x.shape}\")\n\n        if self.Aw:\n            # Apply A-weighting\n            _x = A_weight(x, self.sampling_rate)\n            if isinstance(_x, np.ndarray):\n                # A_weight\u304c\u30bf\u30d7\u30eb\u3092\u8fd4\u3059\u5834\u5408\u3001\u6700\u521d\u306e\u8981\u7d20\u3092\u4f7f\u7528\n                x = _x\n            elif isinstance(_x, tuple):\n                # Use the first element if A_weight returns a tuple\n                x = _x[0]\n            else:\n                raise ValueError(\"A_weighting returned an unexpected type.\")\n\n        # Calculate RMS\n        result = librosa.feature.rms(\n            y=x, frame_length=self.frame_length, hop_length=self.hop_length\n        )[..., 0, :]\n\n        if self.dB:\n            # Convert to dB\n            result = 20 * np.log10(\n                np.maximum(result / self.ref[..., np.newaxis], 1e-12)\n            )\n        #\n        logger.debug(f\"RMS applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.RmsTrend.__init__","title":"<code>__init__(sampling_rate, frame_length=2048, hop_length=512, ref=1.0, dB=False, Aw=False)</code>","text":"<p>Initialize RMS calculation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.RmsTrend.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) frame_length : int     Frame length, default is 2048 hop_length : int     Hop length, default is 512 ref : Union[list[float], float]     Reference value(s) for dB calculation dB : bool     Whether to convert to decibels Aw : bool     Whether to apply A-weighting before RMS calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    ref: Union[list[float], float] = 1.0,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; None:\n    \"\"\"\n    Initialize RMS calculation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    frame_length : int\n        Frame length, default is 2048\n    hop_length : int\n        Hop length, default is 512\n    ref : Union[list[float], float]\n        Reference value(s) for dB calculation\n    dB : bool\n        Whether to convert to decibels\n    Aw : bool\n        Whether to apply A-weighting before RMS calculation\n    \"\"\"\n    self.frame_length = frame_length\n    self.hop_length = hop_length\n    self.dB = dB\n    self.Aw = Aw\n    self.ref = np.array(ref if isinstance(ref, list) else [ref])\n    super().__init__(\n        sampling_rate,\n        frame_length=frame_length,\n        hop_length=hop_length,\n        dB=dB,\n        Aw=Aw,\n        ref=self.ref,\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.RmsTrend.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.RmsTrend.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/ja/api/#wandas.processing.time_series.RmsTrend.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, frames)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, frames)\n    \"\"\"\n    n_frames = librosa.feature.rms(\n        y=np.ones((1, input_shape[-1])),\n        frame_length=self.frame_length,\n        hop_length=self.hop_length,\n    ).shape[-1]\n    return (*input_shape[:-1], n_frames)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.STFT","title":"<code>STFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Short-Time Fourier Transform operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class STFT(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Short-Time Fourier Transform operation\"\"\"\n\n    name = \"stft\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ):\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.noverlap = (\n            self.win_length - self.hop_length if hop_length is not None else None\n        )\n        self.window = window\n\n        self.SFT = ShortTimeFFT(\n            win=get_window(window, self.win_length),\n            hop=self.hop_length,\n            fs=sampling_rate,\n            mfft=self.n_fft,\n            scale_to=\"magnitude\",\n        )\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        n_samples = input_shape[-1]\n        n_f = len(self.SFT.f)\n        n_t = len(self.SFT.t(n_samples))\n        return (input_shape[0], n_f, n_t)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Apply SciPy STFT processing to multiple channels at once\"\"\"\n        logger.debug(f\"Applying SciPy STFT to array with shape: {x.shape}\")\n\n        # Convert 1D input to 2D\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n\n        # Apply STFT to all channels at once\n        result: NDArrayComplex = self.SFT.stft(x)\n        result[..., 1:-1, :] *= 2.0\n        logger.debug(f\"SciPy STFT applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.STFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.STFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/ja/api/#wandas.processing.time_series.STFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    n_samples = input_shape[-1]\n    n_f = len(self.SFT.f)\n    n_t = len(self.SFT.t(n_samples))\n    return (input_shape[0], n_f, n_t)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.Sum","title":"<code>Sum</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Sum calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Sum(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Sum calculation\"\"\"\n\n    name = \"sum\"\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # Use Dask's aggregate function directly without map_blocks\n        return data.sum(axis=0, keepdims=True)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.TransferFunction","title":"<code>TransferFunction</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Transfer function estimation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class TransferFunction(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Transfer function estimation operation\"\"\"\n\n    name = \"transfer_function\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ):\n        \"\"\"\n        Initialize transfer function estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        scaling : str\n            Type of scaling\n        average : str\n            Method of averaging\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        self.scaling = scaling\n        self.average = average\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n            scaling=scaling,\n            average=average,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Processor function for transfer function estimation operation\"\"\"\n        logger.debug(\n            f\"Applying transfer function estimation to array with shape: {x.shape}\"\n        )\n        from scipy import signal as ss\n\n        # Calculate cross-spectral density between all channels\n        f, p_yx = ss.csd(\n            x=x[:, np.newaxis, :],\n            y=x[np.newaxis, :, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n            axis=-1,\n        )\n        # p_yx shape: (num_channels, num_channels, num_frequencies)\n\n        # Calculate power spectral density for each channel\n        f, p_xx = ss.welch(\n            x=x,\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n            axis=-1,\n        )\n        # p_xx shape: (num_channels, num_frequencies)\n\n        # Calculate transfer function H(f) = P_yx / P_xx\n        h_f = p_yx / p_xx[np.newaxis, :, :]\n        result: NDArrayComplex = h_f.transpose(1, 0, 2).reshape(-1, h_f.shape[-1])\n\n        logger.debug(\n            f\"Transfer function estimation applied, result shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.TransferFunction.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend, scaling='spectrum', average='mean')</code>","text":"<p>Initialize transfer function estimation operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.TransferFunction.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend scaling : str     Type of scaling average : str     Method of averaging</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n):\n    \"\"\"\n    Initialize transfer function estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    scaling : str\n        Type of scaling\n    average : str\n        Method of averaging\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    self.scaling = scaling\n    self.average = average\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n        scaling=scaling,\n        average=average,\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.TransferFunction.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.TransferFunction.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/ja/api/#wandas.processing.time_series.TransferFunction.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.Trim","title":"<code>Trim</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Trimming operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Trim(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Trimming operation\"\"\"\n\n    name = \"trim\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        start: float,\n        end: float,\n    ):\n        \"\"\"\n        Initialize trimming operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        start : float\n            Start time for trimming (seconds)\n        end : float\n            End time for trimming (seconds)\n        \"\"\"\n        super().__init__(sampling_rate, start=start, end=end)\n        self.start = start\n        self.end = end\n        self.start_sample = int(start * sampling_rate)\n        self.end_sample = int(end * sampling_rate)\n        logger.debug(\n            f\"Initialized Trim operation with start: {self.start}, end: {self.end}\"\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after trimming\n        # Exclude parts where there is no signal\n        end_sample = min(self.end_sample, input_shape[-1])\n        n_samples = end_sample - self.start_sample\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for trimming operation\"\"\"\n        logger.debug(f\"Applying trim to array with shape: {x.shape}\")\n        # Apply trimming\n        result = x[..., self.start_sample : self.end_sample]\n        logger.debug(f\"Trim applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.Trim.__init__","title":"<code>__init__(sampling_rate, start, end)</code>","text":"<p>Initialize trimming operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.Trim.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) start : float     Start time for trimming (seconds) end : float     End time for trimming (seconds)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    start: float,\n    end: float,\n):\n    \"\"\"\n    Initialize trimming operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    start : float\n        Start time for trimming (seconds)\n    end : float\n        End time for trimming (seconds)\n    \"\"\"\n    super().__init__(sampling_rate, start=start, end=end)\n    self.start = start\n    self.end = end\n    self.start_sample = int(start * sampling_rate)\n    self.end_sample = int(end * sampling_rate)\n    logger.debug(\n        f\"Initialized Trim operation with start: {self.start}, end: {self.end}\"\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.Trim.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.Trim.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/ja/api/#wandas.processing.time_series.Trim.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after trimming\n    # Exclude parts where there is no signal\n    end_sample = min(self.end_sample, input_shape[-1])\n    n_samples = end_sample - self.start_sample\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.Welch","title":"<code>Welch</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Welch</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Welch(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Welch\"\"\"\n\n    name = \"welch\"\n    n_fft: int\n    window: str\n    hop_length: Optional[int]\n    win_length: Optional[int]\n    average: str\n    detrend: str\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        average: str = \"mean\",\n        detrend: str = \"constant\",\n    ):\n        \"\"\"\n        Initialize Welch operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int, optional\n            FFT size, default is 2048\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.noverlap = (\n            self.win_length - self.hop_length if hop_length is not None else None\n        )\n        self.window = window\n        self.average = average\n        self.detrend = detrend\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n            average=average,\n            detrend=detrend,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, freqs)\n        \"\"\"\n        n_freqs = self.n_fft // 2 + 1\n        return (*input_shape[:-1], n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for Welch operation\"\"\"\n        from scipy import signal as ss\n\n        _, result = ss.welch(\n            x,\n            nperseg=self.win_length,\n            noverlap=self.noverlap,\n            nfft=self.n_fft,\n            window=self.window,\n            average=self.average,\n            detrend=self.detrend,\n            scaling=\"spectrum\",\n        )\n\n        if not isinstance(x, np.ndarray):\n            # Trigger computation for Dask array\n            raise ValueError(\n                \"Welch operation requires a Dask array, but received a non-ndarray.\"\n            )\n        return np.array(result)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.Welch.__init__","title":"<code>__init__(sampling_rate, n_fft=2048, hop_length=None, win_length=None, window='hann', average='mean', detrend='constant')</code>","text":"<p>Initialize Welch operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.Welch.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int, optional     FFT size, default is 2048 window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    average: str = \"mean\",\n    detrend: str = \"constant\",\n):\n    \"\"\"\n    Initialize Welch operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int, optional\n        FFT size, default is 2048\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.noverlap = (\n        self.win_length - self.hop_length if hop_length is not None else None\n    )\n    self.window = window\n    self.average = average\n    self.detrend = detrend\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        win_length=self.win_length,\n        hop_length=self.hop_length,\n        window=window,\n        average=average,\n        detrend=detrend,\n    )\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.Welch.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/ja/api/#wandas.processing.time_series.Welch.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/ja/api/#wandas.processing.time_series.Welch.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, freqs)\n    \"\"\"\n    n_freqs = self.n_fft // 2 + 1\n    return (*input_shape[:-1], n_freqs)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.create_operation","title":"<code>create_operation(name, sampling_rate, **params)</code>","text":"<p>Create operation instance from name and parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def create_operation(\n    name: str, sampling_rate: float, **params: Any\n) -&gt; AudioOperation[Any, Any]:\n    \"\"\"Create operation instance from name and parameters\"\"\"\n    operation_class = get_operation(name)\n    return operation_class(sampling_rate, **params)\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.get_operation","title":"<code>get_operation(name)</code>","text":"<p>Get operation class by name</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def get_operation(name: str) -&gt; type[AudioOperation[Any, Any]]:\n    \"\"\"Get operation class by name\"\"\"\n    if name not in _OPERATION_REGISTRY:\n        raise ValueError(f\"Unknown operation type: {name}\")\n    return _OPERATION_REGISTRY[name]\n</code></pre>"},{"location":"en/ja/api/#wandas.processing.time_series.register_operation","title":"<code>register_operation(operation_class)</code>","text":"<p>Register a new operation type</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def register_operation(operation_class: type) -&gt; None:\n    \"\"\"Register a new operation type\"\"\"\n\n    if not issubclass(operation_class, AudioOperation):\n        raise TypeError(\"Strategy class must inherit from AudioOperation.\")\n    if inspect.isabstract(operation_class):\n        raise TypeError(\"Cannot register abstract AudioOperation class.\")\n\n    _OPERATION_REGISTRY[operation_class.name] = operation_class\n</code></pre>"},{"location":"en/ja/api/#_4","title":"\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3","text":""},{"location":"en/ja/api/core/","title":"\u30b3\u30a2\u30e2\u30b8\u30e5\u30fc\u30eb\uff08Core\uff09","text":"<p>\u3053\u306e\u30da\u30fc\u30b8\u3067\u306fWandas\u306e\u30b3\u30a2\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002\u30b3\u30a2\u30e2\u30b8\u30e5\u30fc\u30eb\u306fWandas\u306e\u57fa\u672c\u30c7\u30fc\u30bf\u69cb\u9020\u3068\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"en/ja/api/core/#baseframe","title":"BaseFrame","text":"<p><code>BaseFrame</code>\u306fWandas\u306e\u5168\u3066\u306e\u30d5\u30ec\u30fc\u30e0\u30af\u30e9\u30b9\u306e\u57fa\u5e95\u30af\u30e9\u30b9\u3067\u3059\u3002\u76f4\u63a5\u3053\u306e\u30af\u30e9\u30b9\u3092\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u5316\u3059\u308b\u3053\u3068\u306f\u306a\u304f\u3001\u6d3e\u751f\u30af\u30e9\u30b9\uff08ChannelFrame\u306a\u3069\uff09\u3092\u901a\u3058\u3066\u4f7f\u7528\u3057\u307e\u3059\u3002</p> <pre><code>from wandas.core.base_frame import BaseFrame\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for all signal frame types.</p> <p>This class provides the common interface and functionality for all frame types used in signal processing. It implements basic operations like indexing, iteration, and data manipulation that are shared across all frame types.</p>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The signal data to process. Must be a dask array. sampling_rate : float     The sampling rate of the signal in Hz. label : str, optional     A label for the frame. If not provided, defaults to \"unnamed_frame\". metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame--attributes","title":"Attributes","text":"<p>sampling_rate : float     The sampling rate of the signal in Hz. label : str     The label of the frame. metadata : dict     Additional metadata for the frame. operation_history : list[dict]     History of operations performed on this frame.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>class BaseFrame(ABC, Generic[T]):\n    \"\"\"\n    Abstract base class for all signal frame types.\n\n    This class provides the common interface and functionality for all frame types\n    used in signal processing. It implements basic operations like indexing, iteration,\n    and data manipulation that are shared across all frame types.\n\n    Parameters\n    ----------\n    data : DaArray\n        The signal data to process. Must be a dask array.\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str, optional\n        A label for the frame. If not provided, defaults to \"unnamed_frame\".\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str\n        The label of the frame.\n    metadata : dict\n        Additional metadata for the frame.\n    operation_history : list[dict]\n        History of operations performed on this frame.\n    \"\"\"\n\n    _data: DaArray\n    sampling_rate: float\n    label: str\n    metadata: dict[str, Any]\n    operation_history: list[dict[str, Any]]\n    _channel_metadata: list[ChannelMetadata]\n    _previous: Optional[\"BaseFrame[Any]\"]\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ):\n        self._data = data.rechunk(chunks=-1)  # type: ignore [unused-ignore]\n        if self._data.ndim == 1:\n            self._data = self._data.reshape((1, -1))\n        self.sampling_rate = sampling_rate\n        self.label = label or \"unnamed_frame\"\n        self.metadata = metadata or {}\n        self.operation_history = operation_history or []\n        self._previous = previous\n\n        if channel_metadata:\n            self._channel_metadata = copy.deepcopy(channel_metadata)\n        else:\n            self._channel_metadata = [\n                ChannelMetadata(label=f\"ch{i}\", unit=\"\", extra={})\n                for i in range(self._n_channels)\n            ]\n\n        try:\n            # Display information for newer dask versions\n            logger.debug(f\"Dask graph layers: {list(self._data.dask.layers.keys())}\")\n            logger.debug(\n                f\"Dask graph dependencies: {len(self._data.dask.dependencies)}\"\n            )\n        except Exception as e:\n            logger.debug(f\"Dask graph visualization details unavailable: {e}\")\n\n    @property\n    @abstractmethod\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n\n    @property\n    def n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return len(self)\n\n    @property\n    def channels(self) -&gt; list[ChannelMetadata]:\n        \"\"\"Property to access channel metadata.\"\"\"\n        return self._channel_metadata\n\n    @property\n    def previous(self) -&gt; Optional[\"BaseFrame[Any]\"]:\n        \"\"\"\n        Returns the previous frame.\n        \"\"\"\n        return self._previous\n\n    def get_channel(self: S, channel_idx: int) -&gt; S:\n        n_channels = len(self)\n        if channel_idx &lt; 0 or channel_idx &gt;= n_channels:\n            range_max = n_channels - 1\n            raise ValueError(\n                f\"Channel index out of range: {channel_idx} \"\n                f\"(valid range: 0-{range_max})\"\n            )\n        logger.debug(f\"Extracting channel index={channel_idx} (lazy operation).\")\n        channel_data = self._data[channel_idx : channel_idx + 1]\n\n        return self._create_new_instance(\n            data=channel_data,\n            operation_history=self.operation_history,\n            channel_metadata=[self._channel_metadata[channel_idx]],\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Returns the number of channels.\n        \"\"\"\n        return len(self._channel_metadata)\n\n    def __iter__(self: S) -&gt; Iterator[S]:\n        for idx in range(len(self)):\n            yield self[idx]\n\n    def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n        \"\"\"\n        Method to get a channel by name or index.\n\n        Parameters\n        ----------\n        key : str, int, slice, or tuple of slices\n            Channel name (label) or index number.\n\n        Returns\n        -------\n        BaseFrame\n            The corresponding channel.\n\n        Raises\n        ------\n        ValueError\n            If the key length is invalid for the shape.\n        IndexError\n            If the channel index is out of range.\n        TypeError\n            If the key type is invalid.\n        \"\"\"\n        if isinstance(key, str):\n            index = self.label2index(key)\n            return self.get_channel(index)\n\n        elif isinstance(key, tuple):\n            # When key is a tuple, treat the first element as an index\n            if len(key) &gt; len(self.shape):\n                raise ValueError(\n                    f\"Invalid key length: {len(key)} for shape {self.shape}\"\n                )\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key[0]]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, slice):\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, numbers.Integral):\n            # Access by index number\n            if key &lt; 0 or key &gt;= len(self):\n                raise IndexError(f\"Channel index {key} out of range.\")\n            return self.get_channel(key)\n        else:\n            raise TypeError(\n                f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n            )\n\n    def label2index(self, label: str) -&gt; int:\n        \"\"\"\n        Get the index from a channel label.\n\n        Parameters\n        ----------\n        label : str\n            Channel label.\n\n        Returns\n        -------\n        int\n            Corresponding index.\n\n        Raises\n        ------\n        KeyError\n            If the channel label is not found.\n        \"\"\"\n        for idx, ch in enumerate(self._channel_metadata):\n            if ch.label == label:\n                return idx\n        raise KeyError(f\"Channel label '{label}' not found.\")\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        _shape: tuple[int, ...] = self._data.shape\n        return _shape\n\n    @property\n    def data(self) -&gt; T:\n        \"\"\"\n        Returns the computed data.\n        Calculation is executed the first time this is accessed.\n        \"\"\"\n        return self.compute()\n\n    @property\n    def labels(self) -&gt; list[str]:\n        \"\"\"Get a list of all channel labels.\"\"\"\n        return [ch.label for ch in self._channel_metadata]\n\n    def compute(self) -&gt; T:\n        \"\"\"\n        Compute and return the data.\n        This method materializes lazily computed data into a concrete NumPy array.\n\n        Returns\n        -------\n        NDArrayReal\n            The computed data.\n\n        Raises\n        ------\n        ValueError\n            If the computed result is not a NumPy array.\n        \"\"\"\n        logger.debug(\n            \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n        )\n        result = self._data.compute()\n\n        if not isinstance(result, np.ndarray):\n            raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n        logger.debug(f\"Computation complete, result shape: {result.shape}\")\n        return cast(T, result)\n\n    @abstractmethod\n    def plot(\n        self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n    ) -&gt; Union[Axes, Iterator[Axes]]:\n        \"\"\"Plot the data\"\"\"\n        pass\n\n    def persist(self: S) -&gt; S:\n        \"\"\"Persist the data in memory\"\"\"\n        persisted_data = self._data.persist()\n        return self._create_new_instance(data=persisted_data)\n\n    @abstractmethod\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Abstract method for derived classes to provide\n        additional initialization arguments.\n        \"\"\"\n        pass\n\n    def _create_new_instance(self: S, data: DaArray, **kwargs: Any) -&gt; S:\n        \"\"\"\n        Create a new channel instance based on an existing channel.\n        Keyword arguments can override or extend the original attributes.\n        \"\"\"\n\n        sampling_rate = kwargs.pop(\"sampling_rate\", self.sampling_rate)\n        # if not isinstance(sampling_rate, int):\n        #     raise TypeError(\"Sampling rate must be an integer\")\n\n        label = kwargs.pop(\"label\", self.label)\n        if not isinstance(label, str):\n            raise TypeError(\"Label must be a string\")\n\n        metadata = kwargs.pop(\"metadata\", copy.deepcopy(self.metadata))\n        if not isinstance(metadata, dict):\n            raise TypeError(\"Metadata must be a dictionary\")\n\n        # Get additional initialization arguments from derived classes\n        additional_kwargs = self._get_additional_init_kwargs()\n        kwargs.update(additional_kwargs)\n\n        return type(self)(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            previous=self,\n            **kwargs,\n        )\n\n    def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n        \"\"\"Implicit conversion to NumPy array\"\"\"\n        result = self.compute()\n        if dtype is not None:\n            return result.astype(dtype)\n        return result\n\n    def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n        \"\"\"Visualize the computation graph and save it to a file\"\"\"\n        try:\n            filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n            self._data.visualize(filename=filename)\n            return filename\n        except Exception as e:\n            logger.warning(f\"Failed to visualize the graph: {e}\")\n            return None\n\n    @abstractmethod\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"Basic implementation of binary operations\"\"\"\n        # Basic logic\n        # Actual implementation is left to derived classes\n        pass\n\n    def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Addition operator\"\"\"\n        return self._binary_op(other, lambda x, y: x + y, \"+\")\n\n    def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Subtraction operator\"\"\"\n        return self._binary_op(other, lambda x, y: x - y, \"-\")\n\n    def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Multiplication operator\"\"\"\n        return self._binary_op(other, lambda x, y: x * y, \"*\")\n\n    def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Division operator\"\"\"\n        return self._binary_op(other, lambda x, y: x / y, \"/\")\n\n    def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Apply a named operation.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters to pass to the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        # Apply the operation through abstract method\n        return self._apply_operation_impl(operation_name, **params)\n\n    @abstractmethod\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"Implementation of operation application\"\"\"\n        pass\n\n    def debug_info(self) -&gt; None:\n        \"\"\"Output detailed debug information\"\"\"\n        logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n        logger.debug(f\"Label: {self.label}\")\n        logger.debug(f\"Shape: {self.shape}\")\n        logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n        logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n        self._debug_info_impl()\n        logger.debug(\"=== End Debug Info ===\")\n\n    def _debug_info_impl(self) -&gt; None:\n        \"\"\"Implement derived class-specific debug information\"\"\"\n        pass\n</code></pre>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.channels","title":"<code>channels</code>  <code>property</code>","text":"<p>Property to access channel metadata.</p>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.data","title":"<code>data</code>  <code>property</code>","text":"<p>Returns the computed data. Calculation is executed the first time this is accessed.</p>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>Get a list of all channel labels.</p>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.n_channels","title":"<code>n_channels</code>  <code>property</code>","text":"<p>Returns the number of channels.</p>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.previous","title":"<code>previous</code>  <code>property</code>","text":"<p>Returns the previous frame.</p>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.__add__","title":"<code>__add__(other)</code>","text":"<p>Addition operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Addition operator\"\"\"\n    return self._binary_op(other, lambda x, y: x + y, \"+\")\n</code></pre>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.__array__","title":"<code>__array__(dtype=None)</code>","text":"<p>Implicit conversion to NumPy array</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n    \"\"\"Implicit conversion to NumPy array\"\"\"\n    result = self.compute()\n    if dtype is not None:\n        return result.astype(dtype)\n    return result\n</code></pre>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Method to get a channel by name or index.</p>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.__getitem__--parameters","title":"Parameters","text":"<p>key : str, int, slice, or tuple of slices     Channel name (label) or index number.</p>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.__getitem__--returns","title":"Returns","text":"<p>BaseFrame     The corresponding channel.</p>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.__getitem__--raises","title":"Raises","text":"<p>ValueError     If the key length is invalid for the shape. IndexError     If the channel index is out of range. TypeError     If the key type is invalid.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n    \"\"\"\n    Method to get a channel by name or index.\n\n    Parameters\n    ----------\n    key : str, int, slice, or tuple of slices\n        Channel name (label) or index number.\n\n    Returns\n    -------\n    BaseFrame\n        The corresponding channel.\n\n    Raises\n    ------\n    ValueError\n        If the key length is invalid for the shape.\n    IndexError\n        If the channel index is out of range.\n    TypeError\n        If the key type is invalid.\n    \"\"\"\n    if isinstance(key, str):\n        index = self.label2index(key)\n        return self.get_channel(index)\n\n    elif isinstance(key, tuple):\n        # When key is a tuple, treat the first element as an index\n        if len(key) &gt; len(self.shape):\n            raise ValueError(\n                f\"Invalid key length: {len(key)} for shape {self.shape}\"\n            )\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key[0]]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, slice):\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, numbers.Integral):\n        # Access by index number\n        if key &lt; 0 or key &gt;= len(self):\n            raise IndexError(f\"Channel index {key} out of range.\")\n        return self.get_channel(key)\n    else:\n        raise TypeError(\n            f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n        )\n</code></pre>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of channels.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of channels.\n    \"\"\"\n    return len(self._channel_metadata)\n</code></pre>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplication operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Multiplication operator\"\"\"\n    return self._binary_op(other, lambda x, y: x * y, \"*\")\n</code></pre>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtraction operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Subtraction operator\"\"\"\n    return self._binary_op(other, lambda x, y: x - y, \"-\")\n</code></pre>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Division operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Division operator\"\"\"\n    return self._binary_op(other, lambda x, y: x / y, \"/\")\n</code></pre>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.apply_operation","title":"<code>apply_operation(operation_name, **params)</code>","text":"<p>Apply a named operation.</p>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.apply_operation--parameters","title":"Parameters","text":"<p>operation_name : str     Name of the operation to apply. **params : Any     Parameters to pass to the operation.</p>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.apply_operation--returns","title":"Returns","text":"<p>S     A new instance with the operation applied.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n    \"\"\"\n    Apply a named operation.\n\n    Parameters\n    ----------\n    operation_name : str\n        Name of the operation to apply.\n    **params : Any\n        Parameters to pass to the operation.\n\n    Returns\n    -------\n    S\n        A new instance with the operation applied.\n    \"\"\"\n    # Apply the operation through abstract method\n    return self._apply_operation_impl(operation_name, **params)\n</code></pre>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.compute","title":"<code>compute()</code>","text":"<p>Compute and return the data. This method materializes lazily computed data into a concrete NumPy array.</p>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.compute--returns","title":"Returns","text":"<p>NDArrayReal     The computed data.</p>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.compute--raises","title":"Raises","text":"<p>ValueError     If the computed result is not a NumPy array.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def compute(self) -&gt; T:\n    \"\"\"\n    Compute and return the data.\n    This method materializes lazily computed data into a concrete NumPy array.\n\n    Returns\n    -------\n    NDArrayReal\n        The computed data.\n\n    Raises\n    ------\n    ValueError\n        If the computed result is not a NumPy array.\n    \"\"\"\n    logger.debug(\n        \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n    )\n    result = self._data.compute()\n\n    if not isinstance(result, np.ndarray):\n        raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n    logger.debug(f\"Computation complete, result shape: {result.shape}\")\n    return cast(T, result)\n</code></pre>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.debug_info","title":"<code>debug_info()</code>","text":"<p>Output detailed debug information</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def debug_info(self) -&gt; None:\n    \"\"\"Output detailed debug information\"\"\"\n    logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n    logger.debug(f\"Label: {self.label}\")\n    logger.debug(f\"Shape: {self.shape}\")\n    logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n    logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n    self._debug_info_impl()\n    logger.debug(\"=== End Debug Info ===\")\n</code></pre>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.label2index","title":"<code>label2index(label)</code>","text":"<p>Get the index from a channel label.</p>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.label2index--parameters","title":"Parameters","text":"<p>label : str     Channel label.</p>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.label2index--returns","title":"Returns","text":"<p>int     Corresponding index.</p>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.label2index--raises","title":"Raises","text":"<p>KeyError     If the channel label is not found.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def label2index(self, label: str) -&gt; int:\n    \"\"\"\n    Get the index from a channel label.\n\n    Parameters\n    ----------\n    label : str\n        Channel label.\n\n    Returns\n    -------\n    int\n        Corresponding index.\n\n    Raises\n    ------\n    KeyError\n        If the channel label is not found.\n    \"\"\"\n    for idx, ch in enumerate(self._channel_metadata):\n        if ch.label == label:\n            return idx\n    raise KeyError(f\"Channel label '{label}' not found.\")\n</code></pre>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.persist","title":"<code>persist()</code>","text":"<p>Persist the data in memory</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def persist(self: S) -&gt; S:\n    \"\"\"Persist the data in memory\"\"\"\n    persisted_data = self._data.persist()\n    return self._create_new_instance(data=persisted_data)\n</code></pre>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.plot","title":"<code>plot(plot_type='default', ax=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Plot the data</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>@abstractmethod\ndef plot(\n    self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n) -&gt; Union[Axes, Iterator[Axes]]:\n    \"\"\"Plot the data\"\"\"\n    pass\n</code></pre>"},{"location":"en/ja/api/core/#wandas.core.base_frame.BaseFrame.visualize_graph","title":"<code>visualize_graph(filename=None)</code>","text":"<p>Visualize the computation graph and save it to a file</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"Visualize the computation graph and save it to a file\"\"\"\n    try:\n        filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n        self._data.visualize(filename=filename)\n        return filename\n    except Exception as e:\n        logger.warning(f\"Failed to visualize the graph: {e}\")\n        return None\n</code></pre>"},{"location":"en/ja/api/core/#channelmetadata","title":"ChannelMetadata","text":"<p><code>ChannelMetadata</code>\u306f\u30c1\u30e3\u30f3\u30cd\u30eb\u3054\u3068\u306e\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u7ba1\u7406\u3059\u308b\u305f\u3081\u306e\u30af\u30e9\u30b9\u3067\u3059\u3002\u30c1\u30e3\u30f3\u30cd\u30eb\u540d\u3001\u5358\u4f4d\u3001\u305d\u306e\u4ed6\u306e\u4ed8\u52a0\u60c5\u5831\u3092\u4fdd\u6301\u3057\u307e\u3059\u3002</p> <pre><code>from wandas.core.metadata import ChannelMetadata\n\n# \u4f7f\u7528\u4f8b\nmetadata = ChannelMetadata(label=\"\u5de6\u30c1\u30e3\u30f3\u30cd\u30eb\", unit=\"dB\", extra={\"\u30c7\u30d0\u30a4\u30b9\": \"\u30de\u30a4\u30af\"})\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>Data class for storing channel metadata</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>class ChannelMetadata(BaseModel):\n    \"\"\"\n    Data class for storing channel metadata\n    \"\"\"\n\n    label: str = \"\"\n    unit: str = \"\"\n    ref: float = 1.0\n    # Additional metadata for extensibility\n    extra: dict[str, Any] = Field(default_factory=dict)\n\n    def __getitem__(self, key: str) -&gt; Any:\n        \"\"\"Provide dictionary-like behavior\"\"\"\n        if key == \"label\":\n            return self.label\n        elif key == \"unit\":\n            return self.unit\n        elif key == \"ref\":\n            return self.ref\n        else:\n            return self.extra.get(key)\n\n    def __setitem__(self, key: str, value: Any) -&gt; None:\n        \"\"\"Provide dictionary-like behavior\"\"\"\n        if key == \"label\":\n            self.label = value\n        elif key == \"unit\":\n            self.unit = value\n        elif key == \"ref\":\n            self.ref = value\n        else:\n            self.extra[key] = value\n\n    def to_json(self) -&gt; str:\n        \"\"\"Convert to JSON format\"\"\"\n        json_data: str = self.model_dump_json(indent=4)\n        return json_data\n\n    @classmethod\n    def from_json(cls, json_data: str) -&gt; \"ChannelMetadata\":\n        \"\"\"Convert from JSON format\"\"\"\n        root_model: ChannelMetadata = ChannelMetadata.model_validate_json(json_data)\n\n        return root_model\n</code></pre>"},{"location":"en/ja/api/core/#wandas.core.metadata.ChannelMetadata.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Provide dictionary-like behavior</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Any:\n    \"\"\"Provide dictionary-like behavior\"\"\"\n    if key == \"label\":\n        return self.label\n    elif key == \"unit\":\n        return self.unit\n    elif key == \"ref\":\n        return self.ref\n    else:\n        return self.extra.get(key)\n</code></pre>"},{"location":"en/ja/api/core/#wandas.core.metadata.ChannelMetadata.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Provide dictionary-like behavior</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def __setitem__(self, key: str, value: Any) -&gt; None:\n    \"\"\"Provide dictionary-like behavior\"\"\"\n    if key == \"label\":\n        self.label = value\n    elif key == \"unit\":\n        self.unit = value\n    elif key == \"ref\":\n        self.ref = value\n    else:\n        self.extra[key] = value\n</code></pre>"},{"location":"en/ja/api/core/#wandas.core.metadata.ChannelMetadata.from_json","title":"<code>from_json(json_data)</code>  <code>classmethod</code>","text":"<p>Convert from JSON format</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>@classmethod\ndef from_json(cls, json_data: str) -&gt; \"ChannelMetadata\":\n    \"\"\"Convert from JSON format\"\"\"\n    root_model: ChannelMetadata = ChannelMetadata.model_validate_json(json_data)\n\n    return root_model\n</code></pre>"},{"location":"en/ja/api/core/#wandas.core.metadata.ChannelMetadata.to_json","title":"<code>to_json()</code>","text":"<p>Convert to JSON format</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Convert to JSON format\"\"\"\n    json_data: str = self.model_dump_json(indent=4)\n    return json_data\n</code></pre>"},{"location":"en/ja/api/frames/","title":"\u30d5\u30ec\u30fc\u30e0\u30e2\u30b8\u30e5\u30fc\u30eb\uff08Frames\uff09","text":"<p>\u3053\u306e\u30da\u30fc\u30b8\u3067\u306fWandas\u306e\u30d5\u30ec\u30fc\u30e0\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002\u30d5\u30ec\u30fc\u30e0\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u306f\u3001\u3055\u307e\u3056\u307e\u306a\u30bf\u30a4\u30d7\u306e\u30c7\u30fc\u30bf\u30d5\u30ec\u30fc\u30e0\u304c\u542b\u307e\u308c\u3066\u3044\u307e\u3059\u3002</p>"},{"location":"en/ja/api/frames/#channelframe","title":"ChannelFrame","text":"<p><code>ChannelFrame</code>\u306f\u6642\u9593\u9818\u57df\u306e\u4fe1\u53f7\u30c7\u30fc\u30bf\u3092\u6271\u3046\u30d5\u30ec\u30fc\u30e0\u3067\u3059\u3002</p> <pre><code>from wandas.frames.channel import ChannelFrame\n\n# \u307e\u305f\u306f\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")  # ChannelFrame\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u8fd4\u3057\u307e\u3059\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Channel-based data frame for handling audio signals and time series data.</p> <p>This frame represents channel-based data such as audio signals and time series data, with each channel containing data samples in the time domain.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>class ChannelFrame(BaseFrame[NDArrayReal]):\n    \"\"\"Channel-based data frame for handling audio signals and time series data.\n\n    This frame represents channel-based data such as audio signals and time series data,\n    with each channel containing data samples in the time domain.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"Initialize a ChannelFrame.\n\n        Args:\n            data: Dask array containing channel data.\n            Shape should be (n_channels, n_samples).\n            sampling_rate: The sampling rate of the data in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            operation_history: History of operations applied to the frame.\n            channel_metadata: Metadata for each channel.\n            previous: Reference to the previous frame in the processing chain.\n\n        Raises:\n            ValueError: If data has more than 2 dimensions.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return self.shape[-2]\n\n    @property\n    def time(self) -&gt; NDArrayReal:\n        \"\"\"Get time array for the signal.\n\n        Returns:\n            Array of time points in seconds.\n        \"\"\"\n        return np.arange(self.n_samples) / self.sampling_rate\n\n    @property\n    def n_samples(self) -&gt; int:\n        \"\"\"Returns the number of samples.\"\"\"\n        n: int = self._data.shape[-1]\n        return n\n\n    @property\n    def duration(self) -&gt; float:\n        \"\"\"Returns the duration in seconds.\"\"\"\n        return self.n_samples / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # Apply processing to data\n        processed_data = operation.process(self._data)\n\n        # Update metadata\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        if operation_name == \"resampling\":\n            # For resampling, update sampling rate\n            return self._create_new_instance(\n                sampling_rate=params[\"target_sr\"],\n                data=processed_data,\n                metadata=new_metadata,\n                operation_history=new_history,\n            )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Common implementation for binary operations\n        - utilizing dask's lazy evaluation.\n\n        Args:\n            other: Right operand for the operation.\n            op: Function to execute the operation (e.g., lambda a, b: a + b).\n            symbol: Symbolic representation of the operation (e.g., '+').\n\n        Returns:\n            A new channel containing the operation result (lazy execution).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, ChannelFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Perform operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other._data)\n\n            # Merge channel metadata\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # Perform operation with scalar, NumPy array, or other types\n        else:\n            # Apply operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other)\n\n            # Operand display string\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # Check for dask.array.Array\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # Update channel metadata\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n                previous=self,\n            )\n\n    def add(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        snr: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Add another signal or value to the current signal.\n\n        If SNR is specified, performs addition with consideration for\n        signal-to-noise ratio.\n\n        Args:\n            other: Signal or value to add.\n            snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n                other signal based on this SNR.\n                self is treated as the signal, and other as the noise.\n\n        Returns:\n            A new channel frame containing the addition result (lazy execution).\n        \"\"\"\n        logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n        # Special processing when SNR is specified\n        if snr is not None:\n            # First convert other to ChannelFrame if it's not\n            if not isinstance(other, ChannelFrame):\n                if isinstance(other, np.ndarray):\n                    other = ChannelFrame.from_numpy(\n                        other, self.sampling_rate, label=\"array_data\"\n                    )\n                elif isinstance(other, (int, float)):\n                    # For scalar values, simply add (ignore SNR)\n                    return self + other\n                else:\n                    raise TypeError(\n                        \"Addition target with SNR must be a ChannelFrame or \"\n                        f\"NumPy array: {type(other)}\"\n                    )\n\n            # Check if sampling rates match\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Apply addition operation with SNR adjustment\n            return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n        # Execute normal addition if SNR is not specified\n        return self + other\n\n    def plot(\n        self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Plot the frame data.\n\n        Args:\n            plot_type: Type of plot. Default is \"waveform\".\n            ax: Optional matplotlib axes for plotting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        plot_strategy = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def rms_plot(\n        self,\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = True,\n        Aw: bool = False,  # noqa: N803\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Generate an RMS plot.\n\n        Args:\n            ax: Optional matplotlib axes for plotting.\n            title: Title for the plot.\n            overlay: Whether to overlay the plot on the existing axis.\n            Aw: Apply A-weighting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        kwargs = kwargs or {}\n        ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n        rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n        return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n\n    def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n        \"\"\"Display visual and audio representation of the frame.\n\n        Args:\n            normalize: Whether to normalize the audio data for playback.\n            **kwargs: Additional parameters for visualization.\n        \"\"\"\n        if \"axis_config\" in kwargs:\n            logger.warning(\n                \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            axis_config = kwargs[\"axis_config\"]\n            if \"time_plot\" in axis_config:\n                kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n            if \"freq_plot\" in axis_config:\n                if \"xlim\" in axis_config[\"freq_plot\"]:\n                    vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                    kwargs[\"vmin\"] = vlim[0]\n                    kwargs[\"vmax\"] = vlim[1]\n                if \"ylim\" in axis_config[\"freq_plot\"]:\n                    ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                    kwargs[\"ylim\"] = ylim\n\n        if \"cbar_config\" in kwargs:\n            logger.warning(\n                \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            cbar_config = kwargs[\"cbar_config\"]\n            if \"vmin\" in cbar_config:\n                kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n            if \"vmax\" in cbar_config:\n                kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n        for ch in self:\n            ax: Axes\n            _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n            if isinstance(_ax, Iterator):\n                ax = next(iter(_ax))\n            elif isinstance(_ax, Axes):\n                ax = _ax\n            else:\n                raise TypeError(\n                    f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n                )\n            # Ignore type checks for display and Audio\n            display(ax.figure)  # type: ignore\n            plt.close(ax.figure)  # type: ignore\n            display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n\n    @classmethod\n    def from_numpy(\n        cls,\n        data: NDArrayReal,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        ch_labels: Optional[list[str]] = None,\n        ch_units: Optional[Union[list[str], str]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        Args:\n            data: NumPy array containing channel data.\n            sampling_rate: The sampling rate in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            ch_labels: Labels for each channel.\n            ch_units: Units for each channel.\n\n        Returns:\n            A new ChannelFrame containing the NumPy data.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n\n        # Convert NumPy array to dask array\n        dask_data = da_from_array(data)\n        cf = ChannelFrame(\n            data=dask_data,\n            sampling_rate=sampling_rate,\n            label=label or \"numpy_data\",\n        )\n        if metadata is not None:\n            cf.metadata = metadata\n        if ch_labels is not None:\n            if len(ch_labels) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel labels does not match the number of channels\"\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        if ch_units is not None:\n            if isinstance(ch_units, str):\n                ch_units = [ch_units] * cf.n_channels\n\n            if len(ch_units) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel units does not match the number of channels\"\n                )\n            for i in range(len(ch_units)):\n                cf._channel_metadata[i].unit = ch_units[i]\n\n        return cf\n\n    @classmethod\n    def from_ndarray(\n        cls,\n        array: NDArrayReal,\n        sampling_rate: float,\n        labels: Optional[list[str]] = None,\n        unit: Optional[Union[list[str], str]] = None,\n        frame_label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        This method is deprecated. Use from_numpy instead.\n\n        Args:\n            array: Signal data. Each row corresponds to a channel.\n            sampling_rate: Sampling rate (Hz).\n            labels: Labels for each channel.\n            unit: Unit of the signal.\n            frame_label: Label for the frame.\n            metadata: Optional metadata dictionary.\n\n        Returns:\n            A new ChannelFrame containing the data.\n        \"\"\"\n        # Redirect to from_numpy for compatibility\n        # However, from_ndarray is deprecated\n        logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n        return cls.from_numpy(\n            data=array,\n            sampling_rate=sampling_rate,\n            label=frame_label,\n            metadata=metadata,\n            ch_labels=labels,\n            ch_units=unit,\n        )\n\n    @classmethod\n    def from_file(\n        cls,\n        path: Union[str, Path],\n        channel: Optional[Union[int, list[int]]] = None,\n        start: Optional[float] = None,\n        end: Optional[float] = None,\n        chunk_size: Optional[int] = None,\n        ch_labels: Optional[list[str]] = None,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from an audio file.\n\n        Args:\n            path: Path to the audio file.\n            channel: Channel(s) to load.\n            start: Start time in seconds.\n            end: End time in seconds.\n            chunk_size: Chunk size for processing.\n            Specifies the splitting size for lazy processing.\n            ch_labels: Labels for each channel.\n            **kwargs: Additional arguments passed to the file reader.\n\n        Returns:\n            A new ChannelFrame containing the loaded audio data.\n\n        Raises:\n            ValueError: If channel selection is invalid.\n            TypeError: If channel parameter type is invalid.\n            FileNotFoundError: If the file doesn't exist.\n        \"\"\"\n        from .channel import ChannelFrame\n\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"File not found: {path}\")\n\n        # Get file reader\n        reader = get_file_reader(path)\n\n        # Get file info\n        info = reader.get_file_info(path, **kwargs)\n        sr = info[\"samplerate\"]\n        n_channels = info[\"channels\"]\n        n_frames = info[\"frames\"]\n        ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n        logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n        # Channel selection processing\n        all_channels = list(range(n_channels))\n\n        if channel is None:\n            channels_to_load = all_channels\n            logger.debug(f\"Will load all channels: {channels_to_load}\")\n        elif isinstance(channel, int):\n            if channel &lt; 0 or channel &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n            channels_to_load = [channel]\n            logger.debug(f\"Will load single channel: {channel}\")\n        elif isinstance(channel, (list, tuple)):\n            for ch in channel:\n                if ch &lt; 0 or ch &gt;= n_channels:\n                    raise ValueError(\n                        f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                    )\n            channels_to_load = list(channel)\n            logger.debug(f\"Will load specific channels: {channels_to_load}\")\n        else:\n            raise TypeError(\"channel must be int, list, or None\")\n\n        # Index calculation\n        start_idx = 0 if start is None else max(0, int(start * sr))\n        end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n        frames_to_read = end_idx - start_idx\n\n        logger.debug(\n            f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n            f\"start_idx={start_idx}, end_idx={end_idx}\"\n        )\n\n        # Settings for lazy loading\n        expected_shape = (len(channels_to_load), frames_to_read)\n\n        # Define the loading function using the file reader\n        def _load_audio() -&gt; NDArrayReal:\n            logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n            # Use the reader to get audio data with parameters\n            out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n            if not isinstance(out, np.ndarray):\n                raise ValueError(\"Unexpected data type after reading file\")\n            return out\n\n        logger.debug(\n            f\"Creating delayed dask task with expected shape: {expected_shape}\"\n        )\n\n        # Create delayed operation\n        delayed_data = dask_delayed(_load_audio)()\n        logger.debug(\"Wrapping delayed function in dask array\")\n\n        # Create dask array from delayed computation\n        dask_array = da_from_delayed(\n            delayed_data, shape=expected_shape, dtype=np.float32\n        )\n\n        if chunk_size is not None:\n            if chunk_size &lt;= 0:\n                raise ValueError(\"Chunk size must be a positive integer\")\n            logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n            dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n        logger.debug(\n            \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n        )\n\n        cf = ChannelFrame(\n            data=dask_array,\n            sampling_rate=sr,\n            label=path.stem,\n            metadata={\n                \"filename\": str(path),\n            },\n        )\n        if ch_labels is not None:\n            if len(ch_labels) != len(cf):\n                raise ValueError(\n                    \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        return cf\n\n    @classmethod\n    def read_wav(\n        cls, filename: str, labels: Optional[list[str]] = None\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a WAV file.\n\n        Args:\n            filename: Path to the WAV file.\n            labels: Labels to set for each channel.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(filename, ch_labels=labels)\n        return cf\n\n    @classmethod\n    def read_csv(\n        cls,\n        filename: str,\n        time_column: Union[int, str] = 0,\n        labels: Optional[list[str]] = None,\n        delimiter: str = \",\",\n        header: Optional[int] = 0,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a CSV file.\n\n        Args:\n            filename: Path to the CSV file.\n            time_column: Index or name of the time column.\n            labels: Labels to set for each channel.\n            delimiter: Delimiter character.\n            header: Row number to use as header.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(\n            filename,\n            ch_labels=labels,\n            time_column=time_column,\n            delimiter=delimiter,\n            header=header,\n        )\n        return cf\n\n    def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n        \"\"\"Save the audio data to a file.\n\n        Args:\n            path: Path to save the file.\n            format: File format. If None, determined from file extension.\n        \"\"\"\n        logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n        data = self.compute()\n        data = data.T\n        if data.shape[1] == 1:\n            data = data.squeeze(axis=1)\n        sf.write(str(path), data, int(self.sampling_rate), format=format)\n        logger.debug(f\"Save complete: {path}\")\n\n    def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a high-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n\n    def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a low-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n\n    def normalize(\n        self, target_level: float = -20, channel_wise: bool = True\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Normalize the signal level.\n\n        This method adjusts the signal amplitude to reach a target RMS level.\n\n        Args:\n            target_level: Target RMS level in dB. Default is -20.\n            channel_wise: If True, normalize each channel independently.\n                If False, apply the same scaling to all channels.\n\n        Returns:\n            A new ChannelFrame containing the normalized signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n        )\n        return self.apply_operation(\n            \"normalize\", target_level=target_level, channel_wise=channel_wise\n        )\n\n    def a_weighting(self) -&gt; \"ChannelFrame\":\n        \"\"\"Apply A-weighting filter to the signal.\n\n        A-weighting adjusts the frequency response to approximate human hearing\n        perception, following IEC 61672-1:2013 standard.\n\n        Returns:\n            A new ChannelFrame with A-weighted signal.\n        \"\"\"\n        return self.apply_operation(\"a_weighting\")\n\n    def hpss_harmonic(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract harmonic components using HPSS\n         (Harmonic-Percussive Source Separation).\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_harmonic\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def hpss_percussive(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract percussive components using HPSS\n        (Harmonic-Percussive Source Separation).\n\n        This method separates the percussive (tonal) components from the signal.\n\n        Args:\n            kernel_size: Median filter size for HPSS.\n            power: Exponent for the Weiner filter used in HPSS.\n            margin: Margin size for the separation.\n\n        Returns:\n            A new ChannelFrame containing the harmonic components.\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_percussive\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def resampling(\n        self,\n        target_sr: float,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Resample audio data.\n\n        Parameters\n        ----------\n        target_sr : float\n            Target sampling rate (Hz)\n        resample_type : str, optional\n            Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n        **kwargs : dict\n            Additional resampling parameters\n\n        Returns\n        -------\n        ChannelFrame\n            Resampled channel frame\n        \"\"\"\n        return self.apply_operation(\n            \"resampling\",\n            target_sr=target_sr,\n            **kwargs,\n        )\n\n    def abs(self) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the absolute value of the signal.\n\n        Returns:\n            A new ChannelFrame containing the absolute values.\n        \"\"\"\n        return self.apply_operation(\"abs\")\n\n    def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the power of the signal.\n\n        Args:\n            exponent: The exponent to raise the signal to. Default is 2.0.\n\n        Returns:\n            A new ChannelFrame containing the signal raised to the power.\n        \"\"\"\n        return self.apply_operation(\"power\", exponent=exponent)\n\n    def trim(\n        self,\n        start: float = 0,\n        end: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Trim the signal to specified time range.\n\n        Args:\n            start: Start time in seconds.\n            end: End time in seconds.\n\n        Returns:\n            A new ChannelFrame with trimmed signal.\n\n        Raises:\n            ValueError: If end time is before start time.\n        \"\"\"\n        if end is None:\n            end = self.duration\n        if start &gt; end:\n            raise ValueError(\"start must be less than end\")\n        # Apply trim operation\n        return self.apply_operation(\"trim\", start=start, end=end)\n\n    def rms_trend(\n        self,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the RMS trend of the signal.\n\n        This method computes the root mean square value over sliding windows.\n\n        Args:\n            frame_length: The size of the sliding window in samples. Default is 2048.\n            hop_length: The hop length between windows in samples. Default is 512.\n            dB: Whether to return the RMS values in decibels. Default is False.\n            Aw: Whether to apply A-weighting. Default is False.\n\n        Returns:\n            A new ChannelFrame containing the RMS trend.\n        \"\"\"\n        cf = self.apply_operation(\n            \"rms_trend\",\n            frame_length=frame_length,\n            hop_length=hop_length,\n            ref=[ch.ref for ch in self._channel_metadata],\n            dB=dB,\n            Aw=Aw,\n        )\n        cf.sampling_rate = self.sampling_rate / hop_length\n        return cf\n\n    def sum(self) -&gt; \"ChannelFrame\":\n        \"\"\"Sum all channels.\n\n        Returns:\n            A new ChannelFrame with summed signal.\n        \"\"\"\n        return self.apply_operation(\"sum\")\n\n    def mean(self) -&gt; \"ChannelFrame\":\n        \"\"\"Average all channels.\n\n        Returns:\n            A new ChannelFrame with averaged signal.\n        \"\"\"\n        return self.apply_operation(\"mean\")\n\n    def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate channel differences relative to a reference channel.\n\n        Args:\n            other_channel: Reference channel index or label. Default is 0.\n\n        Returns:\n            A new ChannelFrame with channel differences.\n        \"\"\"\n        if isinstance(other_channel, str):\n            return self.apply_operation(\n                \"channel_difference\", other_channel=self.label2index(other_channel)\n            )\n        return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n\n    def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n        \"\"\"Compute Fast Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is next power of 2 of data length.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectralFrame containing the FFT results.\n        \"\"\"\n        from ..processing.time_series import FFT\n        from .spectral import SpectralFrame\n\n        params = {\"n_fft\": n_fft, \"window\": window}\n        operation_name = \"fft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"FFT\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        if n_fft is None:\n            is_even = spectrum_data.shape[-1] % 2 == 0\n            _n_fft = (\n                spectrum_data.shape[-1] * 2 - 2\n                if is_even\n                else spectrum_data.shape[-1] * 2 - 1\n            )\n        else:\n            _n_fft = n_fft\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=_n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def welch(\n        self,\n        n_fft: Optional[int] = None,\n        hop_length: Optional[int] = None,\n        win_length: int = 2048,\n        window: str = \"hann\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute power spectral density using Welch's method.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the power spectral density.\n        \"\"\"\n        from ..processing.time_series import Welch\n        from .spectral import SpectralFrame\n\n        params = dict(\n            n_fft=n_fft or win_length,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            average=average,\n        )\n        operation_name = \"welch\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Welch\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"welch\", \"params\": params},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def noct_spectrum(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"Compute N-octave band spectrum.\n\n        Args:\n            fmin: Minimum center frequency in Hz. Default is 20 Hz.\n            fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n            n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n            G: Reference gain in dB. Default is 10 dB.\n            fr: Reference frequency in Hz. Default is 1000 Hz.\n\n        Returns:\n            A NOctFrame containing the N-octave band spectrum.\n        \"\"\"\n        from ..processing.time_series import NOctSpectrum\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_spectrum\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSpectrum\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_spectrum\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def stft(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"Compute Short-Time Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectrogramFrame containing the STFT results.\n        \"\"\"\n        from ..processing.time_series import STFT, create_operation\n        from .spectrogram import SpectrogramFrame\n\n        # Set hop length and window length\n        _hop_length = hop_length if hop_length is not None else n_fft // 4\n        _win_length = win_length if win_length is not None else n_fft\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": _hop_length,\n            \"win_length\": _win_length,\n            \"window\": window,\n        }\n        operation_name = \"stft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"STFT\", operation)\n\n        # Apply processing to data\n        spectrogram_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n\n        # Create new instance\n        return SpectrogramFrame(\n            data=spectrogram_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=n_fft,\n            hop_length=_hop_length,\n            win_length=_win_length,\n            window=window,\n            label=f\"stft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def coherence(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute magnitude squared coherence.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n        Returns:\n            A SpectralFrame containing the magnitude squared coherence.\n        \"\"\"\n        from ..processing.time_series import Coherence, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n        }\n        operation_name = \"coherence\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Coherence\", operation)\n\n        # Apply processing to data\n        coherence_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=coherence_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Coherence of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def csd(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute cross-spectral density matrix.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the cross-spectral density matrix.\n        \"\"\"\n        from ..processing.time_series import CSD, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"csd\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"CSD\", operation)\n\n        # Apply processing to data\n        csd_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=csd_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def transfer_function(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute transfer function matrix.\n\n        The transfer function characterizes the signal transmission properties\n        between channels in the frequency domain, representing the input-output\n        relationship of a system.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the transfer function matrix.\n        \"\"\"\n        from ..processing.time_series import TransferFunction, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"transfer_function\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"TransferFunction\", operation)\n\n        # Apply processing to data\n        tf_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=tf_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Transfer function of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"Provide additional initialization arguments required for ChannelFrame.\"\"\"\n        return {}\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Returns the duration in seconds.</p>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>Returns the number of samples.</p>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.time","title":"<code>time</code>  <code>property</code>","text":"<p>Get time array for the signal.</p> <p>Returns:</p> Type Description <code>NDArrayReal</code> <p>Array of time points in seconds.</p>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.__init__","title":"<code>__init__(data, sampling_rate, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a ChannelFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>Dask array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate of the data in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>operation_history</code> <code>Optional[list[dict[str, Any]]]</code> <p>History of operations applied to the frame.</p> <code>None</code> <code>channel_metadata</code> <code>Optional[list[ChannelMetadata]]</code> <p>Metadata for each channel.</p> <code>None</code> <code>previous</code> <code>Optional[BaseFrame[Any]]</code> <p>Reference to the previous frame in the processing chain.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has more than 2 dimensions.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"Initialize a ChannelFrame.\n\n    Args:\n        data: Dask array containing channel data.\n        Shape should be (n_channels, n_samples).\n        sampling_rate: The sampling rate of the data in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        operation_history: History of operations applied to the frame.\n        channel_metadata: Metadata for each channel.\n        previous: Reference to the previous frame in the processing chain.\n\n    Raises:\n        ValueError: If data has more than 2 dimensions.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.a_weighting","title":"<code>a_weighting()</code>","text":"<p>Apply A-weighting filter to the signal.</p> <p>A-weighting adjusts the frequency response to approximate human hearing perception, following IEC 61672-1:2013 standard.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with A-weighted signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def a_weighting(self) -&gt; \"ChannelFrame\":\n    \"\"\"Apply A-weighting filter to the signal.\n\n    A-weighting adjusts the frequency response to approximate human hearing\n    perception, following IEC 61672-1:2013 standard.\n\n    Returns:\n        A new ChannelFrame with A-weighted signal.\n    \"\"\"\n    return self.apply_operation(\"a_weighting\")\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.abs","title":"<code>abs()</code>","text":"<p>Calculate the absolute value of the signal.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the absolute values.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def abs(self) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the absolute value of the signal.\n\n    Returns:\n        A new ChannelFrame containing the absolute values.\n    \"\"\"\n    return self.apply_operation(\"abs\")\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.add","title":"<code>add(other, snr=None)</code>","text":"<p>Add another signal or value to the current signal.</p> <p>If SNR is specified, performs addition with consideration for signal-to-noise ratio.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[ChannelFrame, int, float, NDArrayReal, Array]</code> <p>Signal or value to add.</p> required <code>snr</code> <code>Optional[float]</code> <p>Signal-to-noise ratio (dB). If specified, adjusts the scale of the other signal based on this SNR. self is treated as the signal, and other as the noise.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new channel frame containing the addition result (lazy execution).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def add(\n    self,\n    other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n    snr: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Add another signal or value to the current signal.\n\n    If SNR is specified, performs addition with consideration for\n    signal-to-noise ratio.\n\n    Args:\n        other: Signal or value to add.\n        snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n            other signal based on this SNR.\n            self is treated as the signal, and other as the noise.\n\n    Returns:\n        A new channel frame containing the addition result (lazy execution).\n    \"\"\"\n    logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n    # Special processing when SNR is specified\n    if snr is not None:\n        # First convert other to ChannelFrame if it's not\n        if not isinstance(other, ChannelFrame):\n            if isinstance(other, np.ndarray):\n                other = ChannelFrame.from_numpy(\n                    other, self.sampling_rate, label=\"array_data\"\n                )\n            elif isinstance(other, (int, float)):\n                # For scalar values, simply add (ignore SNR)\n                return self + other\n            else:\n                raise TypeError(\n                    \"Addition target with SNR must be a ChannelFrame or \"\n                    f\"NumPy array: {type(other)}\"\n                )\n\n        # Check if sampling rates match\n        if self.sampling_rate != other.sampling_rate:\n            raise ValueError(\n                \"Sampling rates do not match. Cannot perform operation.\"\n            )\n\n        # Apply addition operation with SNR adjustment\n        return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n    # Execute normal addition if SNR is not specified\n    return self + other\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.channel_difference","title":"<code>channel_difference(other_channel=0)</code>","text":"<p>Calculate channel differences relative to a reference channel.</p> <p>Parameters:</p> Name Type Description Default <code>other_channel</code> <code>Union[int, str]</code> <p>Reference channel index or label. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with channel differences.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate channel differences relative to a reference channel.\n\n    Args:\n        other_channel: Reference channel index or label. Default is 0.\n\n    Returns:\n        A new ChannelFrame with channel differences.\n    \"\"\"\n    if isinstance(other_channel, str):\n        return self.apply_operation(\n            \"channel_difference\", other_channel=self.label2index(other_channel)\n        )\n    return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.coherence","title":"<code>coherence(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant')</code>","text":"<p>Compute magnitude squared coherence.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the magnitude squared coherence.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def coherence(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute magnitude squared coherence.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n    Returns:\n        A SpectralFrame containing the magnitude squared coherence.\n    \"\"\"\n    from ..processing.time_series import Coherence, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n    }\n    operation_name = \"coherence\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Coherence\", operation)\n\n    # Apply processing to data\n    coherence_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=coherence_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Coherence of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.csd","title":"<code>csd(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute cross-spectral density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the cross-spectral density matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def csd(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute cross-spectral density matrix.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the cross-spectral density matrix.\n    \"\"\"\n    from ..processing.time_series import CSD, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"csd\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"CSD\", operation)\n\n    # Apply processing to data\n    csd_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=csd_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.describe","title":"<code>describe(normalize=True, **kwargs)</code>","text":"<p>Display visual and audio representation of the frame.</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>Whether to normalize the audio data for playback.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for visualization.</p> <code>{}</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n    \"\"\"Display visual and audio representation of the frame.\n\n    Args:\n        normalize: Whether to normalize the audio data for playback.\n        **kwargs: Additional parameters for visualization.\n    \"\"\"\n    if \"axis_config\" in kwargs:\n        logger.warning(\n            \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        axis_config = kwargs[\"axis_config\"]\n        if \"time_plot\" in axis_config:\n            kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n        if \"freq_plot\" in axis_config:\n            if \"xlim\" in axis_config[\"freq_plot\"]:\n                vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                kwargs[\"vmin\"] = vlim[0]\n                kwargs[\"vmax\"] = vlim[1]\n            if \"ylim\" in axis_config[\"freq_plot\"]:\n                ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                kwargs[\"ylim\"] = ylim\n\n    if \"cbar_config\" in kwargs:\n        logger.warning(\n            \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        cbar_config = kwargs[\"cbar_config\"]\n        if \"vmin\" in cbar_config:\n            kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n        if \"vmax\" in cbar_config:\n            kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n    for ch in self:\n        ax: Axes\n        _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n        if isinstance(_ax, Iterator):\n            ax = next(iter(_ax))\n        elif isinstance(_ax, Axes):\n            ax = _ax\n        else:\n            raise TypeError(\n                f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n            )\n        # Ignore type checks for display and Audio\n        display(ax.figure)  # type: ignore\n        plt.close(ax.figure)  # type: ignore\n        display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.fft","title":"<code>fft(n_fft=None, window='hann')</code>","text":"<p>Compute Fast Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is next power of 2 of data length.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the FFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n    \"\"\"Compute Fast Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is next power of 2 of data length.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectralFrame containing the FFT results.\n    \"\"\"\n    from ..processing.time_series import FFT\n    from .spectral import SpectralFrame\n\n    params = {\"n_fft\": n_fft, \"window\": window}\n    operation_name = \"fft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"FFT\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    if n_fft is None:\n        is_even = spectrum_data.shape[-1] % 2 == 0\n        _n_fft = (\n            spectrum_data.shape[-1] * 2 - 2\n            if is_even\n            else spectrum_data.shape[-1] * 2 - 1\n        )\n    else:\n        _n_fft = n_fft\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=_n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.from_file","title":"<code>from_file(path, channel=None, start=None, end=None, chunk_size=None, ch_labels=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from an audio file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the audio file.</p> required <code>channel</code> <code>Optional[Union[int, list[int]]]</code> <p>Channel(s) to load.</p> <code>None</code> <code>start</code> <code>Optional[float]</code> <p>Start time in seconds.</p> <code>None</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <code>chunk_size</code> <code>Optional[int]</code> <p>Chunk size for processing.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the file reader.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the loaded audio data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If channel selection is invalid.</p> <code>TypeError</code> <p>If channel parameter type is invalid.</p> <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    path: Union[str, Path],\n    channel: Optional[Union[int, list[int]]] = None,\n    start: Optional[float] = None,\n    end: Optional[float] = None,\n    chunk_size: Optional[int] = None,\n    ch_labels: Optional[list[str]] = None,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from an audio file.\n\n    Args:\n        path: Path to the audio file.\n        channel: Channel(s) to load.\n        start: Start time in seconds.\n        end: End time in seconds.\n        chunk_size: Chunk size for processing.\n        Specifies the splitting size for lazy processing.\n        ch_labels: Labels for each channel.\n        **kwargs: Additional arguments passed to the file reader.\n\n    Returns:\n        A new ChannelFrame containing the loaded audio data.\n\n    Raises:\n        ValueError: If channel selection is invalid.\n        TypeError: If channel parameter type is invalid.\n        FileNotFoundError: If the file doesn't exist.\n    \"\"\"\n    from .channel import ChannelFrame\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    # Get file reader\n    reader = get_file_reader(path)\n\n    # Get file info\n    info = reader.get_file_info(path, **kwargs)\n    sr = info[\"samplerate\"]\n    n_channels = info[\"channels\"]\n    n_frames = info[\"frames\"]\n    ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n    logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n    # Channel selection processing\n    all_channels = list(range(n_channels))\n\n    if channel is None:\n        channels_to_load = all_channels\n        logger.debug(f\"Will load all channels: {channels_to_load}\")\n    elif isinstance(channel, int):\n        if channel &lt; 0 or channel &gt;= n_channels:\n            raise ValueError(\n                f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n            )\n        channels_to_load = [channel]\n        logger.debug(f\"Will load single channel: {channel}\")\n    elif isinstance(channel, (list, tuple)):\n        for ch in channel:\n            if ch &lt; 0 or ch &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n        channels_to_load = list(channel)\n        logger.debug(f\"Will load specific channels: {channels_to_load}\")\n    else:\n        raise TypeError(\"channel must be int, list, or None\")\n\n    # Index calculation\n    start_idx = 0 if start is None else max(0, int(start * sr))\n    end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n    frames_to_read = end_idx - start_idx\n\n    logger.debug(\n        f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n        f\"start_idx={start_idx}, end_idx={end_idx}\"\n    )\n\n    # Settings for lazy loading\n    expected_shape = (len(channels_to_load), frames_to_read)\n\n    # Define the loading function using the file reader\n    def _load_audio() -&gt; NDArrayReal:\n        logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n        # Use the reader to get audio data with parameters\n        out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n        if not isinstance(out, np.ndarray):\n            raise ValueError(\"Unexpected data type after reading file\")\n        return out\n\n    logger.debug(\n        f\"Creating delayed dask task with expected shape: {expected_shape}\"\n    )\n\n    # Create delayed operation\n    delayed_data = dask_delayed(_load_audio)()\n    logger.debug(\"Wrapping delayed function in dask array\")\n\n    # Create dask array from delayed computation\n    dask_array = da_from_delayed(\n        delayed_data, shape=expected_shape, dtype=np.float32\n    )\n\n    if chunk_size is not None:\n        if chunk_size &lt;= 0:\n            raise ValueError(\"Chunk size must be a positive integer\")\n        logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n        dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n    logger.debug(\n        \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n    )\n\n    cf = ChannelFrame(\n        data=dask_array,\n        sampling_rate=sr,\n        label=path.stem,\n        metadata={\n            \"filename\": str(path),\n        },\n    )\n    if ch_labels is not None:\n        if len(ch_labels) != len(cf):\n            raise ValueError(\n                \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    return cf\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.from_ndarray","title":"<code>from_ndarray(array, sampling_rate, labels=None, unit=None, frame_label=None, metadata=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>This method is deprecated. Use from_numpy instead.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>NDArrayReal</code> <p>Signal data. Each row corresponds to a channel.</p> required <code>sampling_rate</code> <code>float</code> <p>Sampling rate (Hz).</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>unit</code> <code>Optional[Union[list[str], str]]</code> <p>Unit of the signal.</p> <code>None</code> <code>frame_label</code> <code>Optional[str]</code> <p>Label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_ndarray(\n    cls,\n    array: NDArrayReal,\n    sampling_rate: float,\n    labels: Optional[list[str]] = None,\n    unit: Optional[Union[list[str], str]] = None,\n    frame_label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    This method is deprecated. Use from_numpy instead.\n\n    Args:\n        array: Signal data. Each row corresponds to a channel.\n        sampling_rate: Sampling rate (Hz).\n        labels: Labels for each channel.\n        unit: Unit of the signal.\n        frame_label: Label for the frame.\n        metadata: Optional metadata dictionary.\n\n    Returns:\n        A new ChannelFrame containing the data.\n    \"\"\"\n    # Redirect to from_numpy for compatibility\n    # However, from_ndarray is deprecated\n    logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n    return cls.from_numpy(\n        data=array,\n        sampling_rate=sampling_rate,\n        label=frame_label,\n        metadata=metadata,\n        ch_labels=labels,\n        ch_units=unit,\n    )\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.from_numpy","title":"<code>from_numpy(data, sampling_rate, label=None, metadata=None, ch_labels=None, ch_units=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArrayReal</code> <p>NumPy array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>ch_units</code> <code>Optional[Union[list[str], str]]</code> <p>Units for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the NumPy data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_numpy(\n    cls,\n    data: NDArrayReal,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    ch_labels: Optional[list[str]] = None,\n    ch_units: Optional[Union[list[str], str]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    Args:\n        data: NumPy array containing channel data.\n        sampling_rate: The sampling rate in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        ch_labels: Labels for each channel.\n        ch_units: Units for each channel.\n\n    Returns:\n        A new ChannelFrame containing the NumPy data.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n\n    # Convert NumPy array to dask array\n    dask_data = da_from_array(data)\n    cf = ChannelFrame(\n        data=dask_data,\n        sampling_rate=sampling_rate,\n        label=label or \"numpy_data\",\n    )\n    if metadata is not None:\n        cf.metadata = metadata\n    if ch_labels is not None:\n        if len(ch_labels) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel labels does not match the number of channels\"\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    if ch_units is not None:\n        if isinstance(ch_units, str):\n            ch_units = [ch_units] * cf.n_channels\n\n        if len(ch_units) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel units does not match the number of channels\"\n            )\n        for i in range(len(ch_units)):\n            cf._channel_metadata[i].unit = ch_units[i]\n\n    return cf\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.high_pass_filter","title":"<code>high_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a high-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a high-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.hpss_harmonic","title":"<code>hpss_harmonic(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract harmonic components using HPSS  (Harmonic-Percussive Source Separation).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_harmonic(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract harmonic components using HPSS\n     (Harmonic-Percussive Source Separation).\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_harmonic\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.hpss_percussive","title":"<code>hpss_percussive(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract percussive components using HPSS (Harmonic-Percussive Source Separation).</p> <p>This method separates the percussive (tonal) components from the signal.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Union[_IntLike_co, tuple[_IntLike_co, _IntLike_co], list[_IntLike_co]]</code> <p>Median filter size for HPSS.</p> <code>31</code> <code>power</code> <code>float</code> <p>Exponent for the Weiner filter used in HPSS.</p> <code>2</code> <code>margin</code> <code>Union[_FloatLike_co, tuple[_FloatLike_co, _FloatLike_co], list[_FloatLike_co]]</code> <p>Margin size for the separation.</p> <code>1</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the harmonic components.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_percussive(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract percussive components using HPSS\n    (Harmonic-Percussive Source Separation).\n\n    This method separates the percussive (tonal) components from the signal.\n\n    Args:\n        kernel_size: Median filter size for HPSS.\n        power: Exponent for the Weiner filter used in HPSS.\n        margin: Margin size for the separation.\n\n    Returns:\n        A new ChannelFrame containing the harmonic components.\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_percussive\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.low_pass_filter","title":"<code>low_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a low-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a low-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.mean","title":"<code>mean()</code>","text":"<p>Average all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with averaged signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def mean(self) -&gt; \"ChannelFrame\":\n    \"\"\"Average all channels.\n\n    Returns:\n        A new ChannelFrame with averaged signal.\n    \"\"\"\n    return self.apply_operation(\"mean\")\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.noct_spectrum","title":"<code>noct_spectrum(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Compute N-octave band spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>fmin</code> <code>float</code> <p>Minimum center frequency in Hz. Default is 20 Hz.</p> required <code>fmax</code> <code>float</code> <p>Maximum center frequency in Hz. Default is 20000 Hz.</p> required <code>n</code> <code>int</code> <p>Band division (1 for octave, 3 for 1/3 octave). Default is 3.</p> <code>3</code> <code>G</code> <code>int</code> <p>Reference gain in dB. Default is 10 dB.</p> <code>10</code> <code>fr</code> <code>int</code> <p>Reference frequency in Hz. Default is 1000 Hz.</p> <code>1000</code> <p>Returns:</p> Type Description <code>NOctFrame</code> <p>A NOctFrame containing the N-octave band spectrum.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def noct_spectrum(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"Compute N-octave band spectrum.\n\n    Args:\n        fmin: Minimum center frequency in Hz. Default is 20 Hz.\n        fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n        n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n        G: Reference gain in dB. Default is 10 dB.\n        fr: Reference frequency in Hz. Default is 1000 Hz.\n\n    Returns:\n        A NOctFrame containing the N-octave band spectrum.\n    \"\"\"\n    from ..processing.time_series import NOctSpectrum\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_spectrum\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSpectrum\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_spectrum\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.normalize","title":"<code>normalize(target_level=-20, channel_wise=True)</code>","text":"<p>Normalize the signal level.</p> <p>This method adjusts the signal amplitude to reach a target RMS level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target RMS level in dB. Default is -20.</p> <code>-20</code> <code>channel_wise</code> <code>bool</code> <p>If True, normalize each channel independently. If False, apply the same scaling to all channels.</p> <code>True</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the normalized signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def normalize(\n    self, target_level: float = -20, channel_wise: bool = True\n) -&gt; \"ChannelFrame\":\n    \"\"\"Normalize the signal level.\n\n    This method adjusts the signal amplitude to reach a target RMS level.\n\n    Args:\n        target_level: Target RMS level in dB. Default is -20.\n        channel_wise: If True, normalize each channel independently.\n            If False, apply the same scaling to all channels.\n\n    Returns:\n        A new ChannelFrame containing the normalized signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n    )\n    return self.apply_operation(\n        \"normalize\", target_level=target_level, channel_wise=channel_wise\n    )\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.plot","title":"<code>plot(plot_type='waveform', ax=None, **kwargs)</code>","text":"<p>Plot the frame data.</p> <p>Parameters:</p> Name Type Description Default <code>plot_type</code> <code>str</code> <p>Type of plot. Default is \"waveform\".</p> <code>'waveform'</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def plot(\n    self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Plot the frame data.\n\n    Args:\n        plot_type: Type of plot. Default is \"waveform\".\n        ax: Optional matplotlib axes for plotting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    plot_strategy = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.power","title":"<code>power(exponent=2.0)</code>","text":"<p>Calculate the power of the signal.</p> <p>Parameters:</p> Name Type Description Default <code>exponent</code> <code>float</code> <p>The exponent to raise the signal to. Default is 2.0.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the signal raised to the power.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the power of the signal.\n\n    Args:\n        exponent: The exponent to raise the signal to. Default is 2.0.\n\n    Returns:\n        A new ChannelFrame containing the signal raised to the power.\n    \"\"\"\n    return self.apply_operation(\"power\", exponent=exponent)\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.read_csv","title":"<code>read_csv(filename, time_column=0, labels=None, delimiter=',', header=0)</code>  <code>classmethod</code>","text":"<p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.read_wav","title":"<code>read_wav(filename, labels=None)</code>  <code>classmethod</code>","text":"<p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.resampling","title":"<code>resampling(target_sr, **kwargs)</code>","text":"<p>Resample audio data.</p>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.resampling--parameters","title":"Parameters","text":"<p>target_sr : float     Target sampling rate (Hz) resample_type : str, optional     Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.) **kwargs : dict     Additional resampling parameters</p>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.resampling--returns","title":"Returns","text":"<p>ChannelFrame     Resampled channel frame</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def resampling(\n    self,\n    target_sr: float,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Resample audio data.\n\n    Parameters\n    ----------\n    target_sr : float\n        Target sampling rate (Hz)\n    resample_type : str, optional\n        Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n    **kwargs : dict\n        Additional resampling parameters\n\n    Returns\n    -------\n    ChannelFrame\n        Resampled channel frame\n    \"\"\"\n    return self.apply_operation(\n        \"resampling\",\n        target_sr=target_sr,\n        **kwargs,\n    )\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.rms_plot","title":"<code>rms_plot(ax=None, title=None, overlay=True, Aw=False, **kwargs)</code>","text":"<p>Generate an RMS plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title for the plot.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay the plot on the existing axis.</p> <code>True</code> <code>Aw</code> <code>bool</code> <p>Apply A-weighting.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_plot(\n    self,\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = True,\n    Aw: bool = False,  # noqa: N803\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Generate an RMS plot.\n\n    Args:\n        ax: Optional matplotlib axes for plotting.\n        title: Title for the plot.\n        overlay: Whether to overlay the plot on the existing axis.\n        Aw: Apply A-weighting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    kwargs = kwargs or {}\n    ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n    rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n    return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.rms_trend","title":"<code>rms_trend(frame_length=2048, hop_length=512, dB=False, Aw=False)</code>","text":"<p>Calculate the RMS trend of the signal.</p> <p>This method computes the root mean square value over sliding windows.</p> <p>Parameters:</p> Name Type Description Default <code>frame_length</code> <code>int</code> <p>The size of the sliding window in samples. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>int</code> <p>The hop length between windows in samples. Default is 512.</p> <code>512</code> <code>dB</code> <code>bool</code> <p>Whether to return the RMS values in decibels. Default is False.</p> <code>False</code> <code>Aw</code> <code>bool</code> <p>Whether to apply A-weighting. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the RMS trend.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_trend(\n    self,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the RMS trend of the signal.\n\n    This method computes the root mean square value over sliding windows.\n\n    Args:\n        frame_length: The size of the sliding window in samples. Default is 2048.\n        hop_length: The hop length between windows in samples. Default is 512.\n        dB: Whether to return the RMS values in decibels. Default is False.\n        Aw: Whether to apply A-weighting. Default is False.\n\n    Returns:\n        A new ChannelFrame containing the RMS trend.\n    \"\"\"\n    cf = self.apply_operation(\n        \"rms_trend\",\n        frame_length=frame_length,\n        hop_length=hop_length,\n        ref=[ch.ref for ch in self._channel_metadata],\n        dB=dB,\n        Aw=Aw,\n    )\n    cf.sampling_rate = self.sampling_rate / hop_length\n    return cf\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.save","title":"<code>save(path, format=None)</code>","text":"<p>Save the audio data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n    data = self.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    sf.write(str(path), data, int(self.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {path}\")\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.stft","title":"<code>stft(n_fft=2048, hop_length=None, win_length=None, window='hann')</code>","text":"<p>Compute Short-Time Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectrogramFrame</code> <p>A SpectrogramFrame containing the STFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def stft(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n) -&gt; \"SpectrogramFrame\":\n    \"\"\"Compute Short-Time Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectrogramFrame containing the STFT results.\n    \"\"\"\n    from ..processing.time_series import STFT, create_operation\n    from .spectrogram import SpectrogramFrame\n\n    # Set hop length and window length\n    _hop_length = hop_length if hop_length is not None else n_fft // 4\n    _win_length = win_length if win_length is not None else n_fft\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": _hop_length,\n        \"win_length\": _win_length,\n        \"window\": window,\n    }\n    operation_name = \"stft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"STFT\", operation)\n\n    # Apply processing to data\n    spectrogram_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n\n    # Create new instance\n    return SpectrogramFrame(\n        data=spectrogram_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=n_fft,\n        hop_length=_hop_length,\n        win_length=_win_length,\n        window=window,\n        label=f\"stft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.sum","title":"<code>sum()</code>","text":"<p>Sum all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with summed signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def sum(self) -&gt; \"ChannelFrame\":\n    \"\"\"Sum all channels.\n\n    Returns:\n        A new ChannelFrame with summed signal.\n    \"\"\"\n    return self.apply_operation(\"sum\")\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.transfer_function","title":"<code>transfer_function(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute transfer function matrix.</p> <p>The transfer function characterizes the signal transmission properties between channels in the frequency domain, representing the input-output relationship of a system.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the transfer function matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def transfer_function(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute transfer function matrix.\n\n    The transfer function characterizes the signal transmission properties\n    between channels in the frequency domain, representing the input-output\n    relationship of a system.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the transfer function matrix.\n    \"\"\"\n    from ..processing.time_series import TransferFunction, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"transfer_function\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"TransferFunction\", operation)\n\n    # Apply processing to data\n    tf_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=tf_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Transfer function of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.trim","title":"<code>trim(start=0, end=None)</code>","text":"<p>Trim the signal to specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>Start time in seconds.</p> <code>0</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with trimmed signal.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If end time is before start time.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def trim(\n    self,\n    start: float = 0,\n    end: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Trim the signal to specified time range.\n\n    Args:\n        start: Start time in seconds.\n        end: End time in seconds.\n\n    Returns:\n        A new ChannelFrame with trimmed signal.\n\n    Raises:\n        ValueError: If end time is before start time.\n    \"\"\"\n    if end is None:\n        end = self.duration\n    if start &gt; end:\n        raise ValueError(\"start must be less than end\")\n    # Apply trim operation\n    return self.apply_operation(\"trim\", start=start, end=end)\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.channel.ChannelFrame.welch","title":"<code>welch(n_fft=None, hop_length=None, win_length=2048, window='hann', average='mean')</code>","text":"<p>Compute power spectral density using Welch's method.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is 2048.</p> <code>None</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>int</code> <p>Length of window. Default is n_fft.</p> <code>2048</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the power spectral density.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def welch(\n    self,\n    n_fft: Optional[int] = None,\n    hop_length: Optional[int] = None,\n    win_length: int = 2048,\n    window: str = \"hann\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute power spectral density using Welch's method.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the power spectral density.\n    \"\"\"\n    from ..processing.time_series import Welch\n    from .spectral import SpectralFrame\n\n    params = dict(\n        n_fft=n_fft or win_length,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        average=average,\n    )\n    operation_name = \"welch\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Welch\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"welch\", \"params\": params},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/ja/api/frames/#spectralframe","title":"SpectralFrame","text":"<p><code>SpectralFrame</code>\u306f\u5468\u6ce2\u6570\u9818\u57df\u306e\u30c7\u30fc\u30bf\u3092\u6271\u3046\u30d5\u30ec\u30fc\u30e0\u3067\u3059\u3002</p> <pre><code>from wandas.frames.spectral import SpectralFrame\n\n# \u307e\u305f\u306f ChannelFrame\u304b\u3089\u5909\u63db\nchannel_frame = wandas.read_wav(\"audio.wav\")\nspectral_frame = channel_frame.to_spectral()\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayComplex]</code></p> <p>Class for handling frequency-domain signal data.</p> <p>This class represents spectral data, providing methods for spectral analysis, manipulation, and visualization. It handles complex-valued frequency domain data obtained through operations like FFT.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The spectral data. Must be a dask array with shape:     - (channels, frequency_bins) for multi-channel data     - (frequency_bins,) for single-channel data, which will be       reshaped to (1, frequency_bins) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. n_fft : int     The FFT size used to generate this spectral data. window : str, default=\"hann\"     The window function used in the FFT. label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame--attributes","title":"Attributes","text":"<p>magnitude : NDArrayReal     The magnitude spectrum of the data. phase : NDArrayReal     The phase spectrum in radians. power : NDArrayReal     The power spectrum (magnitude squared). dB : NDArrayReal     The spectrum in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrum in decibels. freqs : NDArrayReal     The frequency axis values in Hz.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame--examples","title":"Examples","text":"<p>Create a SpectralFrame from FFT:</p> <p>signal = ChannelFrame.from_numpy(data, sampling_rate=44100) spectrum = signal.fft(n_fft=2048)</p> <p>Plot the magnitude spectrum:</p> <p>spectrum.plot()</p> <p>Perform binary operations:</p> <p>scaled = spectrum * 2.0 summed = spectrum1 + spectrum2  # Must have matching sampling rates</p> <p>Convert back to time domain:</p> <p>time_signal = spectrum.ifft()</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame--notes","title":"Notes","text":"<ul> <li>All operations are performed lazily using dask arrays for efficient memory usage.</li> <li>Binary operations (+, -, *, /) can be performed between SpectralFrames or with   scalar values.</li> <li>The class maintains the processing history and metadata through all operations.</li> </ul> Source code in <code>wandas/frames/spectral.py</code> <pre><code>class SpectralFrame(BaseFrame[NDArrayComplex]):\n    \"\"\"\n    Class for handling frequency-domain signal data.\n\n    This class represents spectral data, providing methods for spectral analysis,\n    manipulation, and visualization. It handles complex-valued frequency domain data\n    obtained through operations like FFT.\n\n    Parameters\n    ----------\n    data : DaArray\n        The spectral data. Must be a dask array with shape:\n        - (channels, frequency_bins) for multi-channel data\n        - (frequency_bins,) for single-channel data, which will be\n          reshaped to (1, frequency_bins)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    n_fft : int\n        The FFT size used to generate this spectral data.\n    window : str, default=\"hann\"\n        The window function used in the FFT.\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    magnitude : NDArrayReal\n        The magnitude spectrum of the data.\n    phase : NDArrayReal\n        The phase spectrum in radians.\n    power : NDArrayReal\n        The power spectrum (magnitude squared).\n    dB : NDArrayReal\n        The spectrum in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrum in decibels.\n    freqs : NDArrayReal\n        The frequency axis values in Hz.\n\n    Examples\n    --------\n    Create a SpectralFrame from FFT:\n    &gt;&gt;&gt; signal = ChannelFrame.from_numpy(data, sampling_rate=44100)\n    &gt;&gt;&gt; spectrum = signal.fft(n_fft=2048)\n\n    Plot the magnitude spectrum:\n    &gt;&gt;&gt; spectrum.plot()\n\n    Perform binary operations:\n    &gt;&gt;&gt; scaled = spectrum * 2.0\n    &gt;&gt;&gt; summed = spectrum1 + spectrum2  # Must have matching sampling rates\n\n    Convert back to time domain:\n    &gt;&gt;&gt; time_signal = spectrum.ifft()\n\n    Notes\n    -----\n    - All operations are performed lazily using dask arrays for efficient memory usage.\n    - Binary operations (+, -, *, /) can be performed between SpectralFrames or with\n      scalar values.\n    - The class maintains the processing history and metadata through all operations.\n    \"\"\"\n\n    n_fft: int\n    window: str\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        n_fft: int,\n        window: str = \"hann\",\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306f1\u6b21\u5143\u307e\u305f\u306f2\u6b21\u5143\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u5f62\u72b6: {data.shape}\"\n            )\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def magnitude(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the magnitude spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The absolute values of the complex spectrum.\n        \"\"\"\n        return np.abs(self.data)\n\n    @property\n    def phase(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the phase spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The phase angles of the complex spectrum in radians.\n        \"\"\"\n        return np.angle(self.data)\n\n    @property\n    def power(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the power spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The squared magnitude spectrum.\n        \"\"\"\n        return self.magnitude**2\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrum in decibels.\n\n        The reference values are taken from channel metadata. If no reference\n        is specified, uses 1.0.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrum in dB relative to channel references.\n        \"\"\"\n        mag: NDArrayReal = self.magnitude\n        ref_values: NDArrayReal = np.array([ch.ref for ch in self._channel_metadata])\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(mag / ref_values[:, np.newaxis], 1e-12)\n        )\n\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrum in decibels.\n\n        Applies A-weighting filter to the spectrum for better correlation with\n        perceived loudness.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrum in dB.\n        \"\"\"\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels.\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the frequency axis values in Hz.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of frequency values corresponding to each frequency bin.\n        \"\"\"\n        return np.fft.rfftfreq(self.n_fft, 1.0 / self.sampling_rate)\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Implementation of operation application for spectral data.\n\n        This internal method handles the application of various operations to\n        spectral data, maintaining lazy evaluation through dask.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters for the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        processed_data = operation.process(self._data)\n\n        # \u30e1\u30bf\u30c7\u30fc\u30bf\u66f4\u65b0\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\n            \"SpectralFrame\", int, float, complex, NDArrayComplex, NDArrayReal, \"DaArray\"\n        ],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"\n        Common implementation for binary operations.\n\n        This method handles binary operations between SpectralFrames and various types\n        of operands, maintaining lazy evaluation through dask arrays.\n\n        Parameters\n        ----------\n        other : Union[SpectralFrame, int, float, complex,\n                        NDArrayComplex, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation (e.g., lambda a, b: a + b)\n        symbol : str\n            String representation of the operation (e.g., '+')\n\n        Returns\n        -------\n        SpectralFrame\n            A new SpectralFrame containing the result of the operation.\n\n        Raises\n        ------\n        ValueError\n            If attempting to operate with a SpectralFrame\n            with a different sampling rate.\n        \"\"\"\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, SpectralFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u304c\u4e00\u81f4\u3057\u3066\u3044\u307e\u305b\u3093\u3002\u6f14\u7b97\u3067\u304d\u307e\u305b\u3093\u3002\"\n                )\n\n            # dask array\u3092\u76f4\u63a5\u6f14\u7b97\uff08\u9045\u5ef6\u5b9f\u884c\u3092\u7dad\u6301\uff09\n            result_data = op(self._data, other._data)\n\n            # \u30c1\u30e3\u30cd\u30eb\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u7d50\u5408\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return SpectralFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # \u30b9\u30ab\u30e9\u30fc\u3001NumPy\u914d\u5217\u3001\u307e\u305f\u306f\u4ed6\u306e\u30bf\u30a4\u30d7\u3068\u306e\u6f14\u7b97\n        else:\n            # dask array\u306b\u76f4\u63a5\u6f14\u7b97\u3092\u9069\u7528\uff08\u9045\u5ef6\u5b9f\u884c\u3092\u7dad\u6301\uff09\n            result_data = op(self._data, other)\n\n            # \u30aa\u30da\u30e9\u30f3\u30c9\u306e\u8868\u793a\u7528\u6587\u5b57\u5217\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, complex):\n                other_str = f\"complex({other.real}, {other.imag})\"\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # dask.array.Array\u306e\u30c1\u30a7\u30c3\u30af\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # \u30c1\u30e3\u30cd\u30eb\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u66f4\u65b0\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return SpectralFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n            )\n\n    def plot(\n        self,\n        plot_type: str = \"frequency\",\n        ax: Optional[\"Axes\"] = None,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the spectral data using various visualization strategies.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"frequency\"\n            Type of plot to create. Options include:\n            - \"frequency\": Standard frequency plot\n            - \"matrix\": Matrix plot for comparing channels\n            - Other types as defined by available plot strategies\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - title: Plot title\n            - xlabel, ylabel: Axis labels\n            - vmin, vmax: Value limits for plots\n            - cmap: Colormap name\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def ifft(self) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.\n\n        This method transforms the frequency-domain data back to the time domain using\n        the inverse FFT operation. The window function used in the forward FFT is\n        taken into account to ensure proper reconstruction.\n\n        Returns\n        -------\n        ChannelFrame\n            A new ChannelFrame containing the time-domain signal.\n        \"\"\"\n        from ..processing.time_series import IFFT, create_operation\n        from .channel import ChannelFrame\n\n        params = {\"n_fft\": self.n_fft, \"window\": self.window}\n        operation_name = \"ifft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"IFFT\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        time_series = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        return ChannelFrame(\n            data=time_series,\n            sampling_rate=self.sampling_rate,\n            label=f\"ifft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        SpectralFrame \u306b\u5fc5\u8981\u306a\u8ffd\u52a0\u306e\u521d\u671f\u5316\u5f15\u6570\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments for SpectralFrame.\n        \"\"\"\n        return {\n            \"n_fft\": self.n_fft,\n            \"window\": self.window,\n        }\n\n    def noct_synthesis(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"\n        Synthesize N-octave band spectrum.\n\n        This method combines frequency components into N-octave bands according to\n        standard acoustical band definitions. This is commonly used in noise and\n        vibration analysis.\n\n        Parameters\n        ----------\n        fmin : float\n            Lower frequency bound in Hz.\n        fmax : float\n            Upper frequency bound in Hz.\n        n : int, default=3\n            Number of bands per octave (e.g., 3 for third-octave bands).\n        G : int, default=10\n            Reference band number.\n        fr : int, default=1000\n            Reference frequency in Hz.\n\n        Returns\n        -------\n        NOctFrame\n            A new NOctFrame containing the N-octave band spectrum.\n\n        Raises\n        ------\n        ValueError\n            If the sampling rate is not 48000 Hz, which is required for this operation.\n        \"\"\"\n        if self.sampling_rate != 48000:\n            raise ValueError(\n                \"noct_synthesis\u306f48000Hz\u306e\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u3067\u306e\u307f\u4f7f\u7528\u3067\u304d\u307e\u3059\u3002\"\n            )\n        from ..processing.time_series import NOctSynthesis\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_synthesis\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSynthesis\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_synthesis\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def plot_matrix(\n        self,\n        plot_type: str = \"matrix\",\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot channel relationships in matrix format.\n\n        This method creates a matrix plot showing relationships between channels,\n        such as coherence, transfer functions, or cross-spectral density.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"matrix\"\n            Type of matrix plot to create.\n        **kwargs : dict\n            Additional plot parameters:\n            - vmin, vmax: Color scale limits\n            - cmap: Colormap name\n            - title: Plot title\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrum in decibels.</p> <p>The reference values are taken from channel metadata. If no reference is specified, uses 1.0.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrum in dB relative to channel references.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrum in decibels.</p> <p>Applies A-weighting filter to the spectrum for better correlation with perceived loudness.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrum in dB.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the frequency axis values in Hz.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of frequency values corresponding to each frequency bin.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.magnitude","title":"<code>magnitude</code>  <code>property</code>","text":"<p>Get the magnitude spectrum.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.magnitude--returns","title":"Returns","text":"<p>NDArrayReal     The absolute values of the complex spectrum.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.phase","title":"<code>phase</code>  <code>property</code>","text":"<p>Get the phase spectrum.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.phase--returns","title":"Returns","text":"<p>NDArrayReal     The phase angles of the complex spectrum in radians.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.power","title":"<code>power</code>  <code>property</code>","text":"<p>Get the power spectrum.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.power--returns","title":"Returns","text":"<p>NDArrayReal     The squared magnitude spectrum.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.ifft","title":"<code>ifft()</code>","text":"<p>Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.</p> <p>This method transforms the frequency-domain data back to the time domain using the inverse FFT operation. The window function used in the forward FFT is taken into account to ensure proper reconstruction.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.ifft--returns","title":"Returns","text":"<p>ChannelFrame     A new ChannelFrame containing the time-domain signal.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def ifft(self) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.\n\n    This method transforms the frequency-domain data back to the time domain using\n    the inverse FFT operation. The window function used in the forward FFT is\n    taken into account to ensure proper reconstruction.\n\n    Returns\n    -------\n    ChannelFrame\n        A new ChannelFrame containing the time-domain signal.\n    \"\"\"\n    from ..processing.time_series import IFFT, create_operation\n    from .channel import ChannelFrame\n\n    params = {\"n_fft\": self.n_fft, \"window\": self.window}\n    operation_name = \"ifft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"IFFT\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    time_series = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    return ChannelFrame(\n        data=time_series,\n        sampling_rate=self.sampling_rate,\n        label=f\"ifft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis","title":"<code>noct_synthesis(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Synthesize N-octave band spectrum.</p> <p>This method combines frequency components into N-octave bands according to standard acoustical band definitions. This is commonly used in noise and vibration analysis.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--parameters","title":"Parameters","text":"<p>fmin : float     Lower frequency bound in Hz. fmax : float     Upper frequency bound in Hz. n : int, default=3     Number of bands per octave (e.g., 3 for third-octave bands). G : int, default=10     Reference band number. fr : int, default=1000     Reference frequency in Hz.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--returns","title":"Returns","text":"<p>NOctFrame     A new NOctFrame containing the N-octave band spectrum.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--raises","title":"Raises","text":"<p>ValueError     If the sampling rate is not 48000 Hz, which is required for this operation.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def noct_synthesis(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"\n    Synthesize N-octave band spectrum.\n\n    This method combines frequency components into N-octave bands according to\n    standard acoustical band definitions. This is commonly used in noise and\n    vibration analysis.\n\n    Parameters\n    ----------\n    fmin : float\n        Lower frequency bound in Hz.\n    fmax : float\n        Upper frequency bound in Hz.\n    n : int, default=3\n        Number of bands per octave (e.g., 3 for third-octave bands).\n    G : int, default=10\n        Reference band number.\n    fr : int, default=1000\n        Reference frequency in Hz.\n\n    Returns\n    -------\n    NOctFrame\n        A new NOctFrame containing the N-octave band spectrum.\n\n    Raises\n    ------\n    ValueError\n        If the sampling rate is not 48000 Hz, which is required for this operation.\n    \"\"\"\n    if self.sampling_rate != 48000:\n        raise ValueError(\n            \"noct_synthesis\u306f48000Hz\u306e\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u3067\u306e\u307f\u4f7f\u7528\u3067\u304d\u307e\u3059\u3002\"\n        )\n    from ..processing.time_series import NOctSynthesis\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_synthesis\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSynthesis\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_synthesis\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.plot","title":"<code>plot(plot_type='frequency', ax=None, **kwargs)</code>","text":"<p>Plot the spectral data using various visualization strategies.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"frequency\"     Type of plot to create. Options include:     - \"frequency\": Standard frequency plot     - \"matrix\": Matrix plot for comparing channels     - Other types as defined by available plot strategies ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - title: Plot title     - xlabel, ylabel: Axis labels     - vmin, vmax: Value limits for plots     - cmap: Colormap name     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def plot(\n    self,\n    plot_type: str = \"frequency\",\n    ax: Optional[\"Axes\"] = None,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the spectral data using various visualization strategies.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"frequency\"\n        Type of plot to create. Options include:\n        - \"frequency\": Standard frequency plot\n        - \"matrix\": Matrix plot for comparing channels\n        - Other types as defined by available plot strategies\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - title: Plot title\n        - xlabel, ylabel: Axis labels\n        - vmin, vmax: Value limits for plots\n        - cmap: Colormap name\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix","title":"<code>plot_matrix(plot_type='matrix', **kwargs)</code>","text":"<p>Plot channel relationships in matrix format.</p> <p>This method creates a matrix plot showing relationships between channels, such as coherence, transfer functions, or cross-spectral density.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"matrix\"     Type of matrix plot to create. **kwargs : dict     Additional plot parameters:     - vmin, vmax: Color scale limits     - cmap: Colormap name     - title: Plot title</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def plot_matrix(\n    self,\n    plot_type: str = \"matrix\",\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot channel relationships in matrix format.\n\n    This method creates a matrix plot showing relationships between channels,\n    such as coherence, transfer functions, or cross-spectral density.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"matrix\"\n        Type of matrix plot to create.\n    **kwargs : dict\n        Additional plot parameters:\n        - vmin, vmax: Color scale limits\n        - cmap: Colormap name\n        - title: Plot title\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/ja/api/frames/#spectrogramframe","title":"SpectrogramFrame","text":"<p><code>SpectrogramFrame</code>\u306f\u6642\u9593\u5468\u6ce2\u6570\u8868\u73fe\uff08\u30b9\u30da\u30af\u30c8\u30ed\u30b0\u30e9\u30e0\uff09\u306e\u30c7\u30fc\u30bf\u3092\u6271\u3046\u30d5\u30ec\u30fc\u30e0\u3067\u3059\u3002</p> <pre><code>from wandas.frames.spectrogram import SpectrogramFrame\n\n# \u307e\u305f\u306f ChannelFrame\u304b\u3089\u5909\u63db\nchannel_frame = wandas.read_wav(\"audio.wav\")\nspectrogram_frame = channel_frame.to_spectrogram()\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayComplex]</code></p> <p>Class for handling time-frequency domain data (spectrograms).</p> <p>This class represents spectrogram data obtained through Short-Time Fourier Transform (STFT) or similar time-frequency analysis methods. It provides methods for visualization, manipulation, and conversion back to time domain.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The spectrogram data. Must be a dask array with shape:     - (channels, frequency_bins, time_frames) for multi-channel data     - (frequency_bins, time_frames) for single-channel data, which will be       reshaped to (1, frequency_bins, time_frames) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. n_fft : int     The FFT size used to generate this spectrogram. hop_length : int     Number of samples between successive frames. win_length : int, optional     The window length in samples. If None, defaults to n_fft. window : str, default=\"hann\"     The window function to use (e.g., \"hann\", \"hamming\", \"blackman\"). label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame--attributes","title":"Attributes","text":"<p>magnitude : NDArrayReal     The magnitude spectrogram. phase : NDArrayReal     The phase spectrogram in radians. power : NDArrayReal     The power spectrogram. dB : NDArrayReal     The spectrogram in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrogram in decibels. n_frames : int     Number of time frames. n_freq_bins : int     Number of frequency bins. freqs : NDArrayReal     The frequency axis values in Hz. times : NDArrayReal     The time axis values in seconds.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame--examples","title":"Examples","text":"<p>Create a spectrogram from a time-domain signal:</p> <p>signal = ChannelFrame.from_wav(\"audio.wav\") spectrogram = signal.stft(n_fft=2048, hop_length=512)</p> <p>Extract a specific time frame:</p> <p>frame_at_1s = spectrogram.get_frame_at(int(1.0 * sampling_rate / hop_length))</p> <p>Convert back to time domain:</p> <p>reconstructed = spectrogram.to_channel_frame()</p> <p>Plot the spectrogram:</p> <p>spectrogram.plot()</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>class SpectrogramFrame(BaseFrame[NDArrayComplex]):\n    \"\"\"\n    Class for handling time-frequency domain data (spectrograms).\n\n    This class represents spectrogram data obtained through\n    Short-Time Fourier Transform (STFT)\n    or similar time-frequency analysis methods. It provides methods for visualization,\n    manipulation, and conversion back to time domain.\n\n    Parameters\n    ----------\n    data : DaArray\n        The spectrogram data. Must be a dask array with shape:\n        - (channels, frequency_bins, time_frames) for multi-channel data\n        - (frequency_bins, time_frames) for single-channel data, which will be\n          reshaped to (1, frequency_bins, time_frames)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    n_fft : int\n        The FFT size used to generate this spectrogram.\n    hop_length : int\n        Number of samples between successive frames.\n    win_length : int, optional\n        The window length in samples. If None, defaults to n_fft.\n    window : str, default=\"hann\"\n        The window function to use (e.g., \"hann\", \"hamming\", \"blackman\").\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    magnitude : NDArrayReal\n        The magnitude spectrogram.\n    phase : NDArrayReal\n        The phase spectrogram in radians.\n    power : NDArrayReal\n        The power spectrogram.\n    dB : NDArrayReal\n        The spectrogram in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrogram in decibels.\n    n_frames : int\n        Number of time frames.\n    n_freq_bins : int\n        Number of frequency bins.\n    freqs : NDArrayReal\n        The frequency axis values in Hz.\n    times : NDArrayReal\n        The time axis values in seconds.\n\n    Examples\n    --------\n    Create a spectrogram from a time-domain signal:\n    &gt;&gt;&gt; signal = ChannelFrame.from_wav(\"audio.wav\")\n    &gt;&gt;&gt; spectrogram = signal.stft(n_fft=2048, hop_length=512)\n\n    Extract a specific time frame:\n    &gt;&gt;&gt; frame_at_1s = spectrogram.get_frame_at(int(1.0 * sampling_rate / hop_length))\n\n    Convert back to time domain:\n    &gt;&gt;&gt; reconstructed = spectrogram.to_channel_frame()\n\n    Plot the spectrogram:\n    &gt;&gt;&gt; spectrogram.plot()\n    \"\"\"\n\n    n_fft: int\n    hop_length: int\n    win_length: int\n    window: str\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        if data.ndim == 2:\n            data = da.expand_dims(data, axis=0)  # type: ignore [unused-ignore]\n        elif data.ndim != 3:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306f2\u6b21\u5143\u307e\u305f\u306f3\u6b21\u5143\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u5f62\u72b6: {data.shape}\"\n            )\n        if not data.shape[-2] == n_fft // 2 + 1:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u304c\u7121\u52b9\u3067\u3059\u3002\u5468\u6ce2\u6570\u30d3\u30f3\u6570\u306f {n_fft // 2 + 1} \u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\"  # noqa: E501\n            )\n\n        self.n_fft = n_fft\n        self.hop_length = hop_length\n        self.win_length = win_length if win_length is not None else n_fft\n        self.window = window\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def magnitude(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the magnitude spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The absolute values of the complex spectrogram.\n        \"\"\"\n        return np.abs(self.data)\n\n    @property\n    def phase(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the phase spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The phase angles of the complex spectrogram in radians.\n        \"\"\"\n        return np.angle(self.data)\n\n    @property\n    def power(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the power spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The squared magnitude of the complex spectrogram.\n        \"\"\"\n        return np.abs(self.data) ** 2\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrogram in decibels relative to each channel's reference value.\n\n        The reference value for each channel is specified in its metadata.\n        A minimum value of -120 dB is enforced to avoid numerical issues.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrogram in decibels.\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        ref = np.array([ch.ref for ch in self._channel_metadata])\n        # dB\u5909\u63db\n        # 0\u9664\u7b97\u3092\u907f\u3051\u308b\u305f\u3081\u306b\u3001\u6700\u5927\u5024\u30681e-12\u306e\u3044\u305a\u308c\u304b\u3092\u4f7f\u7528\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(self.magnitude / ref[..., np.newaxis, np.newaxis], 1e-12)\n        )\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrogram in decibels.\n\n        A-weighting applies a frequency-dependent weighting filter that approximates\n        the human ear's response. This is particularly useful for analyzing noise\n        and acoustic measurements.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrogram in decibels.\n        \"\"\"\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted[:, np.newaxis]  # \u5468\u6ce2\u6570\u8ef8\u306b\u6cbf\u3063\u3066\u30d6\u30ed\u30fc\u30c9\u30ad\u30e3\u30b9\u30c8\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels.\n        \"\"\"\n        return self.shape[0]\n\n    @property\n    def n_frames(self) -&gt; int:\n        \"\"\"\n        Get the number of time frames.\n\n        Returns\n        -------\n        int\n            The number of time frames in the spectrogram.\n        \"\"\"\n        return self.shape[-1]\n\n    @property\n    def n_freq_bins(self) -&gt; int:\n        \"\"\"\n        Get the number of frequency bins.\n\n        Returns\n        -------\n        int\n            The number of frequency bins (n_fft // 2 + 1).\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the frequency axis values in Hz.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of frequency values corresponding to each frequency bin.\n        \"\"\"\n        return np.fft.rfftfreq(self.n_fft, 1.0 / self.sampling_rate)\n\n    @property\n    def times(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the time axis values in seconds.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of time values corresponding to each time frame.\n        \"\"\"\n        return np.arange(self.n_frames) * self.hop_length / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Implementation of operation application for spectrogram data.\n\n        This internal method handles the application of various operations to\n        spectrogram data, maintaining lazy evaluation through dask.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters for the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from wandas.processing.time_series import create_operation\n\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        processed_data = operation.process(self._data)\n\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\n            \"SpectrogramFrame\",\n            int,\n            float,\n            complex,\n            NDArrayComplex,\n            NDArrayReal,\n            \"DaArray\",\n        ],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"\n        Common implementation for binary operations.\n\n        This method handles binary operations between\n        SpectrogramFrames and various types\n        of operands, maintaining lazy evaluation through dask arrays.\n\n        Parameters\n        ----------\n        other : Union[SpectrogramFrame, int, float, complex,\n            NDArrayComplex, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation (e.g., lambda a, b: a + b)\n        symbol : str\n            String representation of the operation (e.g., '+')\n\n        Returns\n        -------\n        SpectrogramFrame\n            A new SpectrogramFrame containing the result of the operation.\n\n        Raises\n        ------\n        ValueError\n            If attempting to operate with a SpectrogramFrame\n            with a different sampling rate.\n        \"\"\"\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        if isinstance(other, SpectrogramFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u304c\u4e00\u81f4\u3057\u3066\u3044\u307e\u305b\u3093\u3002\u6f14\u7b97\u3067\u304d\u307e\u305b\u3093\u3002\"\n                )\n\n            result_data = op(self._data, other._data)\n\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return SpectrogramFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                hop_length=self.hop_length,\n                win_length=self.win_length,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n        else:\n            result_data = op(self._data, other)\n\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, complex):\n                other_str = f\"complex({other.real}, {other.imag})\"\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return SpectrogramFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                hop_length=self.hop_length,\n                win_length=self.win_length,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n            )\n\n    def plot(\n        self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the spectrogram using various visualization strategies.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"spectrogram\"\n            Type of plot to create.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - vmin, vmax: Colormap scaling\n            - cmap: Colormap name\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectrogramFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def plot_Aw(  # noqa: N802\n        self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the A-weighted spectrogram.\n\n        A convenience method that calls plot() with Aw=True, applying A-weighting\n        to the spectrogram before plotting.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"spectrogram\"\n            Type of plot to create.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to plot().\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot.\n        \"\"\"\n        return self.plot(plot_type=plot_type, ax=ax, Aw=True, **kwargs)\n\n    def get_frame_at(self, time_idx: int) -&gt; \"SpectralFrame\":\n        \"\"\"\n        Extract spectral data at a specific time frame.\n\n        Parameters\n        ----------\n        time_idx : int\n            Index of the time frame to extract.\n\n        Returns\n        -------\n        SpectralFrame\n            A new SpectralFrame containing the spectral data at the specified time.\n\n        Raises\n        ------\n        IndexError\n            If time_idx is out of range.\n        \"\"\"\n        from wandas.frames.spectral import SpectralFrame\n\n        if time_idx &lt; 0 or time_idx &gt;= self.n_frames:\n            raise IndexError(\n                f\"\u6642\u9593\u30a4\u30f3\u30c7\u30c3\u30af\u30b9 {time_idx} \u304c\u7bc4\u56f2\u5916\u3067\u3059\u3002\u6709\u52b9\u7bc4\u56f2: 0-{self.n_frames - 1}\"  # noqa: E501\n            )\n\n        frame_data = self._data[..., time_idx]\n\n        return SpectralFrame(\n            data=frame_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=self.n_fft,\n            window=self.window,\n            label=f\"{self.label} (Frame {time_idx}, Time {self.times[time_idx]:.3f}s)\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def to_channel_frame(self) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Convert the spectrogram back to time domain using inverse STFT.\n\n        This method performs an inverse Short-Time Fourier Transform (ISTFT) to\n        reconstruct the time-domain signal from the spectrogram.\n\n        Returns\n        -------\n        ChannelFrame\n            A new ChannelFrame containing the reconstructed time-domain signal.\n        \"\"\"\n        from wandas.frames.channel import ChannelFrame\n        from wandas.processing.time_series import ISTFT, create_operation\n\n        params = {\n            \"n_fft\": self.n_fft,\n            \"hop_length\": self.hop_length,\n            \"win_length\": self.win_length,\n            \"window\": self.window,\n        }\n        operation_name = \"istft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"ISTFT\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        time_series = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n\n        # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        return ChannelFrame(\n            data=time_series,\n            sampling_rate=self.sampling_rate,\n            label=f\"istft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get additional initialization arguments for SpectrogramFrame.\n\n        This internal method provides the additional initialization arguments\n        required by SpectrogramFrame beyond those required by BaseFrame.\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments.\n        \"\"\"\n        return {\n            \"n_fft\": self.n_fft,\n            \"hop_length\": self.hop_length,\n            \"win_length\": self.win_length,\n            \"window\": self.window,\n        }\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrogram in decibels relative to each channel's reference value.</p> <p>The reference value for each channel is specified in its metadata. A minimum value of -120 dB is enforced to avoid numerical issues.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrogram in decibels.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrogram in decibels.</p> <p>A-weighting applies a frequency-dependent weighting filter that approximates the human ear's response. This is particularly useful for analyzing noise and acoustic measurements.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrogram in decibels.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the frequency axis values in Hz.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of frequency values corresponding to each frequency bin.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.magnitude","title":"<code>magnitude</code>  <code>property</code>","text":"<p>Get the magnitude spectrogram.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.magnitude--returns","title":"Returns","text":"<p>NDArrayReal     The absolute values of the complex spectrogram.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_frames","title":"<code>n_frames</code>  <code>property</code>","text":"<p>Get the number of time frames.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_frames--returns","title":"Returns","text":"<p>int     The number of time frames in the spectrogram.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_freq_bins","title":"<code>n_freq_bins</code>  <code>property</code>","text":"<p>Get the number of frequency bins.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_freq_bins--returns","title":"Returns","text":"<p>int     The number of frequency bins (n_fft // 2 + 1).</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.phase","title":"<code>phase</code>  <code>property</code>","text":"<p>Get the phase spectrogram.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.phase--returns","title":"Returns","text":"<p>NDArrayReal     The phase angles of the complex spectrogram in radians.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.power","title":"<code>power</code>  <code>property</code>","text":"<p>Get the power spectrogram.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.power--returns","title":"Returns","text":"<p>NDArrayReal     The squared magnitude of the complex spectrogram.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.times","title":"<code>times</code>  <code>property</code>","text":"<p>Get the time axis values in seconds.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.times--returns","title":"Returns","text":"<p>NDArrayReal     Array of time values corresponding to each time frame.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at","title":"<code>get_frame_at(time_idx)</code>","text":"<p>Extract spectral data at a specific time frame.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--parameters","title":"Parameters","text":"<p>time_idx : int     Index of the time frame to extract.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--returns","title":"Returns","text":"<p>SpectralFrame     A new SpectralFrame containing the spectral data at the specified time.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--raises","title":"Raises","text":"<p>IndexError     If time_idx is out of range.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def get_frame_at(self, time_idx: int) -&gt; \"SpectralFrame\":\n    \"\"\"\n    Extract spectral data at a specific time frame.\n\n    Parameters\n    ----------\n    time_idx : int\n        Index of the time frame to extract.\n\n    Returns\n    -------\n    SpectralFrame\n        A new SpectralFrame containing the spectral data at the specified time.\n\n    Raises\n    ------\n    IndexError\n        If time_idx is out of range.\n    \"\"\"\n    from wandas.frames.spectral import SpectralFrame\n\n    if time_idx &lt; 0 or time_idx &gt;= self.n_frames:\n        raise IndexError(\n            f\"\u6642\u9593\u30a4\u30f3\u30c7\u30c3\u30af\u30b9 {time_idx} \u304c\u7bc4\u56f2\u5916\u3067\u3059\u3002\u6709\u52b9\u7bc4\u56f2: 0-{self.n_frames - 1}\"  # noqa: E501\n        )\n\n    frame_data = self._data[..., time_idx]\n\n    return SpectralFrame(\n        data=frame_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=self.n_fft,\n        window=self.window,\n        label=f\"{self.label} (Frame {time_idx}, Time {self.times[time_idx]:.3f}s)\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot","title":"<code>plot(plot_type='spectrogram', ax=None, **kwargs)</code>","text":"<p>Plot the spectrogram using various visualization strategies.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"spectrogram\"     Type of plot to create. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - vmin, vmax: Colormap scaling     - cmap: Colormap name     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def plot(\n    self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the spectrogram using various visualization strategies.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"spectrogram\"\n        Type of plot to create.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - vmin, vmax: Colormap scaling\n        - cmap: Colormap name\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectrogramFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw","title":"<code>plot_Aw(plot_type='spectrogram', ax=None, **kwargs)</code>","text":"<p>Plot the A-weighted spectrogram.</p> <p>A convenience method that calls plot() with Aw=True, applying A-weighting to the spectrogram before plotting.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"spectrogram\"     Type of plot to create. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to plot().</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def plot_Aw(  # noqa: N802\n    self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the A-weighted spectrogram.\n\n    A convenience method that calls plot() with Aw=True, applying A-weighting\n    to the spectrogram before plotting.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"spectrogram\"\n        Type of plot to create.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to plot().\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot.\n    \"\"\"\n    return self.plot(plot_type=plot_type, ax=ax, Aw=True, **kwargs)\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.to_channel_frame","title":"<code>to_channel_frame()</code>","text":"<p>Convert the spectrogram back to time domain using inverse STFT.</p> <p>This method performs an inverse Short-Time Fourier Transform (ISTFT) to reconstruct the time-domain signal from the spectrogram.</p>"},{"location":"en/ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.to_channel_frame--returns","title":"Returns","text":"<p>ChannelFrame     A new ChannelFrame containing the reconstructed time-domain signal.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def to_channel_frame(self) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Convert the spectrogram back to time domain using inverse STFT.\n\n    This method performs an inverse Short-Time Fourier Transform (ISTFT) to\n    reconstruct the time-domain signal from the spectrogram.\n\n    Returns\n    -------\n    ChannelFrame\n        A new ChannelFrame containing the reconstructed time-domain signal.\n    \"\"\"\n    from wandas.frames.channel import ChannelFrame\n    from wandas.processing.time_series import ISTFT, create_operation\n\n    params = {\n        \"n_fft\": self.n_fft,\n        \"hop_length\": self.hop_length,\n        \"win_length\": self.win_length,\n        \"window\": self.window,\n    }\n    operation_name = \"istft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"ISTFT\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    time_series = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n    )\n\n    # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    return ChannelFrame(\n        data=time_series,\n        sampling_rate=self.sampling_rate,\n        label=f\"istft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/ja/api/frames/#noctframe","title":"NOctFrame","text":"<p><code>NOctFrame</code>\u306fN\u30aa\u30af\u30bf\u30fc\u30d6\u5206\u6790\u306e\u30c7\u30fc\u30bf\u3092\u6271\u3046\u30d5\u30ec\u30fc\u30e0\u3067\u3059\u3002</p> <pre><code>from wandas.frames.noct import NOctFrame\n\n# \u307e\u305f\u306f ChannelFrame\u304b\u3089\u5909\u63db\nchannel_frame = wandas.read_wav(\"audio.wav\")\nnoct_frame = channel_frame.to_noct()\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Class for handling N-octave band analysis data.</p> <p>This class represents frequency data analyzed in fractional octave bands, typically used in acoustic and vibration analysis. It handles real-valued data representing energy or power in each frequency band, following standard acoustical band definitions.</p>"},{"location":"en/ja/api/frames/#wandas.frames.noct.NOctFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The N-octave band data. Must be a dask array with shape:     - (channels, frequency_bins) for multi-channel data     - (frequency_bins,) for single-channel data, which will be       reshaped to (1, frequency_bins) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. fmin : float, default=0     Lower frequency bound in Hz. fmax : float, default=0     Upper frequency bound in Hz. n : int, default=3     Number of bands per octave (e.g., 3 for third-octave bands). G : int, default=10     Reference band number according to IEC 61260-1:2014. fr : int, default=1000     Reference frequency in Hz, typically 1000 Hz for acoustic analysis. label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/ja/api/frames/#wandas.frames.noct.NOctFrame--attributes","title":"Attributes","text":"<p>freqs : NDArrayReal     The center frequencies of each band in Hz, calculated according to     the standard fractional octave band definitions. dB : NDArrayReal     The spectrum in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrum in decibels, applying frequency weighting     for better correlation with perceived loudness. fmin : float     Lower frequency bound in Hz. fmax : float     Upper frequency bound in Hz. n : int     Number of bands per octave. G : int     Reference band number. fr : int     Reference frequency in Hz.</p>"},{"location":"en/ja/api/frames/#wandas.frames.noct.NOctFrame--examples","title":"Examples","text":"<p>Create an N-octave band spectrum from a time-domain signal:</p> <p>signal = ChannelFrame.from_wav(\"audio.wav\") spectrum = signal.noct_spectrum(fmin=20, fmax=20000, n=3)</p> <p>Plot the N-octave band spectrum:</p> <p>spectrum.plot()</p> <p>Plot with A-weighting applied:</p> <p>spectrum.plot(Aw=True)</p>"},{"location":"en/ja/api/frames/#wandas.frames.noct.NOctFrame--notes","title":"Notes","text":"<ul> <li>Binary operations (addition, multiplication, etc.) are not currently   supported for N-octave band data.</li> <li>The actual frequency bands are determined by the parameters n, G, and fr   according to IEC 61260-1:2014 standard for fractional octave band filters.</li> <li>The class follows acoustic standards for band definitions and analysis,   making it suitable for noise measurements and sound level analysis.</li> <li>A-weighting is available for better correlation with human hearing   perception, following IEC 61672-1:2013.</li> </ul> Source code in <code>wandas/frames/noct.py</code> <pre><code>class NOctFrame(BaseFrame[NDArrayReal]):\n    \"\"\"\n    Class for handling N-octave band analysis data.\n\n    This class represents frequency data analyzed in fractional octave bands,\n    typically used in acoustic and vibration analysis. It handles real-valued\n    data representing energy or power in each frequency band, following standard\n    acoustical band definitions.\n\n    Parameters\n    ----------\n    data : DaArray\n        The N-octave band data. Must be a dask array with shape:\n        - (channels, frequency_bins) for multi-channel data\n        - (frequency_bins,) for single-channel data, which will be\n          reshaped to (1, frequency_bins)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    fmin : float, default=0\n        Lower frequency bound in Hz.\n    fmax : float, default=0\n        Upper frequency bound in Hz.\n    n : int, default=3\n        Number of bands per octave (e.g., 3 for third-octave bands).\n    G : int, default=10\n        Reference band number according to IEC 61260-1:2014.\n    fr : int, default=1000\n        Reference frequency in Hz, typically 1000 Hz for acoustic analysis.\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    freqs : NDArrayReal\n        The center frequencies of each band in Hz, calculated according to\n        the standard fractional octave band definitions.\n    dB : NDArrayReal\n        The spectrum in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrum in decibels, applying frequency weighting\n        for better correlation with perceived loudness.\n    fmin : float\n        Lower frequency bound in Hz.\n    fmax : float\n        Upper frequency bound in Hz.\n    n : int\n        Number of bands per octave.\n    G : int\n        Reference band number.\n    fr : int\n        Reference frequency in Hz.\n\n    Examples\n    --------\n    Create an N-octave band spectrum from a time-domain signal:\n    &gt;&gt;&gt; signal = ChannelFrame.from_wav(\"audio.wav\")\n    &gt;&gt;&gt; spectrum = signal.noct_spectrum(fmin=20, fmax=20000, n=3)\n\n    Plot the N-octave band spectrum:\n    &gt;&gt;&gt; spectrum.plot()\n\n    Plot with A-weighting applied:\n    &gt;&gt;&gt; spectrum.plot(Aw=True)\n\n    Notes\n    -----\n    - Binary operations (addition, multiplication, etc.) are not currently\n      supported for N-octave band data.\n    - The actual frequency bands are determined by the parameters n, G, and fr\n      according to IEC 61260-1:2014 standard for fractional octave band filters.\n    - The class follows acoustic standards for band definitions and analysis,\n      making it suitable for noise measurements and sound level analysis.\n    - A-weighting is available for better correlation with human hearing\n      perception, following IEC 61672-1:2013.\n    \"\"\"\n\n    fmin: float\n    fmax: float\n    n: int\n    G: int\n    fr: int\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        fmin: float = 0,\n        fmax: float = 0,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a NOctFrame instance.\n\n        Sets up N-octave band analysis parameters and prepares the frame for\n        storing band-filtered data. Data shape is validated to ensure compatibility\n        with N-octave band analysis.\n\n        See class docstring for parameter descriptions.\n        \"\"\"\n        self.n = n\n        self.G = G\n        self.fr = fr\n        self.fmin = fmin\n        self.fmax = fmax\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrum in decibels relative to each channel's reference value.\n\n        The reference value for each channel is specified in its metadata.\n        A minimum value of -120 dB is enforced to avoid numerical issues.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrum in decibels. Shape matches the input data shape:\n            (channels, frequency_bins).\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        ref = np.array([ch.ref for ch in self._channel_metadata])\n        # dB\u5909\u63db\n        # 0\u9664\u7b97\u3092\u907f\u3051\u308b\u305f\u3081\u306b\u3001\u6700\u5927\u5024\u30681e-12\u306e\u3044\u305a\u308c\u304b\u3092\u4f7f\u7528\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(self.data / ref[..., np.newaxis], 1e-12)\n        )\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrum in decibels.\n\n        A-weighting applies a frequency-dependent weighting filter that approximates\n        the human ear's response to different frequencies. This is particularly useful\n        for analyzing noise and acoustic measurements as it provides a better\n        correlation with perceived loudness.\n\n        The weighting is applied according to IEC 61672-1:2013 standard.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrum in decibels. Shape matches the input data shape:\n            (channels, frequency_bins).\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels in the N-octave band data.\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the center frequencies of each band in Hz.\n\n        These frequencies are calculated based on the N-octave band parameters\n        (n, G, fr) and the frequency bounds (fmin, fmax) according to\n        IEC 61260-1:2014 standard for fractional octave band filters.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of center frequencies for each frequency band.\n\n        Raises\n        ------\n        ValueError\n            If the center frequencies cannot be calculated or the result\n            is not a numpy array.\n        \"\"\"\n        _, freqs = _center_freq(\n            fmax=self.fmax,\n            fmin=self.fmin,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        if isinstance(freqs, np.ndarray):\n            return freqs\n        else:\n            raise ValueError(\"freqs is not numpy array.\")\n\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"\n        Binary operations are not currently supported for N-octave band data.\n\n        Parameters\n        ----------\n        other : Union[S, int, float, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation.\n        symbol : str\n            String representation of the operation (e.g., '+', '-', '*', '/').\n\n        Raises\n        ------\n        NotImplementedError\n            Always raises this error as operations are not implemented\n            for N-octave band data.\n        \"\"\"\n        raise NotImplementedError(\n            f\"Operation {symbol} is not implemented for NOctFrame.\"\n        )\n        return self\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        \u9045\u5ef6\u8a55\u4fa1\u3092\u4f7f\u7528\u3057\u3066\u64cd\u4f5c\u3092\u9069\u7528\u3057\u307e\u3059\u3002\n        \"\"\"\n        # \u9045\u5ef6\u8a55\u4fa1\u3092\u4f7f\u7528\u3057\u3066\u64cd\u4f5c\u3092\u9069\u7528\n        raise NotImplementedError(\n            f\"Operation {operation_name} is not implemented for NOctFrame.\"\n        )\n        return self\n\n    def plot(\n        self, plot_type: str = \"noct\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the N-octave band data using various visualization strategies.\n\n        Supports standard plotting configurations for acoustic analysis,\n        including decibel scales and A-weighting.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"noct\"\n            Type of plot to create. The default \"noct\" type creates a bar plot\n            suitable for displaying N-octave band data.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n            - title: Plot title\n            - xlabel, ylabel: Axis labels\n            - xscale: Set to \"log\" for logarithmic frequency axis\n            - grid: Whether to show grid lines\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[NOctFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get additional initialization arguments for NOctFrame.\n\n        This internal method provides the additional initialization arguments\n        required by NOctFrame beyond those required by BaseFrame. These include\n        the N-octave band analysis parameters that define the frequency bands.\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments specific to NOctFrame:\n            - n: Number of bands per octave\n            - G: Reference band number\n            - fr: Reference frequency\n            - fmin: Lower frequency bound\n            - fmax: Upper frequency bound\n        \"\"\"\n        return {\n            \"n\": self.n,\n            \"G\": self.G,\n            \"fr\": self.fr,\n            \"fmin\": self.fmin,\n            \"fmax\": self.fmax,\n        }\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.noct.NOctFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrum in decibels relative to each channel's reference value.</p> <p>The reference value for each channel is specified in its metadata. A minimum value of -120 dB is enforced to avoid numerical issues.</p>"},{"location":"en/ja/api/frames/#wandas.frames.noct.NOctFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrum in decibels. Shape matches the input data shape:     (channels, frequency_bins).</p>"},{"location":"en/ja/api/frames/#wandas.frames.noct.NOctFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrum in decibels.</p> <p>A-weighting applies a frequency-dependent weighting filter that approximates the human ear's response to different frequencies. This is particularly useful for analyzing noise and acoustic measurements as it provides a better correlation with perceived loudness.</p> <p>The weighting is applied according to IEC 61672-1:2013 standard.</p>"},{"location":"en/ja/api/frames/#wandas.frames.noct.NOctFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrum in decibels. Shape matches the input data shape:     (channels, frequency_bins).</p>"},{"location":"en/ja/api/frames/#wandas.frames.noct.NOctFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the center frequencies of each band in Hz.</p> <p>These frequencies are calculated based on the N-octave band parameters (n, G, fr) and the frequency bounds (fmin, fmax) according to IEC 61260-1:2014 standard for fractional octave band filters.</p>"},{"location":"en/ja/api/frames/#wandas.frames.noct.NOctFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of center frequencies for each frequency band.</p>"},{"location":"en/ja/api/frames/#wandas.frames.noct.NOctFrame.freqs--raises","title":"Raises","text":"<p>ValueError     If the center frequencies cannot be calculated or the result     is not a numpy array.</p>"},{"location":"en/ja/api/frames/#wandas.frames.noct.NOctFrame.__init__","title":"<code>__init__(data, sampling_rate, fmin=0, fmax=0, n=3, G=10, fr=1000, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a NOctFrame instance.</p> <p>Sets up N-octave band analysis parameters and prepares the frame for storing band-filtered data. Data shape is validated to ensure compatibility with N-octave band analysis.</p> <p>See class docstring for parameter descriptions.</p> Source code in <code>wandas/frames/noct.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    fmin: float = 0,\n    fmax: float = 0,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a NOctFrame instance.\n\n    Sets up N-octave band analysis parameters and prepares the frame for\n    storing band-filtered data. Data shape is validated to ensure compatibility\n    with N-octave band analysis.\n\n    See class docstring for parameter descriptions.\n    \"\"\"\n    self.n = n\n    self.G = G\n    self.fr = fr\n    self.fmin = fmin\n    self.fmax = fmax\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"en/ja/api/frames/#wandas.frames.noct.NOctFrame.plot","title":"<code>plot(plot_type='noct', ax=None, **kwargs)</code>","text":"<p>Plot the N-octave band data using various visualization strategies.</p> <p>Supports standard plotting configurations for acoustic analysis, including decibel scales and A-weighting.</p>"},{"location":"en/ja/api/frames/#wandas.frames.noct.NOctFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"noct\"     Type of plot to create. The default \"noct\" type creates a bar plot     suitable for displaying N-octave band data. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting     - title: Plot title     - xlabel, ylabel: Axis labels     - xscale: Set to \"log\" for logarithmic frequency axis     - grid: Whether to show grid lines</p>"},{"location":"en/ja/api/frames/#wandas.frames.noct.NOctFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/noct.py</code> <pre><code>def plot(\n    self, plot_type: str = \"noct\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the N-octave band data using various visualization strategies.\n\n    Supports standard plotting configurations for acoustic analysis,\n    including decibel scales and A-weighting.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"noct\"\n        Type of plot to create. The default \"noct\" type creates a bar plot\n        suitable for displaying N-octave band data.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n        - title: Plot title\n        - xlabel, ylabel: Axis labels\n        - xscale: Set to \"log\" for logarithmic frequency axis\n        - grid: Whether to show grid lines\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[NOctFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/ja/api/processing/","title":"\u4fe1\u53f7\u51e6\u7406\u30e2\u30b8\u30e5\u30fc\u30eb\uff08Processing\uff09","text":"<p>\u3053\u306e\u30da\u30fc\u30b8\u3067\u306fWandas\u306e\u4fe1\u53f7\u51e6\u7406\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002\u4fe1\u53f7\u51e6\u7406\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u3001\u6642\u7cfb\u5217\u30c7\u30fc\u30bf\u306b\u5bfe\u3059\u308b\u69d8\u3005\u306a\u51e6\u7406\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"en/ja/api/processing/#_1","title":"\u6642\u7cfb\u5217\u51e6\u7406","text":"<p>\u6642\u7cfb\u5217\u30c7\u30fc\u30bf\u306b\u5bfe\u3059\u308b\u51e6\u7406\u95a2\u6570\u3067\u3059\u3002\u3053\u308c\u3089\u306e\u95a2\u6570\u306f\u57fa\u672c\u7684\u306b<code>ChannelFrame</code>\u30e1\u30bd\u30c3\u30c9\u3092\u901a\u3058\u3066\u4f7f\u7528\u3057\u307e\u3059\u3002</p> <pre><code># \u4e00\u822c\u7684\u306a\u4f7f\u7528\u65b9\u6cd5\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")\nfiltered_frame = frame.filter(cutoff=1000, filter_type=\"lowpass\")\nresampled_frame = frame.resample(target_rate=16000)\n</code></pre>"},{"location":"en/ja/api/processing/#_2","title":"\u4e3b\u8981\u306a\u51e6\u7406\u30af\u30e9\u30b9","text":"<p>\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3084\u4ed6\u306e\u4fe1\u53f7\u51e6\u7406\u6a5f\u80fd\u306f\u3001\u5185\u90e8\u7684\u306b\u306f\u4ee5\u4e0b\u306e\u30af\u30e9\u30b9\u306b\u3088\u3063\u3066\u5b9f\u88c5\u3055\u308c\u3066\u3044\u307e\u3059\uff1a</p> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>High-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HighPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"High-pass filter operation\"\"\"\n\n    name = \"highpass_filter\"\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize high-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            limit = self.sampling_rate / 2\n            raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up high-pass filter processor\"\"\"\n        # Calculate filter coefficients (once) - safely retrieve from instance variables\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"high\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Highpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying highpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Low-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class LowPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Low-pass filter operation\"\"\"\n\n    name = \"lowpass_filter\"\n    a: NDArrayReal\n    b: NDArrayReal\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize low-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            raise ValueError(\n                f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n            )\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up low-pass filter processor\"\"\"\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"low\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Lowpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying lowpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Resampling operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ReSampling(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Resampling operation\"\"\"\n\n    name = \"resampling\"\n\n    def __init__(self, sampling_rate: float, target_sr: float):\n        \"\"\"\n        Initialize resampling operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        target_sampling_rate : float\n            Target sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate, target_sr=target_sr)\n        self.target_sr = target_sr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after resampling\n        ratio = float(self.target_sr) / float(self.sampling_rate)\n        n_samples = int(np.ceil(input_shape[-1] * ratio))\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for resampling operation\"\"\"\n        logger.debug(f\"Applying resampling to array with shape: {x.shape}\")\n        result = librosa.resample(\n            x, orig_sr=self.sampling_rate, target_sr=self.target_sr\n        )\n        logger.debug(f\"Resampling applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>A-weighting filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AWeighting(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"A-weighting filter operation\"\"\"\n\n    name = \"a_weighting\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize A-weighting filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for A-weighting filter\"\"\"\n        logger.debug(f\"Applying A-weighting to array with shape: {x.shape}\")\n        result = A_weight(x, self.sampling_rate)\n\n        # Handle case where A_weight returns a tuple\n        if isinstance(result, tuple):\n            # Use the first element of the tuple\n            result = result[0]\n\n        logger.debug(\n            f\"A-weighting applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.HighPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize high-pass filter</p>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.HighPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize high-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.HighPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        limit = self.sampling_rate / 2\n        raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n</code></pre>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.LowPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize low-pass filter</p>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.LowPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize low-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.LowPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        raise ValueError(\n            f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n        )\n</code></pre>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.ReSampling.__init__","title":"<code>__init__(sampling_rate, target_sr)</code>","text":"<p>Initialize resampling operation</p>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.ReSampling.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) target_sampling_rate : float     Target sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, target_sr: float):\n    \"\"\"\n    Initialize resampling operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    target_sampling_rate : float\n        Target sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate, target_sr=target_sr)\n    self.target_sr = target_sr\n</code></pre>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.ReSampling.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.ReSampling.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.ReSampling.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after resampling\n    ratio = float(self.target_sr) / float(self.sampling_rate)\n    n_samples = int(np.ceil(input_shape[-1] * ratio))\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.AWeighting.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize A-weighting filter</p>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.AWeighting.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize A-weighting filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"en/ja/api/processing/#audiooperation","title":"AudioOperation","text":"<p><code>AudioOperation</code> \u30af\u30e9\u30b9\u306f\u97f3\u58f0\u51e6\u7406\u64cd\u4f5c\u306e\u62bd\u8c61\u5316\u3068\u9023\u9396\u51e6\u7406\u3092\u53ef\u80fd\u306b\u3057\u307e\u3059\u3002</p> <pre><code>from wandas.processing.time_series import AudioOperation\n\n# \u4f7f\u7528\u4f8b\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")\n\n# \u8907\u6570\u306e\u51e6\u7406\u3092\u9023\u9396\u3055\u305b\u308b\noperation = (\n    AudioOperation()\n    .add_step(\"filter\", cutoff=1000, filter_type=\"lowpass\")\n    .add_step(\"normalize\")\n)\n\n# \u51e6\u7406\u3092\u9069\u7528\nprocessed_frame = operation.apply(frame)\n</code></pre> <p>               Bases: <code>Generic[InputArrayType, OutputArrayType]</code></p> <p>Abstract base class for audio processing operations.</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AudioOperation(Generic[InputArrayType, OutputArrayType]):\n    \"\"\"Abstract base class for audio processing operations.\"\"\"\n\n    # Class variable: operation name\n    name: ClassVar[str]\n\n    def __init__(self, sampling_rate: float, **params: Any):\n        \"\"\"\n        Initialize AudioOperation.\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        **params : Any\n            Operation-specific parameters\n        \"\"\"\n        self.sampling_rate = sampling_rate\n        self.params = params\n\n        # Validate parameters during initialization\n        self.validate_params()\n\n        # Create processor function (lazy initialization possible)\n        self._setup_processor()\n\n        logger.debug(\n            f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n        )\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n        pass\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up processor function (implemented by subclasses)\"\"\"\n        pass\n\n    def _process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function (implemented by subclasses)\"\"\"\n        # Default is no-op function\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    @dask.delayed  # type: ignore [misc, unused-ignore]\n    def process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n        # Default is no-op function\n        logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n        return self._process_array(x)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation (implemented by subclasses)\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        \"\"\"\n        Execute operation and return result\n        data shape is (channels, samples)\n        \"\"\"\n        # Add task as delayed processing\n        logger.debug(\"Adding delayed operation to computation graph\")\n        delayed_result = self.process_array(data)\n        # Convert delayed result to dask array and return\n        output_shape = self.calculate_output_shape(data.shape)\n        return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.AudioOperation.__init__","title":"<code>__init__(sampling_rate, **params)</code>","text":"<p>Initialize AudioOperation.</p>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.AudioOperation.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) **params : Any     Operation-specific parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, **params: Any):\n    \"\"\"\n    Initialize AudioOperation.\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    **params : Any\n        Operation-specific parameters\n    \"\"\"\n    self.sampling_rate = sampling_rate\n    self.params = params\n\n    # Validate parameters during initialization\n    self.validate_params()\n\n    # Create processor function (lazy initialization possible)\n    self._setup_processor()\n\n    logger.debug(\n        f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n    )\n</code></pre>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.AudioOperation.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation (implemented by subclasses)</p>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.AudioOperation.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.AudioOperation.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation (implemented by subclasses)\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.AudioOperation.process","title":"<code>process(data)</code>","text":"<p>Execute operation and return result data shape is (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    \"\"\"\n    Execute operation and return result\n    data shape is (channels, samples)\n    \"\"\"\n    # Add task as delayed processing\n    logger.debug(\"Adding delayed operation to computation graph\")\n    delayed_result = self.process_array(data)\n    # Convert delayed result to dask array and return\n    output_shape = self.calculate_output_shape(data.shape)\n    return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.AudioOperation.process_array","title":"<code>process_array(x)</code>","text":"<p>Processing function wrapped with @dask.delayed</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>@dask.delayed  # type: ignore [misc, unused-ignore]\ndef process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n    \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n    # Default is no-op function\n    logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n    return self._process_array(x)\n</code></pre>"},{"location":"en/ja/api/processing/#wandas.processing.time_series.AudioOperation.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters (raises exception if invalid)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n    pass\n</code></pre>"},{"location":"en/ja/explanation/","title":"\u7406\u8ad6\u80cc\u666f\u3068\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3","text":"<p>\u3053\u306e\u30bb\u30af\u30b7\u30e7\u30f3\u3067\u306f\u3001Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u8a2d\u8a08\u601d\u60f3\u3001\u5185\u90e8\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u3001\u304a\u3088\u3073\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u4f7f\u7528\u3055\u308c\u3066\u3044\u308b\u7406\u8ad6\u7684\u80cc\u666f\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002</p>"},{"location":"en/ja/explanation/#_2","title":"\u8a2d\u8a08\u601d\u60f3","text":"<p>Wandas\u306f\u4ee5\u4e0b\u306e\u8a2d\u8a08\u539f\u5247\u306b\u57fa\u3065\u3044\u3066\u958b\u767a\u3055\u308c\u3066\u3044\u307e\u3059\uff1a</p> <ol> <li>\u76f4\u611f\u7684\u306aAPI\u8a2d\u8a08 - \u30e6\u30fc\u30b6\u30fc\u304c\u7c21\u5358\u306b\u4f7f\u3048\u308b\u4e00\u8cab\u6027\u306e\u3042\u308b\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9</li> <li>\u52b9\u7387\u7684\u306a\u30e1\u30e2\u30ea\u4f7f\u7528 - \u5927\u898f\u6a21\u30c7\u30fc\u30bf\u306e\u51e6\u7406\u306b\u9069\u3057\u305f\u30e1\u30e2\u30ea\u52b9\u7387\u306e\u826f\u3044\u5b9f\u88c5</li> <li>\u62e1\u5f35\u6027 - \u65b0\u3057\u3044\u6a5f\u80fd\u3084\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u8ffd\u52a0\u3057\u3084\u3059\u3044\u62e1\u5f35\u53ef\u80fd\u306a\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3</li> <li>\u79d1\u5b66\u7684\u6b63\u78ba\u6027 - \u97f3\u97ff\u4fe1\u53f7\u51e6\u7406\u306e\u7406\u8ad6\u306b\u57fa\u3065\u304f\u6b63\u78ba\u306a\u5b9f\u88c5</li> </ol>"},{"location":"en/ja/explanation/#_3","title":"\u30b3\u30a2\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3","text":""},{"location":"en/ja/explanation/#_4","title":"\u30c7\u30fc\u30bf\u30e2\u30c7\u30eb","text":"<p>Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u4e2d\u5fc3\u3068\u306a\u308b\u30c7\u30fc\u30bf\u30e2\u30c7\u30eb\u306f\u968e\u5c64\u7684\u306b\u69cb\u6210\u3055\u308c\u3066\u3044\u307e\u3059\uff1a</p> <pre><code>BaseChannel (\u57fa\u5e95\u30af\u30e9\u30b9)\n \u251c\u2500\u2500 Channel (\u6642\u9593\u9818\u57df\u4fe1\u53f7)\n \u2502    \u2514\u2500\u2500 FrequencyChannel (\u5468\u6ce2\u6570\u9818\u57df\u4fe1\u53f7)\n \u2502         \u2514\u2500\u2500 TimeFrequencyChannel (\u6642\u9593-\u5468\u6ce2\u6570\u9818\u57df\u4fe1\u53f7)\n \u2514\u2500\u2500 ChannelFrame (\u8907\u6570\u30c1\u30e3\u30f3\u30cd\u30eb\u306e\u30b3\u30f3\u30c6\u30ca)\n      \u251c\u2500\u2500 FileFrame (\u30d5\u30a1\u30a4\u30eb\u30d9\u30fc\u30b9\u306e\u8907\u6570\u30c1\u30e3\u30f3\u30cd\u30eb)\n      \u2514\u2500\u2500 FrequencyChannelFrame (\u5468\u6ce2\u6570\u9818\u57df\u306e\u8907\u6570\u30c1\u30e3\u30f3\u30cd\u30eb)\n</code></pre> <p>\u5404\u30af\u30e9\u30b9\u306e\u8cac\u4efb\uff1a</p> <ul> <li>BaseChannel: \u3059\u3079\u3066\u306e\u30c1\u30e3\u30f3\u30cd\u30eb\u306e\u57fa\u5e95\u30af\u30e9\u30b9\u3002\u30c7\u30fc\u30bf\u30a2\u30af\u30bb\u30b9\u3001\u30e1\u30bf\u30c7\u30fc\u30bf\u7ba1\u7406\u306e\u57fa\u672c\u6a5f\u80fd\u3092\u63d0\u4f9b</li> <li>Channel: \u6642\u9593\u9818\u57df\u306e\u4fe1\u53f7\u30c7\u30fc\u30bf\u3068\u3001\u305d\u308c\u306b\u5bfe\u3059\u308b\u51e6\u7406\u30e1\u30bd\u30c3\u30c9\u3092\u5b9f\u88c5</li> <li>FrequencyChannel: FFT\u30d9\u30fc\u30b9\u306e\u5468\u6ce2\u6570\u9818\u57df\u30c7\u30fc\u30bf\u3068\u51e6\u7406\u3092\u5b9f\u88c5</li> <li>TimeFrequencyChannel: \u77ed\u6642\u9593\u30d5\u30fc\u30ea\u30a8\u5909\u63db\uff08STFT\uff09\u306a\u3069\u306e\u6642\u9593-\u5468\u6ce2\u6570\u9818\u57df\u8868\u73fe\u3092\u5b9f\u88c5</li> <li>ChannelFrame: \u8907\u6570\u306e\u30c1\u30e3\u30f3\u30cd\u30eb\u3092\u7ba1\u7406\u3057\u3001\u4e00\u62ec\u51e6\u7406\u3092\u53ef\u80fd\u306b\u3059\u308b\u30b3\u30f3\u30c6\u30ca</li> </ul>"},{"location":"en/ja/explanation/#_5","title":"\u30c7\u30fc\u30bf\u51e6\u7406\u30d5\u30ed\u30fc","text":"<ol> <li>\u5165\u529b\u6bb5\u968e: WAV\u3084CSV\u306a\u3069\u306e\u30d5\u30a1\u30a4\u30eb\u304b\u3089<code>Channel</code>\u307e\u305f\u306f<code>ChannelFrame</code>\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210</li> <li>\u51e6\u7406\u6bb5\u968e: \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3001\u30ea\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u306a\u3069\u306e\u51e6\u7406\u3092\u9069\u7528</li> <li>\u5206\u6790\u6bb5\u968e: \u4fe1\u53f7\u306e\u7279\u6027\uff08\u30b9\u30da\u30af\u30c8\u30eb\u3001\u30ec\u30d9\u30eb\u7b49\uff09\u3092\u5206\u6790</li> <li>\u51fa\u529b\u6bb5\u968e: \u51e6\u7406\u7d50\u679c\u3092\u30d5\u30a1\u30a4\u30eb\u306b\u4fdd\u5b58\u307e\u305f\u306f\u30b0\u30e9\u30d5\u3068\u3057\u3066\u53ef\u8996\u5316</li> </ol>"},{"location":"en/ja/explanation/#_6","title":"\u5b9f\u88c5\u8a73\u7d30","text":""},{"location":"en/ja/explanation/#_7","title":"\u30e1\u30e2\u30ea\u52b9\u7387","text":"<p>Wandas\u306f\u5927\u898f\u6a21\u306a\u30aa\u30fc\u30c7\u30a3\u30aa\u30c7\u30fc\u30bf\u3092\u6271\u3046\u305f\u3081\u306b\u3001\u4ee5\u4e0b\u306e\u65b9\u6cd5\u3067\u30e1\u30e2\u30ea\u52b9\u7387\u3092\u78ba\u4fdd\u3057\u3066\u3044\u307e\u3059\uff1a</p> <ul> <li>\u9045\u5ef6\u8a55\u4fa1: \u5fc5\u8981\u306b\u306a\u308b\u307e\u3067\u8a08\u7b97\u3092\u9045\u5ef6\u3055\u305b\u308b\u4ed5\u7d44\u307f</li> <li>\u30e1\u30e2\u30ea\u30de\u30c3\u30d4\u30f3\u30b0: \u5927\u304d\u306a\u30d5\u30a1\u30a4\u30eb\u3067\u3082\u30e1\u30e2\u30ea\u306b\u5168\u3066\u8aad\u307f\u8fbc\u307e\u305a\u306b\u30a2\u30af\u30bb\u30b9</li> <li>dask\u3068H5PY: \u5927\u898f\u6a21\u30c7\u30fc\u30bf\u306e\u51e6\u7406\u306b\u9069\u3057\u305f\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u6d3b\u7528</li> </ul>"},{"location":"en/ja/explanation/#_8","title":"\u4fe1\u53f7\u51e6\u7406\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0","text":"<p>Wandas\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u4fe1\u53f7\u51e6\u7406\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u5b9f\u88c5\u3057\u3066\u3044\u307e\u3059\uff1a</p> <ul> <li>\u30c7\u30b8\u30bf\u30eb\u30d5\u30a3\u30eb\u30bf: \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf\u306a\u3069\u306eIIR/FIR\u30d5\u30a3\u30eb\u30bf</li> <li>\u30b9\u30da\u30af\u30c8\u30eb\u5206\u6790: \u9ad8\u901f\u30d5\u30fc\u30ea\u30a8\u5909\u63db\uff08FFT\uff09\u306b\u57fa\u3065\u304f\u5468\u6ce2\u6570\u5206\u6790</li> <li>\u6642\u9593-\u5468\u6ce2\u6570\u5206\u6790: \u77ed\u6642\u9593\u30d5\u30fc\u30ea\u30a8\u5909\u63db\uff08STFT\uff09\u3001\u30b9\u30da\u30af\u30c8\u30ed\u30b0\u30e9\u30e0</li> <li>\u7d71\u8a08\u7684\u5206\u6790: RMS\u3001\u30d4\u30fc\u30af\u5024\u3001\u30af\u30ec\u30b9\u30c8\u30d5\u30a1\u30af\u30bf\u30fc\u306a\u3069\u306e\u4fe1\u53f7\u7279\u6027\u306e\u8a08\u7b97</li> </ul>"},{"location":"en/ja/explanation/#_9","title":"\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u306e\u8003\u616e\u4e8b\u9805","text":"<p>Wandas\u3092\u4f7f\u7528\u3059\u308b\u969b\u306e\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u306b\u95a2\u3059\u308b\u8003\u616e\u4e8b\u9805\uff1a</p> <ul> <li>\u5927\u91cf\u306e\u30c7\u30fc\u30bf\u3092\u51e6\u7406\u3059\u308b\u5834\u5408\u306f\u3001\u51e6\u7406\u3092\u30c1\u30e3\u30f3\u30af\u5358\u4f4d\u3067\u884c\u3046\u3053\u3068\u3092\u691c\u8a0e</li> <li>\u8907\u96d1\u306a\u51e6\u7406\u30c1\u30a7\u30fc\u30f3\u3092\u69cb\u7bc9\u3059\u308b\u5834\u5408\u306f\u3001\u4e2d\u9593\u7d50\u679c\u3092\u30ad\u30e3\u30c3\u30b7\u30e5\u3059\u308b\u3053\u3068\u3067\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u3092\u5411\u4e0a</li> <li>\u30de\u30eb\u30c1\u30c1\u30e3\u30f3\u30cd\u30eb\u51e6\u7406\u306f\u30de\u30eb\u30c1\u30b3\u30a2\u30d7\u30ed\u30bb\u30c3\u30b5\u3092\u52b9\u7387\u7684\u306b\u6d3b\u7528</li> </ul>"},{"location":"en/ja/explanation/#_10","title":"\u53c2\u8003\u6587\u732e","text":"<ol> <li>Smith, J. O. (2011). Spectral Audio Signal Processing. W3K Publishing.</li> <li>M\u00fcller, M. (2015). Fundamentals of Music Processing: Audio, Analysis, Algorithms, Applications. Springer.</li> <li>Z\u00f6lzer, U. (2008). Digital Audio Signal Processing. Wiley.</li> </ol>"},{"location":"en/ja/how_to/","title":"\u30af\u30c3\u30af\u30d6\u30c3\u30af\uff08\u7528\u9014\u5225\u30ec\u30b7\u30d4\u96c6\uff09","text":"<p>\u3053\u306e\u30bb\u30af\u30b7\u30e7\u30f3\u3067\u306f\u3001Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u4f7f\u7528\u3057\u305f\u69d8\u3005\u306a\u5b9f\u8df5\u7684\u306a\u30bf\u30b9\u30af\u306e\u4f8b\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"en/ja/how_to/#_2","title":"\u57fa\u672c\u7684\u306a\u97f3\u58f0\u5206\u6790","text":"<ul> <li>\u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u306e\u57fa\u672c\u60c5\u5831\u3092\u53d6\u5f97\u3059\u308b</li> <li>\u97f3\u58f0\u306e\u5468\u6ce2\u6570\u30b9\u30da\u30af\u30c8\u30eb\u3092\u5206\u6790\u3059\u308b</li> <li>RMS\u30ec\u30d9\u30eb\u3084\u30d4\u30fc\u30af\u30ec\u30d9\u30eb\u306a\u3069\u306e\u97f3\u91cf\u7279\u6027\u3092\u6e2c\u5b9a\u3059\u308b</li> </ul>"},{"location":"en/ja/how_to/#_3","title":"\u4fe1\u53f7\u51e6\u7406","text":"<ul> <li>\u30ed\u30fc\u30d1\u30b9/\u30cf\u30a4\u30d1\u30b9/\u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3092\u9069\u7528\u3059\u308b</li> <li>\u7279\u5b9a\u5468\u6ce2\u6570\u5e2f\u57df\u306e\u97f3\u91cf\u3092\u8abf\u6574\u3059\u308b\uff08\u30a4\u30b3\u30e9\u30a4\u30b6\u30fc\uff09</li> <li>\u30ce\u30a4\u30ba\u9664\u53bb\u3092\u884c\u3046</li> <li>\u97f3\u58f0\u306e\u30d4\u30c3\u30c1\u3092\u5909\u66f4\u3059\u308b</li> </ul>"},{"location":"en/ja/how_to/#_4","title":"\u97f3\u58f0\u30c7\u30fc\u30bf\u306e\u64cd\u4f5c","text":"<ul> <li>\u8907\u6570\u306e\u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u3092\u9023\u7d50\u3059\u308b</li> <li>\u7279\u5b9a\u306e\u90e8\u5206\u3092\u5207\u308a\u51fa\u3059</li> <li>\u97f3\u58f0\u3092\u30d5\u30a7\u30fc\u30c9\u30a4\u30f3/\u30d5\u30a7\u30fc\u30c9\u30a2\u30a6\u30c8\u3055\u305b\u308b</li> <li>\u7570\u306a\u308b\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u9593\u3067\u5909\u63db\u3059\u308b</li> </ul>"},{"location":"en/ja/how_to/#_5","title":"\u7279\u6b8a\u52b9\u679c","text":"<ul> <li>\u30ea\u30d0\u30fc\u30d6\uff08\u6b8b\u97ff\uff09\u52b9\u679c\u3092\u8ffd\u52a0\u3059\u308b</li> <li>\u30a8\u30b3\u30fc\u52b9\u679c\u3092\u8ffd\u52a0\u3059\u308b</li> <li>\u30c7\u30a3\u30b9\u30c8\u30fc\u30b7\u30e7\u30f3\u52b9\u679c\u3092\u9069\u7528\u3059\u308b</li> </ul>"},{"location":"en/ja/how_to/#_6","title":"\u9ad8\u5ea6\u306a\u5fdc\u7528","text":"<ul> <li>\u97f3\u58f0\u8a8d\u8b58\u524d\u51e6\u7406\u3068\u3057\u3066\u4f7f\u7528\u3059\u308b</li> <li>\u5927\u898f\u6a21\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3092\u52b9\u7387\u7684\u306b\u51e6\u7406\u3059\u308b</li> <li>\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u51e6\u7406\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u3092\u69cb\u7bc9\u3059\u308b</li> </ul>"},{"location":"en/ja/how_to/#_7","title":"\u30ab\u30b9\u30bf\u30e0\u51e6\u7406\u306e\u8ffd\u52a0","text":"<ul> <li>\u72ec\u81ea\u306e\u30d5\u30a3\u30eb\u30bf\u3092\u5b9a\u7fa9\u3059\u308b</li> <li>\u65b0\u3057\u3044\u51e6\u7406\u95a2\u6570\u3092\u5b9f\u88c5\u3059\u308b</li> <li>wandas\u3068\u4ed6\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u9023\u643a\u3055\u305b\u308b</li> </ul> <p>\u30d2\u30f3\u30c8</p> <p>\u5404\u30ec\u30b7\u30d4\u306f\u72ec\u7acb\u3057\u3066\u304a\u308a\u3001\u5fc5\u8981\u306b\u5fdc\u3058\u3066\u53c2\u7167\u3067\u304d\u307e\u3059\u3002\u57fa\u672c\u7684\u306a\u4f7f\u3044\u65b9\u304c\u308f\u304b\u3089\u306a\u3044\u5834\u5408\u306f\u3001\u307e\u305a\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3092\u3054\u89a7\u304f\u3060\u3055\u3044\u3002</p>"},{"location":"en/ja/tutorial/","title":"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb","text":"<p>\u3053\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3067\u306f\u3001Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u57fa\u672c\u7684\u306a\u4f7f\u3044\u65b9\u30925\u5206\u3067\u5b66\u3079\u307e\u3059\u3002</p>"},{"location":"en/ja/tutorial/#_2","title":"\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb","text":"<pre><code>pip install wandas\n</code></pre>"},{"location":"en/ja/tutorial/#_3","title":"\u57fa\u672c\u7684\u306a\u4f7f\u3044\u65b9","text":""},{"location":"en/ja/tutorial/#1","title":"1. \u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u30a4\u30f3\u30dd\u30fc\u30c8","text":"<pre><code>import wandas as wd\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"en/ja/tutorial/#2","title":"2. \u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f","text":"<pre><code># WAV\u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u3080\naudio = wd.io.read_wav(\"path/to/audio.wav\")\nprint(f\"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8: {audio.sampling_rate} Hz\")\nprint(f\"\u30c1\u30e3\u30f3\u30cd\u30eb\u6570: {len(audio)}\")\n</code></pre>"},{"location":"en/ja/tutorial/#3","title":"3. \u4fe1\u53f7\u306e\u53ef\u8996\u5316","text":"<pre><code># \u6ce2\u5f62\u3092\u8868\u793a\naudio.plot()\nplt.show()\n</code></pre>"},{"location":"en/ja/tutorial/#4","title":"4. \u57fa\u672c\u7684\u306a\u4fe1\u53f7\u51e6\u7406","text":"<pre><code># \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3092\u9069\u7528\uff081kHz\u4ee5\u4e0b\u306e\u5468\u6ce2\u6570\u3092\u901a\u904e\uff09\nfiltered = audio.filter(lowpass=1000)\n\n# \u7d50\u679c\u3092\u53ef\u8996\u5316\u3057\u3066\u6bd4\u8f03\nfig, axes = plt.subplots(2, 1, figsize=(10, 6))\naudio.plot(ax=axes[0], title=\"\u30aa\u30ea\u30b8\u30ca\u30eb\u4fe1\u53f7\")\nfiltered.plot(ax=axes[1], title=\"\u30d5\u30a3\u30eb\u30bf\u5f8c\u306e\u4fe1\u53f7\")\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"en/ja/tutorial/#5","title":"5. \u51e6\u7406\u7d50\u679c\u306e\u4fdd\u5b58","text":"<pre><code># \u51e6\u7406\u3057\u305f\u4fe1\u53f7\u3092WAV\u30d5\u30a1\u30a4\u30eb\u3068\u3057\u3066\u4fdd\u5b58\nwd.io.write_wav(filtered, \"filtered_audio.wav\")\n</code></pre>"},{"location":"en/ja/tutorial/#_4","title":"\u6b21\u306e\u30b9\u30c6\u30c3\u30d7","text":"<ul> <li>\u30af\u30c3\u30af\u30d6\u30c3\u30af \u3067\u69d8\u3005\u306a\u5fdc\u7528\u4f8b\u3092\u78ba\u8a8d\u3059\u308b</li> <li>API\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9 \u3067\u8a73\u7d30\u306a\u6a5f\u80fd\u3092\u8abf\u3079\u308b</li> <li>\u7406\u8ad6\u80cc\u666f \u3067\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u8a2d\u8a08\u601d\u60f3\u3092\u7406\u89e3\u3059\u308b</li> </ul>"},{"location":"","title":"Wandas Documentation","text":"<p>Welcome to the Wandas documentation.</p> <ul> <li>English Documentation</li> <li>\u65e5\u672c\u8a9e\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8</li> </ul>"},{"location":"frame_dataset_spec/","title":"FrameDataset\u306e\u4ed5\u69d8","text":""},{"location":"frame_dataset_spec/#_1","title":"\u6982\u8981","text":"<p><code>FrameDataset</code>\u306f\u3001\u30d5\u30a9\u30eb\u30c0\u5185\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u52b9\u7387\u7684\u306b\u51e6\u7406\u3059\u308b\u305f\u3081\u306e\u62bd\u8c61\u57fa\u5e95\u30af\u30e9\u30b9\u3067\u3059\u3002\u4e3b\u306a\u7279\u5fb4\u3068\u3057\u3066\u4ee5\u4e0b\u306e\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\uff1a</p> <ul> <li>\u9045\u5ef6\u30ed\u30fc\u30c9: \u5927\u898f\u6a21\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3067\u3082\u52b9\u7387\u7684\u306b\u6271\u3048\u308b\u3088\u3046\u3001\u5fc5\u8981\u306b\u306a\u3063\u305f\u6642\u70b9\u3067\u30c7\u30fc\u30bf\u3092\u30ed\u30fc\u30c9\u3057\u307e\u3059</li> <li>\u5909\u63db\u30c1\u30a7\u30fc\u30f3: \u30c7\u30fc\u30bf\u306b\u5bfe\u3059\u308b\u5909\u63db\u3092\u9023\u9396\u7684\u306b\u9069\u7528\u3067\u304d\u307e\u3059</li> <li>\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0: \u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u304b\u3089\u6307\u5b9a\u6570\u307e\u305f\u306f\u5272\u5408\u306e\u30b5\u30f3\u30d7\u30eb\u3092\u53d6\u5f97\u3067\u304d\u307e\u3059</li> <li>\u30d5\u30a1\u30a4\u30eb\u51fa\u529b: \u51e6\u7406\u6e08\u307f\u306e\u30c7\u30fc\u30bf\u3092\u4fdd\u5b58\u3067\u304d\u307e\u3059</li> </ul>"},{"location":"frame_dataset_spec/#_2","title":"\u30af\u30e9\u30b9\u968e\u5c64","text":"<pre><code>FrameDataset[F] (ABC)\n\u251c\u2500\u2500 _SampledFrameDataset[F] (\u5185\u90e8\u30af\u30e9\u30b9)\n\u251c\u2500\u2500 ChannelFrameDataset\n\u2514\u2500\u2500 SpectrogramFrameDataset\n</code></pre>"},{"location":"frame_dataset_spec/#_3","title":"\u30af\u30e9\u30b9\u306e\u8a73\u7d30","text":""},{"location":"frame_dataset_spec/#framedatasetf","title":"FrameDataset[F]","text":"<p>\u62bd\u8c61\u57fa\u5e95\u30af\u30e9\u30b9\u3067\u3001\u30b8\u30a7\u30cd\u30ea\u30c3\u30af\u578b\u30d1\u30e9\u30e1\u30fc\u30bf<code>F</code>\u306f\u6271\u3046\u30d5\u30ec\u30fc\u30e0\u306e\u578b\uff08<code>ChannelFrame</code>\u307e\u305f\u306f<code>SpectrogramFrame</code>\uff09\u3092\u8868\u3057\u307e\u3059\u3002</p>"},{"location":"frame_dataset_spec/#_4","title":"\u4e3b\u306a\u30e1\u30bd\u30c3\u30c9","text":"<ul> <li><code>__init__</code>: \u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u306e\u521d\u671f\u5316</li> <li><code>_discover_files</code>: \u5bfe\u8c61\u3068\u306a\u308b\u30d5\u30a1\u30a4\u30eb\u3092\u691c\u7d22</li> <li><code>_load_all_files</code>: \u3059\u3079\u3066\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u30ed\u30fc\u30c9\uff08\u975e\u9045\u5ef6\u30e2\u30fc\u30c9\uff09</li> <li><code>_load_file</code>: \u5177\u4f53\u7684\u306a\u30d5\u30a1\u30a4\u30eb\u30ed\u30fc\u30c9\u51e6\u7406\uff08\u62bd\u8c61\u30e1\u30bd\u30c3\u30c9\u3001\u30b5\u30d6\u30af\u30e9\u30b9\u3067\u5b9f\u88c5\uff09</li> <li><code>_ensure_loaded</code>: \u6307\u5b9a\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u30d5\u30ec\u30fc\u30e0\u304c\u30ed\u30fc\u30c9\u3055\u308c\u3066\u3044\u308b\u304b\u78ba\u8a8d\u3057\u3001\u5fc5\u8981\u3067\u3042\u308c\u3070\u30ed\u30fc\u30c9</li> <li><code>__len__</code>: \u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u5185\u306e\u30d5\u30a1\u30a4\u30eb\u6570\u3092\u8fd4\u3059</li> <li><code>__getitem__</code>: \u6307\u5b9a\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u30d5\u30ec\u30fc\u30e0\u3092\u53d6\u5f97</li> <li><code>apply</code>: \u95a2\u6570\u3092\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u5168\u4f53\u306b\u9069\u7528\u3057\u3066\u65b0\u3057\u3044\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3092\u4f5c\u6210</li> <li><code>save</code>: \u51e6\u7406\u6e08\u307f\u30d5\u30ec\u30fc\u30e0\u3092\u30d5\u30a1\u30a4\u30eb\u306b\u4fdd\u5b58</li> <li><code>sample</code>: \u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u304b\u3089\u30b5\u30f3\u30d7\u30eb\u3092\u53d6\u5f97</li> <li><code>get_metadata</code>: \u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u306e\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u53d6\u5f97</li> </ul>"},{"location":"frame_dataset_spec/#_sampledframedatasetf","title":"_SampledFrameDataset[F]","text":"<p><code>FrameDataset</code>\u304b\u3089\u6d3e\u751f\u3057\u305f\u5185\u90e8\u30af\u30e9\u30b9\u3067\u3001\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u3055\u308c\u305f\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3092\u8868\u73fe\u3057\u307e\u3059\u3002\u5143\u306e\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3078\u306e\u53c2\u7167\u3068\u5909\u63db\u30c1\u30a7\u30fc\u30f3\u3092\u4fdd\u6301\u3057\u307e\u3059\u3002</p>"},{"location":"frame_dataset_spec/#_5","title":"\u7279\u5fb4","text":"<ul> <li>\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u3055\u308c\u305f\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u30de\u30c3\u30d7\u3092\u4fdd\u6301</li> <li>\u5909\u63db\u30c1\u30a7\u30fc\u30f3\u3092\u9069\u7528\u3059\u308b\u6d17\u7df4\u3055\u308c\u305f\u5185\u90e8\u5b9f\u88c5</li> <li>\u5143\u306e\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u306e\u69cb\u9020\u3092\u4fdd\u6301\u3057\u3064\u3064\u3001\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u3055\u308c\u305f\u30c7\u30fc\u30bf\u306e\u307f\u3092\u51e6\u7406</li> </ul>"},{"location":"frame_dataset_spec/#channelframedataset","title":"ChannelFrameDataset","text":"<p>\u97f3\u58f0\u30fb\u4fe1\u53f7\u30d5\u30a1\u30a4\u30eb\u3092<code>ChannelFrame</code>\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3068\u3057\u3066\u6271\u3046\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3067\u3059\u3002</p>"},{"location":"frame_dataset_spec/#_6","title":"\u5bfe\u5fdc\u30d5\u30a1\u30a4\u30eb\u5f62\u5f0f","text":"<ul> <li><code>.wav</code></li> <li><code>.mp3</code></li> <li><code>.flac</code></li> <li><code>.csv</code></li> </ul>"},{"location":"frame_dataset_spec/#_7","title":"\u7279\u5fb4\u7684\u306a\u30e1\u30bd\u30c3\u30c9","text":"<ul> <li><code>_load_file</code>: \u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u307e\u305f\u306fCSV\u304b\u3089<code>ChannelFrame</code>\u3092\u4f5c\u6210</li> <li><code>resample</code>: \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u3092\u5909\u66f4</li> <li><code>trim</code>: \u6307\u5b9a\u3057\u305f\u6642\u9593\u7bc4\u56f2\u3067\u30c8\u30ea\u30df\u30f3\u30b0</li> <li><code>normalize</code>: \u97f3\u58f0\u4fe1\u53f7\u3092\u6b63\u898f\u5316</li> <li><code>stft</code>: \u77ed\u6642\u9593\u30d5\u30fc\u30ea\u30a8\u5909\u63db\u3092\u9069\u7528\u3057\u3001<code>SpectrogramFrameDataset</code>\u3092\u4f5c\u6210</li> <li><code>from_folder</code>: \u30d5\u30a1\u30a4\u30eb\u304b\u3089\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3092\u4f5c\u6210\u3059\u308b\u30af\u30e9\u30b9\u30e1\u30bd\u30c3\u30c9</li> </ul>"},{"location":"frame_dataset_spec/#spectrogramframedataset","title":"SpectrogramFrameDataset","text":"<p>\u30b9\u30da\u30af\u30c8\u30ed\u30b0\u30e9\u30e0\u30c7\u30fc\u30bf\u3092<code>SpectrogramFrame</code>\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3068\u3057\u3066\u6271\u3046\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3067\u3059\u3002\u4e3b\u306b<code>ChannelFrameDataset.stft()</code>\u306e\u7d50\u679c\u3068\u3057\u3066\u751f\u6210\u3055\u308c\u308b\u3053\u3068\u3092\u60f3\u5b9a\u3057\u3066\u3044\u307e\u3059\u3002</p>"},{"location":"frame_dataset_spec/#_8","title":"\u7279\u5fb4\u7684\u306a\u30e1\u30bd\u30c3\u30c9","text":"<ul> <li><code>_load_file</code>: \u73fe\u5728\u306f\u76f4\u63a5\u30d5\u30a1\u30a4\u30eb\u304b\u3089\u306e\u30ed\u30fc\u30c9\u3092\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u307e\u305b\u3093</li> <li><code>plot</code>: \u30b9\u30da\u30af\u30c8\u30ed\u30b0\u30e9\u30e0\u3092\u30d7\u30ed\u30c3\u30c8</li> </ul>"},{"location":"frame_dataset_spec/#_9","title":"\u4f7f\u7528\u4f8b","text":""},{"location":"frame_dataset_spec/#_10","title":"\u57fa\u672c\u7684\u306a\u4f7f\u7528\u65b9\u6cd5","text":"<pre><code># \u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u306e\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3092\u4f5c\u6210\ndataset = ChannelFrameDataset.from_folder(\n    \"path/to/audio/files\",\n    sampling_rate=16000,\n    lazy_loading=True\n)\n\n# \u6700\u521d\u306e10\u30d5\u30a1\u30a4\u30eb\u3092\u51e6\u7406\nfor i in range(min(10, len(dataset))):\n    frame = dataset[i]\n    # frame\u3092\u4f7f\u3063\u305f\u51e6\u7406\n    print(f\"File {i}: {frame.label}, SR: {frame.sampling_rate}, Duration: {frame.duration}s\")\n</code></pre>"},{"location":"frame_dataset_spec/#_11","title":"\u5909\u63db\u30c1\u30a7\u30fc\u30f3\u306e\u4f8b","text":"<pre><code># \u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u306e\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3092\u4f5c\u6210\ndataset = ChannelFrameDataset.from_folder(\"path/to/audio/files\")\n\n# \u5909\u63db\u30c1\u30a7\u30fc\u30f3\u3092\u9069\u7528\nprocessed_dataset = (\n    dataset\n    .resample(target_sr=16000)  # \u30ea\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\n    .trim(start=0.5, end=3.5)   # \u30c8\u30ea\u30df\u30f3\u30b0\n    .normalize()                # \u6b63\u898f\u5316\n)\n\n# STFT\u3092\u9069\u7528\u3057\u3066\u30b9\u30da\u30af\u30c8\u30ed\u30b0\u30e9\u30e0\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3092\u4f5c\u6210\nspec_dataset = processed_dataset.stft(n_fft=2048, hop_length=512)\n\n# \u7d50\u679c\u3092\u4fdd\u5b58\nprocessed_dataset.save(\"output/processed_audio\")\nspec_dataset.save(\"output/spectrograms\")\n</code></pre>"},{"location":"frame_dataset_spec/#_12","title":"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u306e\u4f8b","text":"<pre><code># \u5143\u306e\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u304b\u3089\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\nsampled_dataset = dataset.sample(n=10, seed=42)\n\n# \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u3057\u305f\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u306b\u5909\u63db\u3092\u9069\u7528\nprocessed_sampled = (\n    sampled_dataset\n    .resample(target_sr=16000)\n    .normalize()\n)\n</code></pre>"},{"location":"frame_dataset_spec/#_13","title":"\u9ad8\u5ea6\u306a\u6a5f\u80fd","text":""},{"location":"frame_dataset_spec/#_14","title":"\u9045\u5ef6\u30ed\u30fc\u30c9","text":"<p>\u5927\u898f\u6a21\u306a\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3092\u52b9\u7387\u7684\u306b\u6271\u3046\u305f\u3081\u3001<code>lazy_loading=True</code>\uff08\u30c7\u30d5\u30a9\u30eb\u30c8\uff09\u306e\u5834\u5408\u3001\u30c7\u30fc\u30bf\u306f\u5fc5\u8981\u306b\u306a\u3063\u305f\u6642\u70b9\u3067\u30ed\u30fc\u30c9\u3055\u308c\u307e\u3059\u3002\u3053\u308c\u306b\u3088\u308a\u3001\u30e1\u30e2\u30ea\u4f7f\u7528\u91cf\u3092\u6291\u3048\u3064\u3064\u3001\u5927\u91cf\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u6271\u3046\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002</p>"},{"location":"frame_dataset_spec/#_15","title":"\u5909\u63db\u30c1\u30a7\u30fc\u30f3","text":"<p><code>apply()</code>\u30e1\u30bd\u30c3\u30c9\u3092\u4f7f\u7528\u3057\u3066\u95a2\u6570\u3092\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u5168\u4f53\u306b\u9069\u7528\u3067\u304d\u307e\u3059\u3002\u5909\u63db\u306f\u9023\u9396\u7684\u306b\u9069\u7528\u3067\u304d\u3001\u5404\u5909\u63db\u306f\u524d\u306e\u5909\u63db\u306e\u7d50\u679c\u3092\u5165\u529b\u3068\u3057\u3066\u4f7f\u7528\u3057\u307e\u3059\u3002\u7d50\u679c\u306f\u65b0\u3057\u3044\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3068\u3057\u3066\u8fd4\u3055\u308c\u307e\u3059\u3002</p>"},{"location":"frame_dataset_spec/#_16","title":"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0","text":"<p><code>sample()</code>\u30e1\u30bd\u30c3\u30c9\u3092\u4f7f\u7528\u3057\u3066\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u304b\u3089\u6307\u5b9a\u6570\u307e\u305f\u306f\u5272\u5408\u306e\u30b5\u30f3\u30d7\u30eb\u3092\u53d6\u5f97\u3067\u304d\u307e\u3059\u3002\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u3055\u308c\u305f\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3082\u5143\u306e\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3068\u540c\u69d8\u306b\u64cd\u4f5c\u3067\u304d\u3001\u5909\u63db\u30c1\u30a7\u30fc\u30f3\u3082\u9069\u7528\u3067\u304d\u307e\u3059\u3002</p>"},{"location":"en/","title":"Wandas: Waveform Analysis Data Structures","text":"<p>Wandas is an open-source library for efficient signal analysis in Python. Wandas provides comprehensive functionality for signal processing and seamless integration with Matplotlib.</p>"},{"location":"en/#features","title":"Features","text":"<ul> <li>Comprehensive Signal Processing Functions: Easily perform basic signal processing operations including filtering, Fourier transforms, and STFT</li> <li>Integration with Visualization Libraries: Seamlessly integrate with Matplotlib for easy data visualization</li> <li>Lazy Evaluation: Efficiently process large data using dask</li> <li>Various Analysis Tools: Frequency analysis, octave band analysis, time-frequency analysis, and more</li> </ul>"},{"location":"en/#usage-examples","title":"Usage Examples","text":""},{"location":"en/#loading-and-visualizing-audio-files","title":"Loading and Visualizing Audio Files","text":"<pre><code>import wandas as wd\n\ncf = wd.read_wav(\"data/sample.wav\")\ncf.describe()\n</code></pre>"},{"location":"en/#filtering","title":"Filtering","text":"<pre><code>signal = wd.generate_sin(freqs=[5000, 1000], duration=1)\n# Apply low pass filter\nsignal.low_pass_filter(cutoff=1000).fft().plot()\n</code></pre> <p>For detailed documentation and usage examples, see the Tutorial and Cookbook.</p>"},{"location":"en/#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Tutorial - 5-minute getting started guide</li> <li>Cookbook - Recipe collection for common tasks</li> <li>API Reference - Detailed API specifications</li> <li>Theory &amp; Architecture - Design philosophy and algorithm explanations</li> <li>Contributing Guide - Rules and methods for contribution</li> </ul>"},{"location":"en/#license","title":"License","text":"<p>This project is released under the MIT License.</p>"},{"location":"en/contributing/","title":"Contributing Guide","text":"<p>Thank you for your interest in contributing to the Wandas project. This guide explains how to contribute to the project.</p>"},{"location":"en/contributing/#types-of-contributions","title":"Types of Contributions","text":"<p>You can contribute to the Wandas project in the following ways:</p> <ul> <li>Bug reports and feature requests</li> <li>Documentation improvements</li> <li>Bug fixes</li> <li>New feature implementations</li> <li>Test additions and improvements</li> <li>Performance optimizations</li> </ul>"},{"location":"en/contributing/#setting-up-the-development-environment","title":"Setting Up the Development Environment","text":""},{"location":"en/contributing/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/yourusername/wandas.git\ncd wandas\n</code></pre>"},{"location":"en/contributing/#2-set-up-a-virtual-environment-and-install-dependencies","title":"2. Set Up a Virtual Environment and Install Dependencies","text":"<pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip install -e \".[dev]\"\n</code></pre>"},{"location":"en/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"en/contributing/#1-create-a-new-branch","title":"1. Create a New Branch","text":"<p>Create a new branch for new features or bug fixes:</p> <pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/issue-description\n</code></pre>"},{"location":"en/contributing/#2-code-style","title":"2. Code Style","text":"<p>Follow the PEP 8 style guide for code. We use the following tools to ensure code quality:</p> <ul> <li>Ruff: Code linter and formatter</li> <li>mypy: Static type checking</li> </ul> <p>Before committing your code, run the following commands to check your code style:</p> <pre><code># Linting\nruff check wandas tests\n\n# Type checking\nmypy wandas tests\n</code></pre>"},{"location":"en/contributing/#3-testing","title":"3. Testing","text":"<p>Always add tests for new features or bug fixes. Tests are run using <code>pytest</code>:</p> <pre><code>pytest\n</code></pre> <p>To generate a coverage report:</p> <pre><code>pytest --cov=wandas tests/\n</code></pre>"},{"location":"en/contributing/#4-documentation","title":"4. Documentation","text":"<p>Code changes require documentation updates:</p> <ul> <li>Write NumPy-style docstrings for functions and classes</li> <li>Update or add appropriate documentation pages (tutorials, how-tos, API reference) for new features</li> <li>Add sample code to the <code>examples/</code> directory as needed</li> </ul> <p>To build and check the documentation:</p> <pre><code>cd docs\nmkdocs serve\n</code></pre> <p>Then visit http://localhost:8000 in your browser to check.</p>"},{"location":"en/contributing/#5-creating-a-pull-request","title":"5. Creating a Pull Request","text":"<p>Once your changes are complete, create a pull request (PR):</p> <ol> <li>Commit your changes and push to the remote repository</li> </ol> <pre><code>git add .\ngit commit -m \"Descriptive commit message\"\ngit push origin your-branch-name\n</code></pre> <ol> <li>Create a pull request on the GitHub repository page</li> <li>In the PR description, include what was changed, what issues were resolved, and how to test it</li> </ol>"},{"location":"en/contributing/#review-process","title":"Review Process","text":"<p>All PRs are reviewed through the following process:</p> <ol> <li>Automated CI tests must pass</li> <li>Code review by at least one maintainer</li> <li>Requested changes and responses as needed</li> <li>Merge approval</li> </ol>"},{"location":"en/contributing/#communication","title":"Communication","text":"<p>You can communicate for questions or discussions through:</p> <ul> <li>GitHub Issues: Bug reports and feature requests</li> <li>GitHub Discussions: General questions and discussions</li> <li>Project mailing list (if available)</li> </ul>"},{"location":"en/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>All participants in the project are expected to follow the Code of Conduct. Treat other contributors with respect and engage in cooperative and constructive communication.</p>"},{"location":"en/api/","title":"API Reference","text":"<p>This section provides detailed references for all modules, classes, and methods in the Wandas library. It includes documentation automatically generated from the library's source code.</p>"},{"location":"en/api/#core-components","title":"Core Components","text":""},{"location":"en/api/#baseframe","title":"BaseFrame","text":"<p>The <code>BaseFrame</code> class is the basic data structure unit of Wandas.</p> <pre><code>from wandas.core.base_frame import BaseFrame\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for all signal frame types.</p> <p>This class provides the common interface and functionality for all frame types used in signal processing. It implements basic operations like indexing, iteration, and data manipulation that are shared across all frame types.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The signal data to process. Must be a dask array. sampling_rate : float     The sampling rate of the signal in Hz. label : str, optional     A label for the frame. If not provided, defaults to \"unnamed_frame\". metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame--attributes","title":"Attributes","text":"<p>sampling_rate : float     The sampling rate of the signal in Hz. label : str     The label of the frame. metadata : dict     Additional metadata for the frame. operation_history : list[dict]     History of operations performed on this frame.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>class BaseFrame(ABC, Generic[T]):\n    \"\"\"\n    Abstract base class for all signal frame types.\n\n    This class provides the common interface and functionality for all frame types\n    used in signal processing. It implements basic operations like indexing, iteration,\n    and data manipulation that are shared across all frame types.\n\n    Parameters\n    ----------\n    data : DaArray\n        The signal data to process. Must be a dask array.\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str, optional\n        A label for the frame. If not provided, defaults to \"unnamed_frame\".\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str\n        The label of the frame.\n    metadata : dict\n        Additional metadata for the frame.\n    operation_history : list[dict]\n        History of operations performed on this frame.\n    \"\"\"\n\n    _data: DaArray\n    sampling_rate: float\n    label: str\n    metadata: dict[str, Any]\n    operation_history: list[dict[str, Any]]\n    _channel_metadata: list[ChannelMetadata]\n    _previous: Optional[\"BaseFrame[Any]\"]\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ):\n        self._data = data.rechunk(chunks=-1)  # type: ignore [unused-ignore]\n        if self._data.ndim == 1:\n            self._data = self._data.reshape((1, -1))\n        self.sampling_rate = sampling_rate\n        self.label = label or \"unnamed_frame\"\n        self.metadata = metadata or {}\n        self.operation_history = operation_history or []\n        self._previous = previous\n\n        if channel_metadata:\n            self._channel_metadata = copy.deepcopy(channel_metadata)\n        else:\n            self._channel_metadata = [\n                ChannelMetadata(label=f\"ch{i}\", unit=\"\", extra={})\n                for i in range(self._n_channels)\n            ]\n\n        try:\n            # Display information for newer dask versions\n            logger.debug(f\"Dask graph layers: {list(self._data.dask.layers.keys())}\")\n            logger.debug(\n                f\"Dask graph dependencies: {len(self._data.dask.dependencies)}\"\n            )\n        except Exception as e:\n            logger.debug(f\"Dask graph visualization details unavailable: {e}\")\n\n    @property\n    @abstractmethod\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n\n    @property\n    def n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return len(self)\n\n    @property\n    def channels(self) -&gt; list[ChannelMetadata]:\n        \"\"\"Property to access channel metadata.\"\"\"\n        return self._channel_metadata\n\n    @property\n    def previous(self) -&gt; Optional[\"BaseFrame[Any]\"]:\n        \"\"\"\n        Returns the previous frame.\n        \"\"\"\n        return self._previous\n\n    def get_channel(self: S, channel_idx: int) -&gt; S:\n        n_channels = len(self)\n        if channel_idx &lt; 0 or channel_idx &gt;= n_channels:\n            range_max = n_channels - 1\n            raise ValueError(\n                f\"Channel index out of range: {channel_idx} \"\n                f\"(valid range: 0-{range_max})\"\n            )\n        logger.debug(f\"Extracting channel index={channel_idx} (lazy operation).\")\n        channel_data = self._data[channel_idx : channel_idx + 1]\n\n        return self._create_new_instance(\n            data=channel_data,\n            operation_history=self.operation_history,\n            channel_metadata=[self._channel_metadata[channel_idx]],\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Returns the number of channels.\n        \"\"\"\n        return len(self._channel_metadata)\n\n    def __iter__(self: S) -&gt; Iterator[S]:\n        for idx in range(len(self)):\n            yield self[idx]\n\n    def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n        \"\"\"\n        Method to get a channel by name or index.\n\n        Parameters\n        ----------\n        key : str, int, slice, or tuple of slices\n            Channel name (label) or index number.\n\n        Returns\n        -------\n        BaseFrame\n            The corresponding channel.\n\n        Raises\n        ------\n        ValueError\n            If the key length is invalid for the shape.\n        IndexError\n            If the channel index is out of range.\n        TypeError\n            If the key type is invalid.\n        \"\"\"\n        if isinstance(key, str):\n            index = self.label2index(key)\n            return self.get_channel(index)\n\n        elif isinstance(key, tuple):\n            # When key is a tuple, treat the first element as an index\n            if len(key) &gt; len(self.shape):\n                raise ValueError(\n                    f\"Invalid key length: {len(key)} for shape {self.shape}\"\n                )\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key[0]]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, slice):\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, numbers.Integral):\n            # Access by index number\n            if key &lt; 0 or key &gt;= len(self):\n                raise IndexError(f\"Channel index {key} out of range.\")\n            return self.get_channel(key)\n        else:\n            raise TypeError(\n                f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n            )\n\n    def label2index(self, label: str) -&gt; int:\n        \"\"\"\n        Get the index from a channel label.\n\n        Parameters\n        ----------\n        label : str\n            Channel label.\n\n        Returns\n        -------\n        int\n            Corresponding index.\n\n        Raises\n        ------\n        KeyError\n            If the channel label is not found.\n        \"\"\"\n        for idx, ch in enumerate(self._channel_metadata):\n            if ch.label == label:\n                return idx\n        raise KeyError(f\"Channel label '{label}' not found.\")\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        _shape: tuple[int, ...] = self._data.shape\n        return _shape\n\n    @property\n    def data(self) -&gt; T:\n        \"\"\"\n        Returns the computed data.\n        Calculation is executed the first time this is accessed.\n        \"\"\"\n        return self.compute()\n\n    @property\n    def labels(self) -&gt; list[str]:\n        \"\"\"Get a list of all channel labels.\"\"\"\n        return [ch.label for ch in self._channel_metadata]\n\n    def compute(self) -&gt; T:\n        \"\"\"\n        Compute and return the data.\n        This method materializes lazily computed data into a concrete NumPy array.\n\n        Returns\n        -------\n        NDArrayReal\n            The computed data.\n\n        Raises\n        ------\n        ValueError\n            If the computed result is not a NumPy array.\n        \"\"\"\n        logger.debug(\n            \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n        )\n        result = self._data.compute()\n\n        if not isinstance(result, np.ndarray):\n            raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n        logger.debug(f\"Computation complete, result shape: {result.shape}\")\n        return cast(T, result)\n\n    @abstractmethod\n    def plot(\n        self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n    ) -&gt; Union[Axes, Iterator[Axes]]:\n        \"\"\"Plot the data\"\"\"\n        pass\n\n    def persist(self: S) -&gt; S:\n        \"\"\"Persist the data in memory\"\"\"\n        persisted_data = self._data.persist()\n        return self._create_new_instance(data=persisted_data)\n\n    @abstractmethod\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Abstract method for derived classes to provide\n        additional initialization arguments.\n        \"\"\"\n        pass\n\n    def _create_new_instance(self: S, data: DaArray, **kwargs: Any) -&gt; S:\n        \"\"\"\n        Create a new channel instance based on an existing channel.\n        Keyword arguments can override or extend the original attributes.\n        \"\"\"\n\n        sampling_rate = kwargs.pop(\"sampling_rate\", self.sampling_rate)\n        # if not isinstance(sampling_rate, int):\n        #     raise TypeError(\"Sampling rate must be an integer\")\n\n        label = kwargs.pop(\"label\", self.label)\n        if not isinstance(label, str):\n            raise TypeError(\"Label must be a string\")\n\n        metadata = kwargs.pop(\"metadata\", copy.deepcopy(self.metadata))\n        if not isinstance(metadata, dict):\n            raise TypeError(\"Metadata must be a dictionary\")\n\n        # Get additional initialization arguments from derived classes\n        additional_kwargs = self._get_additional_init_kwargs()\n        kwargs.update(additional_kwargs)\n\n        return type(self)(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            previous=self,\n            **kwargs,\n        )\n\n    def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n        \"\"\"Implicit conversion to NumPy array\"\"\"\n        result = self.compute()\n        if dtype is not None:\n            return result.astype(dtype)\n        return result\n\n    def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n        \"\"\"Visualize the computation graph and save it to a file\"\"\"\n        try:\n            filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n            self._data.visualize(filename=filename)\n            return filename\n        except Exception as e:\n            logger.warning(f\"Failed to visualize the graph: {e}\")\n            return None\n\n    @abstractmethod\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"Basic implementation of binary operations\"\"\"\n        # Basic logic\n        # Actual implementation is left to derived classes\n        pass\n\n    def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Addition operator\"\"\"\n        return self._binary_op(other, lambda x, y: x + y, \"+\")\n\n    def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Subtraction operator\"\"\"\n        return self._binary_op(other, lambda x, y: x - y, \"-\")\n\n    def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Multiplication operator\"\"\"\n        return self._binary_op(other, lambda x, y: x * y, \"*\")\n\n    def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Division operator\"\"\"\n        return self._binary_op(other, lambda x, y: x / y, \"/\")\n\n    def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Apply a named operation.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters to pass to the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        # Apply the operation through abstract method\n        return self._apply_operation_impl(operation_name, **params)\n\n    @abstractmethod\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"Implementation of operation application\"\"\"\n        pass\n\n    def debug_info(self) -&gt; None:\n        \"\"\"Output detailed debug information\"\"\"\n        logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n        logger.debug(f\"Label: {self.label}\")\n        logger.debug(f\"Shape: {self.shape}\")\n        logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n        logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n        self._debug_info_impl()\n        logger.debug(\"=== End Debug Info ===\")\n\n    def _debug_info_impl(self) -&gt; None:\n        \"\"\"Implement derived class-specific debug information\"\"\"\n        pass\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.channels","title":"<code>channels</code>  <code>property</code>","text":"<p>Property to access channel metadata.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.data","title":"<code>data</code>  <code>property</code>","text":"<p>Returns the computed data. Calculation is executed the first time this is accessed.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>Get a list of all channel labels.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.n_channels","title":"<code>n_channels</code>  <code>property</code>","text":"<p>Returns the number of channels.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.previous","title":"<code>previous</code>  <code>property</code>","text":"<p>Returns the previous frame.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__add__","title":"<code>__add__(other)</code>","text":"<p>Addition operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Addition operator\"\"\"\n    return self._binary_op(other, lambda x, y: x + y, \"+\")\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__array__","title":"<code>__array__(dtype=None)</code>","text":"<p>Implicit conversion to NumPy array</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n    \"\"\"Implicit conversion to NumPy array\"\"\"\n    result = self.compute()\n    if dtype is not None:\n        return result.astype(dtype)\n    return result\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Method to get a channel by name or index.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__getitem__--parameters","title":"Parameters","text":"<p>key : str, int, slice, or tuple of slices     Channel name (label) or index number.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__getitem__--returns","title":"Returns","text":"<p>BaseFrame     The corresponding channel.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__getitem__--raises","title":"Raises","text":"<p>ValueError     If the key length is invalid for the shape. IndexError     If the channel index is out of range. TypeError     If the key type is invalid.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n    \"\"\"\n    Method to get a channel by name or index.\n\n    Parameters\n    ----------\n    key : str, int, slice, or tuple of slices\n        Channel name (label) or index number.\n\n    Returns\n    -------\n    BaseFrame\n        The corresponding channel.\n\n    Raises\n    ------\n    ValueError\n        If the key length is invalid for the shape.\n    IndexError\n        If the channel index is out of range.\n    TypeError\n        If the key type is invalid.\n    \"\"\"\n    if isinstance(key, str):\n        index = self.label2index(key)\n        return self.get_channel(index)\n\n    elif isinstance(key, tuple):\n        # When key is a tuple, treat the first element as an index\n        if len(key) &gt; len(self.shape):\n            raise ValueError(\n                f\"Invalid key length: {len(key)} for shape {self.shape}\"\n            )\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key[0]]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, slice):\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, numbers.Integral):\n        # Access by index number\n        if key &lt; 0 or key &gt;= len(self):\n            raise IndexError(f\"Channel index {key} out of range.\")\n        return self.get_channel(key)\n    else:\n        raise TypeError(\n            f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n        )\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of channels.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of channels.\n    \"\"\"\n    return len(self._channel_metadata)\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplication operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Multiplication operator\"\"\"\n    return self._binary_op(other, lambda x, y: x * y, \"*\")\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtraction operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Subtraction operator\"\"\"\n    return self._binary_op(other, lambda x, y: x - y, \"-\")\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Division operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Division operator\"\"\"\n    return self._binary_op(other, lambda x, y: x / y, \"/\")\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.apply_operation","title":"<code>apply_operation(operation_name, **params)</code>","text":"<p>Apply a named operation.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.apply_operation--parameters","title":"Parameters","text":"<p>operation_name : str     Name of the operation to apply. **params : Any     Parameters to pass to the operation.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.apply_operation--returns","title":"Returns","text":"<p>S     A new instance with the operation applied.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n    \"\"\"\n    Apply a named operation.\n\n    Parameters\n    ----------\n    operation_name : str\n        Name of the operation to apply.\n    **params : Any\n        Parameters to pass to the operation.\n\n    Returns\n    -------\n    S\n        A new instance with the operation applied.\n    \"\"\"\n    # Apply the operation through abstract method\n    return self._apply_operation_impl(operation_name, **params)\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.compute","title":"<code>compute()</code>","text":"<p>Compute and return the data. This method materializes lazily computed data into a concrete NumPy array.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.compute--returns","title":"Returns","text":"<p>NDArrayReal     The computed data.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.compute--raises","title":"Raises","text":"<p>ValueError     If the computed result is not a NumPy array.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def compute(self) -&gt; T:\n    \"\"\"\n    Compute and return the data.\n    This method materializes lazily computed data into a concrete NumPy array.\n\n    Returns\n    -------\n    NDArrayReal\n        The computed data.\n\n    Raises\n    ------\n    ValueError\n        If the computed result is not a NumPy array.\n    \"\"\"\n    logger.debug(\n        \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n    )\n    result = self._data.compute()\n\n    if not isinstance(result, np.ndarray):\n        raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n    logger.debug(f\"Computation complete, result shape: {result.shape}\")\n    return cast(T, result)\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.debug_info","title":"<code>debug_info()</code>","text":"<p>Output detailed debug information</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def debug_info(self) -&gt; None:\n    \"\"\"Output detailed debug information\"\"\"\n    logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n    logger.debug(f\"Label: {self.label}\")\n    logger.debug(f\"Shape: {self.shape}\")\n    logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n    logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n    self._debug_info_impl()\n    logger.debug(\"=== End Debug Info ===\")\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.label2index","title":"<code>label2index(label)</code>","text":"<p>Get the index from a channel label.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.label2index--parameters","title":"Parameters","text":"<p>label : str     Channel label.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.label2index--returns","title":"Returns","text":"<p>int     Corresponding index.</p>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.label2index--raises","title":"Raises","text":"<p>KeyError     If the channel label is not found.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def label2index(self, label: str) -&gt; int:\n    \"\"\"\n    Get the index from a channel label.\n\n    Parameters\n    ----------\n    label : str\n        Channel label.\n\n    Returns\n    -------\n    int\n        Corresponding index.\n\n    Raises\n    ------\n    KeyError\n        If the channel label is not found.\n    \"\"\"\n    for idx, ch in enumerate(self._channel_metadata):\n        if ch.label == label:\n            return idx\n    raise KeyError(f\"Channel label '{label}' not found.\")\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.persist","title":"<code>persist()</code>","text":"<p>Persist the data in memory</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def persist(self: S) -&gt; S:\n    \"\"\"Persist the data in memory\"\"\"\n    persisted_data = self._data.persist()\n    return self._create_new_instance(data=persisted_data)\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.plot","title":"<code>plot(plot_type='default', ax=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Plot the data</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>@abstractmethod\ndef plot(\n    self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n) -&gt; Union[Axes, Iterator[Axes]]:\n    \"\"\"Plot the data\"\"\"\n    pass\n</code></pre>"},{"location":"en/api/#wandas.core.base_frame.BaseFrame.visualize_graph","title":"<code>visualize_graph(filename=None)</code>","text":"<p>Visualize the computation graph and save it to a file</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"Visualize the computation graph and save it to a file\"\"\"\n    try:\n        filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n        self._data.visualize(filename=filename)\n        return filename\n    except Exception as e:\n        logger.warning(f\"Failed to visualize the graph: {e}\")\n        return None\n</code></pre>"},{"location":"en/api/#frame-module","title":"Frame Module","text":""},{"location":"en/api/#channelframe","title":"ChannelFrame","text":"<p><code>ChannelFrame</code> is a class that handles time-domain signal data.</p> <pre><code>from wandas.frames.channel import ChannelFrame\n</code></pre> <p>You can also import it directly:</p> <pre><code>import wandas\n# Use it as follows\nframe = wandas.read_wav(\"audio.wav\")\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Channel-based data frame for handling audio signals and time series data.</p> <p>This frame represents channel-based data such as audio signals and time series data, with each channel containing data samples in the time domain.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>class ChannelFrame(BaseFrame[NDArrayReal]):\n    \"\"\"Channel-based data frame for handling audio signals and time series data.\n\n    This frame represents channel-based data such as audio signals and time series data,\n    with each channel containing data samples in the time domain.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"Initialize a ChannelFrame.\n\n        Args:\n            data: Dask array containing channel data.\n            Shape should be (n_channels, n_samples).\n            sampling_rate: The sampling rate of the data in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            operation_history: History of operations applied to the frame.\n            channel_metadata: Metadata for each channel.\n            previous: Reference to the previous frame in the processing chain.\n\n        Raises:\n            ValueError: If data has more than 2 dimensions.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return self.shape[-2]\n\n    @property\n    def time(self) -&gt; NDArrayReal:\n        \"\"\"Get time array for the signal.\n\n        Returns:\n            Array of time points in seconds.\n        \"\"\"\n        return np.arange(self.n_samples) / self.sampling_rate\n\n    @property\n    def n_samples(self) -&gt; int:\n        \"\"\"Returns the number of samples.\"\"\"\n        n: int = self._data.shape[-1]\n        return n\n\n    @property\n    def duration(self) -&gt; float:\n        \"\"\"Returns the duration in seconds.\"\"\"\n        return self.n_samples / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # Apply processing to data\n        processed_data = operation.process(self._data)\n\n        # Update metadata\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        if operation_name == \"resampling\":\n            # For resampling, update sampling rate\n            return self._create_new_instance(\n                sampling_rate=params[\"target_sr\"],\n                data=processed_data,\n                metadata=new_metadata,\n                operation_history=new_history,\n            )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Common implementation for binary operations\n        - utilizing dask's lazy evaluation.\n\n        Args:\n            other: Right operand for the operation.\n            op: Function to execute the operation (e.g., lambda a, b: a + b).\n            symbol: Symbolic representation of the operation (e.g., '+').\n\n        Returns:\n            A new channel containing the operation result (lazy execution).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, ChannelFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Perform operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other._data)\n\n            # Merge channel metadata\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # Perform operation with scalar, NumPy array, or other types\n        else:\n            # Apply operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other)\n\n            # Operand display string\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # Check for dask.array.Array\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # Update channel metadata\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n                previous=self,\n            )\n\n    def add(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        snr: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Add another signal or value to the current signal.\n\n        If SNR is specified, performs addition with consideration for\n        signal-to-noise ratio.\n\n        Args:\n            other: Signal or value to add.\n            snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n                other signal based on this SNR.\n                self is treated as the signal, and other as the noise.\n\n        Returns:\n            A new channel frame containing the addition result (lazy execution).\n        \"\"\"\n        logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n        # Special processing when SNR is specified\n        if snr is not None:\n            # First convert other to ChannelFrame if it's not\n            if not isinstance(other, ChannelFrame):\n                if isinstance(other, np.ndarray):\n                    other = ChannelFrame.from_numpy(\n                        other, self.sampling_rate, label=\"array_data\"\n                    )\n                elif isinstance(other, (int, float)):\n                    # For scalar values, simply add (ignore SNR)\n                    return self + other\n                else:\n                    raise TypeError(\n                        \"Addition target with SNR must be a ChannelFrame or \"\n                        f\"NumPy array: {type(other)}\"\n                    )\n\n            # Check if sampling rates match\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Apply addition operation with SNR adjustment\n            return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n        # Execute normal addition if SNR is not specified\n        return self + other\n\n    def plot(\n        self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Plot the frame data.\n\n        Args:\n            plot_type: Type of plot. Default is \"waveform\".\n            ax: Optional matplotlib axes for plotting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        plot_strategy = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def rms_plot(\n        self,\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = True,\n        Aw: bool = False,  # noqa: N803\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Generate an RMS plot.\n\n        Args:\n            ax: Optional matplotlib axes for plotting.\n            title: Title for the plot.\n            overlay: Whether to overlay the plot on the existing axis.\n            Aw: Apply A-weighting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        kwargs = kwargs or {}\n        ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n        rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n        return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n\n    def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n        \"\"\"Display visual and audio representation of the frame.\n\n        Args:\n            normalize: Whether to normalize the audio data for playback.\n            **kwargs: Additional parameters for visualization.\n        \"\"\"\n        if \"axis_config\" in kwargs:\n            logger.warning(\n                \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            axis_config = kwargs[\"axis_config\"]\n            if \"time_plot\" in axis_config:\n                kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n            if \"freq_plot\" in axis_config:\n                if \"xlim\" in axis_config[\"freq_plot\"]:\n                    vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                    kwargs[\"vmin\"] = vlim[0]\n                    kwargs[\"vmax\"] = vlim[1]\n                if \"ylim\" in axis_config[\"freq_plot\"]:\n                    ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                    kwargs[\"ylim\"] = ylim\n\n        if \"cbar_config\" in kwargs:\n            logger.warning(\n                \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            cbar_config = kwargs[\"cbar_config\"]\n            if \"vmin\" in cbar_config:\n                kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n            if \"vmax\" in cbar_config:\n                kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n        for ch in self:\n            ax: Axes\n            _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n            if isinstance(_ax, Iterator):\n                ax = next(iter(_ax))\n            elif isinstance(_ax, Axes):\n                ax = _ax\n            else:\n                raise TypeError(\n                    f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n                )\n            # Ignore type checks for display and Audio\n            display(ax.figure)  # type: ignore\n            plt.close(ax.figure)  # type: ignore\n            display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n\n    @classmethod\n    def from_numpy(\n        cls,\n        data: NDArrayReal,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        ch_labels: Optional[list[str]] = None,\n        ch_units: Optional[Union[list[str], str]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        Args:\n            data: NumPy array containing channel data.\n            sampling_rate: The sampling rate in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            ch_labels: Labels for each channel.\n            ch_units: Units for each channel.\n\n        Returns:\n            A new ChannelFrame containing the NumPy data.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n\n        # Convert NumPy array to dask array\n        dask_data = da_from_array(data)\n        cf = ChannelFrame(\n            data=dask_data,\n            sampling_rate=sampling_rate,\n            label=label or \"numpy_data\",\n        )\n        if metadata is not None:\n            cf.metadata = metadata\n        if ch_labels is not None:\n            if len(ch_labels) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel labels does not match the number of channels\"\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        if ch_units is not None:\n            if isinstance(ch_units, str):\n                ch_units = [ch_units] * cf.n_channels\n\n            if len(ch_units) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel units does not match the number of channels\"\n                )\n            for i in range(len(ch_units)):\n                cf._channel_metadata[i].unit = ch_units[i]\n\n        return cf\n\n    @classmethod\n    def from_ndarray(\n        cls,\n        array: NDArrayReal,\n        sampling_rate: float,\n        labels: Optional[list[str]] = None,\n        unit: Optional[Union[list[str], str]] = None,\n        frame_label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        This method is deprecated. Use from_numpy instead.\n\n        Args:\n            array: Signal data. Each row corresponds to a channel.\n            sampling_rate: Sampling rate (Hz).\n            labels: Labels for each channel.\n            unit: Unit of the signal.\n            frame_label: Label for the frame.\n            metadata: Optional metadata dictionary.\n\n        Returns:\n            A new ChannelFrame containing the data.\n        \"\"\"\n        # Redirect to from_numpy for compatibility\n        # However, from_ndarray is deprecated\n        logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n        return cls.from_numpy(\n            data=array,\n            sampling_rate=sampling_rate,\n            label=frame_label,\n            metadata=metadata,\n            ch_labels=labels,\n            ch_units=unit,\n        )\n\n    @classmethod\n    def from_file(\n        cls,\n        path: Union[str, Path],\n        channel: Optional[Union[int, list[int]]] = None,\n        start: Optional[float] = None,\n        end: Optional[float] = None,\n        chunk_size: Optional[int] = None,\n        ch_labels: Optional[list[str]] = None,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from an audio file.\n\n        Args:\n            path: Path to the audio file.\n            channel: Channel(s) to load.\n            start: Start time in seconds.\n            end: End time in seconds.\n            chunk_size: Chunk size for processing.\n            Specifies the splitting size for lazy processing.\n            ch_labels: Labels for each channel.\n            **kwargs: Additional arguments passed to the file reader.\n\n        Returns:\n            A new ChannelFrame containing the loaded audio data.\n\n        Raises:\n            ValueError: If channel selection is invalid.\n            TypeError: If channel parameter type is invalid.\n            FileNotFoundError: If the file doesn't exist.\n        \"\"\"\n        from .channel import ChannelFrame\n\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"File not found: {path}\")\n\n        # Get file reader\n        reader = get_file_reader(path)\n\n        # Get file info\n        info = reader.get_file_info(path, **kwargs)\n        sr = info[\"samplerate\"]\n        n_channels = info[\"channels\"]\n        n_frames = info[\"frames\"]\n        ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n        logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n        # Channel selection processing\n        all_channels = list(range(n_channels))\n\n        if channel is None:\n            channels_to_load = all_channels\n            logger.debug(f\"Will load all channels: {channels_to_load}\")\n        elif isinstance(channel, int):\n            if channel &lt; 0 or channel &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n            channels_to_load = [channel]\n            logger.debug(f\"Will load single channel: {channel}\")\n        elif isinstance(channel, (list, tuple)):\n            for ch in channel:\n                if ch &lt; 0 or ch &gt;= n_channels:\n                    raise ValueError(\n                        f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                    )\n            channels_to_load = list(channel)\n            logger.debug(f\"Will load specific channels: {channels_to_load}\")\n        else:\n            raise TypeError(\"channel must be int, list, or None\")\n\n        # Index calculation\n        start_idx = 0 if start is None else max(0, int(start * sr))\n        end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n        frames_to_read = end_idx - start_idx\n\n        logger.debug(\n            f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n            f\"start_idx={start_idx}, end_idx={end_idx}\"\n        )\n\n        # Settings for lazy loading\n        expected_shape = (len(channels_to_load), frames_to_read)\n\n        # Define the loading function using the file reader\n        def _load_audio() -&gt; NDArrayReal:\n            logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n            # Use the reader to get audio data with parameters\n            out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n            if not isinstance(out, np.ndarray):\n                raise ValueError(\"Unexpected data type after reading file\")\n            return out\n\n        logger.debug(\n            f\"Creating delayed dask task with expected shape: {expected_shape}\"\n        )\n\n        # Create delayed operation\n        delayed_data = dask_delayed(_load_audio)()\n        logger.debug(\"Wrapping delayed function in dask array\")\n\n        # Create dask array from delayed computation\n        dask_array = da_from_delayed(\n            delayed_data, shape=expected_shape, dtype=np.float32\n        )\n\n        if chunk_size is not None:\n            if chunk_size &lt;= 0:\n                raise ValueError(\"Chunk size must be a positive integer\")\n            logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n            dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n        logger.debug(\n            \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n        )\n\n        cf = ChannelFrame(\n            data=dask_array,\n            sampling_rate=sr,\n            label=path.stem,\n            metadata={\n                \"filename\": str(path),\n            },\n        )\n        if ch_labels is not None:\n            if len(ch_labels) != len(cf):\n                raise ValueError(\n                    \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        return cf\n\n    @classmethod\n    def read_wav(\n        cls, filename: str, labels: Optional[list[str]] = None\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a WAV file.\n\n        Args:\n            filename: Path to the WAV file.\n            labels: Labels to set for each channel.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(filename, ch_labels=labels)\n        return cf\n\n    @classmethod\n    def read_csv(\n        cls,\n        filename: str,\n        time_column: Union[int, str] = 0,\n        labels: Optional[list[str]] = None,\n        delimiter: str = \",\",\n        header: Optional[int] = 0,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a CSV file.\n\n        Args:\n            filename: Path to the CSV file.\n            time_column: Index or name of the time column.\n            labels: Labels to set for each channel.\n            delimiter: Delimiter character.\n            header: Row number to use as header.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(\n            filename,\n            ch_labels=labels,\n            time_column=time_column,\n            delimiter=delimiter,\n            header=header,\n        )\n        return cf\n\n    def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n        \"\"\"Save the audio data to a file.\n\n        Args:\n            path: Path to save the file.\n            format: File format. If None, determined from file extension.\n        \"\"\"\n        logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n        data = self.compute()\n        data = data.T\n        if data.shape[1] == 1:\n            data = data.squeeze(axis=1)\n        sf.write(str(path), data, int(self.sampling_rate), format=format)\n        logger.debug(f\"Save complete: {path}\")\n\n    def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a high-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n\n    def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a low-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n\n    def normalize(\n        self, target_level: float = -20, channel_wise: bool = True\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Normalize the signal level.\n\n        This method adjusts the signal amplitude to reach a target RMS level.\n\n        Args:\n            target_level: Target RMS level in dB. Default is -20.\n            channel_wise: If True, normalize each channel independently.\n                If False, apply the same scaling to all channels.\n\n        Returns:\n            A new ChannelFrame containing the normalized signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n        )\n        return self.apply_operation(\n            \"normalize\", target_level=target_level, channel_wise=channel_wise\n        )\n\n    def a_weighting(self) -&gt; \"ChannelFrame\":\n        \"\"\"Apply A-weighting filter to the signal.\n\n        A-weighting adjusts the frequency response to approximate human hearing\n        perception, following IEC 61672-1:2013 standard.\n\n        Returns:\n            A new ChannelFrame with A-weighted signal.\n        \"\"\"\n        return self.apply_operation(\"a_weighting\")\n\n    def hpss_harmonic(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract harmonic components using HPSS\n         (Harmonic-Percussive Source Separation).\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_harmonic\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def hpss_percussive(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract percussive components using HPSS\n        (Harmonic-Percussive Source Separation).\n\n        This method separates the percussive (tonal) components from the signal.\n\n        Args:\n            kernel_size: Median filter size for HPSS.\n            power: Exponent for the Weiner filter used in HPSS.\n            margin: Margin size for the separation.\n\n        Returns:\n            A new ChannelFrame containing the harmonic components.\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_percussive\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def resampling(\n        self,\n        target_sr: float,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Resample audio data.\n\n        Parameters\n        ----------\n        target_sr : float\n            Target sampling rate (Hz)\n        resample_type : str, optional\n            Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n        **kwargs : dict\n            Additional resampling parameters\n\n        Returns\n        -------\n        ChannelFrame\n            Resampled channel frame\n        \"\"\"\n        return self.apply_operation(\n            \"resampling\",\n            target_sr=target_sr,\n            **kwargs,\n        )\n\n    def abs(self) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the absolute value of the signal.\n\n        Returns:\n            A new ChannelFrame containing the absolute values.\n        \"\"\"\n        return self.apply_operation(\"abs\")\n\n    def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the power of the signal.\n\n        Args:\n            exponent: The exponent to raise the signal to. Default is 2.0.\n\n        Returns:\n            A new ChannelFrame containing the signal raised to the power.\n        \"\"\"\n        return self.apply_operation(\"power\", exponent=exponent)\n\n    def trim(\n        self,\n        start: float = 0,\n        end: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Trim the signal to specified time range.\n\n        Args:\n            start: Start time in seconds.\n            end: End time in seconds.\n\n        Returns:\n            A new ChannelFrame with trimmed signal.\n\n        Raises:\n            ValueError: If end time is before start time.\n        \"\"\"\n        if end is None:\n            end = self.duration\n        if start &gt; end:\n            raise ValueError(\"start must be less than end\")\n        # Apply trim operation\n        return self.apply_operation(\"trim\", start=start, end=end)\n\n    def rms_trend(\n        self,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the RMS trend of the signal.\n\n        This method computes the root mean square value over sliding windows.\n\n        Args:\n            frame_length: The size of the sliding window in samples. Default is 2048.\n            hop_length: The hop length between windows in samples. Default is 512.\n            dB: Whether to return the RMS values in decibels. Default is False.\n            Aw: Whether to apply A-weighting. Default is False.\n\n        Returns:\n            A new ChannelFrame containing the RMS trend.\n        \"\"\"\n        cf = self.apply_operation(\n            \"rms_trend\",\n            frame_length=frame_length,\n            hop_length=hop_length,\n            ref=[ch.ref for ch in self._channel_metadata],\n            dB=dB,\n            Aw=Aw,\n        )\n        cf.sampling_rate = self.sampling_rate / hop_length\n        return cf\n\n    def sum(self) -&gt; \"ChannelFrame\":\n        \"\"\"Sum all channels.\n\n        Returns:\n            A new ChannelFrame with summed signal.\n        \"\"\"\n        return self.apply_operation(\"sum\")\n\n    def mean(self) -&gt; \"ChannelFrame\":\n        \"\"\"Average all channels.\n\n        Returns:\n            A new ChannelFrame with averaged signal.\n        \"\"\"\n        return self.apply_operation(\"mean\")\n\n    def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate channel differences relative to a reference channel.\n\n        Args:\n            other_channel: Reference channel index or label. Default is 0.\n\n        Returns:\n            A new ChannelFrame with channel differences.\n        \"\"\"\n        if isinstance(other_channel, str):\n            return self.apply_operation(\n                \"channel_difference\", other_channel=self.label2index(other_channel)\n            )\n        return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n\n    def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n        \"\"\"Compute Fast Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is next power of 2 of data length.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectralFrame containing the FFT results.\n        \"\"\"\n        from ..processing.time_series import FFT\n        from .spectral import SpectralFrame\n\n        params = {\"n_fft\": n_fft, \"window\": window}\n        operation_name = \"fft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"FFT\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        if n_fft is None:\n            is_even = spectrum_data.shape[-1] % 2 == 0\n            _n_fft = (\n                spectrum_data.shape[-1] * 2 - 2\n                if is_even\n                else spectrum_data.shape[-1] * 2 - 1\n            )\n        else:\n            _n_fft = n_fft\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=_n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def welch(\n        self,\n        n_fft: Optional[int] = None,\n        hop_length: Optional[int] = None,\n        win_length: int = 2048,\n        window: str = \"hann\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute power spectral density using Welch's method.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the power spectral density.\n        \"\"\"\n        from ..processing.time_series import Welch\n        from .spectral import SpectralFrame\n\n        params = dict(\n            n_fft=n_fft or win_length,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            average=average,\n        )\n        operation_name = \"welch\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Welch\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"welch\", \"params\": params},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def noct_spectrum(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"Compute N-octave band spectrum.\n\n        Args:\n            fmin: Minimum center frequency in Hz. Default is 20 Hz.\n            fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n            n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n            G: Reference gain in dB. Default is 10 dB.\n            fr: Reference frequency in Hz. Default is 1000 Hz.\n\n        Returns:\n            A NOctFrame containing the N-octave band spectrum.\n        \"\"\"\n        from ..processing.time_series import NOctSpectrum\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_spectrum\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSpectrum\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_spectrum\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def stft(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"Compute Short-Time Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectrogramFrame containing the STFT results.\n        \"\"\"\n        from ..processing.time_series import STFT, create_operation\n        from .spectrogram import SpectrogramFrame\n\n        # Set hop length and window length\n        _hop_length = hop_length if hop_length is not None else n_fft // 4\n        _win_length = win_length if win_length is not None else n_fft\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": _hop_length,\n            \"win_length\": _win_length,\n            \"window\": window,\n        }\n        operation_name = \"stft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"STFT\", operation)\n\n        # Apply processing to data\n        spectrogram_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n\n        # Create new instance\n        return SpectrogramFrame(\n            data=spectrogram_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=n_fft,\n            hop_length=_hop_length,\n            win_length=_win_length,\n            window=window,\n            label=f\"stft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def coherence(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute magnitude squared coherence.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n        Returns:\n            A SpectralFrame containing the magnitude squared coherence.\n        \"\"\"\n        from ..processing.time_series import Coherence, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n        }\n        operation_name = \"coherence\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Coherence\", operation)\n\n        # Apply processing to data\n        coherence_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=coherence_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Coherence of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def csd(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute cross-spectral density matrix.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the cross-spectral density matrix.\n        \"\"\"\n        from ..processing.time_series import CSD, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"csd\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"CSD\", operation)\n\n        # Apply processing to data\n        csd_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=csd_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def transfer_function(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute transfer function matrix.\n\n        The transfer function characterizes the signal transmission properties\n        between channels in the frequency domain, representing the input-output\n        relationship of a system.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the transfer function matrix.\n        \"\"\"\n        from ..processing.time_series import TransferFunction, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"transfer_function\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"TransferFunction\", operation)\n\n        # Apply processing to data\n        tf_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=tf_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Transfer function of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"Provide additional initialization arguments required for ChannelFrame.\"\"\"\n        return {}\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Returns the duration in seconds.</p>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>Returns the number of samples.</p>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.time","title":"<code>time</code>  <code>property</code>","text":"<p>Get time array for the signal.</p> <p>Returns:</p> Type Description <code>NDArrayReal</code> <p>Array of time points in seconds.</p>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.__init__","title":"<code>__init__(data, sampling_rate, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a ChannelFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>Dask array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate of the data in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>operation_history</code> <code>Optional[list[dict[str, Any]]]</code> <p>History of operations applied to the frame.</p> <code>None</code> <code>channel_metadata</code> <code>Optional[list[ChannelMetadata]]</code> <p>Metadata for each channel.</p> <code>None</code> <code>previous</code> <code>Optional[BaseFrame[Any]]</code> <p>Reference to the previous frame in the processing chain.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has more than 2 dimensions.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"Initialize a ChannelFrame.\n\n    Args:\n        data: Dask array containing channel data.\n        Shape should be (n_channels, n_samples).\n        sampling_rate: The sampling rate of the data in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        operation_history: History of operations applied to the frame.\n        channel_metadata: Metadata for each channel.\n        previous: Reference to the previous frame in the processing chain.\n\n    Raises:\n        ValueError: If data has more than 2 dimensions.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.a_weighting","title":"<code>a_weighting()</code>","text":"<p>Apply A-weighting filter to the signal.</p> <p>A-weighting adjusts the frequency response to approximate human hearing perception, following IEC 61672-1:2013 standard.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with A-weighted signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def a_weighting(self) -&gt; \"ChannelFrame\":\n    \"\"\"Apply A-weighting filter to the signal.\n\n    A-weighting adjusts the frequency response to approximate human hearing\n    perception, following IEC 61672-1:2013 standard.\n\n    Returns:\n        A new ChannelFrame with A-weighted signal.\n    \"\"\"\n    return self.apply_operation(\"a_weighting\")\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.abs","title":"<code>abs()</code>","text":"<p>Calculate the absolute value of the signal.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the absolute values.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def abs(self) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the absolute value of the signal.\n\n    Returns:\n        A new ChannelFrame containing the absolute values.\n    \"\"\"\n    return self.apply_operation(\"abs\")\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.add","title":"<code>add(other, snr=None)</code>","text":"<p>Add another signal or value to the current signal.</p> <p>If SNR is specified, performs addition with consideration for signal-to-noise ratio.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[ChannelFrame, int, float, NDArrayReal, Array]</code> <p>Signal or value to add.</p> required <code>snr</code> <code>Optional[float]</code> <p>Signal-to-noise ratio (dB). If specified, adjusts the scale of the other signal based on this SNR. self is treated as the signal, and other as the noise.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new channel frame containing the addition result (lazy execution).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def add(\n    self,\n    other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n    snr: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Add another signal or value to the current signal.\n\n    If SNR is specified, performs addition with consideration for\n    signal-to-noise ratio.\n\n    Args:\n        other: Signal or value to add.\n        snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n            other signal based on this SNR.\n            self is treated as the signal, and other as the noise.\n\n    Returns:\n        A new channel frame containing the addition result (lazy execution).\n    \"\"\"\n    logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n    # Special processing when SNR is specified\n    if snr is not None:\n        # First convert other to ChannelFrame if it's not\n        if not isinstance(other, ChannelFrame):\n            if isinstance(other, np.ndarray):\n                other = ChannelFrame.from_numpy(\n                    other, self.sampling_rate, label=\"array_data\"\n                )\n            elif isinstance(other, (int, float)):\n                # For scalar values, simply add (ignore SNR)\n                return self + other\n            else:\n                raise TypeError(\n                    \"Addition target with SNR must be a ChannelFrame or \"\n                    f\"NumPy array: {type(other)}\"\n                )\n\n        # Check if sampling rates match\n        if self.sampling_rate != other.sampling_rate:\n            raise ValueError(\n                \"Sampling rates do not match. Cannot perform operation.\"\n            )\n\n        # Apply addition operation with SNR adjustment\n        return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n    # Execute normal addition if SNR is not specified\n    return self + other\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.channel_difference","title":"<code>channel_difference(other_channel=0)</code>","text":"<p>Calculate channel differences relative to a reference channel.</p> <p>Parameters:</p> Name Type Description Default <code>other_channel</code> <code>Union[int, str]</code> <p>Reference channel index or label. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with channel differences.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate channel differences relative to a reference channel.\n\n    Args:\n        other_channel: Reference channel index or label. Default is 0.\n\n    Returns:\n        A new ChannelFrame with channel differences.\n    \"\"\"\n    if isinstance(other_channel, str):\n        return self.apply_operation(\n            \"channel_difference\", other_channel=self.label2index(other_channel)\n        )\n    return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.coherence","title":"<code>coherence(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant')</code>","text":"<p>Compute magnitude squared coherence.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the magnitude squared coherence.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def coherence(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute magnitude squared coherence.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n    Returns:\n        A SpectralFrame containing the magnitude squared coherence.\n    \"\"\"\n    from ..processing.time_series import Coherence, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n    }\n    operation_name = \"coherence\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Coherence\", operation)\n\n    # Apply processing to data\n    coherence_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=coherence_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Coherence of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.csd","title":"<code>csd(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute cross-spectral density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the cross-spectral density matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def csd(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute cross-spectral density matrix.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the cross-spectral density matrix.\n    \"\"\"\n    from ..processing.time_series import CSD, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"csd\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"CSD\", operation)\n\n    # Apply processing to data\n    csd_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=csd_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.describe","title":"<code>describe(normalize=True, **kwargs)</code>","text":"<p>Display visual and audio representation of the frame.</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>Whether to normalize the audio data for playback.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for visualization.</p> <code>{}</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n    \"\"\"Display visual and audio representation of the frame.\n\n    Args:\n        normalize: Whether to normalize the audio data for playback.\n        **kwargs: Additional parameters for visualization.\n    \"\"\"\n    if \"axis_config\" in kwargs:\n        logger.warning(\n            \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        axis_config = kwargs[\"axis_config\"]\n        if \"time_plot\" in axis_config:\n            kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n        if \"freq_plot\" in axis_config:\n            if \"xlim\" in axis_config[\"freq_plot\"]:\n                vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                kwargs[\"vmin\"] = vlim[0]\n                kwargs[\"vmax\"] = vlim[1]\n            if \"ylim\" in axis_config[\"freq_plot\"]:\n                ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                kwargs[\"ylim\"] = ylim\n\n    if \"cbar_config\" in kwargs:\n        logger.warning(\n            \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        cbar_config = kwargs[\"cbar_config\"]\n        if \"vmin\" in cbar_config:\n            kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n        if \"vmax\" in cbar_config:\n            kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n    for ch in self:\n        ax: Axes\n        _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n        if isinstance(_ax, Iterator):\n            ax = next(iter(_ax))\n        elif isinstance(_ax, Axes):\n            ax = _ax\n        else:\n            raise TypeError(\n                f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n            )\n        # Ignore type checks for display and Audio\n        display(ax.figure)  # type: ignore\n        plt.close(ax.figure)  # type: ignore\n        display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.fft","title":"<code>fft(n_fft=None, window='hann')</code>","text":"<p>Compute Fast Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is next power of 2 of data length.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the FFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n    \"\"\"Compute Fast Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is next power of 2 of data length.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectralFrame containing the FFT results.\n    \"\"\"\n    from ..processing.time_series import FFT\n    from .spectral import SpectralFrame\n\n    params = {\"n_fft\": n_fft, \"window\": window}\n    operation_name = \"fft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"FFT\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    if n_fft is None:\n        is_even = spectrum_data.shape[-1] % 2 == 0\n        _n_fft = (\n            spectrum_data.shape[-1] * 2 - 2\n            if is_even\n            else spectrum_data.shape[-1] * 2 - 1\n        )\n    else:\n        _n_fft = n_fft\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=_n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.from_file","title":"<code>from_file(path, channel=None, start=None, end=None, chunk_size=None, ch_labels=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from an audio file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the audio file.</p> required <code>channel</code> <code>Optional[Union[int, list[int]]]</code> <p>Channel(s) to load.</p> <code>None</code> <code>start</code> <code>Optional[float]</code> <p>Start time in seconds.</p> <code>None</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <code>chunk_size</code> <code>Optional[int]</code> <p>Chunk size for processing.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the file reader.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the loaded audio data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If channel selection is invalid.</p> <code>TypeError</code> <p>If channel parameter type is invalid.</p> <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    path: Union[str, Path],\n    channel: Optional[Union[int, list[int]]] = None,\n    start: Optional[float] = None,\n    end: Optional[float] = None,\n    chunk_size: Optional[int] = None,\n    ch_labels: Optional[list[str]] = None,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from an audio file.\n\n    Args:\n        path: Path to the audio file.\n        channel: Channel(s) to load.\n        start: Start time in seconds.\n        end: End time in seconds.\n        chunk_size: Chunk size for processing.\n        Specifies the splitting size for lazy processing.\n        ch_labels: Labels for each channel.\n        **kwargs: Additional arguments passed to the file reader.\n\n    Returns:\n        A new ChannelFrame containing the loaded audio data.\n\n    Raises:\n        ValueError: If channel selection is invalid.\n        TypeError: If channel parameter type is invalid.\n        FileNotFoundError: If the file doesn't exist.\n    \"\"\"\n    from .channel import ChannelFrame\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    # Get file reader\n    reader = get_file_reader(path)\n\n    # Get file info\n    info = reader.get_file_info(path, **kwargs)\n    sr = info[\"samplerate\"]\n    n_channels = info[\"channels\"]\n    n_frames = info[\"frames\"]\n    ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n    logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n    # Channel selection processing\n    all_channels = list(range(n_channels))\n\n    if channel is None:\n        channels_to_load = all_channels\n        logger.debug(f\"Will load all channels: {channels_to_load}\")\n    elif isinstance(channel, int):\n        if channel &lt; 0 or channel &gt;= n_channels:\n            raise ValueError(\n                f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n            )\n        channels_to_load = [channel]\n        logger.debug(f\"Will load single channel: {channel}\")\n    elif isinstance(channel, (list, tuple)):\n        for ch in channel:\n            if ch &lt; 0 or ch &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n        channels_to_load = list(channel)\n        logger.debug(f\"Will load specific channels: {channels_to_load}\")\n    else:\n        raise TypeError(\"channel must be int, list, or None\")\n\n    # Index calculation\n    start_idx = 0 if start is None else max(0, int(start * sr))\n    end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n    frames_to_read = end_idx - start_idx\n\n    logger.debug(\n        f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n        f\"start_idx={start_idx}, end_idx={end_idx}\"\n    )\n\n    # Settings for lazy loading\n    expected_shape = (len(channels_to_load), frames_to_read)\n\n    # Define the loading function using the file reader\n    def _load_audio() -&gt; NDArrayReal:\n        logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n        # Use the reader to get audio data with parameters\n        out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n        if not isinstance(out, np.ndarray):\n            raise ValueError(\"Unexpected data type after reading file\")\n        return out\n\n    logger.debug(\n        f\"Creating delayed dask task with expected shape: {expected_shape}\"\n    )\n\n    # Create delayed operation\n    delayed_data = dask_delayed(_load_audio)()\n    logger.debug(\"Wrapping delayed function in dask array\")\n\n    # Create dask array from delayed computation\n    dask_array = da_from_delayed(\n        delayed_data, shape=expected_shape, dtype=np.float32\n    )\n\n    if chunk_size is not None:\n        if chunk_size &lt;= 0:\n            raise ValueError(\"Chunk size must be a positive integer\")\n        logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n        dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n    logger.debug(\n        \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n    )\n\n    cf = ChannelFrame(\n        data=dask_array,\n        sampling_rate=sr,\n        label=path.stem,\n        metadata={\n            \"filename\": str(path),\n        },\n    )\n    if ch_labels is not None:\n        if len(ch_labels) != len(cf):\n            raise ValueError(\n                \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    return cf\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.from_ndarray","title":"<code>from_ndarray(array, sampling_rate, labels=None, unit=None, frame_label=None, metadata=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>This method is deprecated. Use from_numpy instead.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>NDArrayReal</code> <p>Signal data. Each row corresponds to a channel.</p> required <code>sampling_rate</code> <code>float</code> <p>Sampling rate (Hz).</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>unit</code> <code>Optional[Union[list[str], str]]</code> <p>Unit of the signal.</p> <code>None</code> <code>frame_label</code> <code>Optional[str]</code> <p>Label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_ndarray(\n    cls,\n    array: NDArrayReal,\n    sampling_rate: float,\n    labels: Optional[list[str]] = None,\n    unit: Optional[Union[list[str], str]] = None,\n    frame_label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    This method is deprecated. Use from_numpy instead.\n\n    Args:\n        array: Signal data. Each row corresponds to a channel.\n        sampling_rate: Sampling rate (Hz).\n        labels: Labels for each channel.\n        unit: Unit of the signal.\n        frame_label: Label for the frame.\n        metadata: Optional metadata dictionary.\n\n    Returns:\n        A new ChannelFrame containing the data.\n    \"\"\"\n    # Redirect to from_numpy for compatibility\n    # However, from_ndarray is deprecated\n    logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n    return cls.from_numpy(\n        data=array,\n        sampling_rate=sampling_rate,\n        label=frame_label,\n        metadata=metadata,\n        ch_labels=labels,\n        ch_units=unit,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.from_numpy","title":"<code>from_numpy(data, sampling_rate, label=None, metadata=None, ch_labels=None, ch_units=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArrayReal</code> <p>NumPy array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>ch_units</code> <code>Optional[Union[list[str], str]]</code> <p>Units for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the NumPy data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_numpy(\n    cls,\n    data: NDArrayReal,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    ch_labels: Optional[list[str]] = None,\n    ch_units: Optional[Union[list[str], str]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    Args:\n        data: NumPy array containing channel data.\n        sampling_rate: The sampling rate in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        ch_labels: Labels for each channel.\n        ch_units: Units for each channel.\n\n    Returns:\n        A new ChannelFrame containing the NumPy data.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n\n    # Convert NumPy array to dask array\n    dask_data = da_from_array(data)\n    cf = ChannelFrame(\n        data=dask_data,\n        sampling_rate=sampling_rate,\n        label=label or \"numpy_data\",\n    )\n    if metadata is not None:\n        cf.metadata = metadata\n    if ch_labels is not None:\n        if len(ch_labels) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel labels does not match the number of channels\"\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    if ch_units is not None:\n        if isinstance(ch_units, str):\n            ch_units = [ch_units] * cf.n_channels\n\n        if len(ch_units) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel units does not match the number of channels\"\n            )\n        for i in range(len(ch_units)):\n            cf._channel_metadata[i].unit = ch_units[i]\n\n    return cf\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.high_pass_filter","title":"<code>high_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a high-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a high-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.hpss_harmonic","title":"<code>hpss_harmonic(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract harmonic components using HPSS  (Harmonic-Percussive Source Separation).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_harmonic(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract harmonic components using HPSS\n     (Harmonic-Percussive Source Separation).\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_harmonic\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.hpss_percussive","title":"<code>hpss_percussive(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract percussive components using HPSS (Harmonic-Percussive Source Separation).</p> <p>This method separates the percussive (tonal) components from the signal.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Union[_IntLike_co, tuple[_IntLike_co, _IntLike_co], list[_IntLike_co]]</code> <p>Median filter size for HPSS.</p> <code>31</code> <code>power</code> <code>float</code> <p>Exponent for the Weiner filter used in HPSS.</p> <code>2</code> <code>margin</code> <code>Union[_FloatLike_co, tuple[_FloatLike_co, _FloatLike_co], list[_FloatLike_co]]</code> <p>Margin size for the separation.</p> <code>1</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the harmonic components.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_percussive(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract percussive components using HPSS\n    (Harmonic-Percussive Source Separation).\n\n    This method separates the percussive (tonal) components from the signal.\n\n    Args:\n        kernel_size: Median filter size for HPSS.\n        power: Exponent for the Weiner filter used in HPSS.\n        margin: Margin size for the separation.\n\n    Returns:\n        A new ChannelFrame containing the harmonic components.\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_percussive\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.low_pass_filter","title":"<code>low_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a low-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a low-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.mean","title":"<code>mean()</code>","text":"<p>Average all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with averaged signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def mean(self) -&gt; \"ChannelFrame\":\n    \"\"\"Average all channels.\n\n    Returns:\n        A new ChannelFrame with averaged signal.\n    \"\"\"\n    return self.apply_operation(\"mean\")\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.noct_spectrum","title":"<code>noct_spectrum(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Compute N-octave band spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>fmin</code> <code>float</code> <p>Minimum center frequency in Hz. Default is 20 Hz.</p> required <code>fmax</code> <code>float</code> <p>Maximum center frequency in Hz. Default is 20000 Hz.</p> required <code>n</code> <code>int</code> <p>Band division (1 for octave, 3 for 1/3 octave). Default is 3.</p> <code>3</code> <code>G</code> <code>int</code> <p>Reference gain in dB. Default is 10 dB.</p> <code>10</code> <code>fr</code> <code>int</code> <p>Reference frequency in Hz. Default is 1000 Hz.</p> <code>1000</code> <p>Returns:</p> Type Description <code>NOctFrame</code> <p>A NOctFrame containing the N-octave band spectrum.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def noct_spectrum(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"Compute N-octave band spectrum.\n\n    Args:\n        fmin: Minimum center frequency in Hz. Default is 20 Hz.\n        fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n        n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n        G: Reference gain in dB. Default is 10 dB.\n        fr: Reference frequency in Hz. Default is 1000 Hz.\n\n    Returns:\n        A NOctFrame containing the N-octave band spectrum.\n    \"\"\"\n    from ..processing.time_series import NOctSpectrum\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_spectrum\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSpectrum\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_spectrum\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.normalize","title":"<code>normalize(target_level=-20, channel_wise=True)</code>","text":"<p>Normalize the signal level.</p> <p>This method adjusts the signal amplitude to reach a target RMS level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target RMS level in dB. Default is -20.</p> <code>-20</code> <code>channel_wise</code> <code>bool</code> <p>If True, normalize each channel independently. If False, apply the same scaling to all channels.</p> <code>True</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the normalized signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def normalize(\n    self, target_level: float = -20, channel_wise: bool = True\n) -&gt; \"ChannelFrame\":\n    \"\"\"Normalize the signal level.\n\n    This method adjusts the signal amplitude to reach a target RMS level.\n\n    Args:\n        target_level: Target RMS level in dB. Default is -20.\n        channel_wise: If True, normalize each channel independently.\n            If False, apply the same scaling to all channels.\n\n    Returns:\n        A new ChannelFrame containing the normalized signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n    )\n    return self.apply_operation(\n        \"normalize\", target_level=target_level, channel_wise=channel_wise\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.plot","title":"<code>plot(plot_type='waveform', ax=None, **kwargs)</code>","text":"<p>Plot the frame data.</p> <p>Parameters:</p> Name Type Description Default <code>plot_type</code> <code>str</code> <p>Type of plot. Default is \"waveform\".</p> <code>'waveform'</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def plot(\n    self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Plot the frame data.\n\n    Args:\n        plot_type: Type of plot. Default is \"waveform\".\n        ax: Optional matplotlib axes for plotting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    plot_strategy = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.power","title":"<code>power(exponent=2.0)</code>","text":"<p>Calculate the power of the signal.</p> <p>Parameters:</p> Name Type Description Default <code>exponent</code> <code>float</code> <p>The exponent to raise the signal to. Default is 2.0.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the signal raised to the power.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the power of the signal.\n\n    Args:\n        exponent: The exponent to raise the signal to. Default is 2.0.\n\n    Returns:\n        A new ChannelFrame containing the signal raised to the power.\n    \"\"\"\n    return self.apply_operation(\"power\", exponent=exponent)\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.read_csv","title":"<code>read_csv(filename, time_column=0, labels=None, delimiter=',', header=0)</code>  <code>classmethod</code>","text":"<p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.read_wav","title":"<code>read_wav(filename, labels=None)</code>  <code>classmethod</code>","text":"<p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.resampling","title":"<code>resampling(target_sr, **kwargs)</code>","text":"<p>Resample audio data.</p>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.resampling--parameters","title":"Parameters","text":"<p>target_sr : float     Target sampling rate (Hz) resample_type : str, optional     Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.) **kwargs : dict     Additional resampling parameters</p>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.resampling--returns","title":"Returns","text":"<p>ChannelFrame     Resampled channel frame</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def resampling(\n    self,\n    target_sr: float,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Resample audio data.\n\n    Parameters\n    ----------\n    target_sr : float\n        Target sampling rate (Hz)\n    resample_type : str, optional\n        Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n    **kwargs : dict\n        Additional resampling parameters\n\n    Returns\n    -------\n    ChannelFrame\n        Resampled channel frame\n    \"\"\"\n    return self.apply_operation(\n        \"resampling\",\n        target_sr=target_sr,\n        **kwargs,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.rms_plot","title":"<code>rms_plot(ax=None, title=None, overlay=True, Aw=False, **kwargs)</code>","text":"<p>Generate an RMS plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title for the plot.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay the plot on the existing axis.</p> <code>True</code> <code>Aw</code> <code>bool</code> <p>Apply A-weighting.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_plot(\n    self,\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = True,\n    Aw: bool = False,  # noqa: N803\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Generate an RMS plot.\n\n    Args:\n        ax: Optional matplotlib axes for plotting.\n        title: Title for the plot.\n        overlay: Whether to overlay the plot on the existing axis.\n        Aw: Apply A-weighting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    kwargs = kwargs or {}\n    ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n    rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n    return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.rms_trend","title":"<code>rms_trend(frame_length=2048, hop_length=512, dB=False, Aw=False)</code>","text":"<p>Calculate the RMS trend of the signal.</p> <p>This method computes the root mean square value over sliding windows.</p> <p>Parameters:</p> Name Type Description Default <code>frame_length</code> <code>int</code> <p>The size of the sliding window in samples. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>int</code> <p>The hop length between windows in samples. Default is 512.</p> <code>512</code> <code>dB</code> <code>bool</code> <p>Whether to return the RMS values in decibels. Default is False.</p> <code>False</code> <code>Aw</code> <code>bool</code> <p>Whether to apply A-weighting. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the RMS trend.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_trend(\n    self,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the RMS trend of the signal.\n\n    This method computes the root mean square value over sliding windows.\n\n    Args:\n        frame_length: The size of the sliding window in samples. Default is 2048.\n        hop_length: The hop length between windows in samples. Default is 512.\n        dB: Whether to return the RMS values in decibels. Default is False.\n        Aw: Whether to apply A-weighting. Default is False.\n\n    Returns:\n        A new ChannelFrame containing the RMS trend.\n    \"\"\"\n    cf = self.apply_operation(\n        \"rms_trend\",\n        frame_length=frame_length,\n        hop_length=hop_length,\n        ref=[ch.ref for ch in self._channel_metadata],\n        dB=dB,\n        Aw=Aw,\n    )\n    cf.sampling_rate = self.sampling_rate / hop_length\n    return cf\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.save","title":"<code>save(path, format=None)</code>","text":"<p>Save the audio data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n    data = self.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    sf.write(str(path), data, int(self.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {path}\")\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.stft","title":"<code>stft(n_fft=2048, hop_length=None, win_length=None, window='hann')</code>","text":"<p>Compute Short-Time Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectrogramFrame</code> <p>A SpectrogramFrame containing the STFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def stft(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n) -&gt; \"SpectrogramFrame\":\n    \"\"\"Compute Short-Time Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectrogramFrame containing the STFT results.\n    \"\"\"\n    from ..processing.time_series import STFT, create_operation\n    from .spectrogram import SpectrogramFrame\n\n    # Set hop length and window length\n    _hop_length = hop_length if hop_length is not None else n_fft // 4\n    _win_length = win_length if win_length is not None else n_fft\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": _hop_length,\n        \"win_length\": _win_length,\n        \"window\": window,\n    }\n    operation_name = \"stft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"STFT\", operation)\n\n    # Apply processing to data\n    spectrogram_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n\n    # Create new instance\n    return SpectrogramFrame(\n        data=spectrogram_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=n_fft,\n        hop_length=_hop_length,\n        win_length=_win_length,\n        window=window,\n        label=f\"stft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.sum","title":"<code>sum()</code>","text":"<p>Sum all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with summed signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def sum(self) -&gt; \"ChannelFrame\":\n    \"\"\"Sum all channels.\n\n    Returns:\n        A new ChannelFrame with summed signal.\n    \"\"\"\n    return self.apply_operation(\"sum\")\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.transfer_function","title":"<code>transfer_function(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute transfer function matrix.</p> <p>The transfer function characterizes the signal transmission properties between channels in the frequency domain, representing the input-output relationship of a system.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the transfer function matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def transfer_function(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute transfer function matrix.\n\n    The transfer function characterizes the signal transmission properties\n    between channels in the frequency domain, representing the input-output\n    relationship of a system.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the transfer function matrix.\n    \"\"\"\n    from ..processing.time_series import TransferFunction, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"transfer_function\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"TransferFunction\", operation)\n\n    # Apply processing to data\n    tf_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=tf_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Transfer function of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.trim","title":"<code>trim(start=0, end=None)</code>","text":"<p>Trim the signal to specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>Start time in seconds.</p> <code>0</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with trimmed signal.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If end time is before start time.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def trim(\n    self,\n    start: float = 0,\n    end: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Trim the signal to specified time range.\n\n    Args:\n        start: Start time in seconds.\n        end: End time in seconds.\n\n    Returns:\n        A new ChannelFrame with trimmed signal.\n\n    Raises:\n        ValueError: If end time is before start time.\n    \"\"\"\n    if end is None:\n        end = self.duration\n    if start &gt; end:\n        raise ValueError(\"start must be less than end\")\n    # Apply trim operation\n    return self.apply_operation(\"trim\", start=start, end=end)\n</code></pre>"},{"location":"en/api/#wandas.frames.channel.ChannelFrame.welch","title":"<code>welch(n_fft=None, hop_length=None, win_length=2048, window='hann', average='mean')</code>","text":"<p>Compute power spectral density using Welch's method.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is 2048.</p> <code>None</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>int</code> <p>Length of window. Default is n_fft.</p> <code>2048</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the power spectral density.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def welch(\n    self,\n    n_fft: Optional[int] = None,\n    hop_length: Optional[int] = None,\n    win_length: int = 2048,\n    window: str = \"hann\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute power spectral density using Welch's method.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the power spectral density.\n    \"\"\"\n    from ..processing.time_series import Welch\n    from .spectral import SpectralFrame\n\n    params = dict(\n        n_fft=n_fft or win_length,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        average=average,\n    )\n    operation_name = \"welch\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Welch\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"welch\", \"params\": params},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/#inputoutput-io","title":"Input/Output (I/O)","text":"<p>Wandas provides various methods to read audio files and CSV files.</p>"},{"location":"en/api/#wav-file-operations","title":"WAV File Operations","text":"<pre><code># Reading WAV files\nfrom wandas.frames.channel import ChannelFrame\nframe = ChannelFrame.read_wav(\"audio.wav\")\n\n# Or using direct import\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")\n\n# Writing WAV files\nframe.save(\"output.wav\")\n</code></pre> <p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre> <p>Save the audio data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n    data = self.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    sf.write(str(path), data, int(self.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {path}\")\n</code></pre>"},{"location":"en/api/#csv-file-operations","title":"CSV File Operations","text":"<pre><code># Reading CSV files\nfrom wandas.frames.channel import ChannelFrame\nframe = ChannelFrame.read_csv(\"data.csv\")\n\n# Or using direct import\nimport wandas\nframe = wandas.read_csv(\"data.csv\")\n</code></pre> <p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"en/api/#signal-processing","title":"Signal Processing","text":"<p>Wandas provides various signal processing functions.</p>"},{"location":"en/api/#wandas.processing.time_series.ABS","title":"<code>ABS</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Absolute value operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ABS(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Absolute value operation\"\"\"\n\n    name = \"abs\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize absolute value operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        return da.abs(data)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.ABS.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize absolute value operation</p>"},{"location":"en/api/#wandas.processing.time_series.ABS.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize absolute value operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AWeighting","title":"<code>AWeighting</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>A-weighting filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AWeighting(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"A-weighting filter operation\"\"\"\n\n    name = \"a_weighting\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize A-weighting filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for A-weighting filter\"\"\"\n        logger.debug(f\"Applying A-weighting to array with shape: {x.shape}\")\n        result = A_weight(x, self.sampling_rate)\n\n        # Handle case where A_weight returns a tuple\n        if isinstance(result, tuple):\n            # Use the first element of the tuple\n            result = result[0]\n\n        logger.debug(\n            f\"A-weighting applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AWeighting.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize A-weighting filter</p>"},{"location":"en/api/#wandas.processing.time_series.AWeighting.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize A-weighting filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AddWithSNR","title":"<code>AddWithSNR</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Addition operation considering SNR</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AddWithSNR(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Addition operation considering SNR\"\"\"\n\n    name = \"add_with_snr\"\n\n    def __init__(self, sampling_rate: float, other: DaArray, snr: float):\n        \"\"\"\n        Initialize addition operation considering SNR\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        other : DaArray\n            Noise signal to add (channel-frame format)\n        snr : float\n            Signal-to-noise ratio (dB)\n        \"\"\"\n        super().__init__(sampling_rate, other=other, snr=snr)\n\n        self.other = other\n        self.snr = snr\n        logger.debug(f\"Initialized AddWithSNR operation with SNR: {snr} dB\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape (same as input)\n        \"\"\"\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Perform addition processing considering SNR\"\"\"\n        logger.debug(f\"Applying SNR-based addition with shape: {x.shape}\")\n        other: NDArrayReal = self.other.compute()\n\n        # Use multi-channel versions of calculate_rms and calculate_desired_noise_rms\n        clean_rms = util.calculate_rms(x)\n        other_rms = util.calculate_rms(other)\n\n        # Adjust noise gain based on specified SNR (apply per channel)\n        desired_noise_rms = util.calculate_desired_noise_rms(clean_rms, self.snr)\n\n        # Apply gain per channel using broadcasting\n        gain = desired_noise_rms / other_rms\n        # Add adjusted noise to signal\n        result: NDArrayReal = x + other * gain\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AddWithSNR.__init__","title":"<code>__init__(sampling_rate, other, snr)</code>","text":"<p>Initialize addition operation considering SNR</p>"},{"location":"en/api/#wandas.processing.time_series.AddWithSNR.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) other : DaArray     Noise signal to add (channel-frame format) snr : float     Signal-to-noise ratio (dB)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, other: DaArray, snr: float):\n    \"\"\"\n    Initialize addition operation considering SNR\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    other : DaArray\n        Noise signal to add (channel-frame format)\n    snr : float\n        Signal-to-noise ratio (dB)\n    \"\"\"\n    super().__init__(sampling_rate, other=other, snr=snr)\n\n    self.other = other\n    self.snr = snr\n    logger.debug(f\"Initialized AddWithSNR operation with SNR: {snr} dB\")\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AddWithSNR.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.AddWithSNR.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/api/#wandas.processing.time_series.AddWithSNR.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (same as input)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape (same as input)\n    \"\"\"\n    return input_shape\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AudioOperation","title":"<code>AudioOperation</code>","text":"<p>               Bases: <code>Generic[InputArrayType, OutputArrayType]</code></p> <p>Abstract base class for audio processing operations.</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AudioOperation(Generic[InputArrayType, OutputArrayType]):\n    \"\"\"Abstract base class for audio processing operations.\"\"\"\n\n    # Class variable: operation name\n    name: ClassVar[str]\n\n    def __init__(self, sampling_rate: float, **params: Any):\n        \"\"\"\n        Initialize AudioOperation.\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        **params : Any\n            Operation-specific parameters\n        \"\"\"\n        self.sampling_rate = sampling_rate\n        self.params = params\n\n        # Validate parameters during initialization\n        self.validate_params()\n\n        # Create processor function (lazy initialization possible)\n        self._setup_processor()\n\n        logger.debug(\n            f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n        )\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n        pass\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up processor function (implemented by subclasses)\"\"\"\n        pass\n\n    def _process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function (implemented by subclasses)\"\"\"\n        # Default is no-op function\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    @dask.delayed  # type: ignore [misc, unused-ignore]\n    def process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n        # Default is no-op function\n        logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n        return self._process_array(x)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation (implemented by subclasses)\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        \"\"\"\n        Execute operation and return result\n        data shape is (channels, samples)\n        \"\"\"\n        # Add task as delayed processing\n        logger.debug(\"Adding delayed operation to computation graph\")\n        delayed_result = self.process_array(data)\n        # Convert delayed result to dask array and return\n        output_shape = self.calculate_output_shape(data.shape)\n        return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AudioOperation.__init__","title":"<code>__init__(sampling_rate, **params)</code>","text":"<p>Initialize AudioOperation.</p>"},{"location":"en/api/#wandas.processing.time_series.AudioOperation.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) **params : Any     Operation-specific parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, **params: Any):\n    \"\"\"\n    Initialize AudioOperation.\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    **params : Any\n        Operation-specific parameters\n    \"\"\"\n    self.sampling_rate = sampling_rate\n    self.params = params\n\n    # Validate parameters during initialization\n    self.validate_params()\n\n    # Create processor function (lazy initialization possible)\n    self._setup_processor()\n\n    logger.debug(\n        f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n    )\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AudioOperation.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation (implemented by subclasses)</p>"},{"location":"en/api/#wandas.processing.time_series.AudioOperation.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/api/#wandas.processing.time_series.AudioOperation.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation (implemented by subclasses)\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AudioOperation.process","title":"<code>process(data)</code>","text":"<p>Execute operation and return result data shape is (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    \"\"\"\n    Execute operation and return result\n    data shape is (channels, samples)\n    \"\"\"\n    # Add task as delayed processing\n    logger.debug(\"Adding delayed operation to computation graph\")\n    delayed_result = self.process_array(data)\n    # Convert delayed result to dask array and return\n    output_shape = self.calculate_output_shape(data.shape)\n    return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AudioOperation.process_array","title":"<code>process_array(x)</code>","text":"<p>Processing function wrapped with @dask.delayed</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>@dask.delayed  # type: ignore [misc, unused-ignore]\ndef process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n    \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n    # Default is no-op function\n    logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n    return self._process_array(x)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.AudioOperation.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters (raises exception if invalid)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n    pass\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.CSD","title":"<code>CSD</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Cross-spectral density estimation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class CSD(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Cross-spectral density estimation operation\"\"\"\n\n    name = \"csd\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n        scaling: str,\n        average: str,\n    ):\n        \"\"\"\n        Initialize cross-spectral density estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        scaling : str\n            Type of scaling\n        average : str\n            Method of averaging\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        self.scaling = scaling\n        self.average = average\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n            scaling=scaling,\n            average=average,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Processor function for cross-spectral density estimation operation\"\"\"\n        logger.debug(f\"Applying CSD estimation to array with shape: {x.shape}\")\n        from scipy import signal as ss\n\n        # Calculate all combinations using scipy's csd function\n        _, csd_result = ss.csd(\n            x=x[:, np.newaxis],\n            y=x[np.newaxis, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n        )\n\n        # Reshape result to (n_channels * n_channels, n_freqs)\n        result: NDArrayComplex = csd_result.transpose(1, 0, 2).reshape(\n            -1, csd_result.shape[-1]\n        )\n\n        logger.debug(f\"CSD estimation applied, result shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.CSD.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend, scaling, average)</code>","text":"<p>Initialize cross-spectral density estimation operation</p>"},{"location":"en/api/#wandas.processing.time_series.CSD.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend scaling : str     Type of scaling average : str     Method of averaging</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n    scaling: str,\n    average: str,\n):\n    \"\"\"\n    Initialize cross-spectral density estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    scaling : str\n        Type of scaling\n    average : str\n        Method of averaging\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    self.scaling = scaling\n    self.average = average\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n        scaling=scaling,\n        average=average,\n    )\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.CSD.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.CSD.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/api/#wandas.processing.time_series.CSD.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.ChannelDifference","title":"<code>ChannelDifference</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Channel difference calculation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ChannelDifference(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Channel difference calculation operation\"\"\"\n\n    name = \"channel_difference\"\n    other_channel: int\n\n    def __init__(self, sampling_rate: float, other_channel: int = 0):\n        \"\"\"\n        Initialize channel difference calculation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        other_channel : int\n            Channel to calculate difference with, default is 0\n        \"\"\"\n        self.other_channel = other_channel\n        super().__init__(sampling_rate, other_channel=other_channel)\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        result = data - data[self.other_channel]\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.ChannelDifference.__init__","title":"<code>__init__(sampling_rate, other_channel=0)</code>","text":"<p>Initialize channel difference calculation</p>"},{"location":"en/api/#wandas.processing.time_series.ChannelDifference.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) other_channel : int     Channel to calculate difference with, default is 0</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, other_channel: int = 0):\n    \"\"\"\n    Initialize channel difference calculation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    other_channel : int\n        Channel to calculate difference with, default is 0\n    \"\"\"\n    self.other_channel = other_channel\n    super().__init__(sampling_rate, other_channel=other_channel)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Coherence","title":"<code>Coherence</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Coherence estimation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Coherence(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Coherence estimation operation\"\"\"\n\n    name = \"coherence\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n    ):\n        \"\"\"\n        Initialize coherence estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Processor function for coherence estimation operation\"\"\"\n        logger.debug(f\"Applying coherence estimation to array with shape: {x.shape}\")\n        from scipy import signal as ss\n\n        _, coh = ss.coherence(\n            x=x[:, np.newaxis],\n            y=x[np.newaxis, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n        )\n\n        # Reshape result to (n_channels * n_channels, n_freqs)\n        result: NDArrayReal = coh.transpose(1, 0, 2).reshape(-1, coh.shape[-1])\n\n        logger.debug(f\"Coherence estimation applied, result shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Coherence.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend)</code>","text":"<p>Initialize coherence estimation operation</p>"},{"location":"en/api/#wandas.processing.time_series.Coherence.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n):\n    \"\"\"\n    Initialize coherence estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n    )\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Coherence.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.Coherence.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/api/#wandas.processing.time_series.Coherence.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.FFT","title":"<code>FFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>FFT (Fast Fourier Transform) operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class FFT(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"FFT (Fast Fourier Transform) operation\"\"\"\n\n    name = \"fft\"\n    n_fft: Optional[int]\n    window: str\n\n    def __init__(\n        self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n    ):\n        \"\"\"\n        Initialize FFT operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int, optional\n            FFT size, default is None (determined by input size)\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(sampling_rate, n_fft=n_fft, window=window)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        \u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059\n\n        Parameters\n        ----------\n        input_shape : tuple\n            \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)\n\n        Returns\n        -------\n        tuple\n            \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)\n        \"\"\"\n        n_freqs = self.n_fft // 2 + 1 if self.n_fft else input_shape[-1] // 2 + 1\n        return (*input_shape[:-1], n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"FFT\u64cd\u4f5c\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u95a2\u6570\u3092\u4f5c\u6210\"\"\"\n        from scipy.signal import get_window\n\n        win = get_window(self.window, x.shape[-1])\n        x = x * win\n        result: NDArrayComplex = np.fft.rfft(x, n=self.n_fft, axis=-1)\n        result[..., 1:-1] *= 2.0\n        # \u7a93\u95a2\u6570\u88dc\u6b63\n        scaling_factor = np.sum(win)\n        result = result / scaling_factor\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.FFT.__init__","title":"<code>__init__(sampling_rate, n_fft=None, window='hann')</code>","text":"<p>Initialize FFT operation</p>"},{"location":"en/api/#wandas.processing.time_series.FFT.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int, optional     FFT size, default is None (determined by input size) window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n):\n    \"\"\"\n    Initialize FFT operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int, optional\n        FFT size, default is None (determined by input size)\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(sampling_rate, n_fft=n_fft, window=window)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.FFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>\u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059</p>"},{"location":"en/api/#wandas.processing.time_series.FFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)</p>"},{"location":"en/api/#wandas.processing.time_series.FFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    \u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059\n\n    Parameters\n    ----------\n    input_shape : tuple\n        \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)\n\n    Returns\n    -------\n    tuple\n        \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)\n    \"\"\"\n    n_freqs = self.n_fft // 2 + 1 if self.n_fft else input_shape[-1] // 2 + 1\n    return (*input_shape[:-1], n_freqs)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.HighPassFilter","title":"<code>HighPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>High-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HighPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"High-pass filter operation\"\"\"\n\n    name = \"highpass_filter\"\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize high-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            limit = self.sampling_rate / 2\n            raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up high-pass filter processor\"\"\"\n        # Calculate filter coefficients (once) - safely retrieve from instance variables\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"high\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Highpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying highpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.HighPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize high-pass filter</p>"},{"location":"en/api/#wandas.processing.time_series.HighPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize high-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.HighPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        limit = self.sampling_rate / 2\n        raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.HpssHarmonic","title":"<code>HpssHarmonic</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>HPSS Harmonic operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HpssHarmonic(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"HPSS Harmonic operation\"\"\"\n\n    name = \"hpss_harmonic\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize HPSS Harmonic\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        self.kwargs = kwargs\n        super().__init__(sampling_rate, **kwargs)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for HPSS Harmonic\"\"\"\n        logger.debug(f\"Applying HPSS Harmonic to array with shape: {x.shape}\")\n        result = librosa.effects.harmonic(x, **self.kwargs)\n        logger.debug(\n            f\"HPSS Harmonic applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.HpssHarmonic.__init__","title":"<code>__init__(sampling_rate, **kwargs)</code>","text":"<p>Initialize HPSS Harmonic</p>"},{"location":"en/api/#wandas.processing.time_series.HpssHarmonic.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize HPSS Harmonic\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    self.kwargs = kwargs\n    super().__init__(sampling_rate, **kwargs)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.HpssPercussive","title":"<code>HpssPercussive</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>HPSS Percussive operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HpssPercussive(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"HPSS Percussive operation\"\"\"\n\n    name = \"hpss_percussive\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize HPSS Percussive\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        self.kwargs = kwargs\n        super().__init__(sampling_rate, **kwargs)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for HPSS Percussive\"\"\"\n        logger.debug(f\"Applying HPSS Percussive to array with shape: {x.shape}\")\n        result = librosa.effects.percussive(x, **self.kwargs)\n        logger.debug(\n            f\"HPSS Percussive applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.HpssPercussive.__init__","title":"<code>__init__(sampling_rate, **kwargs)</code>","text":"<p>Initialize HPSS Percussive</p>"},{"location":"en/api/#wandas.processing.time_series.HpssPercussive.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize HPSS Percussive\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    self.kwargs = kwargs\n    super().__init__(sampling_rate, **kwargs)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.IFFT","title":"<code>IFFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayComplex, NDArrayReal]</code></p> <p>IFFT (Inverse Fast Fourier Transform) operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class IFFT(AudioOperation[NDArrayComplex, NDArrayReal]):\n    \"\"\"IFFT (Inverse Fast Fourier Transform) operation\"\"\"\n\n    name = \"ifft\"\n    n_fft: Optional[int]\n    window: str\n\n    def __init__(\n        self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n    ):\n        \"\"\"\n        Initialize IFFT operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : Optional[int], optional\n            IFFT size, default is None (determined based on input size)\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(sampling_rate, n_fft=n_fft, window=window)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, freqs)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, samples)\n        \"\"\"\n        n_samples = 2 * (input_shape[-1] - 1) if self.n_fft is None else self.n_fft\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayComplex) -&gt; NDArrayReal:\n        \"\"\"Create processor function for IFFT operation\"\"\"\n        logger.debug(f\"Applying IFFT to array with shape: {x.shape}\")\n\n        # Restore frequency component scaling (remove the 2.0 multiplier applied in FFT)\n        _x = x.copy()\n        _x[..., 1:-1] /= 2.0\n\n        # Execute IFFT\n        result: NDArrayReal = np.fft.irfft(_x, n=self.n_fft, axis=-1)\n\n        # Window function correction (inverse of FFT operation)\n        from scipy.signal import get_window\n\n        win = get_window(self.window, result.shape[-1])\n\n        # Correct the FFT window function scaling\n        scaling_factor = np.sum(win) / result.shape[-1]\n        result = result / scaling_factor\n\n        logger.debug(f\"IFFT applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.IFFT.__init__","title":"<code>__init__(sampling_rate, n_fft=None, window='hann')</code>","text":"<p>Initialize IFFT operation</p>"},{"location":"en/api/#wandas.processing.time_series.IFFT.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : Optional[int], optional     IFFT size, default is None (determined based on input size) window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n):\n    \"\"\"\n    Initialize IFFT operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : Optional[int], optional\n        IFFT size, default is None (determined based on input size)\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(sampling_rate, n_fft=n_fft, window=window)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.IFFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.IFFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, freqs)</p>"},{"location":"en/api/#wandas.processing.time_series.IFFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, freqs)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, samples)\n    \"\"\"\n    n_samples = 2 * (input_shape[-1] - 1) if self.n_fft is None else self.n_fft\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.ISTFT","title":"<code>ISTFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayComplex, NDArrayReal]</code></p> <p>Inverse Short-Time Fourier Transform operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ISTFT(AudioOperation[NDArrayComplex, NDArrayReal]):\n    \"\"\"Inverse Short-Time Fourier Transform operation\"\"\"\n\n    name = \"istft\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        length: Optional[int] = None,\n    ):\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.length = length\n\n        # Instantiate ShortTimeFFT for ISTFT calculation\n        self.SFT = ShortTimeFFT(\n            win=get_window(window, self.win_length),\n            hop=self.hop_length,\n            fs=sampling_rate,\n            mfft=self.n_fft,\n            scale_to=\"magnitude\",  # Consistent scaling with STFT\n        )\n\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n            length=length,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, freqs, time_frames)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, samples)\n        \"\"\"\n        k0: int = 0\n        q_max = input_shape[-1] + self.SFT.p_min\n        k_max = (q_max - 1) * self.SFT.hop + self.SFT.m_num - self.SFT.m_num_mid\n        k_q0, k_q1 = self.SFT.nearest_k_p(k0), self.SFT.nearest_k_p(k_max, left=False)\n        n_pts = k_q1 - k_q0 + self.SFT.m_num - self.SFT.m_num_mid\n\n        return input_shape[:-2] + (n_pts,)\n\n    def _process_array(self, x: NDArrayComplex) -&gt; NDArrayReal:\n        \"\"\"\n        Apply SciPy ISTFT processing to multiple channels at once using ShortTimeFFT\"\"\"\n        logger.debug(\n            f\"Applying SciPy ISTFT (ShortTimeFFT) to array with shape: {x.shape}\"\n        )\n\n        # Convert 2D input to 3D (assume single channel)\n        if x.ndim == 2:\n            x = x.reshape(1, *x.shape)\n\n        # Adjust scaling back if STFT applied factor of 2\n        _x = np.copy(x)\n        _x[..., 1:-1, :] /= 2.0\n\n        # Apply ISTFT using the ShortTimeFFT instance\n        result: NDArrayReal = self.SFT.istft(_x)\n\n        # Trim to desired length if specified\n        if self.length is not None:\n            result = result[..., : self.length]\n\n        logger.debug(\n            f\"ShortTimeFFT applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.ISTFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.ISTFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, freqs, time_frames)</p>"},{"location":"en/api/#wandas.processing.time_series.ISTFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, freqs, time_frames)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, samples)\n    \"\"\"\n    k0: int = 0\n    q_max = input_shape[-1] + self.SFT.p_min\n    k_max = (q_max - 1) * self.SFT.hop + self.SFT.m_num - self.SFT.m_num_mid\n    k_q0, k_q1 = self.SFT.nearest_k_p(k0), self.SFT.nearest_k_p(k_max, left=False)\n    n_pts = k_q1 - k_q0 + self.SFT.m_num - self.SFT.m_num_mid\n\n    return input_shape[:-2] + (n_pts,)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.LowPassFilter","title":"<code>LowPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Low-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class LowPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Low-pass filter operation\"\"\"\n\n    name = \"lowpass_filter\"\n    a: NDArrayReal\n    b: NDArrayReal\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize low-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            raise ValueError(\n                f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n            )\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up low-pass filter processor\"\"\"\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"low\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Lowpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying lowpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.LowPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize low-pass filter</p>"},{"location":"en/api/#wandas.processing.time_series.LowPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize low-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.LowPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        raise ValueError(\n            f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n        )\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Mean","title":"<code>Mean</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Mean calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Mean(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Mean calculation\"\"\"\n\n    name = \"mean\"\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # Use Dask's aggregate function directly without map_blocks\n        return data.mean(axis=0, keepdims=True)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.NOctSpectrum","title":"<code>NOctSpectrum</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>N-octave spectrum operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class NOctSpectrum(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"N-octave spectrum operation\"\"\"\n\n    name = \"noct_spectrum\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ):\n        \"\"\"\n        Initialize N-octave spectrum\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        fmin : float\n            Minimum frequency (Hz)\n        fmax : float\n            Maximum frequency (Hz)\n        n : int, optional\n            Number of octave divisions, default is 3\n        G : int, optional\n            Reference level, default is 10\n        fr : int, optional\n            Reference frequency, default is 1000\n        \"\"\"\n        super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n        self.fmin = fmin\n        self.fmax = fmax\n        self.n = n\n        self.G = G\n        self.fr = fr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate output shape for octave spectrum\n        _, fpref = _center_freq(\n            fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n        )\n        return (input_shape[0], fpref.shape[0])\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for octave spectrum\"\"\"\n        logger.debug(f\"Applying NoctSpectrum to array with shape: {x.shape}\")\n        spec, _ = noct_spectrum(\n            sig=x.T,\n            fs=self.sampling_rate,\n            fmin=self.fmin,\n            fmax=self.fmax,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        if spec.ndim == 1:\n            # Add channel dimension for 1D\n            spec = np.expand_dims(spec, axis=0)\n        else:\n            spec = spec.T\n        logger.debug(f\"NoctSpectrum applied, returning result with shape: {spec.shape}\")\n        return np.array(spec)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.NOctSpectrum.__init__","title":"<code>__init__(sampling_rate, fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Initialize N-octave spectrum</p>"},{"location":"en/api/#wandas.processing.time_series.NOctSpectrum.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) fmin : float     Minimum frequency (Hz) fmax : float     Maximum frequency (Hz) n : int, optional     Number of octave divisions, default is 3 G : int, optional     Reference level, default is 10 fr : int, optional     Reference frequency, default is 1000</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n):\n    \"\"\"\n    Initialize N-octave spectrum\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    fmin : float\n        Minimum frequency (Hz)\n    fmax : float\n        Maximum frequency (Hz)\n    n : int, optional\n        Number of octave divisions, default is 3\n    G : int, optional\n        Reference level, default is 10\n    fr : int, optional\n        Reference frequency, default is 1000\n    \"\"\"\n    super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n    self.fmin = fmin\n    self.fmax = fmax\n    self.n = n\n    self.G = G\n    self.fr = fr\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.NOctSpectrum.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.NOctSpectrum.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/api/#wandas.processing.time_series.NOctSpectrum.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate output shape for octave spectrum\n    _, fpref = _center_freq(\n        fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n    )\n    return (input_shape[0], fpref.shape[0])\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.NOctSynthesis","title":"<code>NOctSynthesis</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Octave synthesis operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class NOctSynthesis(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Octave synthesis operation\"\"\"\n\n    name = \"noct_synthesis\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ):\n        \"\"\"\n        Initialize octave synthesis\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        fmin : float\n            Minimum frequency (Hz)\n        fmax : float\n            Maximum frequency (Hz)\n        n : int, optional\n            Number of octave divisions, default is 3\n        G : int, optional\n            Reference level, default is 10\n        fr : int, optional\n            Reference frequency, default is 1000\n        \"\"\"\n        super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n\n        self.fmin = fmin\n        self.fmax = fmax\n        self.n = n\n        self.G = G\n        self.fr = fr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate output shape for octave spectrum\n        _, fpref = _center_freq(\n            fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n        )\n        return (input_shape[0], fpref.shape[0])\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for octave synthesis\"\"\"\n        logger.debug(f\"Applying NoctSynthesis to array with shape: {x.shape}\")\n        # Calculate n from shape[-1]\n        n = x.shape[-1]  # Calculate n from shape[-1]\n        if n % 2 == 0:\n            n = n * 2 - 1\n        else:\n            n = (n - 1) * 2\n        freqs = np.fft.rfftfreq(n, d=1 / self.sampling_rate)\n        result, _ = noct_synthesis(\n            spectrum=np.abs(x).T,\n            freqs=freqs,\n            fmin=self.fmin,\n            fmax=self.fmax,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        result = result.T\n        logger.debug(\n            f\"NoctSynthesis applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.NOctSynthesis.__init__","title":"<code>__init__(sampling_rate, fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Initialize octave synthesis</p>"},{"location":"en/api/#wandas.processing.time_series.NOctSynthesis.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) fmin : float     Minimum frequency (Hz) fmax : float     Maximum frequency (Hz) n : int, optional     Number of octave divisions, default is 3 G : int, optional     Reference level, default is 10 fr : int, optional     Reference frequency, default is 1000</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n):\n    \"\"\"\n    Initialize octave synthesis\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    fmin : float\n        Minimum frequency (Hz)\n    fmax : float\n        Maximum frequency (Hz)\n    n : int, optional\n        Number of octave divisions, default is 3\n    G : int, optional\n        Reference level, default is 10\n    fr : int, optional\n        Reference frequency, default is 1000\n    \"\"\"\n    super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n\n    self.fmin = fmin\n    self.fmax = fmax\n    self.n = n\n    self.G = G\n    self.fr = fr\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.NOctSynthesis.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.NOctSynthesis.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/api/#wandas.processing.time_series.NOctSynthesis.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate output shape for octave spectrum\n    _, fpref = _center_freq(\n        fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n    )\n    return (input_shape[0], fpref.shape[0])\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Power","title":"<code>Power</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Power operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Power(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Power operation\"\"\"\n\n    name = \"power\"\n\n    def __init__(self, sampling_rate: float, exponent: float):\n        \"\"\"\n        Initialize power operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        exponent : float\n            Power exponent\n        \"\"\"\n        super().__init__(sampling_rate)\n        self.exp = exponent\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        return da.power(data, self.exp)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Power.__init__","title":"<code>__init__(sampling_rate, exponent)</code>","text":"<p>Initialize power operation</p>"},{"location":"en/api/#wandas.processing.time_series.Power.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) exponent : float     Power exponent</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, exponent: float):\n    \"\"\"\n    Initialize power operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    exponent : float\n        Power exponent\n    \"\"\"\n    super().__init__(sampling_rate)\n    self.exp = exponent\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.ReSampling","title":"<code>ReSampling</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Resampling operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ReSampling(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Resampling operation\"\"\"\n\n    name = \"resampling\"\n\n    def __init__(self, sampling_rate: float, target_sr: float):\n        \"\"\"\n        Initialize resampling operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        target_sampling_rate : float\n            Target sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate, target_sr=target_sr)\n        self.target_sr = target_sr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after resampling\n        ratio = float(self.target_sr) / float(self.sampling_rate)\n        n_samples = int(np.ceil(input_shape[-1] * ratio))\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for resampling operation\"\"\"\n        logger.debug(f\"Applying resampling to array with shape: {x.shape}\")\n        result = librosa.resample(\n            x, orig_sr=self.sampling_rate, target_sr=self.target_sr\n        )\n        logger.debug(f\"Resampling applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.ReSampling.__init__","title":"<code>__init__(sampling_rate, target_sr)</code>","text":"<p>Initialize resampling operation</p>"},{"location":"en/api/#wandas.processing.time_series.ReSampling.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) target_sampling_rate : float     Target sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, target_sr: float):\n    \"\"\"\n    Initialize resampling operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    target_sampling_rate : float\n        Target sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate, target_sr=target_sr)\n    self.target_sr = target_sr\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.ReSampling.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.ReSampling.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/api/#wandas.processing.time_series.ReSampling.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after resampling\n    ratio = float(self.target_sr) / float(self.sampling_rate)\n    n_samples = int(np.ceil(input_shape[-1] * ratio))\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.RmsTrend","title":"<code>RmsTrend</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>RMS calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class RmsTrend(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"RMS calculation\"\"\"\n\n    name = \"rms_trend\"\n    frame_length: int\n    hop_length: int\n    Aw: bool\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        ref: Union[list[float], float] = 1.0,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; None:\n        \"\"\"\n        Initialize RMS calculation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        frame_length : int\n            Frame length, default is 2048\n        hop_length : int\n            Hop length, default is 512\n        ref : Union[list[float], float]\n            Reference value(s) for dB calculation\n        dB : bool\n            Whether to convert to decibels\n        Aw : bool\n            Whether to apply A-weighting before RMS calculation\n        \"\"\"\n        self.frame_length = frame_length\n        self.hop_length = hop_length\n        self.dB = dB\n        self.Aw = Aw\n        self.ref = np.array(ref if isinstance(ref, list) else [ref])\n        super().__init__(\n            sampling_rate,\n            frame_length=frame_length,\n            hop_length=hop_length,\n            dB=dB,\n            Aw=Aw,\n            ref=self.ref,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, frames)\n        \"\"\"\n        n_frames = librosa.feature.rms(\n            y=np.ones((1, input_shape[-1])),\n            frame_length=self.frame_length,\n            hop_length=self.hop_length,\n        ).shape[-1]\n        return (*input_shape[:-1], n_frames)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for RMS calculation\"\"\"\n        logger.debug(f\"Applying RMS to array with shape: {x.shape}\")\n\n        if self.Aw:\n            # Apply A-weighting\n            _x = A_weight(x, self.sampling_rate)\n            if isinstance(_x, np.ndarray):\n                # A_weight\u304c\u30bf\u30d7\u30eb\u3092\u8fd4\u3059\u5834\u5408\u3001\u6700\u521d\u306e\u8981\u7d20\u3092\u4f7f\u7528\n                x = _x\n            elif isinstance(_x, tuple):\n                # Use the first element if A_weight returns a tuple\n                x = _x[0]\n            else:\n                raise ValueError(\"A_weighting returned an unexpected type.\")\n\n        # Calculate RMS\n        result = librosa.feature.rms(\n            y=x, frame_length=self.frame_length, hop_length=self.hop_length\n        )[..., 0, :]\n\n        if self.dB:\n            # Convert to dB\n            result = 20 * np.log10(\n                np.maximum(result / self.ref[..., np.newaxis], 1e-12)\n            )\n        #\n        logger.debug(f\"RMS applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.RmsTrend.__init__","title":"<code>__init__(sampling_rate, frame_length=2048, hop_length=512, ref=1.0, dB=False, Aw=False)</code>","text":"<p>Initialize RMS calculation</p>"},{"location":"en/api/#wandas.processing.time_series.RmsTrend.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) frame_length : int     Frame length, default is 2048 hop_length : int     Hop length, default is 512 ref : Union[list[float], float]     Reference value(s) for dB calculation dB : bool     Whether to convert to decibels Aw : bool     Whether to apply A-weighting before RMS calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    ref: Union[list[float], float] = 1.0,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; None:\n    \"\"\"\n    Initialize RMS calculation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    frame_length : int\n        Frame length, default is 2048\n    hop_length : int\n        Hop length, default is 512\n    ref : Union[list[float], float]\n        Reference value(s) for dB calculation\n    dB : bool\n        Whether to convert to decibels\n    Aw : bool\n        Whether to apply A-weighting before RMS calculation\n    \"\"\"\n    self.frame_length = frame_length\n    self.hop_length = hop_length\n    self.dB = dB\n    self.Aw = Aw\n    self.ref = np.array(ref if isinstance(ref, list) else [ref])\n    super().__init__(\n        sampling_rate,\n        frame_length=frame_length,\n        hop_length=hop_length,\n        dB=dB,\n        Aw=Aw,\n        ref=self.ref,\n    )\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.RmsTrend.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.RmsTrend.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/api/#wandas.processing.time_series.RmsTrend.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, frames)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, frames)\n    \"\"\"\n    n_frames = librosa.feature.rms(\n        y=np.ones((1, input_shape[-1])),\n        frame_length=self.frame_length,\n        hop_length=self.hop_length,\n    ).shape[-1]\n    return (*input_shape[:-1], n_frames)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.STFT","title":"<code>STFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Short-Time Fourier Transform operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class STFT(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Short-Time Fourier Transform operation\"\"\"\n\n    name = \"stft\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ):\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.noverlap = (\n            self.win_length - self.hop_length if hop_length is not None else None\n        )\n        self.window = window\n\n        self.SFT = ShortTimeFFT(\n            win=get_window(window, self.win_length),\n            hop=self.hop_length,\n            fs=sampling_rate,\n            mfft=self.n_fft,\n            scale_to=\"magnitude\",\n        )\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        n_samples = input_shape[-1]\n        n_f = len(self.SFT.f)\n        n_t = len(self.SFT.t(n_samples))\n        return (input_shape[0], n_f, n_t)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Apply SciPy STFT processing to multiple channels at once\"\"\"\n        logger.debug(f\"Applying SciPy STFT to array with shape: {x.shape}\")\n\n        # Convert 1D input to 2D\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n\n        # Apply STFT to all channels at once\n        result: NDArrayComplex = self.SFT.stft(x)\n        result[..., 1:-1, :] *= 2.0\n        logger.debug(f\"SciPy STFT applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.STFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.STFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/api/#wandas.processing.time_series.STFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    n_samples = input_shape[-1]\n    n_f = len(self.SFT.f)\n    n_t = len(self.SFT.t(n_samples))\n    return (input_shape[0], n_f, n_t)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Sum","title":"<code>Sum</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Sum calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Sum(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Sum calculation\"\"\"\n\n    name = \"sum\"\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # Use Dask's aggregate function directly without map_blocks\n        return data.sum(axis=0, keepdims=True)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.TransferFunction","title":"<code>TransferFunction</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Transfer function estimation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class TransferFunction(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Transfer function estimation operation\"\"\"\n\n    name = \"transfer_function\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ):\n        \"\"\"\n        Initialize transfer function estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        scaling : str\n            Type of scaling\n        average : str\n            Method of averaging\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        self.scaling = scaling\n        self.average = average\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n            scaling=scaling,\n            average=average,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Processor function for transfer function estimation operation\"\"\"\n        logger.debug(\n            f\"Applying transfer function estimation to array with shape: {x.shape}\"\n        )\n        from scipy import signal as ss\n\n        # Calculate cross-spectral density between all channels\n        f, p_yx = ss.csd(\n            x=x[:, np.newaxis, :],\n            y=x[np.newaxis, :, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n            axis=-1,\n        )\n        # p_yx shape: (num_channels, num_channels, num_frequencies)\n\n        # Calculate power spectral density for each channel\n        f, p_xx = ss.welch(\n            x=x,\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n            axis=-1,\n        )\n        # p_xx shape: (num_channels, num_frequencies)\n\n        # Calculate transfer function H(f) = P_yx / P_xx\n        h_f = p_yx / p_xx[np.newaxis, :, :]\n        result: NDArrayComplex = h_f.transpose(1, 0, 2).reshape(-1, h_f.shape[-1])\n\n        logger.debug(\n            f\"Transfer function estimation applied, result shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.TransferFunction.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend, scaling='spectrum', average='mean')</code>","text":"<p>Initialize transfer function estimation operation</p>"},{"location":"en/api/#wandas.processing.time_series.TransferFunction.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend scaling : str     Type of scaling average : str     Method of averaging</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n):\n    \"\"\"\n    Initialize transfer function estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    scaling : str\n        Type of scaling\n    average : str\n        Method of averaging\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    self.scaling = scaling\n    self.average = average\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n        scaling=scaling,\n        average=average,\n    )\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.TransferFunction.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.TransferFunction.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/api/#wandas.processing.time_series.TransferFunction.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Trim","title":"<code>Trim</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Trimming operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Trim(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Trimming operation\"\"\"\n\n    name = \"trim\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        start: float,\n        end: float,\n    ):\n        \"\"\"\n        Initialize trimming operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        start : float\n            Start time for trimming (seconds)\n        end : float\n            End time for trimming (seconds)\n        \"\"\"\n        super().__init__(sampling_rate, start=start, end=end)\n        self.start = start\n        self.end = end\n        self.start_sample = int(start * sampling_rate)\n        self.end_sample = int(end * sampling_rate)\n        logger.debug(\n            f\"Initialized Trim operation with start: {self.start}, end: {self.end}\"\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after trimming\n        # Exclude parts where there is no signal\n        end_sample = min(self.end_sample, input_shape[-1])\n        n_samples = end_sample - self.start_sample\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for trimming operation\"\"\"\n        logger.debug(f\"Applying trim to array with shape: {x.shape}\")\n        # Apply trimming\n        result = x[..., self.start_sample : self.end_sample]\n        logger.debug(f\"Trim applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Trim.__init__","title":"<code>__init__(sampling_rate, start, end)</code>","text":"<p>Initialize trimming operation</p>"},{"location":"en/api/#wandas.processing.time_series.Trim.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) start : float     Start time for trimming (seconds) end : float     End time for trimming (seconds)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    start: float,\n    end: float,\n):\n    \"\"\"\n    Initialize trimming operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    start : float\n        Start time for trimming (seconds)\n    end : float\n        End time for trimming (seconds)\n    \"\"\"\n    super().__init__(sampling_rate, start=start, end=end)\n    self.start = start\n    self.end = end\n    self.start_sample = int(start * sampling_rate)\n    self.end_sample = int(end * sampling_rate)\n    logger.debug(\n        f\"Initialized Trim operation with start: {self.start}, end: {self.end}\"\n    )\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Trim.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.Trim.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/api/#wandas.processing.time_series.Trim.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after trimming\n    # Exclude parts where there is no signal\n    end_sample = min(self.end_sample, input_shape[-1])\n    n_samples = end_sample - self.start_sample\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Welch","title":"<code>Welch</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Welch</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Welch(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Welch\"\"\"\n\n    name = \"welch\"\n    n_fft: int\n    window: str\n    hop_length: Optional[int]\n    win_length: Optional[int]\n    average: str\n    detrend: str\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        average: str = \"mean\",\n        detrend: str = \"constant\",\n    ):\n        \"\"\"\n        Initialize Welch operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int, optional\n            FFT size, default is 2048\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.noverlap = (\n            self.win_length - self.hop_length if hop_length is not None else None\n        )\n        self.window = window\n        self.average = average\n        self.detrend = detrend\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n            average=average,\n            detrend=detrend,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, freqs)\n        \"\"\"\n        n_freqs = self.n_fft // 2 + 1\n        return (*input_shape[:-1], n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for Welch operation\"\"\"\n        from scipy import signal as ss\n\n        _, result = ss.welch(\n            x,\n            nperseg=self.win_length,\n            noverlap=self.noverlap,\n            nfft=self.n_fft,\n            window=self.window,\n            average=self.average,\n            detrend=self.detrend,\n            scaling=\"spectrum\",\n        )\n\n        if not isinstance(x, np.ndarray):\n            # Trigger computation for Dask array\n            raise ValueError(\n                \"Welch operation requires a Dask array, but received a non-ndarray.\"\n            )\n        return np.array(result)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Welch.__init__","title":"<code>__init__(sampling_rate, n_fft=2048, hop_length=None, win_length=None, window='hann', average='mean', detrend='constant')</code>","text":"<p>Initialize Welch operation</p>"},{"location":"en/api/#wandas.processing.time_series.Welch.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int, optional     FFT size, default is 2048 window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    average: str = \"mean\",\n    detrend: str = \"constant\",\n):\n    \"\"\"\n    Initialize Welch operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int, optional\n        FFT size, default is 2048\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.noverlap = (\n        self.win_length - self.hop_length if hop_length is not None else None\n    )\n    self.window = window\n    self.average = average\n    self.detrend = detrend\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        win_length=self.win_length,\n        hop_length=self.hop_length,\n        window=window,\n        average=average,\n        detrend=detrend,\n    )\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.Welch.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/#wandas.processing.time_series.Welch.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"en/api/#wandas.processing.time_series.Welch.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, freqs)\n    \"\"\"\n    n_freqs = self.n_fft // 2 + 1\n    return (*input_shape[:-1], n_freqs)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.create_operation","title":"<code>create_operation(name, sampling_rate, **params)</code>","text":"<p>Create operation instance from name and parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def create_operation(\n    name: str, sampling_rate: float, **params: Any\n) -&gt; AudioOperation[Any, Any]:\n    \"\"\"Create operation instance from name and parameters\"\"\"\n    operation_class = get_operation(name)\n    return operation_class(sampling_rate, **params)\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.get_operation","title":"<code>get_operation(name)</code>","text":"<p>Get operation class by name</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def get_operation(name: str) -&gt; type[AudioOperation[Any, Any]]:\n    \"\"\"Get operation class by name\"\"\"\n    if name not in _OPERATION_REGISTRY:\n        raise ValueError(f\"Unknown operation type: {name}\")\n    return _OPERATION_REGISTRY[name]\n</code></pre>"},{"location":"en/api/#wandas.processing.time_series.register_operation","title":"<code>register_operation(operation_class)</code>","text":"<p>Register a new operation type</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def register_operation(operation_class: type) -&gt; None:\n    \"\"\"Register a new operation type\"\"\"\n\n    if not issubclass(operation_class, AudioOperation):\n        raise TypeError(\"Strategy class must inherit from AudioOperation.\")\n    if inspect.isabstract(operation_class):\n        raise TypeError(\"Cannot register abstract AudioOperation class.\")\n\n    _OPERATION_REGISTRY[operation_class.name] = operation_class\n</code></pre>"},{"location":"en/api/#utilities","title":"Utilities","text":""},{"location":"en/api/core/","title":"Core Module","text":"<p>This page explains the core module of Wandas. The core module provides the basic data structures and functionality of Wandas.</p>"},{"location":"en/api/core/#baseframe","title":"BaseFrame","text":"<p><code>BaseFrame</code> is the base class for all frame classes in Wandas. You don't instantiate this class directly but use it through derived classes (like ChannelFrame).</p> <pre><code>from wandas.core.base_frame import BaseFrame\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for all signal frame types.</p> <p>This class provides the common interface and functionality for all frame types used in signal processing. It implements basic operations like indexing, iteration, and data manipulation that are shared across all frame types.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The signal data to process. Must be a dask array. sampling_rate : float     The sampling rate of the signal in Hz. label : str, optional     A label for the frame. If not provided, defaults to \"unnamed_frame\". metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame--attributes","title":"Attributes","text":"<p>sampling_rate : float     The sampling rate of the signal in Hz. label : str     The label of the frame. metadata : dict     Additional metadata for the frame. operation_history : list[dict]     History of operations performed on this frame.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>class BaseFrame(ABC, Generic[T]):\n    \"\"\"\n    Abstract base class for all signal frame types.\n\n    This class provides the common interface and functionality for all frame types\n    used in signal processing. It implements basic operations like indexing, iteration,\n    and data manipulation that are shared across all frame types.\n\n    Parameters\n    ----------\n    data : DaArray\n        The signal data to process. Must be a dask array.\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str, optional\n        A label for the frame. If not provided, defaults to \"unnamed_frame\".\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str\n        The label of the frame.\n    metadata : dict\n        Additional metadata for the frame.\n    operation_history : list[dict]\n        History of operations performed on this frame.\n    \"\"\"\n\n    _data: DaArray\n    sampling_rate: float\n    label: str\n    metadata: dict[str, Any]\n    operation_history: list[dict[str, Any]]\n    _channel_metadata: list[ChannelMetadata]\n    _previous: Optional[\"BaseFrame[Any]\"]\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ):\n        self._data = data.rechunk(chunks=-1)  # type: ignore [unused-ignore]\n        if self._data.ndim == 1:\n            self._data = self._data.reshape((1, -1))\n        self.sampling_rate = sampling_rate\n        self.label = label or \"unnamed_frame\"\n        self.metadata = metadata or {}\n        self.operation_history = operation_history or []\n        self._previous = previous\n\n        if channel_metadata:\n            self._channel_metadata = copy.deepcopy(channel_metadata)\n        else:\n            self._channel_metadata = [\n                ChannelMetadata(label=f\"ch{i}\", unit=\"\", extra={})\n                for i in range(self._n_channels)\n            ]\n\n        try:\n            # Display information for newer dask versions\n            logger.debug(f\"Dask graph layers: {list(self._data.dask.layers.keys())}\")\n            logger.debug(\n                f\"Dask graph dependencies: {len(self._data.dask.dependencies)}\"\n            )\n        except Exception as e:\n            logger.debug(f\"Dask graph visualization details unavailable: {e}\")\n\n    @property\n    @abstractmethod\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n\n    @property\n    def n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return len(self)\n\n    @property\n    def channels(self) -&gt; list[ChannelMetadata]:\n        \"\"\"Property to access channel metadata.\"\"\"\n        return self._channel_metadata\n\n    @property\n    def previous(self) -&gt; Optional[\"BaseFrame[Any]\"]:\n        \"\"\"\n        Returns the previous frame.\n        \"\"\"\n        return self._previous\n\n    def get_channel(self: S, channel_idx: int) -&gt; S:\n        n_channels = len(self)\n        if channel_idx &lt; 0 or channel_idx &gt;= n_channels:\n            range_max = n_channels - 1\n            raise ValueError(\n                f\"Channel index out of range: {channel_idx} \"\n                f\"(valid range: 0-{range_max})\"\n            )\n        logger.debug(f\"Extracting channel index={channel_idx} (lazy operation).\")\n        channel_data = self._data[channel_idx : channel_idx + 1]\n\n        return self._create_new_instance(\n            data=channel_data,\n            operation_history=self.operation_history,\n            channel_metadata=[self._channel_metadata[channel_idx]],\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Returns the number of channels.\n        \"\"\"\n        return len(self._channel_metadata)\n\n    def __iter__(self: S) -&gt; Iterator[S]:\n        for idx in range(len(self)):\n            yield self[idx]\n\n    def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n        \"\"\"\n        Method to get a channel by name or index.\n\n        Parameters\n        ----------\n        key : str, int, slice, or tuple of slices\n            Channel name (label) or index number.\n\n        Returns\n        -------\n        BaseFrame\n            The corresponding channel.\n\n        Raises\n        ------\n        ValueError\n            If the key length is invalid for the shape.\n        IndexError\n            If the channel index is out of range.\n        TypeError\n            If the key type is invalid.\n        \"\"\"\n        if isinstance(key, str):\n            index = self.label2index(key)\n            return self.get_channel(index)\n\n        elif isinstance(key, tuple):\n            # When key is a tuple, treat the first element as an index\n            if len(key) &gt; len(self.shape):\n                raise ValueError(\n                    f\"Invalid key length: {len(key)} for shape {self.shape}\"\n                )\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key[0]]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, slice):\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, numbers.Integral):\n            # Access by index number\n            if key &lt; 0 or key &gt;= len(self):\n                raise IndexError(f\"Channel index {key} out of range.\")\n            return self.get_channel(key)\n        else:\n            raise TypeError(\n                f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n            )\n\n    def label2index(self, label: str) -&gt; int:\n        \"\"\"\n        Get the index from a channel label.\n\n        Parameters\n        ----------\n        label : str\n            Channel label.\n\n        Returns\n        -------\n        int\n            Corresponding index.\n\n        Raises\n        ------\n        KeyError\n            If the channel label is not found.\n        \"\"\"\n        for idx, ch in enumerate(self._channel_metadata):\n            if ch.label == label:\n                return idx\n        raise KeyError(f\"Channel label '{label}' not found.\")\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        _shape: tuple[int, ...] = self._data.shape\n        return _shape\n\n    @property\n    def data(self) -&gt; T:\n        \"\"\"\n        Returns the computed data.\n        Calculation is executed the first time this is accessed.\n        \"\"\"\n        return self.compute()\n\n    @property\n    def labels(self) -&gt; list[str]:\n        \"\"\"Get a list of all channel labels.\"\"\"\n        return [ch.label for ch in self._channel_metadata]\n\n    def compute(self) -&gt; T:\n        \"\"\"\n        Compute and return the data.\n        This method materializes lazily computed data into a concrete NumPy array.\n\n        Returns\n        -------\n        NDArrayReal\n            The computed data.\n\n        Raises\n        ------\n        ValueError\n            If the computed result is not a NumPy array.\n        \"\"\"\n        logger.debug(\n            \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n        )\n        result = self._data.compute()\n\n        if not isinstance(result, np.ndarray):\n            raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n        logger.debug(f\"Computation complete, result shape: {result.shape}\")\n        return cast(T, result)\n\n    @abstractmethod\n    def plot(\n        self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n    ) -&gt; Union[Axes, Iterator[Axes]]:\n        \"\"\"Plot the data\"\"\"\n        pass\n\n    def persist(self: S) -&gt; S:\n        \"\"\"Persist the data in memory\"\"\"\n        persisted_data = self._data.persist()\n        return self._create_new_instance(data=persisted_data)\n\n    @abstractmethod\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Abstract method for derived classes to provide\n        additional initialization arguments.\n        \"\"\"\n        pass\n\n    def _create_new_instance(self: S, data: DaArray, **kwargs: Any) -&gt; S:\n        \"\"\"\n        Create a new channel instance based on an existing channel.\n        Keyword arguments can override or extend the original attributes.\n        \"\"\"\n\n        sampling_rate = kwargs.pop(\"sampling_rate\", self.sampling_rate)\n        # if not isinstance(sampling_rate, int):\n        #     raise TypeError(\"Sampling rate must be an integer\")\n\n        label = kwargs.pop(\"label\", self.label)\n        if not isinstance(label, str):\n            raise TypeError(\"Label must be a string\")\n\n        metadata = kwargs.pop(\"metadata\", copy.deepcopy(self.metadata))\n        if not isinstance(metadata, dict):\n            raise TypeError(\"Metadata must be a dictionary\")\n\n        # Get additional initialization arguments from derived classes\n        additional_kwargs = self._get_additional_init_kwargs()\n        kwargs.update(additional_kwargs)\n\n        return type(self)(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            previous=self,\n            **kwargs,\n        )\n\n    def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n        \"\"\"Implicit conversion to NumPy array\"\"\"\n        result = self.compute()\n        if dtype is not None:\n            return result.astype(dtype)\n        return result\n\n    def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n        \"\"\"Visualize the computation graph and save it to a file\"\"\"\n        try:\n            filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n            self._data.visualize(filename=filename)\n            return filename\n        except Exception as e:\n            logger.warning(f\"Failed to visualize the graph: {e}\")\n            return None\n\n    @abstractmethod\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"Basic implementation of binary operations\"\"\"\n        # Basic logic\n        # Actual implementation is left to derived classes\n        pass\n\n    def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Addition operator\"\"\"\n        return self._binary_op(other, lambda x, y: x + y, \"+\")\n\n    def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Subtraction operator\"\"\"\n        return self._binary_op(other, lambda x, y: x - y, \"-\")\n\n    def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Multiplication operator\"\"\"\n        return self._binary_op(other, lambda x, y: x * y, \"*\")\n\n    def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Division operator\"\"\"\n        return self._binary_op(other, lambda x, y: x / y, \"/\")\n\n    def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Apply a named operation.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters to pass to the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        # Apply the operation through abstract method\n        return self._apply_operation_impl(operation_name, **params)\n\n    @abstractmethod\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"Implementation of operation application\"\"\"\n        pass\n\n    def debug_info(self) -&gt; None:\n        \"\"\"Output detailed debug information\"\"\"\n        logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n        logger.debug(f\"Label: {self.label}\")\n        logger.debug(f\"Shape: {self.shape}\")\n        logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n        logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n        self._debug_info_impl()\n        logger.debug(\"=== End Debug Info ===\")\n\n    def _debug_info_impl(self) -&gt; None:\n        \"\"\"Implement derived class-specific debug information\"\"\"\n        pass\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.channels","title":"<code>channels</code>  <code>property</code>","text":"<p>Property to access channel metadata.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.data","title":"<code>data</code>  <code>property</code>","text":"<p>Returns the computed data. Calculation is executed the first time this is accessed.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>Get a list of all channel labels.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.n_channels","title":"<code>n_channels</code>  <code>property</code>","text":"<p>Returns the number of channels.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.previous","title":"<code>previous</code>  <code>property</code>","text":"<p>Returns the previous frame.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__add__","title":"<code>__add__(other)</code>","text":"<p>Addition operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Addition operator\"\"\"\n    return self._binary_op(other, lambda x, y: x + y, \"+\")\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__array__","title":"<code>__array__(dtype=None)</code>","text":"<p>Implicit conversion to NumPy array</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n    \"\"\"Implicit conversion to NumPy array\"\"\"\n    result = self.compute()\n    if dtype is not None:\n        return result.astype(dtype)\n    return result\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Method to get a channel by name or index.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__getitem__--parameters","title":"Parameters","text":"<p>key : str, int, slice, or tuple of slices     Channel name (label) or index number.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__getitem__--returns","title":"Returns","text":"<p>BaseFrame     The corresponding channel.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__getitem__--raises","title":"Raises","text":"<p>ValueError     If the key length is invalid for the shape. IndexError     If the channel index is out of range. TypeError     If the key type is invalid.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n    \"\"\"\n    Method to get a channel by name or index.\n\n    Parameters\n    ----------\n    key : str, int, slice, or tuple of slices\n        Channel name (label) or index number.\n\n    Returns\n    -------\n    BaseFrame\n        The corresponding channel.\n\n    Raises\n    ------\n    ValueError\n        If the key length is invalid for the shape.\n    IndexError\n        If the channel index is out of range.\n    TypeError\n        If the key type is invalid.\n    \"\"\"\n    if isinstance(key, str):\n        index = self.label2index(key)\n        return self.get_channel(index)\n\n    elif isinstance(key, tuple):\n        # When key is a tuple, treat the first element as an index\n        if len(key) &gt; len(self.shape):\n            raise ValueError(\n                f\"Invalid key length: {len(key)} for shape {self.shape}\"\n            )\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key[0]]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, slice):\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, numbers.Integral):\n        # Access by index number\n        if key &lt; 0 or key &gt;= len(self):\n            raise IndexError(f\"Channel index {key} out of range.\")\n        return self.get_channel(key)\n    else:\n        raise TypeError(\n            f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n        )\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of channels.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of channels.\n    \"\"\"\n    return len(self._channel_metadata)\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplication operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Multiplication operator\"\"\"\n    return self._binary_op(other, lambda x, y: x * y, \"*\")\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtraction operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Subtraction operator\"\"\"\n    return self._binary_op(other, lambda x, y: x - y, \"-\")\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Division operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Division operator\"\"\"\n    return self._binary_op(other, lambda x, y: x / y, \"/\")\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.apply_operation","title":"<code>apply_operation(operation_name, **params)</code>","text":"<p>Apply a named operation.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.apply_operation--parameters","title":"Parameters","text":"<p>operation_name : str     Name of the operation to apply. **params : Any     Parameters to pass to the operation.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.apply_operation--returns","title":"Returns","text":"<p>S     A new instance with the operation applied.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n    \"\"\"\n    Apply a named operation.\n\n    Parameters\n    ----------\n    operation_name : str\n        Name of the operation to apply.\n    **params : Any\n        Parameters to pass to the operation.\n\n    Returns\n    -------\n    S\n        A new instance with the operation applied.\n    \"\"\"\n    # Apply the operation through abstract method\n    return self._apply_operation_impl(operation_name, **params)\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.compute","title":"<code>compute()</code>","text":"<p>Compute and return the data. This method materializes lazily computed data into a concrete NumPy array.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.compute--returns","title":"Returns","text":"<p>NDArrayReal     The computed data.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.compute--raises","title":"Raises","text":"<p>ValueError     If the computed result is not a NumPy array.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def compute(self) -&gt; T:\n    \"\"\"\n    Compute and return the data.\n    This method materializes lazily computed data into a concrete NumPy array.\n\n    Returns\n    -------\n    NDArrayReal\n        The computed data.\n\n    Raises\n    ------\n    ValueError\n        If the computed result is not a NumPy array.\n    \"\"\"\n    logger.debug(\n        \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n    )\n    result = self._data.compute()\n\n    if not isinstance(result, np.ndarray):\n        raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n    logger.debug(f\"Computation complete, result shape: {result.shape}\")\n    return cast(T, result)\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.debug_info","title":"<code>debug_info()</code>","text":"<p>Output detailed debug information</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def debug_info(self) -&gt; None:\n    \"\"\"Output detailed debug information\"\"\"\n    logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n    logger.debug(f\"Label: {self.label}\")\n    logger.debug(f\"Shape: {self.shape}\")\n    logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n    logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n    self._debug_info_impl()\n    logger.debug(\"=== End Debug Info ===\")\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.label2index","title":"<code>label2index(label)</code>","text":"<p>Get the index from a channel label.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.label2index--parameters","title":"Parameters","text":"<p>label : str     Channel label.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.label2index--returns","title":"Returns","text":"<p>int     Corresponding index.</p>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.label2index--raises","title":"Raises","text":"<p>KeyError     If the channel label is not found.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def label2index(self, label: str) -&gt; int:\n    \"\"\"\n    Get the index from a channel label.\n\n    Parameters\n    ----------\n    label : str\n        Channel label.\n\n    Returns\n    -------\n    int\n        Corresponding index.\n\n    Raises\n    ------\n    KeyError\n        If the channel label is not found.\n    \"\"\"\n    for idx, ch in enumerate(self._channel_metadata):\n        if ch.label == label:\n            return idx\n    raise KeyError(f\"Channel label '{label}' not found.\")\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.persist","title":"<code>persist()</code>","text":"<p>Persist the data in memory</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def persist(self: S) -&gt; S:\n    \"\"\"Persist the data in memory\"\"\"\n    persisted_data = self._data.persist()\n    return self._create_new_instance(data=persisted_data)\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.plot","title":"<code>plot(plot_type='default', ax=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Plot the data</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>@abstractmethod\ndef plot(\n    self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n) -&gt; Union[Axes, Iterator[Axes]]:\n    \"\"\"Plot the data\"\"\"\n    pass\n</code></pre>"},{"location":"en/api/core/#wandas.core.base_frame.BaseFrame.visualize_graph","title":"<code>visualize_graph(filename=None)</code>","text":"<p>Visualize the computation graph and save it to a file</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"Visualize the computation graph and save it to a file\"\"\"\n    try:\n        filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n        self._data.visualize(filename=filename)\n        return filename\n    except Exception as e:\n        logger.warning(f\"Failed to visualize the graph: {e}\")\n        return None\n</code></pre>"},{"location":"en/api/core/#channelmetadata","title":"ChannelMetadata","text":"<p><code>ChannelMetadata</code> is a class for managing metadata for each channel. It holds channel names, units, and other additional information.</p> <pre><code>from wandas.core.metadata import ChannelMetadata\n\n# Usage example\nmetadata = ChannelMetadata(label=\"Left Channel\", unit=\"dB\", extra={\"device\": \"Microphone\"})\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>Data class for storing channel metadata</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>class ChannelMetadata(BaseModel):\n    \"\"\"\n    Data class for storing channel metadata\n    \"\"\"\n\n    label: str = \"\"\n    unit: str = \"\"\n    ref: float = 1.0\n    # Additional metadata for extensibility\n    extra: dict[str, Any] = Field(default_factory=dict)\n\n    def __getitem__(self, key: str) -&gt; Any:\n        \"\"\"Provide dictionary-like behavior\"\"\"\n        if key == \"label\":\n            return self.label\n        elif key == \"unit\":\n            return self.unit\n        elif key == \"ref\":\n            return self.ref\n        else:\n            return self.extra.get(key)\n\n    def __setitem__(self, key: str, value: Any) -&gt; None:\n        \"\"\"Provide dictionary-like behavior\"\"\"\n        if key == \"label\":\n            self.label = value\n        elif key == \"unit\":\n            self.unit = value\n        elif key == \"ref\":\n            self.ref = value\n        else:\n            self.extra[key] = value\n\n    def to_json(self) -&gt; str:\n        \"\"\"Convert to JSON format\"\"\"\n        json_data: str = self.model_dump_json(indent=4)\n        return json_data\n\n    @classmethod\n    def from_json(cls, json_data: str) -&gt; \"ChannelMetadata\":\n        \"\"\"Convert from JSON format\"\"\"\n        root_model: ChannelMetadata = ChannelMetadata.model_validate_json(json_data)\n\n        return root_model\n</code></pre>"},{"location":"en/api/core/#wandas.core.metadata.ChannelMetadata.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Provide dictionary-like behavior</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Any:\n    \"\"\"Provide dictionary-like behavior\"\"\"\n    if key == \"label\":\n        return self.label\n    elif key == \"unit\":\n        return self.unit\n    elif key == \"ref\":\n        return self.ref\n    else:\n        return self.extra.get(key)\n</code></pre>"},{"location":"en/api/core/#wandas.core.metadata.ChannelMetadata.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Provide dictionary-like behavior</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def __setitem__(self, key: str, value: Any) -&gt; None:\n    \"\"\"Provide dictionary-like behavior\"\"\"\n    if key == \"label\":\n        self.label = value\n    elif key == \"unit\":\n        self.unit = value\n    elif key == \"ref\":\n        self.ref = value\n    else:\n        self.extra[key] = value\n</code></pre>"},{"location":"en/api/core/#wandas.core.metadata.ChannelMetadata.from_json","title":"<code>from_json(json_data)</code>  <code>classmethod</code>","text":"<p>Convert from JSON format</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>@classmethod\ndef from_json(cls, json_data: str) -&gt; \"ChannelMetadata\":\n    \"\"\"Convert from JSON format\"\"\"\n    root_model: ChannelMetadata = ChannelMetadata.model_validate_json(json_data)\n\n    return root_model\n</code></pre>"},{"location":"en/api/core/#wandas.core.metadata.ChannelMetadata.to_json","title":"<code>to_json()</code>","text":"<p>Convert to JSON format</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Convert to JSON format\"\"\"\n    json_data: str = self.model_dump_json(indent=4)\n    return json_data\n</code></pre>"},{"location":"en/api/frames/","title":"Frame Module","text":"<p>This page explains the frame modules in Wandas. The frame module includes various types of data frames.</p>"},{"location":"en/api/frames/#channelframe","title":"ChannelFrame","text":"<p><code>ChannelFrame</code> is a frame that handles time-domain signal data.</p> <pre><code>from wandas.frames.channel import ChannelFrame\n\n# Or\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")  # Returns a ChannelFrame instance\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Channel-based data frame for handling audio signals and time series data.</p> <p>This frame represents channel-based data such as audio signals and time series data, with each channel containing data samples in the time domain.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>class ChannelFrame(BaseFrame[NDArrayReal]):\n    \"\"\"Channel-based data frame for handling audio signals and time series data.\n\n    This frame represents channel-based data such as audio signals and time series data,\n    with each channel containing data samples in the time domain.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"Initialize a ChannelFrame.\n\n        Args:\n            data: Dask array containing channel data.\n            Shape should be (n_channels, n_samples).\n            sampling_rate: The sampling rate of the data in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            operation_history: History of operations applied to the frame.\n            channel_metadata: Metadata for each channel.\n            previous: Reference to the previous frame in the processing chain.\n\n        Raises:\n            ValueError: If data has more than 2 dimensions.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return self.shape[-2]\n\n    @property\n    def time(self) -&gt; NDArrayReal:\n        \"\"\"Get time array for the signal.\n\n        Returns:\n            Array of time points in seconds.\n        \"\"\"\n        return np.arange(self.n_samples) / self.sampling_rate\n\n    @property\n    def n_samples(self) -&gt; int:\n        \"\"\"Returns the number of samples.\"\"\"\n        n: int = self._data.shape[-1]\n        return n\n\n    @property\n    def duration(self) -&gt; float:\n        \"\"\"Returns the duration in seconds.\"\"\"\n        return self.n_samples / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # Apply processing to data\n        processed_data = operation.process(self._data)\n\n        # Update metadata\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        if operation_name == \"resampling\":\n            # For resampling, update sampling rate\n            return self._create_new_instance(\n                sampling_rate=params[\"target_sr\"],\n                data=processed_data,\n                metadata=new_metadata,\n                operation_history=new_history,\n            )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Common implementation for binary operations\n        - utilizing dask's lazy evaluation.\n\n        Args:\n            other: Right operand for the operation.\n            op: Function to execute the operation (e.g., lambda a, b: a + b).\n            symbol: Symbolic representation of the operation (e.g., '+').\n\n        Returns:\n            A new channel containing the operation result (lazy execution).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, ChannelFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Perform operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other._data)\n\n            # Merge channel metadata\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # Perform operation with scalar, NumPy array, or other types\n        else:\n            # Apply operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other)\n\n            # Operand display string\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # Check for dask.array.Array\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # Update channel metadata\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n                previous=self,\n            )\n\n    def add(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        snr: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Add another signal or value to the current signal.\n\n        If SNR is specified, performs addition with consideration for\n        signal-to-noise ratio.\n\n        Args:\n            other: Signal or value to add.\n            snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n                other signal based on this SNR.\n                self is treated as the signal, and other as the noise.\n\n        Returns:\n            A new channel frame containing the addition result (lazy execution).\n        \"\"\"\n        logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n        # Special processing when SNR is specified\n        if snr is not None:\n            # First convert other to ChannelFrame if it's not\n            if not isinstance(other, ChannelFrame):\n                if isinstance(other, np.ndarray):\n                    other = ChannelFrame.from_numpy(\n                        other, self.sampling_rate, label=\"array_data\"\n                    )\n                elif isinstance(other, (int, float)):\n                    # For scalar values, simply add (ignore SNR)\n                    return self + other\n                else:\n                    raise TypeError(\n                        \"Addition target with SNR must be a ChannelFrame or \"\n                        f\"NumPy array: {type(other)}\"\n                    )\n\n            # Check if sampling rates match\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Apply addition operation with SNR adjustment\n            return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n        # Execute normal addition if SNR is not specified\n        return self + other\n\n    def plot(\n        self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Plot the frame data.\n\n        Args:\n            plot_type: Type of plot. Default is \"waveform\".\n            ax: Optional matplotlib axes for plotting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        plot_strategy = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def rms_plot(\n        self,\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = True,\n        Aw: bool = False,  # noqa: N803\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Generate an RMS plot.\n\n        Args:\n            ax: Optional matplotlib axes for plotting.\n            title: Title for the plot.\n            overlay: Whether to overlay the plot on the existing axis.\n            Aw: Apply A-weighting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        kwargs = kwargs or {}\n        ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n        rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n        return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n\n    def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n        \"\"\"Display visual and audio representation of the frame.\n\n        Args:\n            normalize: Whether to normalize the audio data for playback.\n            **kwargs: Additional parameters for visualization.\n        \"\"\"\n        if \"axis_config\" in kwargs:\n            logger.warning(\n                \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            axis_config = kwargs[\"axis_config\"]\n            if \"time_plot\" in axis_config:\n                kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n            if \"freq_plot\" in axis_config:\n                if \"xlim\" in axis_config[\"freq_plot\"]:\n                    vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                    kwargs[\"vmin\"] = vlim[0]\n                    kwargs[\"vmax\"] = vlim[1]\n                if \"ylim\" in axis_config[\"freq_plot\"]:\n                    ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                    kwargs[\"ylim\"] = ylim\n\n        if \"cbar_config\" in kwargs:\n            logger.warning(\n                \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            cbar_config = kwargs[\"cbar_config\"]\n            if \"vmin\" in cbar_config:\n                kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n            if \"vmax\" in cbar_config:\n                kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n        for ch in self:\n            ax: Axes\n            _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n            if isinstance(_ax, Iterator):\n                ax = next(iter(_ax))\n            elif isinstance(_ax, Axes):\n                ax = _ax\n            else:\n                raise TypeError(\n                    f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n                )\n            # Ignore type checks for display and Audio\n            display(ax.figure)  # type: ignore\n            plt.close(ax.figure)  # type: ignore\n            display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n\n    @classmethod\n    def from_numpy(\n        cls,\n        data: NDArrayReal,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        ch_labels: Optional[list[str]] = None,\n        ch_units: Optional[Union[list[str], str]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        Args:\n            data: NumPy array containing channel data.\n            sampling_rate: The sampling rate in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            ch_labels: Labels for each channel.\n            ch_units: Units for each channel.\n\n        Returns:\n            A new ChannelFrame containing the NumPy data.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n\n        # Convert NumPy array to dask array\n        dask_data = da_from_array(data)\n        cf = ChannelFrame(\n            data=dask_data,\n            sampling_rate=sampling_rate,\n            label=label or \"numpy_data\",\n        )\n        if metadata is not None:\n            cf.metadata = metadata\n        if ch_labels is not None:\n            if len(ch_labels) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel labels does not match the number of channels\"\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        if ch_units is not None:\n            if isinstance(ch_units, str):\n                ch_units = [ch_units] * cf.n_channels\n\n            if len(ch_units) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel units does not match the number of channels\"\n                )\n            for i in range(len(ch_units)):\n                cf._channel_metadata[i].unit = ch_units[i]\n\n        return cf\n\n    @classmethod\n    def from_ndarray(\n        cls,\n        array: NDArrayReal,\n        sampling_rate: float,\n        labels: Optional[list[str]] = None,\n        unit: Optional[Union[list[str], str]] = None,\n        frame_label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        This method is deprecated. Use from_numpy instead.\n\n        Args:\n            array: Signal data. Each row corresponds to a channel.\n            sampling_rate: Sampling rate (Hz).\n            labels: Labels for each channel.\n            unit: Unit of the signal.\n            frame_label: Label for the frame.\n            metadata: Optional metadata dictionary.\n\n        Returns:\n            A new ChannelFrame containing the data.\n        \"\"\"\n        # Redirect to from_numpy for compatibility\n        # However, from_ndarray is deprecated\n        logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n        return cls.from_numpy(\n            data=array,\n            sampling_rate=sampling_rate,\n            label=frame_label,\n            metadata=metadata,\n            ch_labels=labels,\n            ch_units=unit,\n        )\n\n    @classmethod\n    def from_file(\n        cls,\n        path: Union[str, Path],\n        channel: Optional[Union[int, list[int]]] = None,\n        start: Optional[float] = None,\n        end: Optional[float] = None,\n        chunk_size: Optional[int] = None,\n        ch_labels: Optional[list[str]] = None,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from an audio file.\n\n        Args:\n            path: Path to the audio file.\n            channel: Channel(s) to load.\n            start: Start time in seconds.\n            end: End time in seconds.\n            chunk_size: Chunk size for processing.\n            Specifies the splitting size for lazy processing.\n            ch_labels: Labels for each channel.\n            **kwargs: Additional arguments passed to the file reader.\n\n        Returns:\n            A new ChannelFrame containing the loaded audio data.\n\n        Raises:\n            ValueError: If channel selection is invalid.\n            TypeError: If channel parameter type is invalid.\n            FileNotFoundError: If the file doesn't exist.\n        \"\"\"\n        from .channel import ChannelFrame\n\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"File not found: {path}\")\n\n        # Get file reader\n        reader = get_file_reader(path)\n\n        # Get file info\n        info = reader.get_file_info(path, **kwargs)\n        sr = info[\"samplerate\"]\n        n_channels = info[\"channels\"]\n        n_frames = info[\"frames\"]\n        ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n        logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n        # Channel selection processing\n        all_channels = list(range(n_channels))\n\n        if channel is None:\n            channels_to_load = all_channels\n            logger.debug(f\"Will load all channels: {channels_to_load}\")\n        elif isinstance(channel, int):\n            if channel &lt; 0 or channel &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n            channels_to_load = [channel]\n            logger.debug(f\"Will load single channel: {channel}\")\n        elif isinstance(channel, (list, tuple)):\n            for ch in channel:\n                if ch &lt; 0 or ch &gt;= n_channels:\n                    raise ValueError(\n                        f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                    )\n            channels_to_load = list(channel)\n            logger.debug(f\"Will load specific channels: {channels_to_load}\")\n        else:\n            raise TypeError(\"channel must be int, list, or None\")\n\n        # Index calculation\n        start_idx = 0 if start is None else max(0, int(start * sr))\n        end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n        frames_to_read = end_idx - start_idx\n\n        logger.debug(\n            f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n            f\"start_idx={start_idx}, end_idx={end_idx}\"\n        )\n\n        # Settings for lazy loading\n        expected_shape = (len(channels_to_load), frames_to_read)\n\n        # Define the loading function using the file reader\n        def _load_audio() -&gt; NDArrayReal:\n            logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n            # Use the reader to get audio data with parameters\n            out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n            if not isinstance(out, np.ndarray):\n                raise ValueError(\"Unexpected data type after reading file\")\n            return out\n\n        logger.debug(\n            f\"Creating delayed dask task with expected shape: {expected_shape}\"\n        )\n\n        # Create delayed operation\n        delayed_data = dask_delayed(_load_audio)()\n        logger.debug(\"Wrapping delayed function in dask array\")\n\n        # Create dask array from delayed computation\n        dask_array = da_from_delayed(\n            delayed_data, shape=expected_shape, dtype=np.float32\n        )\n\n        if chunk_size is not None:\n            if chunk_size &lt;= 0:\n                raise ValueError(\"Chunk size must be a positive integer\")\n            logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n            dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n        logger.debug(\n            \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n        )\n\n        cf = ChannelFrame(\n            data=dask_array,\n            sampling_rate=sr,\n            label=path.stem,\n            metadata={\n                \"filename\": str(path),\n            },\n        )\n        if ch_labels is not None:\n            if len(ch_labels) != len(cf):\n                raise ValueError(\n                    \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        return cf\n\n    @classmethod\n    def read_wav(\n        cls, filename: str, labels: Optional[list[str]] = None\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a WAV file.\n\n        Args:\n            filename: Path to the WAV file.\n            labels: Labels to set for each channel.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(filename, ch_labels=labels)\n        return cf\n\n    @classmethod\n    def read_csv(\n        cls,\n        filename: str,\n        time_column: Union[int, str] = 0,\n        labels: Optional[list[str]] = None,\n        delimiter: str = \",\",\n        header: Optional[int] = 0,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a CSV file.\n\n        Args:\n            filename: Path to the CSV file.\n            time_column: Index or name of the time column.\n            labels: Labels to set for each channel.\n            delimiter: Delimiter character.\n            header: Row number to use as header.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(\n            filename,\n            ch_labels=labels,\n            time_column=time_column,\n            delimiter=delimiter,\n            header=header,\n        )\n        return cf\n\n    def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n        \"\"\"Save the audio data to a file.\n\n        Args:\n            path: Path to save the file.\n            format: File format. If None, determined from file extension.\n        \"\"\"\n        logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n        data = self.compute()\n        data = data.T\n        if data.shape[1] == 1:\n            data = data.squeeze(axis=1)\n        sf.write(str(path), data, int(self.sampling_rate), format=format)\n        logger.debug(f\"Save complete: {path}\")\n\n    def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a high-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n\n    def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a low-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n\n    def normalize(\n        self, target_level: float = -20, channel_wise: bool = True\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Normalize the signal level.\n\n        This method adjusts the signal amplitude to reach a target RMS level.\n\n        Args:\n            target_level: Target RMS level in dB. Default is -20.\n            channel_wise: If True, normalize each channel independently.\n                If False, apply the same scaling to all channels.\n\n        Returns:\n            A new ChannelFrame containing the normalized signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n        )\n        return self.apply_operation(\n            \"normalize\", target_level=target_level, channel_wise=channel_wise\n        )\n\n    def a_weighting(self) -&gt; \"ChannelFrame\":\n        \"\"\"Apply A-weighting filter to the signal.\n\n        A-weighting adjusts the frequency response to approximate human hearing\n        perception, following IEC 61672-1:2013 standard.\n\n        Returns:\n            A new ChannelFrame with A-weighted signal.\n        \"\"\"\n        return self.apply_operation(\"a_weighting\")\n\n    def hpss_harmonic(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract harmonic components using HPSS\n         (Harmonic-Percussive Source Separation).\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_harmonic\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def hpss_percussive(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract percussive components using HPSS\n        (Harmonic-Percussive Source Separation).\n\n        This method separates the percussive (tonal) components from the signal.\n\n        Args:\n            kernel_size: Median filter size for HPSS.\n            power: Exponent for the Weiner filter used in HPSS.\n            margin: Margin size for the separation.\n\n        Returns:\n            A new ChannelFrame containing the harmonic components.\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_percussive\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def resampling(\n        self,\n        target_sr: float,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Resample audio data.\n\n        Parameters\n        ----------\n        target_sr : float\n            Target sampling rate (Hz)\n        resample_type : str, optional\n            Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n        **kwargs : dict\n            Additional resampling parameters\n\n        Returns\n        -------\n        ChannelFrame\n            Resampled channel frame\n        \"\"\"\n        return self.apply_operation(\n            \"resampling\",\n            target_sr=target_sr,\n            **kwargs,\n        )\n\n    def abs(self) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the absolute value of the signal.\n\n        Returns:\n            A new ChannelFrame containing the absolute values.\n        \"\"\"\n        return self.apply_operation(\"abs\")\n\n    def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the power of the signal.\n\n        Args:\n            exponent: The exponent to raise the signal to. Default is 2.0.\n\n        Returns:\n            A new ChannelFrame containing the signal raised to the power.\n        \"\"\"\n        return self.apply_operation(\"power\", exponent=exponent)\n\n    def trim(\n        self,\n        start: float = 0,\n        end: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Trim the signal to specified time range.\n\n        Args:\n            start: Start time in seconds.\n            end: End time in seconds.\n\n        Returns:\n            A new ChannelFrame with trimmed signal.\n\n        Raises:\n            ValueError: If end time is before start time.\n        \"\"\"\n        if end is None:\n            end = self.duration\n        if start &gt; end:\n            raise ValueError(\"start must be less than end\")\n        # Apply trim operation\n        return self.apply_operation(\"trim\", start=start, end=end)\n\n    def rms_trend(\n        self,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the RMS trend of the signal.\n\n        This method computes the root mean square value over sliding windows.\n\n        Args:\n            frame_length: The size of the sliding window in samples. Default is 2048.\n            hop_length: The hop length between windows in samples. Default is 512.\n            dB: Whether to return the RMS values in decibels. Default is False.\n            Aw: Whether to apply A-weighting. Default is False.\n\n        Returns:\n            A new ChannelFrame containing the RMS trend.\n        \"\"\"\n        cf = self.apply_operation(\n            \"rms_trend\",\n            frame_length=frame_length,\n            hop_length=hop_length,\n            ref=[ch.ref for ch in self._channel_metadata],\n            dB=dB,\n            Aw=Aw,\n        )\n        cf.sampling_rate = self.sampling_rate / hop_length\n        return cf\n\n    def sum(self) -&gt; \"ChannelFrame\":\n        \"\"\"Sum all channels.\n\n        Returns:\n            A new ChannelFrame with summed signal.\n        \"\"\"\n        return self.apply_operation(\"sum\")\n\n    def mean(self) -&gt; \"ChannelFrame\":\n        \"\"\"Average all channels.\n\n        Returns:\n            A new ChannelFrame with averaged signal.\n        \"\"\"\n        return self.apply_operation(\"mean\")\n\n    def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate channel differences relative to a reference channel.\n\n        Args:\n            other_channel: Reference channel index or label. Default is 0.\n\n        Returns:\n            A new ChannelFrame with channel differences.\n        \"\"\"\n        if isinstance(other_channel, str):\n            return self.apply_operation(\n                \"channel_difference\", other_channel=self.label2index(other_channel)\n            )\n        return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n\n    def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n        \"\"\"Compute Fast Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is next power of 2 of data length.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectralFrame containing the FFT results.\n        \"\"\"\n        from ..processing.time_series import FFT\n        from .spectral import SpectralFrame\n\n        params = {\"n_fft\": n_fft, \"window\": window}\n        operation_name = \"fft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"FFT\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        if n_fft is None:\n            is_even = spectrum_data.shape[-1] % 2 == 0\n            _n_fft = (\n                spectrum_data.shape[-1] * 2 - 2\n                if is_even\n                else spectrum_data.shape[-1] * 2 - 1\n            )\n        else:\n            _n_fft = n_fft\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=_n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def welch(\n        self,\n        n_fft: Optional[int] = None,\n        hop_length: Optional[int] = None,\n        win_length: int = 2048,\n        window: str = \"hann\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute power spectral density using Welch's method.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the power spectral density.\n        \"\"\"\n        from ..processing.time_series import Welch\n        from .spectral import SpectralFrame\n\n        params = dict(\n            n_fft=n_fft or win_length,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            average=average,\n        )\n        operation_name = \"welch\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Welch\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"welch\", \"params\": params},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def noct_spectrum(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"Compute N-octave band spectrum.\n\n        Args:\n            fmin: Minimum center frequency in Hz. Default is 20 Hz.\n            fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n            n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n            G: Reference gain in dB. Default is 10 dB.\n            fr: Reference frequency in Hz. Default is 1000 Hz.\n\n        Returns:\n            A NOctFrame containing the N-octave band spectrum.\n        \"\"\"\n        from ..processing.time_series import NOctSpectrum\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_spectrum\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSpectrum\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_spectrum\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def stft(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"Compute Short-Time Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectrogramFrame containing the STFT results.\n        \"\"\"\n        from ..processing.time_series import STFT, create_operation\n        from .spectrogram import SpectrogramFrame\n\n        # Set hop length and window length\n        _hop_length = hop_length if hop_length is not None else n_fft // 4\n        _win_length = win_length if win_length is not None else n_fft\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": _hop_length,\n            \"win_length\": _win_length,\n            \"window\": window,\n        }\n        operation_name = \"stft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"STFT\", operation)\n\n        # Apply processing to data\n        spectrogram_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n\n        # Create new instance\n        return SpectrogramFrame(\n            data=spectrogram_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=n_fft,\n            hop_length=_hop_length,\n            win_length=_win_length,\n            window=window,\n            label=f\"stft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def coherence(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute magnitude squared coherence.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n        Returns:\n            A SpectralFrame containing the magnitude squared coherence.\n        \"\"\"\n        from ..processing.time_series import Coherence, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n        }\n        operation_name = \"coherence\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Coherence\", operation)\n\n        # Apply processing to data\n        coherence_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=coherence_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Coherence of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def csd(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute cross-spectral density matrix.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the cross-spectral density matrix.\n        \"\"\"\n        from ..processing.time_series import CSD, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"csd\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"CSD\", operation)\n\n        # Apply processing to data\n        csd_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=csd_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def transfer_function(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute transfer function matrix.\n\n        The transfer function characterizes the signal transmission properties\n        between channels in the frequency domain, representing the input-output\n        relationship of a system.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the transfer function matrix.\n        \"\"\"\n        from ..processing.time_series import TransferFunction, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"transfer_function\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"TransferFunction\", operation)\n\n        # Apply processing to data\n        tf_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=tf_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Transfer function of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"Provide additional initialization arguments required for ChannelFrame.\"\"\"\n        return {}\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Returns the duration in seconds.</p>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>Returns the number of samples.</p>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.time","title":"<code>time</code>  <code>property</code>","text":"<p>Get time array for the signal.</p> <p>Returns:</p> Type Description <code>NDArrayReal</code> <p>Array of time points in seconds.</p>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.__init__","title":"<code>__init__(data, sampling_rate, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a ChannelFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>Dask array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate of the data in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>operation_history</code> <code>Optional[list[dict[str, Any]]]</code> <p>History of operations applied to the frame.</p> <code>None</code> <code>channel_metadata</code> <code>Optional[list[ChannelMetadata]]</code> <p>Metadata for each channel.</p> <code>None</code> <code>previous</code> <code>Optional[BaseFrame[Any]]</code> <p>Reference to the previous frame in the processing chain.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has more than 2 dimensions.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"Initialize a ChannelFrame.\n\n    Args:\n        data: Dask array containing channel data.\n        Shape should be (n_channels, n_samples).\n        sampling_rate: The sampling rate of the data in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        operation_history: History of operations applied to the frame.\n        channel_metadata: Metadata for each channel.\n        previous: Reference to the previous frame in the processing chain.\n\n    Raises:\n        ValueError: If data has more than 2 dimensions.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.a_weighting","title":"<code>a_weighting()</code>","text":"<p>Apply A-weighting filter to the signal.</p> <p>A-weighting adjusts the frequency response to approximate human hearing perception, following IEC 61672-1:2013 standard.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with A-weighted signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def a_weighting(self) -&gt; \"ChannelFrame\":\n    \"\"\"Apply A-weighting filter to the signal.\n\n    A-weighting adjusts the frequency response to approximate human hearing\n    perception, following IEC 61672-1:2013 standard.\n\n    Returns:\n        A new ChannelFrame with A-weighted signal.\n    \"\"\"\n    return self.apply_operation(\"a_weighting\")\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.abs","title":"<code>abs()</code>","text":"<p>Calculate the absolute value of the signal.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the absolute values.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def abs(self) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the absolute value of the signal.\n\n    Returns:\n        A new ChannelFrame containing the absolute values.\n    \"\"\"\n    return self.apply_operation(\"abs\")\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.add","title":"<code>add(other, snr=None)</code>","text":"<p>Add another signal or value to the current signal.</p> <p>If SNR is specified, performs addition with consideration for signal-to-noise ratio.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[ChannelFrame, int, float, NDArrayReal, Array]</code> <p>Signal or value to add.</p> required <code>snr</code> <code>Optional[float]</code> <p>Signal-to-noise ratio (dB). If specified, adjusts the scale of the other signal based on this SNR. self is treated as the signal, and other as the noise.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new channel frame containing the addition result (lazy execution).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def add(\n    self,\n    other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n    snr: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Add another signal or value to the current signal.\n\n    If SNR is specified, performs addition with consideration for\n    signal-to-noise ratio.\n\n    Args:\n        other: Signal or value to add.\n        snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n            other signal based on this SNR.\n            self is treated as the signal, and other as the noise.\n\n    Returns:\n        A new channel frame containing the addition result (lazy execution).\n    \"\"\"\n    logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n    # Special processing when SNR is specified\n    if snr is not None:\n        # First convert other to ChannelFrame if it's not\n        if not isinstance(other, ChannelFrame):\n            if isinstance(other, np.ndarray):\n                other = ChannelFrame.from_numpy(\n                    other, self.sampling_rate, label=\"array_data\"\n                )\n            elif isinstance(other, (int, float)):\n                # For scalar values, simply add (ignore SNR)\n                return self + other\n            else:\n                raise TypeError(\n                    \"Addition target with SNR must be a ChannelFrame or \"\n                    f\"NumPy array: {type(other)}\"\n                )\n\n        # Check if sampling rates match\n        if self.sampling_rate != other.sampling_rate:\n            raise ValueError(\n                \"Sampling rates do not match. Cannot perform operation.\"\n            )\n\n        # Apply addition operation with SNR adjustment\n        return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n    # Execute normal addition if SNR is not specified\n    return self + other\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.channel_difference","title":"<code>channel_difference(other_channel=0)</code>","text":"<p>Calculate channel differences relative to a reference channel.</p> <p>Parameters:</p> Name Type Description Default <code>other_channel</code> <code>Union[int, str]</code> <p>Reference channel index or label. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with channel differences.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate channel differences relative to a reference channel.\n\n    Args:\n        other_channel: Reference channel index or label. Default is 0.\n\n    Returns:\n        A new ChannelFrame with channel differences.\n    \"\"\"\n    if isinstance(other_channel, str):\n        return self.apply_operation(\n            \"channel_difference\", other_channel=self.label2index(other_channel)\n        )\n    return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.coherence","title":"<code>coherence(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant')</code>","text":"<p>Compute magnitude squared coherence.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the magnitude squared coherence.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def coherence(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute magnitude squared coherence.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n    Returns:\n        A SpectralFrame containing the magnitude squared coherence.\n    \"\"\"\n    from ..processing.time_series import Coherence, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n    }\n    operation_name = \"coherence\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Coherence\", operation)\n\n    # Apply processing to data\n    coherence_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=coherence_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Coherence of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.csd","title":"<code>csd(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute cross-spectral density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the cross-spectral density matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def csd(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute cross-spectral density matrix.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the cross-spectral density matrix.\n    \"\"\"\n    from ..processing.time_series import CSD, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"csd\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"CSD\", operation)\n\n    # Apply processing to data\n    csd_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=csd_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.describe","title":"<code>describe(normalize=True, **kwargs)</code>","text":"<p>Display visual and audio representation of the frame.</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>Whether to normalize the audio data for playback.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for visualization.</p> <code>{}</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n    \"\"\"Display visual and audio representation of the frame.\n\n    Args:\n        normalize: Whether to normalize the audio data for playback.\n        **kwargs: Additional parameters for visualization.\n    \"\"\"\n    if \"axis_config\" in kwargs:\n        logger.warning(\n            \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        axis_config = kwargs[\"axis_config\"]\n        if \"time_plot\" in axis_config:\n            kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n        if \"freq_plot\" in axis_config:\n            if \"xlim\" in axis_config[\"freq_plot\"]:\n                vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                kwargs[\"vmin\"] = vlim[0]\n                kwargs[\"vmax\"] = vlim[1]\n            if \"ylim\" in axis_config[\"freq_plot\"]:\n                ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                kwargs[\"ylim\"] = ylim\n\n    if \"cbar_config\" in kwargs:\n        logger.warning(\n            \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        cbar_config = kwargs[\"cbar_config\"]\n        if \"vmin\" in cbar_config:\n            kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n        if \"vmax\" in cbar_config:\n            kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n    for ch in self:\n        ax: Axes\n        _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n        if isinstance(_ax, Iterator):\n            ax = next(iter(_ax))\n        elif isinstance(_ax, Axes):\n            ax = _ax\n        else:\n            raise TypeError(\n                f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n            )\n        # Ignore type checks for display and Audio\n        display(ax.figure)  # type: ignore\n        plt.close(ax.figure)  # type: ignore\n        display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.fft","title":"<code>fft(n_fft=None, window='hann')</code>","text":"<p>Compute Fast Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is next power of 2 of data length.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the FFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n    \"\"\"Compute Fast Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is next power of 2 of data length.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectralFrame containing the FFT results.\n    \"\"\"\n    from ..processing.time_series import FFT\n    from .spectral import SpectralFrame\n\n    params = {\"n_fft\": n_fft, \"window\": window}\n    operation_name = \"fft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"FFT\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    if n_fft is None:\n        is_even = spectrum_data.shape[-1] % 2 == 0\n        _n_fft = (\n            spectrum_data.shape[-1] * 2 - 2\n            if is_even\n            else spectrum_data.shape[-1] * 2 - 1\n        )\n    else:\n        _n_fft = n_fft\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=_n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.from_file","title":"<code>from_file(path, channel=None, start=None, end=None, chunk_size=None, ch_labels=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from an audio file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the audio file.</p> required <code>channel</code> <code>Optional[Union[int, list[int]]]</code> <p>Channel(s) to load.</p> <code>None</code> <code>start</code> <code>Optional[float]</code> <p>Start time in seconds.</p> <code>None</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <code>chunk_size</code> <code>Optional[int]</code> <p>Chunk size for processing.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the file reader.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the loaded audio data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If channel selection is invalid.</p> <code>TypeError</code> <p>If channel parameter type is invalid.</p> <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    path: Union[str, Path],\n    channel: Optional[Union[int, list[int]]] = None,\n    start: Optional[float] = None,\n    end: Optional[float] = None,\n    chunk_size: Optional[int] = None,\n    ch_labels: Optional[list[str]] = None,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from an audio file.\n\n    Args:\n        path: Path to the audio file.\n        channel: Channel(s) to load.\n        start: Start time in seconds.\n        end: End time in seconds.\n        chunk_size: Chunk size for processing.\n        Specifies the splitting size for lazy processing.\n        ch_labels: Labels for each channel.\n        **kwargs: Additional arguments passed to the file reader.\n\n    Returns:\n        A new ChannelFrame containing the loaded audio data.\n\n    Raises:\n        ValueError: If channel selection is invalid.\n        TypeError: If channel parameter type is invalid.\n        FileNotFoundError: If the file doesn't exist.\n    \"\"\"\n    from .channel import ChannelFrame\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    # Get file reader\n    reader = get_file_reader(path)\n\n    # Get file info\n    info = reader.get_file_info(path, **kwargs)\n    sr = info[\"samplerate\"]\n    n_channels = info[\"channels\"]\n    n_frames = info[\"frames\"]\n    ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n    logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n    # Channel selection processing\n    all_channels = list(range(n_channels))\n\n    if channel is None:\n        channels_to_load = all_channels\n        logger.debug(f\"Will load all channels: {channels_to_load}\")\n    elif isinstance(channel, int):\n        if channel &lt; 0 or channel &gt;= n_channels:\n            raise ValueError(\n                f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n            )\n        channels_to_load = [channel]\n        logger.debug(f\"Will load single channel: {channel}\")\n    elif isinstance(channel, (list, tuple)):\n        for ch in channel:\n            if ch &lt; 0 or ch &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n        channels_to_load = list(channel)\n        logger.debug(f\"Will load specific channels: {channels_to_load}\")\n    else:\n        raise TypeError(\"channel must be int, list, or None\")\n\n    # Index calculation\n    start_idx = 0 if start is None else max(0, int(start * sr))\n    end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n    frames_to_read = end_idx - start_idx\n\n    logger.debug(\n        f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n        f\"start_idx={start_idx}, end_idx={end_idx}\"\n    )\n\n    # Settings for lazy loading\n    expected_shape = (len(channels_to_load), frames_to_read)\n\n    # Define the loading function using the file reader\n    def _load_audio() -&gt; NDArrayReal:\n        logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n        # Use the reader to get audio data with parameters\n        out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n        if not isinstance(out, np.ndarray):\n            raise ValueError(\"Unexpected data type after reading file\")\n        return out\n\n    logger.debug(\n        f\"Creating delayed dask task with expected shape: {expected_shape}\"\n    )\n\n    # Create delayed operation\n    delayed_data = dask_delayed(_load_audio)()\n    logger.debug(\"Wrapping delayed function in dask array\")\n\n    # Create dask array from delayed computation\n    dask_array = da_from_delayed(\n        delayed_data, shape=expected_shape, dtype=np.float32\n    )\n\n    if chunk_size is not None:\n        if chunk_size &lt;= 0:\n            raise ValueError(\"Chunk size must be a positive integer\")\n        logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n        dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n    logger.debug(\n        \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n    )\n\n    cf = ChannelFrame(\n        data=dask_array,\n        sampling_rate=sr,\n        label=path.stem,\n        metadata={\n            \"filename\": str(path),\n        },\n    )\n    if ch_labels is not None:\n        if len(ch_labels) != len(cf):\n            raise ValueError(\n                \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    return cf\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.from_ndarray","title":"<code>from_ndarray(array, sampling_rate, labels=None, unit=None, frame_label=None, metadata=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>This method is deprecated. Use from_numpy instead.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>NDArrayReal</code> <p>Signal data. Each row corresponds to a channel.</p> required <code>sampling_rate</code> <code>float</code> <p>Sampling rate (Hz).</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>unit</code> <code>Optional[Union[list[str], str]]</code> <p>Unit of the signal.</p> <code>None</code> <code>frame_label</code> <code>Optional[str]</code> <p>Label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_ndarray(\n    cls,\n    array: NDArrayReal,\n    sampling_rate: float,\n    labels: Optional[list[str]] = None,\n    unit: Optional[Union[list[str], str]] = None,\n    frame_label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    This method is deprecated. Use from_numpy instead.\n\n    Args:\n        array: Signal data. Each row corresponds to a channel.\n        sampling_rate: Sampling rate (Hz).\n        labels: Labels for each channel.\n        unit: Unit of the signal.\n        frame_label: Label for the frame.\n        metadata: Optional metadata dictionary.\n\n    Returns:\n        A new ChannelFrame containing the data.\n    \"\"\"\n    # Redirect to from_numpy for compatibility\n    # However, from_ndarray is deprecated\n    logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n    return cls.from_numpy(\n        data=array,\n        sampling_rate=sampling_rate,\n        label=frame_label,\n        metadata=metadata,\n        ch_labels=labels,\n        ch_units=unit,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.from_numpy","title":"<code>from_numpy(data, sampling_rate, label=None, metadata=None, ch_labels=None, ch_units=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArrayReal</code> <p>NumPy array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>ch_units</code> <code>Optional[Union[list[str], str]]</code> <p>Units for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the NumPy data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_numpy(\n    cls,\n    data: NDArrayReal,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    ch_labels: Optional[list[str]] = None,\n    ch_units: Optional[Union[list[str], str]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    Args:\n        data: NumPy array containing channel data.\n        sampling_rate: The sampling rate in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        ch_labels: Labels for each channel.\n        ch_units: Units for each channel.\n\n    Returns:\n        A new ChannelFrame containing the NumPy data.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n\n    # Convert NumPy array to dask array\n    dask_data = da_from_array(data)\n    cf = ChannelFrame(\n        data=dask_data,\n        sampling_rate=sampling_rate,\n        label=label or \"numpy_data\",\n    )\n    if metadata is not None:\n        cf.metadata = metadata\n    if ch_labels is not None:\n        if len(ch_labels) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel labels does not match the number of channels\"\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    if ch_units is not None:\n        if isinstance(ch_units, str):\n            ch_units = [ch_units] * cf.n_channels\n\n        if len(ch_units) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel units does not match the number of channels\"\n            )\n        for i in range(len(ch_units)):\n            cf._channel_metadata[i].unit = ch_units[i]\n\n    return cf\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.high_pass_filter","title":"<code>high_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a high-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a high-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.hpss_harmonic","title":"<code>hpss_harmonic(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract harmonic components using HPSS  (Harmonic-Percussive Source Separation).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_harmonic(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract harmonic components using HPSS\n     (Harmonic-Percussive Source Separation).\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_harmonic\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.hpss_percussive","title":"<code>hpss_percussive(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract percussive components using HPSS (Harmonic-Percussive Source Separation).</p> <p>This method separates the percussive (tonal) components from the signal.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Union[_IntLike_co, tuple[_IntLike_co, _IntLike_co], list[_IntLike_co]]</code> <p>Median filter size for HPSS.</p> <code>31</code> <code>power</code> <code>float</code> <p>Exponent for the Weiner filter used in HPSS.</p> <code>2</code> <code>margin</code> <code>Union[_FloatLike_co, tuple[_FloatLike_co, _FloatLike_co], list[_FloatLike_co]]</code> <p>Margin size for the separation.</p> <code>1</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the harmonic components.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_percussive(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract percussive components using HPSS\n    (Harmonic-Percussive Source Separation).\n\n    This method separates the percussive (tonal) components from the signal.\n\n    Args:\n        kernel_size: Median filter size for HPSS.\n        power: Exponent for the Weiner filter used in HPSS.\n        margin: Margin size for the separation.\n\n    Returns:\n        A new ChannelFrame containing the harmonic components.\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_percussive\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.low_pass_filter","title":"<code>low_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a low-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a low-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.mean","title":"<code>mean()</code>","text":"<p>Average all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with averaged signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def mean(self) -&gt; \"ChannelFrame\":\n    \"\"\"Average all channels.\n\n    Returns:\n        A new ChannelFrame with averaged signal.\n    \"\"\"\n    return self.apply_operation(\"mean\")\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.noct_spectrum","title":"<code>noct_spectrum(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Compute N-octave band spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>fmin</code> <code>float</code> <p>Minimum center frequency in Hz. Default is 20 Hz.</p> required <code>fmax</code> <code>float</code> <p>Maximum center frequency in Hz. Default is 20000 Hz.</p> required <code>n</code> <code>int</code> <p>Band division (1 for octave, 3 for 1/3 octave). Default is 3.</p> <code>3</code> <code>G</code> <code>int</code> <p>Reference gain in dB. Default is 10 dB.</p> <code>10</code> <code>fr</code> <code>int</code> <p>Reference frequency in Hz. Default is 1000 Hz.</p> <code>1000</code> <p>Returns:</p> Type Description <code>NOctFrame</code> <p>A NOctFrame containing the N-octave band spectrum.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def noct_spectrum(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"Compute N-octave band spectrum.\n\n    Args:\n        fmin: Minimum center frequency in Hz. Default is 20 Hz.\n        fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n        n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n        G: Reference gain in dB. Default is 10 dB.\n        fr: Reference frequency in Hz. Default is 1000 Hz.\n\n    Returns:\n        A NOctFrame containing the N-octave band spectrum.\n    \"\"\"\n    from ..processing.time_series import NOctSpectrum\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_spectrum\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSpectrum\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_spectrum\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.normalize","title":"<code>normalize(target_level=-20, channel_wise=True)</code>","text":"<p>Normalize the signal level.</p> <p>This method adjusts the signal amplitude to reach a target RMS level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target RMS level in dB. Default is -20.</p> <code>-20</code> <code>channel_wise</code> <code>bool</code> <p>If True, normalize each channel independently. If False, apply the same scaling to all channels.</p> <code>True</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the normalized signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def normalize(\n    self, target_level: float = -20, channel_wise: bool = True\n) -&gt; \"ChannelFrame\":\n    \"\"\"Normalize the signal level.\n\n    This method adjusts the signal amplitude to reach a target RMS level.\n\n    Args:\n        target_level: Target RMS level in dB. Default is -20.\n        channel_wise: If True, normalize each channel independently.\n            If False, apply the same scaling to all channels.\n\n    Returns:\n        A new ChannelFrame containing the normalized signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n    )\n    return self.apply_operation(\n        \"normalize\", target_level=target_level, channel_wise=channel_wise\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.plot","title":"<code>plot(plot_type='waveform', ax=None, **kwargs)</code>","text":"<p>Plot the frame data.</p> <p>Parameters:</p> Name Type Description Default <code>plot_type</code> <code>str</code> <p>Type of plot. Default is \"waveform\".</p> <code>'waveform'</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def plot(\n    self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Plot the frame data.\n\n    Args:\n        plot_type: Type of plot. Default is \"waveform\".\n        ax: Optional matplotlib axes for plotting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    plot_strategy = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.power","title":"<code>power(exponent=2.0)</code>","text":"<p>Calculate the power of the signal.</p> <p>Parameters:</p> Name Type Description Default <code>exponent</code> <code>float</code> <p>The exponent to raise the signal to. Default is 2.0.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the signal raised to the power.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the power of the signal.\n\n    Args:\n        exponent: The exponent to raise the signal to. Default is 2.0.\n\n    Returns:\n        A new ChannelFrame containing the signal raised to the power.\n    \"\"\"\n    return self.apply_operation(\"power\", exponent=exponent)\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.read_csv","title":"<code>read_csv(filename, time_column=0, labels=None, delimiter=',', header=0)</code>  <code>classmethod</code>","text":"<p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.read_wav","title":"<code>read_wav(filename, labels=None)</code>  <code>classmethod</code>","text":"<p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.resampling","title":"<code>resampling(target_sr, **kwargs)</code>","text":"<p>Resample audio data.</p>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.resampling--parameters","title":"Parameters","text":"<p>target_sr : float     Target sampling rate (Hz) resample_type : str, optional     Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.) **kwargs : dict     Additional resampling parameters</p>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.resampling--returns","title":"Returns","text":"<p>ChannelFrame     Resampled channel frame</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def resampling(\n    self,\n    target_sr: float,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Resample audio data.\n\n    Parameters\n    ----------\n    target_sr : float\n        Target sampling rate (Hz)\n    resample_type : str, optional\n        Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n    **kwargs : dict\n        Additional resampling parameters\n\n    Returns\n    -------\n    ChannelFrame\n        Resampled channel frame\n    \"\"\"\n    return self.apply_operation(\n        \"resampling\",\n        target_sr=target_sr,\n        **kwargs,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.rms_plot","title":"<code>rms_plot(ax=None, title=None, overlay=True, Aw=False, **kwargs)</code>","text":"<p>Generate an RMS plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title for the plot.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay the plot on the existing axis.</p> <code>True</code> <code>Aw</code> <code>bool</code> <p>Apply A-weighting.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_plot(\n    self,\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = True,\n    Aw: bool = False,  # noqa: N803\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Generate an RMS plot.\n\n    Args:\n        ax: Optional matplotlib axes for plotting.\n        title: Title for the plot.\n        overlay: Whether to overlay the plot on the existing axis.\n        Aw: Apply A-weighting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    kwargs = kwargs or {}\n    ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n    rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n    return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.rms_trend","title":"<code>rms_trend(frame_length=2048, hop_length=512, dB=False, Aw=False)</code>","text":"<p>Calculate the RMS trend of the signal.</p> <p>This method computes the root mean square value over sliding windows.</p> <p>Parameters:</p> Name Type Description Default <code>frame_length</code> <code>int</code> <p>The size of the sliding window in samples. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>int</code> <p>The hop length between windows in samples. Default is 512.</p> <code>512</code> <code>dB</code> <code>bool</code> <p>Whether to return the RMS values in decibels. Default is False.</p> <code>False</code> <code>Aw</code> <code>bool</code> <p>Whether to apply A-weighting. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the RMS trend.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_trend(\n    self,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the RMS trend of the signal.\n\n    This method computes the root mean square value over sliding windows.\n\n    Args:\n        frame_length: The size of the sliding window in samples. Default is 2048.\n        hop_length: The hop length between windows in samples. Default is 512.\n        dB: Whether to return the RMS values in decibels. Default is False.\n        Aw: Whether to apply A-weighting. Default is False.\n\n    Returns:\n        A new ChannelFrame containing the RMS trend.\n    \"\"\"\n    cf = self.apply_operation(\n        \"rms_trend\",\n        frame_length=frame_length,\n        hop_length=hop_length,\n        ref=[ch.ref for ch in self._channel_metadata],\n        dB=dB,\n        Aw=Aw,\n    )\n    cf.sampling_rate = self.sampling_rate / hop_length\n    return cf\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.save","title":"<code>save(path, format=None)</code>","text":"<p>Save the audio data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n    data = self.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    sf.write(str(path), data, int(self.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {path}\")\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.stft","title":"<code>stft(n_fft=2048, hop_length=None, win_length=None, window='hann')</code>","text":"<p>Compute Short-Time Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectrogramFrame</code> <p>A SpectrogramFrame containing the STFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def stft(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n) -&gt; \"SpectrogramFrame\":\n    \"\"\"Compute Short-Time Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectrogramFrame containing the STFT results.\n    \"\"\"\n    from ..processing.time_series import STFT, create_operation\n    from .spectrogram import SpectrogramFrame\n\n    # Set hop length and window length\n    _hop_length = hop_length if hop_length is not None else n_fft // 4\n    _win_length = win_length if win_length is not None else n_fft\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": _hop_length,\n        \"win_length\": _win_length,\n        \"window\": window,\n    }\n    operation_name = \"stft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"STFT\", operation)\n\n    # Apply processing to data\n    spectrogram_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n\n    # Create new instance\n    return SpectrogramFrame(\n        data=spectrogram_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=n_fft,\n        hop_length=_hop_length,\n        win_length=_win_length,\n        window=window,\n        label=f\"stft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.sum","title":"<code>sum()</code>","text":"<p>Sum all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with summed signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def sum(self) -&gt; \"ChannelFrame\":\n    \"\"\"Sum all channels.\n\n    Returns:\n        A new ChannelFrame with summed signal.\n    \"\"\"\n    return self.apply_operation(\"sum\")\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.transfer_function","title":"<code>transfer_function(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute transfer function matrix.</p> <p>The transfer function characterizes the signal transmission properties between channels in the frequency domain, representing the input-output relationship of a system.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the transfer function matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def transfer_function(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute transfer function matrix.\n\n    The transfer function characterizes the signal transmission properties\n    between channels in the frequency domain, representing the input-output\n    relationship of a system.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the transfer function matrix.\n    \"\"\"\n    from ..processing.time_series import TransferFunction, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"transfer_function\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"TransferFunction\", operation)\n\n    # Apply processing to data\n    tf_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=tf_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Transfer function of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.trim","title":"<code>trim(start=0, end=None)</code>","text":"<p>Trim the signal to specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>Start time in seconds.</p> <code>0</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with trimmed signal.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If end time is before start time.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def trim(\n    self,\n    start: float = 0,\n    end: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Trim the signal to specified time range.\n\n    Args:\n        start: Start time in seconds.\n        end: End time in seconds.\n\n    Returns:\n        A new ChannelFrame with trimmed signal.\n\n    Raises:\n        ValueError: If end time is before start time.\n    \"\"\"\n    if end is None:\n        end = self.duration\n    if start &gt; end:\n        raise ValueError(\"start must be less than end\")\n    # Apply trim operation\n    return self.apply_operation(\"trim\", start=start, end=end)\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.channel.ChannelFrame.welch","title":"<code>welch(n_fft=None, hop_length=None, win_length=2048, window='hann', average='mean')</code>","text":"<p>Compute power spectral density using Welch's method.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is 2048.</p> <code>None</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>int</code> <p>Length of window. Default is n_fft.</p> <code>2048</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the power spectral density.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def welch(\n    self,\n    n_fft: Optional[int] = None,\n    hop_length: Optional[int] = None,\n    win_length: int = 2048,\n    window: str = \"hann\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute power spectral density using Welch's method.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the power spectral density.\n    \"\"\"\n    from ..processing.time_series import Welch\n    from .spectral import SpectralFrame\n\n    params = dict(\n        n_fft=n_fft or win_length,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        average=average,\n    )\n    operation_name = \"welch\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Welch\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"welch\", \"params\": params},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/frames/#spectralframe","title":"SpectralFrame","text":"<p><code>SpectralFrame</code> is a frame that handles frequency-domain data.</p> <pre><code>from wandas.frames.spectral import SpectralFrame\n\n# Or convert from ChannelFrame\nchannel_frame = wandas.read_wav(\"audio.wav\")\nspectral_frame = channel_frame.to_spectral()\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayComplex]</code></p> <p>Class for handling frequency-domain signal data.</p> <p>This class represents spectral data, providing methods for spectral analysis, manipulation, and visualization. It handles complex-valued frequency domain data obtained through operations like FFT.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The spectral data. Must be a dask array with shape:     - (channels, frequency_bins) for multi-channel data     - (frequency_bins,) for single-channel data, which will be       reshaped to (1, frequency_bins) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. n_fft : int     The FFT size used to generate this spectral data. window : str, default=\"hann\"     The window function used in the FFT. label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame--attributes","title":"Attributes","text":"<p>magnitude : NDArrayReal     The magnitude spectrum of the data. phase : NDArrayReal     The phase spectrum in radians. power : NDArrayReal     The power spectrum (magnitude squared). dB : NDArrayReal     The spectrum in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrum in decibels. freqs : NDArrayReal     The frequency axis values in Hz.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame--examples","title":"Examples","text":"<p>Create a SpectralFrame from FFT:</p> <p>signal = ChannelFrame.from_numpy(data, sampling_rate=44100) spectrum = signal.fft(n_fft=2048)</p> <p>Plot the magnitude spectrum:</p> <p>spectrum.plot()</p> <p>Perform binary operations:</p> <p>scaled = spectrum * 2.0 summed = spectrum1 + spectrum2  # Must have matching sampling rates</p> <p>Convert back to time domain:</p> <p>time_signal = spectrum.ifft()</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame--notes","title":"Notes","text":"<ul> <li>All operations are performed lazily using dask arrays for efficient memory usage.</li> <li>Binary operations (+, -, *, /) can be performed between SpectralFrames or with   scalar values.</li> <li>The class maintains the processing history and metadata through all operations.</li> </ul> Source code in <code>wandas/frames/spectral.py</code> <pre><code>class SpectralFrame(BaseFrame[NDArrayComplex]):\n    \"\"\"\n    Class for handling frequency-domain signal data.\n\n    This class represents spectral data, providing methods for spectral analysis,\n    manipulation, and visualization. It handles complex-valued frequency domain data\n    obtained through operations like FFT.\n\n    Parameters\n    ----------\n    data : DaArray\n        The spectral data. Must be a dask array with shape:\n        - (channels, frequency_bins) for multi-channel data\n        - (frequency_bins,) for single-channel data, which will be\n          reshaped to (1, frequency_bins)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    n_fft : int\n        The FFT size used to generate this spectral data.\n    window : str, default=\"hann\"\n        The window function used in the FFT.\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    magnitude : NDArrayReal\n        The magnitude spectrum of the data.\n    phase : NDArrayReal\n        The phase spectrum in radians.\n    power : NDArrayReal\n        The power spectrum (magnitude squared).\n    dB : NDArrayReal\n        The spectrum in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrum in decibels.\n    freqs : NDArrayReal\n        The frequency axis values in Hz.\n\n    Examples\n    --------\n    Create a SpectralFrame from FFT:\n    &gt;&gt;&gt; signal = ChannelFrame.from_numpy(data, sampling_rate=44100)\n    &gt;&gt;&gt; spectrum = signal.fft(n_fft=2048)\n\n    Plot the magnitude spectrum:\n    &gt;&gt;&gt; spectrum.plot()\n\n    Perform binary operations:\n    &gt;&gt;&gt; scaled = spectrum * 2.0\n    &gt;&gt;&gt; summed = spectrum1 + spectrum2  # Must have matching sampling rates\n\n    Convert back to time domain:\n    &gt;&gt;&gt; time_signal = spectrum.ifft()\n\n    Notes\n    -----\n    - All operations are performed lazily using dask arrays for efficient memory usage.\n    - Binary operations (+, -, *, /) can be performed between SpectralFrames or with\n      scalar values.\n    - The class maintains the processing history and metadata through all operations.\n    \"\"\"\n\n    n_fft: int\n    window: str\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        n_fft: int,\n        window: str = \"hann\",\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306f1\u6b21\u5143\u307e\u305f\u306f2\u6b21\u5143\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u5f62\u72b6: {data.shape}\"\n            )\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def magnitude(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the magnitude spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The absolute values of the complex spectrum.\n        \"\"\"\n        return np.abs(self.data)\n\n    @property\n    def phase(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the phase spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The phase angles of the complex spectrum in radians.\n        \"\"\"\n        return np.angle(self.data)\n\n    @property\n    def power(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the power spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The squared magnitude spectrum.\n        \"\"\"\n        return self.magnitude**2\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrum in decibels.\n\n        The reference values are taken from channel metadata. If no reference\n        is specified, uses 1.0.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrum in dB relative to channel references.\n        \"\"\"\n        mag: NDArrayReal = self.magnitude\n        ref_values: NDArrayReal = np.array([ch.ref for ch in self._channel_metadata])\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(mag / ref_values[:, np.newaxis], 1e-12)\n        )\n\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrum in decibels.\n\n        Applies A-weighting filter to the spectrum for better correlation with\n        perceived loudness.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrum in dB.\n        \"\"\"\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels.\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the frequency axis values in Hz.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of frequency values corresponding to each frequency bin.\n        \"\"\"\n        return np.fft.rfftfreq(self.n_fft, 1.0 / self.sampling_rate)\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Implementation of operation application for spectral data.\n\n        This internal method handles the application of various operations to\n        spectral data, maintaining lazy evaluation through dask.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters for the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        processed_data = operation.process(self._data)\n\n        # \u30e1\u30bf\u30c7\u30fc\u30bf\u66f4\u65b0\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\n            \"SpectralFrame\", int, float, complex, NDArrayComplex, NDArrayReal, \"DaArray\"\n        ],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"\n        Common implementation for binary operations.\n\n        This method handles binary operations between SpectralFrames and various types\n        of operands, maintaining lazy evaluation through dask arrays.\n\n        Parameters\n        ----------\n        other : Union[SpectralFrame, int, float, complex,\n                        NDArrayComplex, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation (e.g., lambda a, b: a + b)\n        symbol : str\n            String representation of the operation (e.g., '+')\n\n        Returns\n        -------\n        SpectralFrame\n            A new SpectralFrame containing the result of the operation.\n\n        Raises\n        ------\n        ValueError\n            If attempting to operate with a SpectralFrame\n            with a different sampling rate.\n        \"\"\"\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, SpectralFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u304c\u4e00\u81f4\u3057\u3066\u3044\u307e\u305b\u3093\u3002\u6f14\u7b97\u3067\u304d\u307e\u305b\u3093\u3002\"\n                )\n\n            # dask array\u3092\u76f4\u63a5\u6f14\u7b97\uff08\u9045\u5ef6\u5b9f\u884c\u3092\u7dad\u6301\uff09\n            result_data = op(self._data, other._data)\n\n            # \u30c1\u30e3\u30cd\u30eb\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u7d50\u5408\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return SpectralFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # \u30b9\u30ab\u30e9\u30fc\u3001NumPy\u914d\u5217\u3001\u307e\u305f\u306f\u4ed6\u306e\u30bf\u30a4\u30d7\u3068\u306e\u6f14\u7b97\n        else:\n            # dask array\u306b\u76f4\u63a5\u6f14\u7b97\u3092\u9069\u7528\uff08\u9045\u5ef6\u5b9f\u884c\u3092\u7dad\u6301\uff09\n            result_data = op(self._data, other)\n\n            # \u30aa\u30da\u30e9\u30f3\u30c9\u306e\u8868\u793a\u7528\u6587\u5b57\u5217\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, complex):\n                other_str = f\"complex({other.real}, {other.imag})\"\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # dask.array.Array\u306e\u30c1\u30a7\u30c3\u30af\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # \u30c1\u30e3\u30cd\u30eb\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u66f4\u65b0\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return SpectralFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n            )\n\n    def plot(\n        self,\n        plot_type: str = \"frequency\",\n        ax: Optional[\"Axes\"] = None,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the spectral data using various visualization strategies.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"frequency\"\n            Type of plot to create. Options include:\n            - \"frequency\": Standard frequency plot\n            - \"matrix\": Matrix plot for comparing channels\n            - Other types as defined by available plot strategies\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - title: Plot title\n            - xlabel, ylabel: Axis labels\n            - vmin, vmax: Value limits for plots\n            - cmap: Colormap name\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def ifft(self) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.\n\n        This method transforms the frequency-domain data back to the time domain using\n        the inverse FFT operation. The window function used in the forward FFT is\n        taken into account to ensure proper reconstruction.\n\n        Returns\n        -------\n        ChannelFrame\n            A new ChannelFrame containing the time-domain signal.\n        \"\"\"\n        from ..processing.time_series import IFFT, create_operation\n        from .channel import ChannelFrame\n\n        params = {\"n_fft\": self.n_fft, \"window\": self.window}\n        operation_name = \"ifft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"IFFT\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        time_series = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        return ChannelFrame(\n            data=time_series,\n            sampling_rate=self.sampling_rate,\n            label=f\"ifft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        SpectralFrame \u306b\u5fc5\u8981\u306a\u8ffd\u52a0\u306e\u521d\u671f\u5316\u5f15\u6570\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments for SpectralFrame.\n        \"\"\"\n        return {\n            \"n_fft\": self.n_fft,\n            \"window\": self.window,\n        }\n\n    def noct_synthesis(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"\n        Synthesize N-octave band spectrum.\n\n        This method combines frequency components into N-octave bands according to\n        standard acoustical band definitions. This is commonly used in noise and\n        vibration analysis.\n\n        Parameters\n        ----------\n        fmin : float\n            Lower frequency bound in Hz.\n        fmax : float\n            Upper frequency bound in Hz.\n        n : int, default=3\n            Number of bands per octave (e.g., 3 for third-octave bands).\n        G : int, default=10\n            Reference band number.\n        fr : int, default=1000\n            Reference frequency in Hz.\n\n        Returns\n        -------\n        NOctFrame\n            A new NOctFrame containing the N-octave band spectrum.\n\n        Raises\n        ------\n        ValueError\n            If the sampling rate is not 48000 Hz, which is required for this operation.\n        \"\"\"\n        if self.sampling_rate != 48000:\n            raise ValueError(\n                \"noct_synthesis\u306f48000Hz\u306e\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u3067\u306e\u307f\u4f7f\u7528\u3067\u304d\u307e\u3059\u3002\"\n            )\n        from ..processing.time_series import NOctSynthesis\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_synthesis\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSynthesis\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_synthesis\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def plot_matrix(\n        self,\n        plot_type: str = \"matrix\",\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot channel relationships in matrix format.\n\n        This method creates a matrix plot showing relationships between channels,\n        such as coherence, transfer functions, or cross-spectral density.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"matrix\"\n            Type of matrix plot to create.\n        **kwargs : dict\n            Additional plot parameters:\n            - vmin, vmax: Color scale limits\n            - cmap: Colormap name\n            - title: Plot title\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrum in decibels.</p> <p>The reference values are taken from channel metadata. If no reference is specified, uses 1.0.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrum in dB relative to channel references.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrum in decibels.</p> <p>Applies A-weighting filter to the spectrum for better correlation with perceived loudness.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrum in dB.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the frequency axis values in Hz.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of frequency values corresponding to each frequency bin.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.magnitude","title":"<code>magnitude</code>  <code>property</code>","text":"<p>Get the magnitude spectrum.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.magnitude--returns","title":"Returns","text":"<p>NDArrayReal     The absolute values of the complex spectrum.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.phase","title":"<code>phase</code>  <code>property</code>","text":"<p>Get the phase spectrum.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.phase--returns","title":"Returns","text":"<p>NDArrayReal     The phase angles of the complex spectrum in radians.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.power","title":"<code>power</code>  <code>property</code>","text":"<p>Get the power spectrum.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.power--returns","title":"Returns","text":"<p>NDArrayReal     The squared magnitude spectrum.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.ifft","title":"<code>ifft()</code>","text":"<p>Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.</p> <p>This method transforms the frequency-domain data back to the time domain using the inverse FFT operation. The window function used in the forward FFT is taken into account to ensure proper reconstruction.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.ifft--returns","title":"Returns","text":"<p>ChannelFrame     A new ChannelFrame containing the time-domain signal.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def ifft(self) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.\n\n    This method transforms the frequency-domain data back to the time domain using\n    the inverse FFT operation. The window function used in the forward FFT is\n    taken into account to ensure proper reconstruction.\n\n    Returns\n    -------\n    ChannelFrame\n        A new ChannelFrame containing the time-domain signal.\n    \"\"\"\n    from ..processing.time_series import IFFT, create_operation\n    from .channel import ChannelFrame\n\n    params = {\"n_fft\": self.n_fft, \"window\": self.window}\n    operation_name = \"ifft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"IFFT\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    time_series = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    return ChannelFrame(\n        data=time_series,\n        sampling_rate=self.sampling_rate,\n        label=f\"ifft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis","title":"<code>noct_synthesis(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Synthesize N-octave band spectrum.</p> <p>This method combines frequency components into N-octave bands according to standard acoustical band definitions. This is commonly used in noise and vibration analysis.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--parameters","title":"Parameters","text":"<p>fmin : float     Lower frequency bound in Hz. fmax : float     Upper frequency bound in Hz. n : int, default=3     Number of bands per octave (e.g., 3 for third-octave bands). G : int, default=10     Reference band number. fr : int, default=1000     Reference frequency in Hz.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--returns","title":"Returns","text":"<p>NOctFrame     A new NOctFrame containing the N-octave band spectrum.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--raises","title":"Raises","text":"<p>ValueError     If the sampling rate is not 48000 Hz, which is required for this operation.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def noct_synthesis(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"\n    Synthesize N-octave band spectrum.\n\n    This method combines frequency components into N-octave bands according to\n    standard acoustical band definitions. This is commonly used in noise and\n    vibration analysis.\n\n    Parameters\n    ----------\n    fmin : float\n        Lower frequency bound in Hz.\n    fmax : float\n        Upper frequency bound in Hz.\n    n : int, default=3\n        Number of bands per octave (e.g., 3 for third-octave bands).\n    G : int, default=10\n        Reference band number.\n    fr : int, default=1000\n        Reference frequency in Hz.\n\n    Returns\n    -------\n    NOctFrame\n        A new NOctFrame containing the N-octave band spectrum.\n\n    Raises\n    ------\n    ValueError\n        If the sampling rate is not 48000 Hz, which is required for this operation.\n    \"\"\"\n    if self.sampling_rate != 48000:\n        raise ValueError(\n            \"noct_synthesis\u306f48000Hz\u306e\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u3067\u306e\u307f\u4f7f\u7528\u3067\u304d\u307e\u3059\u3002\"\n        )\n    from ..processing.time_series import NOctSynthesis\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_synthesis\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSynthesis\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_synthesis\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.plot","title":"<code>plot(plot_type='frequency', ax=None, **kwargs)</code>","text":"<p>Plot the spectral data using various visualization strategies.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"frequency\"     Type of plot to create. Options include:     - \"frequency\": Standard frequency plot     - \"matrix\": Matrix plot for comparing channels     - Other types as defined by available plot strategies ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - title: Plot title     - xlabel, ylabel: Axis labels     - vmin, vmax: Value limits for plots     - cmap: Colormap name     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def plot(\n    self,\n    plot_type: str = \"frequency\",\n    ax: Optional[\"Axes\"] = None,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the spectral data using various visualization strategies.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"frequency\"\n        Type of plot to create. Options include:\n        - \"frequency\": Standard frequency plot\n        - \"matrix\": Matrix plot for comparing channels\n        - Other types as defined by available plot strategies\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - title: Plot title\n        - xlabel, ylabel: Axis labels\n        - vmin, vmax: Value limits for plots\n        - cmap: Colormap name\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix","title":"<code>plot_matrix(plot_type='matrix', **kwargs)</code>","text":"<p>Plot channel relationships in matrix format.</p> <p>This method creates a matrix plot showing relationships between channels, such as coherence, transfer functions, or cross-spectral density.</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"matrix\"     Type of matrix plot to create. **kwargs : dict     Additional plot parameters:     - vmin, vmax: Color scale limits     - cmap: Colormap name     - title: Plot title</p>"},{"location":"en/api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def plot_matrix(\n    self,\n    plot_type: str = \"matrix\",\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot channel relationships in matrix format.\n\n    This method creates a matrix plot showing relationships between channels,\n    such as coherence, transfer functions, or cross-spectral density.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"matrix\"\n        Type of matrix plot to create.\n    **kwargs : dict\n        Additional plot parameters:\n        - vmin, vmax: Color scale limits\n        - cmap: Colormap name\n        - title: Plot title\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/api/frames/#spectrogramframe","title":"SpectrogramFrame","text":"<p><code>SpectrogramFrame</code> is a frame that handles time-frequency representation (spectrogram) data.</p> <pre><code>from wandas.frames.spectrogram import SpectrogramFrame\n\n# Or convert from ChannelFrame\nchannel_frame = wandas.read_wav(\"audio.wav\")\nspectrogram_frame = channel_frame.to_spectrogram()\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayComplex]</code></p> <p>Class for handling time-frequency domain data (spectrograms).</p> <p>This class represents spectrogram data obtained through Short-Time Fourier Transform (STFT) or similar time-frequency analysis methods. It provides methods for visualization, manipulation, and conversion back to time domain.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The spectrogram data. Must be a dask array with shape:     - (channels, frequency_bins, time_frames) for multi-channel data     - (frequency_bins, time_frames) for single-channel data, which will be       reshaped to (1, frequency_bins, time_frames) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. n_fft : int     The FFT size used to generate this spectrogram. hop_length : int     Number of samples between successive frames. win_length : int, optional     The window length in samples. If None, defaults to n_fft. window : str, default=\"hann\"     The window function to use (e.g., \"hann\", \"hamming\", \"blackman\"). label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame--attributes","title":"Attributes","text":"<p>magnitude : NDArrayReal     The magnitude spectrogram. phase : NDArrayReal     The phase spectrogram in radians. power : NDArrayReal     The power spectrogram. dB : NDArrayReal     The spectrogram in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrogram in decibels. n_frames : int     Number of time frames. n_freq_bins : int     Number of frequency bins. freqs : NDArrayReal     The frequency axis values in Hz. times : NDArrayReal     The time axis values in seconds.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame--examples","title":"Examples","text":"<p>Create a spectrogram from a time-domain signal:</p> <p>signal = ChannelFrame.from_wav(\"audio.wav\") spectrogram = signal.stft(n_fft=2048, hop_length=512)</p> <p>Extract a specific time frame:</p> <p>frame_at_1s = spectrogram.get_frame_at(int(1.0 * sampling_rate / hop_length))</p> <p>Convert back to time domain:</p> <p>reconstructed = spectrogram.to_channel_frame()</p> <p>Plot the spectrogram:</p> <p>spectrogram.plot()</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>class SpectrogramFrame(BaseFrame[NDArrayComplex]):\n    \"\"\"\n    Class for handling time-frequency domain data (spectrograms).\n\n    This class represents spectrogram data obtained through\n    Short-Time Fourier Transform (STFT)\n    or similar time-frequency analysis methods. It provides methods for visualization,\n    manipulation, and conversion back to time domain.\n\n    Parameters\n    ----------\n    data : DaArray\n        The spectrogram data. Must be a dask array with shape:\n        - (channels, frequency_bins, time_frames) for multi-channel data\n        - (frequency_bins, time_frames) for single-channel data, which will be\n          reshaped to (1, frequency_bins, time_frames)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    n_fft : int\n        The FFT size used to generate this spectrogram.\n    hop_length : int\n        Number of samples between successive frames.\n    win_length : int, optional\n        The window length in samples. If None, defaults to n_fft.\n    window : str, default=\"hann\"\n        The window function to use (e.g., \"hann\", \"hamming\", \"blackman\").\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    magnitude : NDArrayReal\n        The magnitude spectrogram.\n    phase : NDArrayReal\n        The phase spectrogram in radians.\n    power : NDArrayReal\n        The power spectrogram.\n    dB : NDArrayReal\n        The spectrogram in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrogram in decibels.\n    n_frames : int\n        Number of time frames.\n    n_freq_bins : int\n        Number of frequency bins.\n    freqs : NDArrayReal\n        The frequency axis values in Hz.\n    times : NDArrayReal\n        The time axis values in seconds.\n\n    Examples\n    --------\n    Create a spectrogram from a time-domain signal:\n    &gt;&gt;&gt; signal = ChannelFrame.from_wav(\"audio.wav\")\n    &gt;&gt;&gt; spectrogram = signal.stft(n_fft=2048, hop_length=512)\n\n    Extract a specific time frame:\n    &gt;&gt;&gt; frame_at_1s = spectrogram.get_frame_at(int(1.0 * sampling_rate / hop_length))\n\n    Convert back to time domain:\n    &gt;&gt;&gt; reconstructed = spectrogram.to_channel_frame()\n\n    Plot the spectrogram:\n    &gt;&gt;&gt; spectrogram.plot()\n    \"\"\"\n\n    n_fft: int\n    hop_length: int\n    win_length: int\n    window: str\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        if data.ndim == 2:\n            data = da.expand_dims(data, axis=0)  # type: ignore [unused-ignore]\n        elif data.ndim != 3:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306f2\u6b21\u5143\u307e\u305f\u306f3\u6b21\u5143\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u5f62\u72b6: {data.shape}\"\n            )\n        if not data.shape[-2] == n_fft // 2 + 1:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u304c\u7121\u52b9\u3067\u3059\u3002\u5468\u6ce2\u6570\u30d3\u30f3\u6570\u306f {n_fft // 2 + 1} \u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\"  # noqa: E501\n            )\n\n        self.n_fft = n_fft\n        self.hop_length = hop_length\n        self.win_length = win_length if win_length is not None else n_fft\n        self.window = window\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def magnitude(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the magnitude spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The absolute values of the complex spectrogram.\n        \"\"\"\n        return np.abs(self.data)\n\n    @property\n    def phase(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the phase spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The phase angles of the complex spectrogram in radians.\n        \"\"\"\n        return np.angle(self.data)\n\n    @property\n    def power(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the power spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The squared magnitude of the complex spectrogram.\n        \"\"\"\n        return np.abs(self.data) ** 2\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrogram in decibels relative to each channel's reference value.\n\n        The reference value for each channel is specified in its metadata.\n        A minimum value of -120 dB is enforced to avoid numerical issues.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrogram in decibels.\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        ref = np.array([ch.ref for ch in self._channel_metadata])\n        # dB\u5909\u63db\n        # 0\u9664\u7b97\u3092\u907f\u3051\u308b\u305f\u3081\u306b\u3001\u6700\u5927\u5024\u30681e-12\u306e\u3044\u305a\u308c\u304b\u3092\u4f7f\u7528\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(self.magnitude / ref[..., np.newaxis, np.newaxis], 1e-12)\n        )\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrogram in decibels.\n\n        A-weighting applies a frequency-dependent weighting filter that approximates\n        the human ear's response. This is particularly useful for analyzing noise\n        and acoustic measurements.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrogram in decibels.\n        \"\"\"\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted[:, np.newaxis]  # \u5468\u6ce2\u6570\u8ef8\u306b\u6cbf\u3063\u3066\u30d6\u30ed\u30fc\u30c9\u30ad\u30e3\u30b9\u30c8\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels.\n        \"\"\"\n        return self.shape[0]\n\n    @property\n    def n_frames(self) -&gt; int:\n        \"\"\"\n        Get the number of time frames.\n\n        Returns\n        -------\n        int\n            The number of time frames in the spectrogram.\n        \"\"\"\n        return self.shape[-1]\n\n    @property\n    def n_freq_bins(self) -&gt; int:\n        \"\"\"\n        Get the number of frequency bins.\n\n        Returns\n        -------\n        int\n            The number of frequency bins (n_fft // 2 + 1).\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the frequency axis values in Hz.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of frequency values corresponding to each frequency bin.\n        \"\"\"\n        return np.fft.rfftfreq(self.n_fft, 1.0 / self.sampling_rate)\n\n    @property\n    def times(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the time axis values in seconds.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of time values corresponding to each time frame.\n        \"\"\"\n        return np.arange(self.n_frames) * self.hop_length / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Implementation of operation application for spectrogram data.\n\n        This internal method handles the application of various operations to\n        spectrogram data, maintaining lazy evaluation through dask.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters for the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from wandas.processing.time_series import create_operation\n\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        processed_data = operation.process(self._data)\n\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\n            \"SpectrogramFrame\",\n            int,\n            float,\n            complex,\n            NDArrayComplex,\n            NDArrayReal,\n            \"DaArray\",\n        ],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"\n        Common implementation for binary operations.\n\n        This method handles binary operations between\n        SpectrogramFrames and various types\n        of operands, maintaining lazy evaluation through dask arrays.\n\n        Parameters\n        ----------\n        other : Union[SpectrogramFrame, int, float, complex,\n            NDArrayComplex, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation (e.g., lambda a, b: a + b)\n        symbol : str\n            String representation of the operation (e.g., '+')\n\n        Returns\n        -------\n        SpectrogramFrame\n            A new SpectrogramFrame containing the result of the operation.\n\n        Raises\n        ------\n        ValueError\n            If attempting to operate with a SpectrogramFrame\n            with a different sampling rate.\n        \"\"\"\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        if isinstance(other, SpectrogramFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u304c\u4e00\u81f4\u3057\u3066\u3044\u307e\u305b\u3093\u3002\u6f14\u7b97\u3067\u304d\u307e\u305b\u3093\u3002\"\n                )\n\n            result_data = op(self._data, other._data)\n\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return SpectrogramFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                hop_length=self.hop_length,\n                win_length=self.win_length,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n        else:\n            result_data = op(self._data, other)\n\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, complex):\n                other_str = f\"complex({other.real}, {other.imag})\"\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return SpectrogramFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                hop_length=self.hop_length,\n                win_length=self.win_length,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n            )\n\n    def plot(\n        self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the spectrogram using various visualization strategies.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"spectrogram\"\n            Type of plot to create.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - vmin, vmax: Colormap scaling\n            - cmap: Colormap name\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectrogramFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def plot_Aw(  # noqa: N802\n        self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the A-weighted spectrogram.\n\n        A convenience method that calls plot() with Aw=True, applying A-weighting\n        to the spectrogram before plotting.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"spectrogram\"\n            Type of plot to create.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to plot().\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot.\n        \"\"\"\n        return self.plot(plot_type=plot_type, ax=ax, Aw=True, **kwargs)\n\n    def get_frame_at(self, time_idx: int) -&gt; \"SpectralFrame\":\n        \"\"\"\n        Extract spectral data at a specific time frame.\n\n        Parameters\n        ----------\n        time_idx : int\n            Index of the time frame to extract.\n\n        Returns\n        -------\n        SpectralFrame\n            A new SpectralFrame containing the spectral data at the specified time.\n\n        Raises\n        ------\n        IndexError\n            If time_idx is out of range.\n        \"\"\"\n        from wandas.frames.spectral import SpectralFrame\n\n        if time_idx &lt; 0 or time_idx &gt;= self.n_frames:\n            raise IndexError(\n                f\"\u6642\u9593\u30a4\u30f3\u30c7\u30c3\u30af\u30b9 {time_idx} \u304c\u7bc4\u56f2\u5916\u3067\u3059\u3002\u6709\u52b9\u7bc4\u56f2: 0-{self.n_frames - 1}\"  # noqa: E501\n            )\n\n        frame_data = self._data[..., time_idx]\n\n        return SpectralFrame(\n            data=frame_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=self.n_fft,\n            window=self.window,\n            label=f\"{self.label} (Frame {time_idx}, Time {self.times[time_idx]:.3f}s)\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def to_channel_frame(self) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Convert the spectrogram back to time domain using inverse STFT.\n\n        This method performs an inverse Short-Time Fourier Transform (ISTFT) to\n        reconstruct the time-domain signal from the spectrogram.\n\n        Returns\n        -------\n        ChannelFrame\n            A new ChannelFrame containing the reconstructed time-domain signal.\n        \"\"\"\n        from wandas.frames.channel import ChannelFrame\n        from wandas.processing.time_series import ISTFT, create_operation\n\n        params = {\n            \"n_fft\": self.n_fft,\n            \"hop_length\": self.hop_length,\n            \"win_length\": self.win_length,\n            \"window\": self.window,\n        }\n        operation_name = \"istft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"ISTFT\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        time_series = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n\n        # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        return ChannelFrame(\n            data=time_series,\n            sampling_rate=self.sampling_rate,\n            label=f\"istft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get additional initialization arguments for SpectrogramFrame.\n\n        This internal method provides the additional initialization arguments\n        required by SpectrogramFrame beyond those required by BaseFrame.\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments.\n        \"\"\"\n        return {\n            \"n_fft\": self.n_fft,\n            \"hop_length\": self.hop_length,\n            \"win_length\": self.win_length,\n            \"window\": self.window,\n        }\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrogram in decibels relative to each channel's reference value.</p> <p>The reference value for each channel is specified in its metadata. A minimum value of -120 dB is enforced to avoid numerical issues.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrogram in decibels.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrogram in decibels.</p> <p>A-weighting applies a frequency-dependent weighting filter that approximates the human ear's response. This is particularly useful for analyzing noise and acoustic measurements.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrogram in decibels.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the frequency axis values in Hz.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of frequency values corresponding to each frequency bin.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.magnitude","title":"<code>magnitude</code>  <code>property</code>","text":"<p>Get the magnitude spectrogram.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.magnitude--returns","title":"Returns","text":"<p>NDArrayReal     The absolute values of the complex spectrogram.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_frames","title":"<code>n_frames</code>  <code>property</code>","text":"<p>Get the number of time frames.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_frames--returns","title":"Returns","text":"<p>int     The number of time frames in the spectrogram.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_freq_bins","title":"<code>n_freq_bins</code>  <code>property</code>","text":"<p>Get the number of frequency bins.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_freq_bins--returns","title":"Returns","text":"<p>int     The number of frequency bins (n_fft // 2 + 1).</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.phase","title":"<code>phase</code>  <code>property</code>","text":"<p>Get the phase spectrogram.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.phase--returns","title":"Returns","text":"<p>NDArrayReal     The phase angles of the complex spectrogram in radians.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.power","title":"<code>power</code>  <code>property</code>","text":"<p>Get the power spectrogram.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.power--returns","title":"Returns","text":"<p>NDArrayReal     The squared magnitude of the complex spectrogram.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.times","title":"<code>times</code>  <code>property</code>","text":"<p>Get the time axis values in seconds.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.times--returns","title":"Returns","text":"<p>NDArrayReal     Array of time values corresponding to each time frame.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at","title":"<code>get_frame_at(time_idx)</code>","text":"<p>Extract spectral data at a specific time frame.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--parameters","title":"Parameters","text":"<p>time_idx : int     Index of the time frame to extract.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--returns","title":"Returns","text":"<p>SpectralFrame     A new SpectralFrame containing the spectral data at the specified time.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--raises","title":"Raises","text":"<p>IndexError     If time_idx is out of range.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def get_frame_at(self, time_idx: int) -&gt; \"SpectralFrame\":\n    \"\"\"\n    Extract spectral data at a specific time frame.\n\n    Parameters\n    ----------\n    time_idx : int\n        Index of the time frame to extract.\n\n    Returns\n    -------\n    SpectralFrame\n        A new SpectralFrame containing the spectral data at the specified time.\n\n    Raises\n    ------\n    IndexError\n        If time_idx is out of range.\n    \"\"\"\n    from wandas.frames.spectral import SpectralFrame\n\n    if time_idx &lt; 0 or time_idx &gt;= self.n_frames:\n        raise IndexError(\n            f\"\u6642\u9593\u30a4\u30f3\u30c7\u30c3\u30af\u30b9 {time_idx} \u304c\u7bc4\u56f2\u5916\u3067\u3059\u3002\u6709\u52b9\u7bc4\u56f2: 0-{self.n_frames - 1}\"  # noqa: E501\n        )\n\n    frame_data = self._data[..., time_idx]\n\n    return SpectralFrame(\n        data=frame_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=self.n_fft,\n        window=self.window,\n        label=f\"{self.label} (Frame {time_idx}, Time {self.times[time_idx]:.3f}s)\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot","title":"<code>plot(plot_type='spectrogram', ax=None, **kwargs)</code>","text":"<p>Plot the spectrogram using various visualization strategies.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"spectrogram\"     Type of plot to create. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - vmin, vmax: Colormap scaling     - cmap: Colormap name     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def plot(\n    self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the spectrogram using various visualization strategies.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"spectrogram\"\n        Type of plot to create.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - vmin, vmax: Colormap scaling\n        - cmap: Colormap name\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectrogramFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw","title":"<code>plot_Aw(plot_type='spectrogram', ax=None, **kwargs)</code>","text":"<p>Plot the A-weighted spectrogram.</p> <p>A convenience method that calls plot() with Aw=True, applying A-weighting to the spectrogram before plotting.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"spectrogram\"     Type of plot to create. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to plot().</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def plot_Aw(  # noqa: N802\n    self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the A-weighted spectrogram.\n\n    A convenience method that calls plot() with Aw=True, applying A-weighting\n    to the spectrogram before plotting.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"spectrogram\"\n        Type of plot to create.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to plot().\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot.\n    \"\"\"\n    return self.plot(plot_type=plot_type, ax=ax, Aw=True, **kwargs)\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.to_channel_frame","title":"<code>to_channel_frame()</code>","text":"<p>Convert the spectrogram back to time domain using inverse STFT.</p> <p>This method performs an inverse Short-Time Fourier Transform (ISTFT) to reconstruct the time-domain signal from the spectrogram.</p>"},{"location":"en/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.to_channel_frame--returns","title":"Returns","text":"<p>ChannelFrame     A new ChannelFrame containing the reconstructed time-domain signal.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def to_channel_frame(self) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Convert the spectrogram back to time domain using inverse STFT.\n\n    This method performs an inverse Short-Time Fourier Transform (ISTFT) to\n    reconstruct the time-domain signal from the spectrogram.\n\n    Returns\n    -------\n    ChannelFrame\n        A new ChannelFrame containing the reconstructed time-domain signal.\n    \"\"\"\n    from wandas.frames.channel import ChannelFrame\n    from wandas.processing.time_series import ISTFT, create_operation\n\n    params = {\n        \"n_fft\": self.n_fft,\n        \"hop_length\": self.hop_length,\n        \"win_length\": self.win_length,\n        \"window\": self.window,\n    }\n    operation_name = \"istft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"ISTFT\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    time_series = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n    )\n\n    # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    return ChannelFrame(\n        data=time_series,\n        sampling_rate=self.sampling_rate,\n        label=f\"istft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"en/api/frames/#noctframe","title":"NOctFrame","text":"<p><code>NOctFrame</code> is a frame that handles N-octave analysis data.</p> <pre><code>from wandas.frames.noct import NOctFrame\n\n# Or convert from ChannelFrame\nchannel_frame = wandas.read_wav(\"audio.wav\")\nnoct_frame = channel_frame.to_noct()\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Class for handling N-octave band analysis data.</p> <p>This class represents frequency data analyzed in fractional octave bands, typically used in acoustic and vibration analysis. It handles real-valued data representing energy or power in each frequency band, following standard acoustical band definitions.</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The N-octave band data. Must be a dask array with shape:     - (channels, frequency_bins) for multi-channel data     - (frequency_bins,) for single-channel data, which will be       reshaped to (1, frequency_bins) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. fmin : float, default=0     Lower frequency bound in Hz. fmax : float, default=0     Upper frequency bound in Hz. n : int, default=3     Number of bands per octave (e.g., 3 for third-octave bands). G : int, default=10     Reference band number according to IEC 61260-1:2014. fr : int, default=1000     Reference frequency in Hz, typically 1000 Hz for acoustic analysis. label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame--attributes","title":"Attributes","text":"<p>freqs : NDArrayReal     The center frequencies of each band in Hz, calculated according to     the standard fractional octave band definitions. dB : NDArrayReal     The spectrum in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrum in decibels, applying frequency weighting     for better correlation with perceived loudness. fmin : float     Lower frequency bound in Hz. fmax : float     Upper frequency bound in Hz. n : int     Number of bands per octave. G : int     Reference band number. fr : int     Reference frequency in Hz.</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame--examples","title":"Examples","text":"<p>Create an N-octave band spectrum from a time-domain signal:</p> <p>signal = ChannelFrame.from_wav(\"audio.wav\") spectrum = signal.noct_spectrum(fmin=20, fmax=20000, n=3)</p> <p>Plot the N-octave band spectrum:</p> <p>spectrum.plot()</p> <p>Plot with A-weighting applied:</p> <p>spectrum.plot(Aw=True)</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame--notes","title":"Notes","text":"<ul> <li>Binary operations (addition, multiplication, etc.) are not currently   supported for N-octave band data.</li> <li>The actual frequency bands are determined by the parameters n, G, and fr   according to IEC 61260-1:2014 standard for fractional octave band filters.</li> <li>The class follows acoustic standards for band definitions and analysis,   making it suitable for noise measurements and sound level analysis.</li> <li>A-weighting is available for better correlation with human hearing   perception, following IEC 61672-1:2013.</li> </ul> Source code in <code>wandas/frames/noct.py</code> <pre><code>class NOctFrame(BaseFrame[NDArrayReal]):\n    \"\"\"\n    Class for handling N-octave band analysis data.\n\n    This class represents frequency data analyzed in fractional octave bands,\n    typically used in acoustic and vibration analysis. It handles real-valued\n    data representing energy or power in each frequency band, following standard\n    acoustical band definitions.\n\n    Parameters\n    ----------\n    data : DaArray\n        The N-octave band data. Must be a dask array with shape:\n        - (channels, frequency_bins) for multi-channel data\n        - (frequency_bins,) for single-channel data, which will be\n          reshaped to (1, frequency_bins)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    fmin : float, default=0\n        Lower frequency bound in Hz.\n    fmax : float, default=0\n        Upper frequency bound in Hz.\n    n : int, default=3\n        Number of bands per octave (e.g., 3 for third-octave bands).\n    G : int, default=10\n        Reference band number according to IEC 61260-1:2014.\n    fr : int, default=1000\n        Reference frequency in Hz, typically 1000 Hz for acoustic analysis.\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    freqs : NDArrayReal\n        The center frequencies of each band in Hz, calculated according to\n        the standard fractional octave band definitions.\n    dB : NDArrayReal\n        The spectrum in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrum in decibels, applying frequency weighting\n        for better correlation with perceived loudness.\n    fmin : float\n        Lower frequency bound in Hz.\n    fmax : float\n        Upper frequency bound in Hz.\n    n : int\n        Number of bands per octave.\n    G : int\n        Reference band number.\n    fr : int\n        Reference frequency in Hz.\n\n    Examples\n    --------\n    Create an N-octave band spectrum from a time-domain signal:\n    &gt;&gt;&gt; signal = ChannelFrame.from_wav(\"audio.wav\")\n    &gt;&gt;&gt; spectrum = signal.noct_spectrum(fmin=20, fmax=20000, n=3)\n\n    Plot the N-octave band spectrum:\n    &gt;&gt;&gt; spectrum.plot()\n\n    Plot with A-weighting applied:\n    &gt;&gt;&gt; spectrum.plot(Aw=True)\n\n    Notes\n    -----\n    - Binary operations (addition, multiplication, etc.) are not currently\n      supported for N-octave band data.\n    - The actual frequency bands are determined by the parameters n, G, and fr\n      according to IEC 61260-1:2014 standard for fractional octave band filters.\n    - The class follows acoustic standards for band definitions and analysis,\n      making it suitable for noise measurements and sound level analysis.\n    - A-weighting is available for better correlation with human hearing\n      perception, following IEC 61672-1:2013.\n    \"\"\"\n\n    fmin: float\n    fmax: float\n    n: int\n    G: int\n    fr: int\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        fmin: float = 0,\n        fmax: float = 0,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a NOctFrame instance.\n\n        Sets up N-octave band analysis parameters and prepares the frame for\n        storing band-filtered data. Data shape is validated to ensure compatibility\n        with N-octave band analysis.\n\n        See class docstring for parameter descriptions.\n        \"\"\"\n        self.n = n\n        self.G = G\n        self.fr = fr\n        self.fmin = fmin\n        self.fmax = fmax\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrum in decibels relative to each channel's reference value.\n\n        The reference value for each channel is specified in its metadata.\n        A minimum value of -120 dB is enforced to avoid numerical issues.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrum in decibels. Shape matches the input data shape:\n            (channels, frequency_bins).\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        ref = np.array([ch.ref for ch in self._channel_metadata])\n        # dB\u5909\u63db\n        # 0\u9664\u7b97\u3092\u907f\u3051\u308b\u305f\u3081\u306b\u3001\u6700\u5927\u5024\u30681e-12\u306e\u3044\u305a\u308c\u304b\u3092\u4f7f\u7528\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(self.data / ref[..., np.newaxis], 1e-12)\n        )\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrum in decibels.\n\n        A-weighting applies a frequency-dependent weighting filter that approximates\n        the human ear's response to different frequencies. This is particularly useful\n        for analyzing noise and acoustic measurements as it provides a better\n        correlation with perceived loudness.\n\n        The weighting is applied according to IEC 61672-1:2013 standard.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrum in decibels. Shape matches the input data shape:\n            (channels, frequency_bins).\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels in the N-octave band data.\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the center frequencies of each band in Hz.\n\n        These frequencies are calculated based on the N-octave band parameters\n        (n, G, fr) and the frequency bounds (fmin, fmax) according to\n        IEC 61260-1:2014 standard for fractional octave band filters.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of center frequencies for each frequency band.\n\n        Raises\n        ------\n        ValueError\n            If the center frequencies cannot be calculated or the result\n            is not a numpy array.\n        \"\"\"\n        _, freqs = _center_freq(\n            fmax=self.fmax,\n            fmin=self.fmin,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        if isinstance(freqs, np.ndarray):\n            return freqs\n        else:\n            raise ValueError(\"freqs is not numpy array.\")\n\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"\n        Binary operations are not currently supported for N-octave band data.\n\n        Parameters\n        ----------\n        other : Union[S, int, float, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation.\n        symbol : str\n            String representation of the operation (e.g., '+', '-', '*', '/').\n\n        Raises\n        ------\n        NotImplementedError\n            Always raises this error as operations are not implemented\n            for N-octave band data.\n        \"\"\"\n        raise NotImplementedError(\n            f\"Operation {symbol} is not implemented for NOctFrame.\"\n        )\n        return self\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        \u9045\u5ef6\u8a55\u4fa1\u3092\u4f7f\u7528\u3057\u3066\u64cd\u4f5c\u3092\u9069\u7528\u3057\u307e\u3059\u3002\n        \"\"\"\n        # \u9045\u5ef6\u8a55\u4fa1\u3092\u4f7f\u7528\u3057\u3066\u64cd\u4f5c\u3092\u9069\u7528\n        raise NotImplementedError(\n            f\"Operation {operation_name} is not implemented for NOctFrame.\"\n        )\n        return self\n\n    def plot(\n        self, plot_type: str = \"noct\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the N-octave band data using various visualization strategies.\n\n        Supports standard plotting configurations for acoustic analysis,\n        including decibel scales and A-weighting.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"noct\"\n            Type of plot to create. The default \"noct\" type creates a bar plot\n            suitable for displaying N-octave band data.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n            - title: Plot title\n            - xlabel, ylabel: Axis labels\n            - xscale: Set to \"log\" for logarithmic frequency axis\n            - grid: Whether to show grid lines\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[NOctFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get additional initialization arguments for NOctFrame.\n\n        This internal method provides the additional initialization arguments\n        required by NOctFrame beyond those required by BaseFrame. These include\n        the N-octave band analysis parameters that define the frequency bands.\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments specific to NOctFrame:\n            - n: Number of bands per octave\n            - G: Reference band number\n            - fr: Reference frequency\n            - fmin: Lower frequency bound\n            - fmax: Upper frequency bound\n        \"\"\"\n        return {\n            \"n\": self.n,\n            \"G\": self.G,\n            \"fr\": self.fr,\n            \"fmin\": self.fmin,\n            \"fmax\": self.fmax,\n        }\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrum in decibels relative to each channel's reference value.</p> <p>The reference value for each channel is specified in its metadata. A minimum value of -120 dB is enforced to avoid numerical issues.</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrum in decibels. Shape matches the input data shape:     (channels, frequency_bins).</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrum in decibels.</p> <p>A-weighting applies a frequency-dependent weighting filter that approximates the human ear's response to different frequencies. This is particularly useful for analyzing noise and acoustic measurements as it provides a better correlation with perceived loudness.</p> <p>The weighting is applied according to IEC 61672-1:2013 standard.</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrum in decibels. Shape matches the input data shape:     (channels, frequency_bins).</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the center frequencies of each band in Hz.</p> <p>These frequencies are calculated based on the N-octave band parameters (n, G, fr) and the frequency bounds (fmin, fmax) according to IEC 61260-1:2014 standard for fractional octave band filters.</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of center frequencies for each frequency band.</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.freqs--raises","title":"Raises","text":"<p>ValueError     If the center frequencies cannot be calculated or the result     is not a numpy array.</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.__init__","title":"<code>__init__(data, sampling_rate, fmin=0, fmax=0, n=3, G=10, fr=1000, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a NOctFrame instance.</p> <p>Sets up N-octave band analysis parameters and prepares the frame for storing band-filtered data. Data shape is validated to ensure compatibility with N-octave band analysis.</p> <p>See class docstring for parameter descriptions.</p> Source code in <code>wandas/frames/noct.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    fmin: float = 0,\n    fmax: float = 0,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a NOctFrame instance.\n\n    Sets up N-octave band analysis parameters and prepares the frame for\n    storing band-filtered data. Data shape is validated to ensure compatibility\n    with N-octave band analysis.\n\n    See class docstring for parameter descriptions.\n    \"\"\"\n    self.n = n\n    self.G = G\n    self.fr = fr\n    self.fmin = fmin\n    self.fmax = fmax\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.plot","title":"<code>plot(plot_type='noct', ax=None, **kwargs)</code>","text":"<p>Plot the N-octave band data using various visualization strategies.</p> <p>Supports standard plotting configurations for acoustic analysis, including decibel scales and A-weighting.</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"noct\"     Type of plot to create. The default \"noct\" type creates a bar plot     suitable for displaying N-octave band data. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting     - title: Plot title     - xlabel, ylabel: Axis labels     - xscale: Set to \"log\" for logarithmic frequency axis     - grid: Whether to show grid lines</p>"},{"location":"en/api/frames/#wandas.frames.noct.NOctFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/noct.py</code> <pre><code>def plot(\n    self, plot_type: str = \"noct\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the N-octave band data using various visualization strategies.\n\n    Supports standard plotting configurations for acoustic analysis,\n    including decibel scales and A-weighting.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"noct\"\n        Type of plot to create. The default \"noct\" type creates a bar plot\n        suitable for displaying N-octave band data.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n        - title: Plot title\n        - xlabel, ylabel: Axis labels\n        - xscale: Set to \"log\" for logarithmic frequency axis\n        - grid: Whether to show grid lines\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[NOctFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"en/api/processing/","title":"Processing Module","text":"<p>This page explains the processing module of Wandas. The processing module provides various processing functions for time-series data.</p>"},{"location":"en/api/processing/#time-series-processing","title":"Time Series Processing","text":"<p>These are processing functions for time-series data. These functions are typically used through <code>ChannelFrame</code> methods.</p> <pre><code># Common usage\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")\nfiltered_frame = frame.filter(cutoff=1000, filter_type=\"lowpass\")\nresampled_frame = frame.resample(target_rate=16000)\n</code></pre>"},{"location":"en/api/processing/#key-processing-classes","title":"Key Processing Classes","text":"<p>The filtering and other signal processing functions are internally implemented by the following classes:</p> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>High-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HighPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"High-pass filter operation\"\"\"\n\n    name = \"highpass_filter\"\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize high-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            limit = self.sampling_rate / 2\n            raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up high-pass filter processor\"\"\"\n        # Calculate filter coefficients (once) - safely retrieve from instance variables\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"high\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Highpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying highpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Low-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class LowPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Low-pass filter operation\"\"\"\n\n    name = \"lowpass_filter\"\n    a: NDArrayReal\n    b: NDArrayReal\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize low-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            raise ValueError(\n                f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n            )\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up low-pass filter processor\"\"\"\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"low\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Lowpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying lowpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Resampling operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ReSampling(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Resampling operation\"\"\"\n\n    name = \"resampling\"\n\n    def __init__(self, sampling_rate: float, target_sr: float):\n        \"\"\"\n        Initialize resampling operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        target_sampling_rate : float\n            Target sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate, target_sr=target_sr)\n        self.target_sr = target_sr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after resampling\n        ratio = float(self.target_sr) / float(self.sampling_rate)\n        n_samples = int(np.ceil(input_shape[-1] * ratio))\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for resampling operation\"\"\"\n        logger.debug(f\"Applying resampling to array with shape: {x.shape}\")\n        result = librosa.resample(\n            x, orig_sr=self.sampling_rate, target_sr=self.target_sr\n        )\n        logger.debug(f\"Resampling applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>A-weighting filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AWeighting(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"A-weighting filter operation\"\"\"\n\n    name = \"a_weighting\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize A-weighting filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for A-weighting filter\"\"\"\n        logger.debug(f\"Applying A-weighting to array with shape: {x.shape}\")\n        result = A_weight(x, self.sampling_rate)\n\n        # Handle case where A_weight returns a tuple\n        if isinstance(result, tuple):\n            # Use the first element of the tuple\n            result = result[0]\n\n        logger.debug(\n            f\"A-weighting applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.HighPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize high-pass filter</p>"},{"location":"en/api/processing/#wandas.processing.time_series.HighPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize high-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.HighPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        limit = self.sampling_rate / 2\n        raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.LowPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize low-pass filter</p>"},{"location":"en/api/processing/#wandas.processing.time_series.LowPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize low-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.LowPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        raise ValueError(\n            f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n        )\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.ReSampling.__init__","title":"<code>__init__(sampling_rate, target_sr)</code>","text":"<p>Initialize resampling operation</p>"},{"location":"en/api/processing/#wandas.processing.time_series.ReSampling.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) target_sampling_rate : float     Target sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, target_sr: float):\n    \"\"\"\n    Initialize resampling operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    target_sampling_rate : float\n        Target sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate, target_sr=target_sr)\n    self.target_sr = target_sr\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.ReSampling.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"en/api/processing/#wandas.processing.time_series.ReSampling.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/api/processing/#wandas.processing.time_series.ReSampling.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after resampling\n    ratio = float(self.target_sr) / float(self.sampling_rate)\n    n_samples = int(np.ceil(input_shape[-1] * ratio))\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.AWeighting.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize A-weighting filter</p>"},{"location":"en/api/processing/#wandas.processing.time_series.AWeighting.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize A-weighting filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"en/api/processing/#audiooperation","title":"AudioOperation","text":"<p>The <code>AudioOperation</code> class enables abstraction and chaining of audio processing operations.</p> <pre><code>from wandas.processing.time_series import AudioOperation\n\n# Usage example\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")\n\n# Chain multiple processing steps\noperation = (\n    AudioOperation()\n    .add_step(\"filter\", cutoff=1000, filter_type=\"lowpass\")\n    .add_step(\"normalize\")\n)\n\n# Apply the processing\nprocessed_frame = operation.apply(frame)\n</code></pre> <p>               Bases: <code>Generic[InputArrayType, OutputArrayType]</code></p> <p>Abstract base class for audio processing operations.</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AudioOperation(Generic[InputArrayType, OutputArrayType]):\n    \"\"\"Abstract base class for audio processing operations.\"\"\"\n\n    # Class variable: operation name\n    name: ClassVar[str]\n\n    def __init__(self, sampling_rate: float, **params: Any):\n        \"\"\"\n        Initialize AudioOperation.\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        **params : Any\n            Operation-specific parameters\n        \"\"\"\n        self.sampling_rate = sampling_rate\n        self.params = params\n\n        # Validate parameters during initialization\n        self.validate_params()\n\n        # Create processor function (lazy initialization possible)\n        self._setup_processor()\n\n        logger.debug(\n            f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n        )\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n        pass\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up processor function (implemented by subclasses)\"\"\"\n        pass\n\n    def _process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function (implemented by subclasses)\"\"\"\n        # Default is no-op function\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    @dask.delayed  # type: ignore [misc, unused-ignore]\n    def process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n        # Default is no-op function\n        logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n        return self._process_array(x)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation (implemented by subclasses)\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        \"\"\"\n        Execute operation and return result\n        data shape is (channels, samples)\n        \"\"\"\n        # Add task as delayed processing\n        logger.debug(\"Adding delayed operation to computation graph\")\n        delayed_result = self.process_array(data)\n        # Convert delayed result to dask array and return\n        output_shape = self.calculate_output_shape(data.shape)\n        return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.AudioOperation.__init__","title":"<code>__init__(sampling_rate, **params)</code>","text":"<p>Initialize AudioOperation.</p>"},{"location":"en/api/processing/#wandas.processing.time_series.AudioOperation.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) **params : Any     Operation-specific parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, **params: Any):\n    \"\"\"\n    Initialize AudioOperation.\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    **params : Any\n        Operation-specific parameters\n    \"\"\"\n    self.sampling_rate = sampling_rate\n    self.params = params\n\n    # Validate parameters during initialization\n    self.validate_params()\n\n    # Create processor function (lazy initialization possible)\n    self._setup_processor()\n\n    logger.debug(\n        f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n    )\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.AudioOperation.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation (implemented by subclasses)</p>"},{"location":"en/api/processing/#wandas.processing.time_series.AudioOperation.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"en/api/processing/#wandas.processing.time_series.AudioOperation.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation (implemented by subclasses)\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.AudioOperation.process","title":"<code>process(data)</code>","text":"<p>Execute operation and return result data shape is (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    \"\"\"\n    Execute operation and return result\n    data shape is (channels, samples)\n    \"\"\"\n    # Add task as delayed processing\n    logger.debug(\"Adding delayed operation to computation graph\")\n    delayed_result = self.process_array(data)\n    # Convert delayed result to dask array and return\n    output_shape = self.calculate_output_shape(data.shape)\n    return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.AudioOperation.process_array","title":"<code>process_array(x)</code>","text":"<p>Processing function wrapped with @dask.delayed</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>@dask.delayed  # type: ignore [misc, unused-ignore]\ndef process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n    \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n    # Default is no-op function\n    logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n    return self._process_array(x)\n</code></pre>"},{"location":"en/api/processing/#wandas.processing.time_series.AudioOperation.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters (raises exception if invalid)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n    pass\n</code></pre>"},{"location":"en/explanation/","title":"Theory Background and Architecture","text":"<p>This section explains the design philosophy, internal architecture, and theoretical background used in the Wandas library.</p>"},{"location":"en/explanation/#design-philosophy","title":"Design Philosophy","text":"<p>Wandas is developed based on the following design principles:</p> <ol> <li>Intuitive API Design - Consistent interface that users can easily use</li> <li>Efficient Memory Usage - Memory-efficient implementation suitable for processing large-scale data</li> <li>Extensibility - Expandable architecture that makes it easy to add new features and algorithms</li> <li>Scientific Accuracy - Accurate implementation based on acoustic signal processing theory</li> </ol>"},{"location":"en/explanation/#core-architecture","title":"Core Architecture","text":""},{"location":"en/explanation/#data-model","title":"Data Model","text":"<p>The central data model of the Wandas library is hierarchically structured:</p> <pre><code>BaseChannel (base class)\n \u251c\u2500\u2500 Channel (time-domain signal)\n \u2502    \u2514\u2500\u2500 FrequencyChannel (frequency-domain signal)\n \u2502         \u2514\u2500\u2500 TimeFrequencyChannel (time-frequency domain signal)\n \u2514\u2500\u2500 ChannelFrame (container for multiple channels)\n      \u251c\u2500\u2500 FileFrame (file-based multiple channels)\n      \u2514\u2500\u2500 FrequencyChannelFrame (multiple channels in frequency domain)\n</code></pre> <p>Responsibilities of each class:</p> <ul> <li>BaseChannel: Base class for all channels. Provides basic functionality for data access and metadata management</li> <li>Channel: Implements time-domain signal data and processing methods</li> <li>FrequencyChannel: Implements FFT-based frequency-domain data and processing</li> <li>TimeFrequencyChannel: Implements time-frequency domain representations such as Short-Time Fourier Transform (STFT)</li> <li>ChannelFrame: Manages multiple channels and enables batch processing</li> </ul>"},{"location":"en/explanation/#data-processing-flow","title":"Data Processing Flow","text":"<ol> <li>Input Stage: Generate <code>Channel</code> or <code>ChannelFrame</code> objects from files such as WAV and CSV</li> <li>Processing Stage: Apply processing such as filtering and resampling</li> <li>Analysis Stage: Analyze signal characteristics (spectrum, level, etc.)</li> <li>Output Stage: Save processing results to files or visualize as graphs</li> </ol>"},{"location":"en/explanation/#implementation-details","title":"Implementation Details","text":""},{"location":"en/explanation/#memory-efficiency","title":"Memory Efficiency","text":"<p>Wandas ensures memory efficiency for handling large audio data through the following methods:</p> <ul> <li>Lazy Evaluation: A mechanism that delays calculations until needed</li> <li>Memory Mapping: Access to large files without loading them entirely into memory</li> <li>Dask and H5PY: Utilizing libraries suitable for large-scale data processing</li> </ul>"},{"location":"en/explanation/#signal-processing-algorithms","title":"Signal Processing Algorithms","text":"<p>Wandas implements signal processing algorithms such as:</p> <ul> <li>Digital Filters: IIR/FIR filters such as Butterworth filters</li> <li>Spectral Analysis: Frequency analysis based on Fast Fourier Transform (FFT)</li> <li>Time-Frequency Analysis: Short-Time Fourier Transform (STFT), spectrograms</li> <li>Statistical Analysis: Calculation of signal characteristics such as RMS, peak values, crest factor</li> </ul>"},{"location":"en/explanation/#performance-considerations","title":"Performance Considerations","text":"<p>Performance considerations when using Wandas:</p> <ul> <li>When processing large amounts of data, consider processing in chunks</li> <li>When building complex processing chains, improve performance by caching intermediate results</li> <li>Multi-channel processing efficiently utilizes multi-core processors</li> </ul>"},{"location":"en/explanation/#references","title":"References","text":"<ol> <li>Smith, J. O. (2011). Spectral Audio Signal Processing. W3K Publishing.</li> <li>M\u00fcller, M. (2015). Fundamentals of Music Processing: Audio, Analysis, Algorithms, Applications. Springer.</li> <li>Z\u00f6lzer, U. (2008). Digital Audio Signal Processing. Wiley.</li> </ol>"},{"location":"en/how_to/","title":"Cookbook (Use Case Recipes)","text":"<p>This section provides examples of various practical tasks using the Wandas library.</p>"},{"location":"en/how_to/#basic-audio-analysis","title":"Basic Audio Analysis","text":"<ul> <li>Get basic information from audio files</li> <li>Analyze the frequency spectrum of audio</li> <li>Measure volume characteristics such as RMS level and peak level</li> </ul>"},{"location":"en/how_to/#signal-processing","title":"Signal Processing","text":"<ul> <li>Apply low-pass/high-pass/band-pass filters</li> <li>Adjust the volume of specific frequency bands (equalizer)</li> <li>Perform noise reduction</li> <li>Change the pitch of audio</li> </ul>"},{"location":"en/how_to/#audio-data-manipulation","title":"Audio Data Manipulation","text":"<ul> <li>Concatenate multiple audio files</li> <li>Extract specific parts</li> <li>Apply fade-in/fade-out to audio</li> <li>Convert between different formats</li> </ul>"},{"location":"en/how_to/#special-effects","title":"Special Effects","text":"<ul> <li>Add reverb effects</li> <li>Add echo effects</li> <li>Apply distortion effects</li> </ul>"},{"location":"en/how_to/#advanced-applications","title":"Advanced Applications","text":"<ul> <li>Use as preprocessing for speech recognition</li> <li>Efficiently process large datasets</li> <li>Build real-time processing pipelines</li> </ul>"},{"location":"en/how_to/#adding-custom-processing","title":"Adding Custom Processing","text":"<ul> <li>Define your own filters</li> <li>Implement new processing functions</li> <li>Integrate wandas with other libraries</li> </ul> <p>Tip</p> <p>Each recipe is independent and can be referenced as needed. If you don't understand the basic usage, please see the Tutorial first.</p>"},{"location":"en/tutorial/","title":"Tutorial","text":"<p>This tutorial will teach you the basics of the Wandas library in 5 minutes.</p>"},{"location":"en/tutorial/#installation","title":"Installation","text":"<pre><code>pip install wandas\n</code></pre>"},{"location":"en/tutorial/#basic-usage","title":"Basic Usage","text":""},{"location":"en/tutorial/#1-import-the-library","title":"1. Import the Library","text":"<pre><code>import wandas as wd\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"en/tutorial/#2-load-audio-files","title":"2. Load Audio Files","text":"<pre><code># Load a WAV file\naudio = wd.io.read_wav(\"path/to/audio.wav\")\nprint(f\"Sampling rate: {audio.sampling_rate} Hz\")\nprint(f\"Number of channels: {len(audio)}\")\n</code></pre>"},{"location":"en/tutorial/#3-visualize-signals","title":"3. Visualize Signals","text":"<pre><code># Display waveform\naudio.plot()\nplt.show()\n</code></pre>"},{"location":"en/tutorial/#4-basic-signal-processing","title":"4. Basic Signal Processing","text":"<pre><code># Apply a low-pass filter (passing frequencies below 1kHz)\nfiltered = audio.filter(lowpass=1000)\n\n# Visualize and compare results\nfig, axes = plt.subplots(2, 1, figsize=(10, 6))\naudio.plot(ax=axes[0], title=\"Original Signal\")\nfiltered.plot(ax=axes[1], title=\"Filtered Signal\")\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"en/tutorial/#5-save-processing-results","title":"5. Save Processing Results","text":"<pre><code># Save the processed signal as a WAV file\nwd.io.write_wav(filtered, \"filtered_audio.wav\")\n</code></pre>"},{"location":"en/tutorial/#next-steps","title":"Next Steps","text":"<ul> <li>Check out various applications in the Cookbook</li> <li>Look up detailed functions in the API Reference</li> <li>Understand the library's design philosophy in the Theory Background</li> </ul>"},{"location":"ja/","title":"Wandas: Waveform Analysis Data Structures","text":"<p>Wandas \u306f\u3001Python\u306b\u3088\u308b\u52b9\u7387\u7684\u306a\u4fe1\u53f7\u89e3\u6790\u306e\u305f\u3081\u306e\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3059\u3002Wandas \u306f\u3001\u4fe1\u53f7\u51e6\u7406\u306e\u305f\u3081\u306e\u5305\u62ec\u7684\u306a\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u3001Matplotlib\u3068\u306e\u30b7\u30fc\u30e0\u30ec\u30b9\u306a\u7d71\u5408\u3092\u5b9f\u73fe\u3057\u3066\u3044\u307e\u3059\u3002</p>"},{"location":"ja/#_1","title":"\u6a5f\u80fd","text":"<ul> <li>\u5305\u62ec\u7684\u306a\u4fe1\u53f7\u51e6\u7406\u6a5f\u80fd: \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3001\u30d5\u30fc\u30ea\u30a8\u5909\u63db\u3001STFT\u306a\u3069\u3001\u57fa\u672c\u7684\u306a\u4fe1\u53f7\u51e6\u7406\u64cd\u4f5c\u3092\u7c21\u5358\u306b\u5b9f\u884c\u53ef\u80fd</li> <li>\u53ef\u8996\u5316\u30e9\u30a4\u30d6\u30e9\u30ea\u3068\u306e\u7d71\u5408: Matplotlib\u3068\u30b7\u30fc\u30e0\u30ec\u30b9\u306b\u7d71\u5408\u3057\u3066\u30c7\u30fc\u30bf\u3092\u7c21\u5358\u306b\u53ef\u8996\u5316\u53ef\u80fd</li> <li>\u9045\u5ef6\u8a55\u4fa1: dask\u3092\u6d3b\u7528\u3057\u305f\u52b9\u7387\u7684\u306a\u5927\u898f\u6a21\u30c7\u30fc\u30bf\u51e6\u7406</li> <li>\u591a\u69d8\u306a\u5206\u6790\u30c4\u30fc\u30eb: \u5468\u6ce2\u6570\u5206\u6790\u3001\u30aa\u30af\u30bf\u30fc\u30d6\u30d0\u30f3\u30c9\u5206\u6790\u3001\u6642\u9593-\u5468\u6ce2\u6570\u5206\u6790\u306a\u3069</li> </ul>"},{"location":"ja/#_2","title":"\u4f7f\u7528\u4f8b","text":""},{"location":"ja/#_3","title":"\u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\u3068\u53ef\u8996\u5316","text":"<pre><code>import wandas as wd\n\n# docs/docs/ja/index.md \u304b\u3089\u306e\u76f8\u5bfe\u30d1\u30b9\u3067\u30b5\u30f3\u30d7\u30eb\u30c7\u30fc\u30bf\u3092\u6307\u5b9a\n# \u5b9f\u969b\u306e\u4f7f\u7528\u6642\u306f\u9069\u5207\u306a\u30d1\u30b9\u306b\u5909\u66f4\u3057\u3066\u304f\u3060\u3055\u3044\n# cf = wd.read_wav(\"../../examples/data/summer_streets1.wav\")\n# cf.describe()\n</code></pre>"},{"location":"ja/#_4","title":"\u30d5\u30a3\u30eb\u30bf\u51e6\u7406","text":"<pre><code># import wandas as wd\n# import numpy as np\n# signal = wd.generate_sin(freqs=[5000, 1000], duration=1)\n# \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3092\u9069\u7528\n# filtered_signal = signal.low_pass_filter(cutoff=1000)\n# filtered_signal.fft().plot()\n</code></pre> <p>\u8a73\u7d30\u306a\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3084\u4f7f\u7528\u4f8b\u306b\u3064\u3044\u3066\u306f\u3001\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3084\u30af\u30c3\u30af\u30d6\u30c3\u30af\u3092\u3054\u89a7\u304f\u3060\u3055\u3044\u3002</p>"},{"location":"ja/#_5","title":"\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u69cb\u6210","text":"<ul> <li>\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb - 5\u5206\u3067\u59cb\u3081\u3089\u308c\u308b\u5165\u9580\u30ac\u30a4\u30c9</li> <li>\u30af\u30c3\u30af\u30d6\u30c3\u30af - \u4e00\u822c\u7684\u306a\u30bf\u30b9\u30af\u306e\u30ec\u30b7\u30d4\u96c6</li> <li>API\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9 - \u8a73\u7d30\u306aAPI\u4ed5\u69d8</li> <li>\u7406\u8ad6\u80cc\u666f/\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3 - \u8a2d\u8a08\u601d\u60f3\u3068\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u89e3\u8aac</li> <li>\u8ca2\u732e\u30ac\u30a4\u30c9 - \u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30b7\u30e7\u30f3\u306e\u30eb\u30fc\u30eb\u3068\u65b9\u6cd5</li> </ul>"},{"location":"ja/#_6","title":"\u30e9\u30a4\u30bb\u30f3\u30b9","text":"<p>\u3053\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306f MIT\u30e9\u30a4\u30bb\u30f3\u30b9 \u306e\u4e0b\u3067\u516c\u958b\u3055\u308c\u3066\u3044\u307e\u3059\u3002</p>"},{"location":"ja/contributing/","title":"\u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30b7\u30e7\u30f3\u30ac\u30a4\u30c9","text":"<p>Wandas\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3078\u306e\u8ca2\u732e\u306b\u8208\u5473\u3092\u6301\u3063\u3066\u3044\u305f\u3060\u304d\u3042\u308a\u304c\u3068\u3046\u3054\u3056\u3044\u307e\u3059\u3002\u3053\u306e\u30ac\u30a4\u30c9\u3067\u306f\u3001\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30c8\u3059\u308b\u65b9\u6cd5\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002</p>"},{"location":"ja/contributing/#_2","title":"\u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30b7\u30e7\u30f3\u306e\u7a2e\u985e","text":"<p>\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u5f62\u3067Wandas\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u8ca2\u732e\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff1a</p> <ul> <li>\u30d0\u30b0\u5831\u544a\u3084\u6a5f\u80fd\u30ea\u30af\u30a8\u30b9\u30c8</li> <li>\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306e\u6539\u5584</li> <li>\u30d0\u30b0\u4fee\u6b63</li> <li>\u65b0\u6a5f\u80fd\u306e\u5b9f\u88c5</li> <li>\u30c6\u30b9\u30c8\u306e\u8ffd\u52a0\u3084\u6539\u5584</li> <li>\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u306e\u6700\u9069\u5316</li> </ul>"},{"location":"ja/contributing/#_3","title":"\u958b\u767a\u74b0\u5883\u306e\u30bb\u30c3\u30c8\u30a2\u30c3\u30d7","text":""},{"location":"ja/contributing/#1","title":"1. \u30ea\u30dd\u30b8\u30c8\u30ea\u306e\u30af\u30ed\u30fc\u30f3","text":"<pre><code>git clone https://github.com/yourusername/wandas.git\ncd wandas\n</code></pre>"},{"location":"ja/contributing/#2","title":"2. \u4eee\u60f3\u74b0\u5883\u306e\u30bb\u30c3\u30c8\u30a2\u30c3\u30d7\u3068\u4f9d\u5b58\u95a2\u4fc2\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb","text":"<pre><code>python -m venv venv\nsource venv/bin/activate  # Windows\u306e\u5834\u5408: venv\\Scripts\\activate\npip install -e \".[dev]\"\n</code></pre>"},{"location":"ja/contributing/#_4","title":"\u958b\u767a\u30ef\u30fc\u30af\u30d5\u30ed\u30fc","text":""},{"location":"ja/contributing/#1_1","title":"1. \u65b0\u3057\u3044\u30d6\u30e9\u30f3\u30c1\u306e\u4f5c\u6210","text":"<p>\u65b0\u3057\u3044\u6a5f\u80fd\u3084\u30d0\u30b0\u4fee\u6b63\u306b\u306f\u3001\u65b0\u3057\u3044\u30d6\u30e9\u30f3\u30c1\u3092\u4f5c\u6210\u3057\u3066\u304f\u3060\u3055\u3044\uff1a</p> <pre><code>git checkout -b feature/your-feature-name\n# \u307e\u305f\u306f\ngit checkout -b fix/issue-description\n</code></pre>"},{"location":"ja/contributing/#2_1","title":"2. \u30b3\u30fc\u30c9\u30b9\u30bf\u30a4\u30eb","text":"<p>\u30b3\u30fc\u30c9\u306fPEP 8\u30b9\u30bf\u30a4\u30eb\u30ac\u30a4\u30c9\u306b\u5f93\u3063\u3066\u304f\u3060\u3055\u3044\u3002\u30b3\u30fc\u30c9\u306e\u54c1\u8cea\u3092\u78ba\u4fdd\u3059\u308b\u305f\u3081\u306b\u3001\u4ee5\u4e0b\u306e\u30c4\u30fc\u30eb\u3092\u4f7f\u7528\u3057\u3066\u3044\u307e\u3059\uff1a</p> <ul> <li>Ruff: \u30b3\u30fc\u30c9\u30ea\u30f3\u30bf\u30fc\u3068\u30d5\u30a9\u30fc\u30de\u30c3\u30bf\u30fc</li> <li>mypy: \u9759\u7684\u578b\u30c1\u30a7\u30c3\u30af</li> </ul> <p>\u30b3\u30fc\u30c9\u3092\u30b3\u30df\u30c3\u30c8\u3059\u308b\u524d\u306b\u3001\u4ee5\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u3066\u30b3\u30fc\u30c9\u30b9\u30bf\u30a4\u30eb\u3092\u30c1\u30a7\u30c3\u30af\u3057\u3066\u304f\u3060\u3055\u3044\uff1a</p> <pre><code># \u30ea\u30f3\u30c6\u30a3\u30f3\u30b0\nruff check wandas tests\n\n# \u578b\u30c1\u30a7\u30c3\u30af\nmypy wandas tests\n</code></pre>"},{"location":"ja/contributing/#3","title":"3. \u30c6\u30b9\u30c8","text":"<p>\u65b0\u3057\u3044\u6a5f\u80fd\u3084\u30d0\u30b0\u4fee\u6b63\u306b\u306f\u3001\u5fc5\u305a\u30c6\u30b9\u30c8\u3092\u8ffd\u52a0\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u30c6\u30b9\u30c8\u306f<code>pytest</code>\u3092\u4f7f\u7528\u3057\u3066\u5b9f\u884c\u3057\u307e\u3059\uff1a</p> <pre><code>pytest\n</code></pre> <p>\u30ab\u30d0\u30ec\u30c3\u30b8\u30ec\u30dd\u30fc\u30c8\u3092\u751f\u6210\u3059\u308b\u306b\u306f\uff1a</p> <pre><code>pytest --cov=wandas tests/\n</code></pre>"},{"location":"ja/contributing/#4","title":"4. \u30c9\u30ad\u30e5\u30e1\u30f3\u30c8","text":"<p>\u30b3\u30fc\u30c9\u306e\u5909\u66f4\u306b\u306f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306e\u66f4\u65b0\u304c\u5fc5\u8981\u3067\u3059\uff1a</p> <ul> <li>\u95a2\u6570\u3084\u30af\u30e9\u30b9\u306b\u306fNumPy\u5f62\u5f0f\u306edocstring\u3092\u8a18\u8ff0</li> <li>\u65b0\u3057\u3044\u6a5f\u80fd\u306b\u3064\u3044\u3066\u306f\u3001\u9069\u5207\u306a\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u30da\u30fc\u30b8\uff08\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3001\u30cf\u30a6\u30c4\u30fc\u3001API\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\uff09\u3092\u66f4\u65b0\u307e\u305f\u306f\u8ffd\u52a0</li> <li>\u5fc5\u8981\u306b\u5fdc\u3058\u3066\u3001<code>examples/</code>\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3092\u8ffd\u52a0</li> </ul> <p>\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3092\u30d3\u30eb\u30c9\u3057\u3066\u78ba\u8a8d\u3059\u308b\u306b\u306f\uff1a</p> <pre><code>cd docs\nmkdocs serve\n</code></pre> <p>\u305d\u306e\u5f8c\u3001\u30d6\u30e9\u30a6\u30b6\u3067 http://localhost:8000 \u306b\u30a2\u30af\u30bb\u30b9\u3057\u3066\u78ba\u8a8d\u3067\u304d\u307e\u3059\u3002</p>"},{"location":"ja/contributing/#5","title":"5. \u30d7\u30eb\u30ea\u30af\u30a8\u30b9\u30c8\u306e\u4f5c\u6210","text":"<p>\u5909\u66f4\u304c\u5b8c\u4e86\u3057\u305f\u3089\u3001\u30d7\u30eb\u30ea\u30af\u30a8\u30b9\u30c8\uff08PR\uff09\u3092\u4f5c\u6210\u3057\u3066\u304f\u3060\u3055\u3044\uff1a</p> <ol> <li> <p>\u5909\u66f4\u3092\u30b3\u30df\u30c3\u30c8\u3057\u3001\u30ea\u30e2\u30fc\u30c8\u30ea\u30dd\u30b8\u30c8\u30ea\u306b\u30d7\u30c3\u30b7\u30e5    <pre><code>git add .\ngit commit -m \"\u8aac\u660e\u7684\u306a\u30b3\u30df\u30c3\u30c8\u30e1\u30c3\u30bb\u30fc\u30b8\"\ngit push origin your-branch-name\n</code></pre></p> </li> <li> <p>GitHub\u30ea\u30dd\u30b8\u30c8\u30ea\u30da\u30fc\u30b8\u3067\u30d7\u30eb\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u4f5c\u6210</p> </li> <li>PR\u306e\u8aac\u660e\u306b\u306f\u3001\u5909\u66f4\u5185\u5bb9\u3001\u89e3\u6c7a\u3057\u305f\u554f\u984c\u3001\u30c6\u30b9\u30c8\u65b9\u6cd5\u306a\u3069\u3092\u8a18\u8f09</li> </ol>"},{"location":"ja/contributing/#_5","title":"\u30ec\u30d3\u30e5\u30fc\u30d7\u30ed\u30bb\u30b9","text":"<p>\u3059\u3079\u3066\u306ePR\u306f\u4ee5\u4e0b\u306e\u30d7\u30ed\u30bb\u30b9\u3067\u30ec\u30d3\u30e5\u30fc\u3055\u308c\u307e\u3059\uff1a</p> <ol> <li>\u81ea\u52d5CI\u30c6\u30b9\u30c8\u304c\u6210\u529f\u3059\u308b\u3053\u3068</li> <li>\u5c11\u306a\u304f\u3068\u30821\u4eba\u306e\u30e1\u30f3\u30c6\u30ca\u306b\u3088\u308b\u30b3\u30fc\u30c9\u30ec\u30d3\u30e5\u30fc</li> <li>\u5fc5\u8981\u306b\u5fdc\u3058\u3066\u5909\u66f4\u306e\u4f9d\u983c\u3068\u5bfe\u5fdc</li> <li>\u30de\u30fc\u30b8\u627f\u8a8d</li> </ol>"},{"location":"ja/contributing/#_6","title":"\u30b3\u30df\u30e5\u30cb\u30b1\u30fc\u30b7\u30e7\u30f3","text":"<p>\u8cea\u554f\u3084\u8b70\u8ad6\u304c\u3042\u308c\u3070\u3001\u4ee5\u4e0b\u306e\u65b9\u6cd5\u3067\u30b3\u30df\u30e5\u30cb\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u53d6\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff1a</p> <ul> <li>GitHub Issues: \u30d0\u30b0\u5831\u544a\u3084\u6a5f\u80fd\u30ea\u30af\u30a8\u30b9\u30c8</li> <li>GitHub Discussions: \u4e00\u822c\u7684\u306a\u8cea\u554f\u3084\u8b70\u8ad6</li> <li>\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306e\u30e1\u30fc\u30ea\u30f3\u30b0\u30ea\u30b9\u30c8\uff08\u3042\u308b\u5834\u5408\uff09</li> </ul>"},{"location":"ja/contributing/#_7","title":"\u884c\u52d5\u898f\u7bc4","text":"<p>\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u53c2\u52a0\u3059\u308b\u3059\u3079\u3066\u306e\u4eba\u306f\u3001\u884c\u52d5\u898f\u7bc4\u306b\u5f93\u3046\u3053\u3068\u304c\u671f\u5f85\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u4ed6\u306e\u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30bf\u30fc\u306b\u5bfe\u3057\u3066\u656c\u610f\u3092\u6301\u3063\u3066\u63a5\u3057\u3001\u5354\u529b\u7684\u3067\u5efa\u8a2d\u7684\u306a\u30b3\u30df\u30e5\u30cb\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u5fc3\u304c\u3051\u3066\u304f\u3060\u3055\u3044\u3002</p>"},{"location":"ja/api/","title":"API\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9","text":"<p>\u3053\u306e\u30bb\u30af\u30b7\u30e7\u30f3\u3067\u306f\u3001Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u5168\u3066\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3001\u30af\u30e9\u30b9\u3001\u30e1\u30bd\u30c3\u30c9\u306e\u8a73\u7d30\u306a\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u304b\u3089\u81ea\u52d5\u7684\u306b\u751f\u6210\u3055\u308c\u305f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3092\u542b\u3093\u3067\u3044\u307e\u3059\u3002</p>"},{"location":"ja/api/#_1","title":"\u30b3\u30a2\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8","text":""},{"location":"ja/api/#baseframe","title":"BaseFrame","text":"<p><code>BaseFrame</code>\u30af\u30e9\u30b9\u306fWandas\u306e\u57fa\u672c\u5358\u4f4d\u3068\u306a\u308b\u30c7\u30fc\u30bf\u69cb\u9020\u3067\u3059\u3002</p> <pre><code>from wandas.core.base_frame import BaseFrame\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for all signal frame types.</p> <p>This class provides the common interface and functionality for all frame types used in signal processing. It implements basic operations like indexing, iteration, and data manipulation that are shared across all frame types.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The signal data to process. Must be a dask array. sampling_rate : float     The sampling rate of the signal in Hz. label : str, optional     A label for the frame. If not provided, defaults to \"unnamed_frame\". metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame--attributes","title":"Attributes","text":"<p>sampling_rate : float     The sampling rate of the signal in Hz. label : str     The label of the frame. metadata : dict     Additional metadata for the frame. operation_history : list[dict]     History of operations performed on this frame.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>class BaseFrame(ABC, Generic[T]):\n    \"\"\"\n    Abstract base class for all signal frame types.\n\n    This class provides the common interface and functionality for all frame types\n    used in signal processing. It implements basic operations like indexing, iteration,\n    and data manipulation that are shared across all frame types.\n\n    Parameters\n    ----------\n    data : DaArray\n        The signal data to process. Must be a dask array.\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str, optional\n        A label for the frame. If not provided, defaults to \"unnamed_frame\".\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str\n        The label of the frame.\n    metadata : dict\n        Additional metadata for the frame.\n    operation_history : list[dict]\n        History of operations performed on this frame.\n    \"\"\"\n\n    _data: DaArray\n    sampling_rate: float\n    label: str\n    metadata: dict[str, Any]\n    operation_history: list[dict[str, Any]]\n    _channel_metadata: list[ChannelMetadata]\n    _previous: Optional[\"BaseFrame[Any]\"]\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ):\n        self._data = data.rechunk(chunks=-1)  # type: ignore [unused-ignore]\n        if self._data.ndim == 1:\n            self._data = self._data.reshape((1, -1))\n        self.sampling_rate = sampling_rate\n        self.label = label or \"unnamed_frame\"\n        self.metadata = metadata or {}\n        self.operation_history = operation_history or []\n        self._previous = previous\n\n        if channel_metadata:\n            self._channel_metadata = copy.deepcopy(channel_metadata)\n        else:\n            self._channel_metadata = [\n                ChannelMetadata(label=f\"ch{i}\", unit=\"\", extra={})\n                for i in range(self._n_channels)\n            ]\n\n        try:\n            # Display information for newer dask versions\n            logger.debug(f\"Dask graph layers: {list(self._data.dask.layers.keys())}\")\n            logger.debug(\n                f\"Dask graph dependencies: {len(self._data.dask.dependencies)}\"\n            )\n        except Exception as e:\n            logger.debug(f\"Dask graph visualization details unavailable: {e}\")\n\n    @property\n    @abstractmethod\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n\n    @property\n    def n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return len(self)\n\n    @property\n    def channels(self) -&gt; list[ChannelMetadata]:\n        \"\"\"Property to access channel metadata.\"\"\"\n        return self._channel_metadata\n\n    @property\n    def previous(self) -&gt; Optional[\"BaseFrame[Any]\"]:\n        \"\"\"\n        Returns the previous frame.\n        \"\"\"\n        return self._previous\n\n    def get_channel(self: S, channel_idx: int) -&gt; S:\n        n_channels = len(self)\n        if channel_idx &lt; 0 or channel_idx &gt;= n_channels:\n            range_max = n_channels - 1\n            raise ValueError(\n                f\"Channel index out of range: {channel_idx} \"\n                f\"(valid range: 0-{range_max})\"\n            )\n        logger.debug(f\"Extracting channel index={channel_idx} (lazy operation).\")\n        channel_data = self._data[channel_idx : channel_idx + 1]\n\n        return self._create_new_instance(\n            data=channel_data,\n            operation_history=self.operation_history,\n            channel_metadata=[self._channel_metadata[channel_idx]],\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Returns the number of channels.\n        \"\"\"\n        return len(self._channel_metadata)\n\n    def __iter__(self: S) -&gt; Iterator[S]:\n        for idx in range(len(self)):\n            yield self[idx]\n\n    def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n        \"\"\"\n        Method to get a channel by name or index.\n\n        Parameters\n        ----------\n        key : str, int, slice, or tuple of slices\n            Channel name (label) or index number.\n\n        Returns\n        -------\n        BaseFrame\n            The corresponding channel.\n\n        Raises\n        ------\n        ValueError\n            If the key length is invalid for the shape.\n        IndexError\n            If the channel index is out of range.\n        TypeError\n            If the key type is invalid.\n        \"\"\"\n        if isinstance(key, str):\n            index = self.label2index(key)\n            return self.get_channel(index)\n\n        elif isinstance(key, tuple):\n            # When key is a tuple, treat the first element as an index\n            if len(key) &gt; len(self.shape):\n                raise ValueError(\n                    f\"Invalid key length: {len(key)} for shape {self.shape}\"\n                )\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key[0]]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, slice):\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, numbers.Integral):\n            # Access by index number\n            if key &lt; 0 or key &gt;= len(self):\n                raise IndexError(f\"Channel index {key} out of range.\")\n            return self.get_channel(key)\n        else:\n            raise TypeError(\n                f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n            )\n\n    def label2index(self, label: str) -&gt; int:\n        \"\"\"\n        Get the index from a channel label.\n\n        Parameters\n        ----------\n        label : str\n            Channel label.\n\n        Returns\n        -------\n        int\n            Corresponding index.\n\n        Raises\n        ------\n        KeyError\n            If the channel label is not found.\n        \"\"\"\n        for idx, ch in enumerate(self._channel_metadata):\n            if ch.label == label:\n                return idx\n        raise KeyError(f\"Channel label '{label}' not found.\")\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        _shape: tuple[int, ...] = self._data.shape\n        return _shape\n\n    @property\n    def data(self) -&gt; T:\n        \"\"\"\n        Returns the computed data.\n        Calculation is executed the first time this is accessed.\n        \"\"\"\n        return self.compute()\n\n    @property\n    def labels(self) -&gt; list[str]:\n        \"\"\"Get a list of all channel labels.\"\"\"\n        return [ch.label for ch in self._channel_metadata]\n\n    def compute(self) -&gt; T:\n        \"\"\"\n        Compute and return the data.\n        This method materializes lazily computed data into a concrete NumPy array.\n\n        Returns\n        -------\n        NDArrayReal\n            The computed data.\n\n        Raises\n        ------\n        ValueError\n            If the computed result is not a NumPy array.\n        \"\"\"\n        logger.debug(\n            \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n        )\n        result = self._data.compute()\n\n        if not isinstance(result, np.ndarray):\n            raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n        logger.debug(f\"Computation complete, result shape: {result.shape}\")\n        return cast(T, result)\n\n    @abstractmethod\n    def plot(\n        self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n    ) -&gt; Union[Axes, Iterator[Axes]]:\n        \"\"\"Plot the data\"\"\"\n        pass\n\n    def persist(self: S) -&gt; S:\n        \"\"\"Persist the data in memory\"\"\"\n        persisted_data = self._data.persist()\n        return self._create_new_instance(data=persisted_data)\n\n    @abstractmethod\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Abstract method for derived classes to provide\n        additional initialization arguments.\n        \"\"\"\n        pass\n\n    def _create_new_instance(self: S, data: DaArray, **kwargs: Any) -&gt; S:\n        \"\"\"\n        Create a new channel instance based on an existing channel.\n        Keyword arguments can override or extend the original attributes.\n        \"\"\"\n\n        sampling_rate = kwargs.pop(\"sampling_rate\", self.sampling_rate)\n        # if not isinstance(sampling_rate, int):\n        #     raise TypeError(\"Sampling rate must be an integer\")\n\n        label = kwargs.pop(\"label\", self.label)\n        if not isinstance(label, str):\n            raise TypeError(\"Label must be a string\")\n\n        metadata = kwargs.pop(\"metadata\", copy.deepcopy(self.metadata))\n        if not isinstance(metadata, dict):\n            raise TypeError(\"Metadata must be a dictionary\")\n\n        # Get additional initialization arguments from derived classes\n        additional_kwargs = self._get_additional_init_kwargs()\n        kwargs.update(additional_kwargs)\n\n        return type(self)(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            previous=self,\n            **kwargs,\n        )\n\n    def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n        \"\"\"Implicit conversion to NumPy array\"\"\"\n        result = self.compute()\n        if dtype is not None:\n            return result.astype(dtype)\n        return result\n\n    def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n        \"\"\"Visualize the computation graph and save it to a file\"\"\"\n        try:\n            filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n            self._data.visualize(filename=filename)\n            return filename\n        except Exception as e:\n            logger.warning(f\"Failed to visualize the graph: {e}\")\n            return None\n\n    @abstractmethod\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"Basic implementation of binary operations\"\"\"\n        # Basic logic\n        # Actual implementation is left to derived classes\n        pass\n\n    def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Addition operator\"\"\"\n        return self._binary_op(other, lambda x, y: x + y, \"+\")\n\n    def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Subtraction operator\"\"\"\n        return self._binary_op(other, lambda x, y: x - y, \"-\")\n\n    def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Multiplication operator\"\"\"\n        return self._binary_op(other, lambda x, y: x * y, \"*\")\n\n    def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Division operator\"\"\"\n        return self._binary_op(other, lambda x, y: x / y, \"/\")\n\n    def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Apply a named operation.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters to pass to the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        # Apply the operation through abstract method\n        return self._apply_operation_impl(operation_name, **params)\n\n    @abstractmethod\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"Implementation of operation application\"\"\"\n        pass\n\n    def debug_info(self) -&gt; None:\n        \"\"\"Output detailed debug information\"\"\"\n        logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n        logger.debug(f\"Label: {self.label}\")\n        logger.debug(f\"Shape: {self.shape}\")\n        logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n        logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n        self._debug_info_impl()\n        logger.debug(\"=== End Debug Info ===\")\n\n    def _debug_info_impl(self) -&gt; None:\n        \"\"\"Implement derived class-specific debug information\"\"\"\n        pass\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.channels","title":"<code>channels</code>  <code>property</code>","text":"<p>Property to access channel metadata.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.data","title":"<code>data</code>  <code>property</code>","text":"<p>Returns the computed data. Calculation is executed the first time this is accessed.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>Get a list of all channel labels.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.n_channels","title":"<code>n_channels</code>  <code>property</code>","text":"<p>Returns the number of channels.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.previous","title":"<code>previous</code>  <code>property</code>","text":"<p>Returns the previous frame.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__add__","title":"<code>__add__(other)</code>","text":"<p>Addition operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Addition operator\"\"\"\n    return self._binary_op(other, lambda x, y: x + y, \"+\")\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__array__","title":"<code>__array__(dtype=None)</code>","text":"<p>Implicit conversion to NumPy array</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n    \"\"\"Implicit conversion to NumPy array\"\"\"\n    result = self.compute()\n    if dtype is not None:\n        return result.astype(dtype)\n    return result\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Method to get a channel by name or index.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__getitem__--parameters","title":"Parameters","text":"<p>key : str, int, slice, or tuple of slices     Channel name (label) or index number.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__getitem__--returns","title":"Returns","text":"<p>BaseFrame     The corresponding channel.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__getitem__--raises","title":"Raises","text":"<p>ValueError     If the key length is invalid for the shape. IndexError     If the channel index is out of range. TypeError     If the key type is invalid.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n    \"\"\"\n    Method to get a channel by name or index.\n\n    Parameters\n    ----------\n    key : str, int, slice, or tuple of slices\n        Channel name (label) or index number.\n\n    Returns\n    -------\n    BaseFrame\n        The corresponding channel.\n\n    Raises\n    ------\n    ValueError\n        If the key length is invalid for the shape.\n    IndexError\n        If the channel index is out of range.\n    TypeError\n        If the key type is invalid.\n    \"\"\"\n    if isinstance(key, str):\n        index = self.label2index(key)\n        return self.get_channel(index)\n\n    elif isinstance(key, tuple):\n        # When key is a tuple, treat the first element as an index\n        if len(key) &gt; len(self.shape):\n            raise ValueError(\n                f\"Invalid key length: {len(key)} for shape {self.shape}\"\n            )\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key[0]]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, slice):\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, numbers.Integral):\n        # Access by index number\n        if key &lt; 0 or key &gt;= len(self):\n            raise IndexError(f\"Channel index {key} out of range.\")\n        return self.get_channel(key)\n    else:\n        raise TypeError(\n            f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n        )\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of channels.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of channels.\n    \"\"\"\n    return len(self._channel_metadata)\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplication operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Multiplication operator\"\"\"\n    return self._binary_op(other, lambda x, y: x * y, \"*\")\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtraction operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Subtraction operator\"\"\"\n    return self._binary_op(other, lambda x, y: x - y, \"-\")\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Division operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Division operator\"\"\"\n    return self._binary_op(other, lambda x, y: x / y, \"/\")\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.apply_operation","title":"<code>apply_operation(operation_name, **params)</code>","text":"<p>Apply a named operation.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.apply_operation--parameters","title":"Parameters","text":"<p>operation_name : str     Name of the operation to apply. **params : Any     Parameters to pass to the operation.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.apply_operation--returns","title":"Returns","text":"<p>S     A new instance with the operation applied.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n    \"\"\"\n    Apply a named operation.\n\n    Parameters\n    ----------\n    operation_name : str\n        Name of the operation to apply.\n    **params : Any\n        Parameters to pass to the operation.\n\n    Returns\n    -------\n    S\n        A new instance with the operation applied.\n    \"\"\"\n    # Apply the operation through abstract method\n    return self._apply_operation_impl(operation_name, **params)\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.compute","title":"<code>compute()</code>","text":"<p>Compute and return the data. This method materializes lazily computed data into a concrete NumPy array.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.compute--returns","title":"Returns","text":"<p>NDArrayReal     The computed data.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.compute--raises","title":"Raises","text":"<p>ValueError     If the computed result is not a NumPy array.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def compute(self) -&gt; T:\n    \"\"\"\n    Compute and return the data.\n    This method materializes lazily computed data into a concrete NumPy array.\n\n    Returns\n    -------\n    NDArrayReal\n        The computed data.\n\n    Raises\n    ------\n    ValueError\n        If the computed result is not a NumPy array.\n    \"\"\"\n    logger.debug(\n        \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n    )\n    result = self._data.compute()\n\n    if not isinstance(result, np.ndarray):\n        raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n    logger.debug(f\"Computation complete, result shape: {result.shape}\")\n    return cast(T, result)\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.debug_info","title":"<code>debug_info()</code>","text":"<p>Output detailed debug information</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def debug_info(self) -&gt; None:\n    \"\"\"Output detailed debug information\"\"\"\n    logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n    logger.debug(f\"Label: {self.label}\")\n    logger.debug(f\"Shape: {self.shape}\")\n    logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n    logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n    self._debug_info_impl()\n    logger.debug(\"=== End Debug Info ===\")\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.label2index","title":"<code>label2index(label)</code>","text":"<p>Get the index from a channel label.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.label2index--parameters","title":"Parameters","text":"<p>label : str     Channel label.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.label2index--returns","title":"Returns","text":"<p>int     Corresponding index.</p>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.label2index--raises","title":"Raises","text":"<p>KeyError     If the channel label is not found.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def label2index(self, label: str) -&gt; int:\n    \"\"\"\n    Get the index from a channel label.\n\n    Parameters\n    ----------\n    label : str\n        Channel label.\n\n    Returns\n    -------\n    int\n        Corresponding index.\n\n    Raises\n    ------\n    KeyError\n        If the channel label is not found.\n    \"\"\"\n    for idx, ch in enumerate(self._channel_metadata):\n        if ch.label == label:\n            return idx\n    raise KeyError(f\"Channel label '{label}' not found.\")\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.persist","title":"<code>persist()</code>","text":"<p>Persist the data in memory</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def persist(self: S) -&gt; S:\n    \"\"\"Persist the data in memory\"\"\"\n    persisted_data = self._data.persist()\n    return self._create_new_instance(data=persisted_data)\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.plot","title":"<code>plot(plot_type='default', ax=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Plot the data</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>@abstractmethod\ndef plot(\n    self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n) -&gt; Union[Axes, Iterator[Axes]]:\n    \"\"\"Plot the data\"\"\"\n    pass\n</code></pre>"},{"location":"ja/api/#wandas.core.base_frame.BaseFrame.visualize_graph","title":"<code>visualize_graph(filename=None)</code>","text":"<p>Visualize the computation graph and save it to a file</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"Visualize the computation graph and save it to a file\"\"\"\n    try:\n        filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n        self._data.visualize(filename=filename)\n        return filename\n    except Exception as e:\n        logger.warning(f\"Failed to visualize the graph: {e}\")\n        return None\n</code></pre>"},{"location":"ja/api/#_2","title":"\u30d5\u30ec\u30fc\u30e0\u30e2\u30b8\u30e5\u30fc\u30eb","text":""},{"location":"ja/api/#channelframe","title":"ChannelFrame","text":"<p><code>ChannelFrame</code>\u306f\u6642\u9593\u9818\u57df\u306e\u4fe1\u53f7\u30c7\u30fc\u30bf\u3092\u6271\u3046\u30af\u30e9\u30b9\u3067\u3059\u3002</p> <pre><code>from wandas.frames.channel import ChannelFrame\n</code></pre> <p>\u307e\u305f\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u76f4\u63a5\u30a4\u30f3\u30dd\u30fc\u30c8\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059\uff1a</p> <pre><code>import wandas\n# \u4ee5\u4e0b\u306e\u3088\u3046\u306b\u4f7f\u7528\u3067\u304d\u307e\u3059\nframe = wandas.read_wav(\"audio.wav\")\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Channel-based data frame for handling audio signals and time series data.</p> <p>This frame represents channel-based data such as audio signals and time series data, with each channel containing data samples in the time domain.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>class ChannelFrame(BaseFrame[NDArrayReal]):\n    \"\"\"Channel-based data frame for handling audio signals and time series data.\n\n    This frame represents channel-based data such as audio signals and time series data,\n    with each channel containing data samples in the time domain.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"Initialize a ChannelFrame.\n\n        Args:\n            data: Dask array containing channel data.\n            Shape should be (n_channels, n_samples).\n            sampling_rate: The sampling rate of the data in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            operation_history: History of operations applied to the frame.\n            channel_metadata: Metadata for each channel.\n            previous: Reference to the previous frame in the processing chain.\n\n        Raises:\n            ValueError: If data has more than 2 dimensions.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return self.shape[-2]\n\n    @property\n    def time(self) -&gt; NDArrayReal:\n        \"\"\"Get time array for the signal.\n\n        Returns:\n            Array of time points in seconds.\n        \"\"\"\n        return np.arange(self.n_samples) / self.sampling_rate\n\n    @property\n    def n_samples(self) -&gt; int:\n        \"\"\"Returns the number of samples.\"\"\"\n        n: int = self._data.shape[-1]\n        return n\n\n    @property\n    def duration(self) -&gt; float:\n        \"\"\"Returns the duration in seconds.\"\"\"\n        return self.n_samples / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # Apply processing to data\n        processed_data = operation.process(self._data)\n\n        # Update metadata\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        if operation_name == \"resampling\":\n            # For resampling, update sampling rate\n            return self._create_new_instance(\n                sampling_rate=params[\"target_sr\"],\n                data=processed_data,\n                metadata=new_metadata,\n                operation_history=new_history,\n            )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Common implementation for binary operations\n        - utilizing dask's lazy evaluation.\n\n        Args:\n            other: Right operand for the operation.\n            op: Function to execute the operation (e.g., lambda a, b: a + b).\n            symbol: Symbolic representation of the operation (e.g., '+').\n\n        Returns:\n            A new channel containing the operation result (lazy execution).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, ChannelFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Perform operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other._data)\n\n            # Merge channel metadata\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # Perform operation with scalar, NumPy array, or other types\n        else:\n            # Apply operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other)\n\n            # Operand display string\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # Check for dask.array.Array\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # Update channel metadata\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n                previous=self,\n            )\n\n    def add(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        snr: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Add another signal or value to the current signal.\n\n        If SNR is specified, performs addition with consideration for\n        signal-to-noise ratio.\n\n        Args:\n            other: Signal or value to add.\n            snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n                other signal based on this SNR.\n                self is treated as the signal, and other as the noise.\n\n        Returns:\n            A new channel frame containing the addition result (lazy execution).\n        \"\"\"\n        logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n        # Special processing when SNR is specified\n        if snr is not None:\n            # First convert other to ChannelFrame if it's not\n            if not isinstance(other, ChannelFrame):\n                if isinstance(other, np.ndarray):\n                    other = ChannelFrame.from_numpy(\n                        other, self.sampling_rate, label=\"array_data\"\n                    )\n                elif isinstance(other, (int, float)):\n                    # For scalar values, simply add (ignore SNR)\n                    return self + other\n                else:\n                    raise TypeError(\n                        \"Addition target with SNR must be a ChannelFrame or \"\n                        f\"NumPy array: {type(other)}\"\n                    )\n\n            # Check if sampling rates match\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Apply addition operation with SNR adjustment\n            return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n        # Execute normal addition if SNR is not specified\n        return self + other\n\n    def plot(\n        self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Plot the frame data.\n\n        Args:\n            plot_type: Type of plot. Default is \"waveform\".\n            ax: Optional matplotlib axes for plotting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        plot_strategy = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def rms_plot(\n        self,\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = True,\n        Aw: bool = False,  # noqa: N803\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Generate an RMS plot.\n\n        Args:\n            ax: Optional matplotlib axes for plotting.\n            title: Title for the plot.\n            overlay: Whether to overlay the plot on the existing axis.\n            Aw: Apply A-weighting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        kwargs = kwargs or {}\n        ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n        rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n        return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n\n    def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n        \"\"\"Display visual and audio representation of the frame.\n\n        Args:\n            normalize: Whether to normalize the audio data for playback.\n            **kwargs: Additional parameters for visualization.\n        \"\"\"\n        if \"axis_config\" in kwargs:\n            logger.warning(\n                \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            axis_config = kwargs[\"axis_config\"]\n            if \"time_plot\" in axis_config:\n                kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n            if \"freq_plot\" in axis_config:\n                if \"xlim\" in axis_config[\"freq_plot\"]:\n                    vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                    kwargs[\"vmin\"] = vlim[0]\n                    kwargs[\"vmax\"] = vlim[1]\n                if \"ylim\" in axis_config[\"freq_plot\"]:\n                    ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                    kwargs[\"ylim\"] = ylim\n\n        if \"cbar_config\" in kwargs:\n            logger.warning(\n                \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            cbar_config = kwargs[\"cbar_config\"]\n            if \"vmin\" in cbar_config:\n                kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n            if \"vmax\" in cbar_config:\n                kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n        for ch in self:\n            ax: Axes\n            _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n            if isinstance(_ax, Iterator):\n                ax = next(iter(_ax))\n            elif isinstance(_ax, Axes):\n                ax = _ax\n            else:\n                raise TypeError(\n                    f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n                )\n            # Ignore type checks for display and Audio\n            display(ax.figure)  # type: ignore\n            plt.close(ax.figure)  # type: ignore\n            display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n\n    @classmethod\n    def from_numpy(\n        cls,\n        data: NDArrayReal,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        ch_labels: Optional[list[str]] = None,\n        ch_units: Optional[Union[list[str], str]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        Args:\n            data: NumPy array containing channel data.\n            sampling_rate: The sampling rate in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            ch_labels: Labels for each channel.\n            ch_units: Units for each channel.\n\n        Returns:\n            A new ChannelFrame containing the NumPy data.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n\n        # Convert NumPy array to dask array\n        dask_data = da_from_array(data)\n        cf = ChannelFrame(\n            data=dask_data,\n            sampling_rate=sampling_rate,\n            label=label or \"numpy_data\",\n        )\n        if metadata is not None:\n            cf.metadata = metadata\n        if ch_labels is not None:\n            if len(ch_labels) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel labels does not match the number of channels\"\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        if ch_units is not None:\n            if isinstance(ch_units, str):\n                ch_units = [ch_units] * cf.n_channels\n\n            if len(ch_units) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel units does not match the number of channels\"\n                )\n            for i in range(len(ch_units)):\n                cf._channel_metadata[i].unit = ch_units[i]\n\n        return cf\n\n    @classmethod\n    def from_ndarray(\n        cls,\n        array: NDArrayReal,\n        sampling_rate: float,\n        labels: Optional[list[str]] = None,\n        unit: Optional[Union[list[str], str]] = None,\n        frame_label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        This method is deprecated. Use from_numpy instead.\n\n        Args:\n            array: Signal data. Each row corresponds to a channel.\n            sampling_rate: Sampling rate (Hz).\n            labels: Labels for each channel.\n            unit: Unit of the signal.\n            frame_label: Label for the frame.\n            metadata: Optional metadata dictionary.\n\n        Returns:\n            A new ChannelFrame containing the data.\n        \"\"\"\n        # Redirect to from_numpy for compatibility\n        # However, from_ndarray is deprecated\n        logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n        return cls.from_numpy(\n            data=array,\n            sampling_rate=sampling_rate,\n            label=frame_label,\n            metadata=metadata,\n            ch_labels=labels,\n            ch_units=unit,\n        )\n\n    @classmethod\n    def from_file(\n        cls,\n        path: Union[str, Path],\n        channel: Optional[Union[int, list[int]]] = None,\n        start: Optional[float] = None,\n        end: Optional[float] = None,\n        chunk_size: Optional[int] = None,\n        ch_labels: Optional[list[str]] = None,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from an audio file.\n\n        Args:\n            path: Path to the audio file.\n            channel: Channel(s) to load.\n            start: Start time in seconds.\n            end: End time in seconds.\n            chunk_size: Chunk size for processing.\n            Specifies the splitting size for lazy processing.\n            ch_labels: Labels for each channel.\n            **kwargs: Additional arguments passed to the file reader.\n\n        Returns:\n            A new ChannelFrame containing the loaded audio data.\n\n        Raises:\n            ValueError: If channel selection is invalid.\n            TypeError: If channel parameter type is invalid.\n            FileNotFoundError: If the file doesn't exist.\n        \"\"\"\n        from .channel import ChannelFrame\n\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"File not found: {path}\")\n\n        # Get file reader\n        reader = get_file_reader(path)\n\n        # Get file info\n        info = reader.get_file_info(path, **kwargs)\n        sr = info[\"samplerate\"]\n        n_channels = info[\"channels\"]\n        n_frames = info[\"frames\"]\n        ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n        logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n        # Channel selection processing\n        all_channels = list(range(n_channels))\n\n        if channel is None:\n            channels_to_load = all_channels\n            logger.debug(f\"Will load all channels: {channels_to_load}\")\n        elif isinstance(channel, int):\n            if channel &lt; 0 or channel &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n            channels_to_load = [channel]\n            logger.debug(f\"Will load single channel: {channel}\")\n        elif isinstance(channel, (list, tuple)):\n            for ch in channel:\n                if ch &lt; 0 or ch &gt;= n_channels:\n                    raise ValueError(\n                        f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                    )\n            channels_to_load = list(channel)\n            logger.debug(f\"Will load specific channels: {channels_to_load}\")\n        else:\n            raise TypeError(\"channel must be int, list, or None\")\n\n        # Index calculation\n        start_idx = 0 if start is None else max(0, int(start * sr))\n        end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n        frames_to_read = end_idx - start_idx\n\n        logger.debug(\n            f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n            f\"start_idx={start_idx}, end_idx={end_idx}\"\n        )\n\n        # Settings for lazy loading\n        expected_shape = (len(channels_to_load), frames_to_read)\n\n        # Define the loading function using the file reader\n        def _load_audio() -&gt; NDArrayReal:\n            logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n            # Use the reader to get audio data with parameters\n            out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n            if not isinstance(out, np.ndarray):\n                raise ValueError(\"Unexpected data type after reading file\")\n            return out\n\n        logger.debug(\n            f\"Creating delayed dask task with expected shape: {expected_shape}\"\n        )\n\n        # Create delayed operation\n        delayed_data = dask_delayed(_load_audio)()\n        logger.debug(\"Wrapping delayed function in dask array\")\n\n        # Create dask array from delayed computation\n        dask_array = da_from_delayed(\n            delayed_data, shape=expected_shape, dtype=np.float32\n        )\n\n        if chunk_size is not None:\n            if chunk_size &lt;= 0:\n                raise ValueError(\"Chunk size must be a positive integer\")\n            logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n            dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n        logger.debug(\n            \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n        )\n\n        cf = ChannelFrame(\n            data=dask_array,\n            sampling_rate=sr,\n            label=path.stem,\n            metadata={\n                \"filename\": str(path),\n            },\n        )\n        if ch_labels is not None:\n            if len(ch_labels) != len(cf):\n                raise ValueError(\n                    \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        return cf\n\n    @classmethod\n    def read_wav(\n        cls, filename: str, labels: Optional[list[str]] = None\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a WAV file.\n\n        Args:\n            filename: Path to the WAV file.\n            labels: Labels to set for each channel.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(filename, ch_labels=labels)\n        return cf\n\n    @classmethod\n    def read_csv(\n        cls,\n        filename: str,\n        time_column: Union[int, str] = 0,\n        labels: Optional[list[str]] = None,\n        delimiter: str = \",\",\n        header: Optional[int] = 0,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a CSV file.\n\n        Args:\n            filename: Path to the CSV file.\n            time_column: Index or name of the time column.\n            labels: Labels to set for each channel.\n            delimiter: Delimiter character.\n            header: Row number to use as header.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(\n            filename,\n            ch_labels=labels,\n            time_column=time_column,\n            delimiter=delimiter,\n            header=header,\n        )\n        return cf\n\n    def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n        \"\"\"Save the audio data to a file.\n\n        Args:\n            path: Path to save the file.\n            format: File format. If None, determined from file extension.\n        \"\"\"\n        logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n        data = self.compute()\n        data = data.T\n        if data.shape[1] == 1:\n            data = data.squeeze(axis=1)\n        sf.write(str(path), data, int(self.sampling_rate), format=format)\n        logger.debug(f\"Save complete: {path}\")\n\n    def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a high-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n\n    def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a low-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n\n    def normalize(\n        self, target_level: float = -20, channel_wise: bool = True\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Normalize the signal level.\n\n        This method adjusts the signal amplitude to reach a target RMS level.\n\n        Args:\n            target_level: Target RMS level in dB. Default is -20.\n            channel_wise: If True, normalize each channel independently.\n                If False, apply the same scaling to all channels.\n\n        Returns:\n            A new ChannelFrame containing the normalized signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n        )\n        return self.apply_operation(\n            \"normalize\", target_level=target_level, channel_wise=channel_wise\n        )\n\n    def a_weighting(self) -&gt; \"ChannelFrame\":\n        \"\"\"Apply A-weighting filter to the signal.\n\n        A-weighting adjusts the frequency response to approximate human hearing\n        perception, following IEC 61672-1:2013 standard.\n\n        Returns:\n            A new ChannelFrame with A-weighted signal.\n        \"\"\"\n        return self.apply_operation(\"a_weighting\")\n\n    def hpss_harmonic(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract harmonic components using HPSS\n         (Harmonic-Percussive Source Separation).\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_harmonic\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def hpss_percussive(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract percussive components using HPSS\n        (Harmonic-Percussive Source Separation).\n\n        This method separates the percussive (tonal) components from the signal.\n\n        Args:\n            kernel_size: Median filter size for HPSS.\n            power: Exponent for the Weiner filter used in HPSS.\n            margin: Margin size for the separation.\n\n        Returns:\n            A new ChannelFrame containing the harmonic components.\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_percussive\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def resampling(\n        self,\n        target_sr: float,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Resample audio data.\n\n        Parameters\n        ----------\n        target_sr : float\n            Target sampling rate (Hz)\n        resample_type : str, optional\n            Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n        **kwargs : dict\n            Additional resampling parameters\n\n        Returns\n        -------\n        ChannelFrame\n            Resampled channel frame\n        \"\"\"\n        return self.apply_operation(\n            \"resampling\",\n            target_sr=target_sr,\n            **kwargs,\n        )\n\n    def abs(self) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the absolute value of the signal.\n\n        Returns:\n            A new ChannelFrame containing the absolute values.\n        \"\"\"\n        return self.apply_operation(\"abs\")\n\n    def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the power of the signal.\n\n        Args:\n            exponent: The exponent to raise the signal to. Default is 2.0.\n\n        Returns:\n            A new ChannelFrame containing the signal raised to the power.\n        \"\"\"\n        return self.apply_operation(\"power\", exponent=exponent)\n\n    def trim(\n        self,\n        start: float = 0,\n        end: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Trim the signal to specified time range.\n\n        Args:\n            start: Start time in seconds.\n            end: End time in seconds.\n\n        Returns:\n            A new ChannelFrame with trimmed signal.\n\n        Raises:\n            ValueError: If end time is before start time.\n        \"\"\"\n        if end is None:\n            end = self.duration\n        if start &gt; end:\n            raise ValueError(\"start must be less than end\")\n        # Apply trim operation\n        return self.apply_operation(\"trim\", start=start, end=end)\n\n    def rms_trend(\n        self,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the RMS trend of the signal.\n\n        This method computes the root mean square value over sliding windows.\n\n        Args:\n            frame_length: The size of the sliding window in samples. Default is 2048.\n            hop_length: The hop length between windows in samples. Default is 512.\n            dB: Whether to return the RMS values in decibels. Default is False.\n            Aw: Whether to apply A-weighting. Default is False.\n\n        Returns:\n            A new ChannelFrame containing the RMS trend.\n        \"\"\"\n        cf = self.apply_operation(\n            \"rms_trend\",\n            frame_length=frame_length,\n            hop_length=hop_length,\n            ref=[ch.ref for ch in self._channel_metadata],\n            dB=dB,\n            Aw=Aw,\n        )\n        cf.sampling_rate = self.sampling_rate / hop_length\n        return cf\n\n    def sum(self) -&gt; \"ChannelFrame\":\n        \"\"\"Sum all channels.\n\n        Returns:\n            A new ChannelFrame with summed signal.\n        \"\"\"\n        return self.apply_operation(\"sum\")\n\n    def mean(self) -&gt; \"ChannelFrame\":\n        \"\"\"Average all channels.\n\n        Returns:\n            A new ChannelFrame with averaged signal.\n        \"\"\"\n        return self.apply_operation(\"mean\")\n\n    def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate channel differences relative to a reference channel.\n\n        Args:\n            other_channel: Reference channel index or label. Default is 0.\n\n        Returns:\n            A new ChannelFrame with channel differences.\n        \"\"\"\n        if isinstance(other_channel, str):\n            return self.apply_operation(\n                \"channel_difference\", other_channel=self.label2index(other_channel)\n            )\n        return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n\n    def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n        \"\"\"Compute Fast Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is next power of 2 of data length.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectralFrame containing the FFT results.\n        \"\"\"\n        from ..processing.time_series import FFT\n        from .spectral import SpectralFrame\n\n        params = {\"n_fft\": n_fft, \"window\": window}\n        operation_name = \"fft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"FFT\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        if n_fft is None:\n            is_even = spectrum_data.shape[-1] % 2 == 0\n            _n_fft = (\n                spectrum_data.shape[-1] * 2 - 2\n                if is_even\n                else spectrum_data.shape[-1] * 2 - 1\n            )\n        else:\n            _n_fft = n_fft\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=_n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def welch(\n        self,\n        n_fft: Optional[int] = None,\n        hop_length: Optional[int] = None,\n        win_length: int = 2048,\n        window: str = \"hann\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute power spectral density using Welch's method.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the power spectral density.\n        \"\"\"\n        from ..processing.time_series import Welch\n        from .spectral import SpectralFrame\n\n        params = dict(\n            n_fft=n_fft or win_length,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            average=average,\n        )\n        operation_name = \"welch\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Welch\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"welch\", \"params\": params},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def noct_spectrum(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"Compute N-octave band spectrum.\n\n        Args:\n            fmin: Minimum center frequency in Hz. Default is 20 Hz.\n            fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n            n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n            G: Reference gain in dB. Default is 10 dB.\n            fr: Reference frequency in Hz. Default is 1000 Hz.\n\n        Returns:\n            A NOctFrame containing the N-octave band spectrum.\n        \"\"\"\n        from ..processing.time_series import NOctSpectrum\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_spectrum\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSpectrum\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_spectrum\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def stft(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"Compute Short-Time Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectrogramFrame containing the STFT results.\n        \"\"\"\n        from ..processing.time_series import STFT, create_operation\n        from .spectrogram import SpectrogramFrame\n\n        # Set hop length and window length\n        _hop_length = hop_length if hop_length is not None else n_fft // 4\n        _win_length = win_length if win_length is not None else n_fft\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": _hop_length,\n            \"win_length\": _win_length,\n            \"window\": window,\n        }\n        operation_name = \"stft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"STFT\", operation)\n\n        # Apply processing to data\n        spectrogram_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n\n        # Create new instance\n        return SpectrogramFrame(\n            data=spectrogram_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=n_fft,\n            hop_length=_hop_length,\n            win_length=_win_length,\n            window=window,\n            label=f\"stft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def coherence(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute magnitude squared coherence.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n        Returns:\n            A SpectralFrame containing the magnitude squared coherence.\n        \"\"\"\n        from ..processing.time_series import Coherence, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n        }\n        operation_name = \"coherence\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Coherence\", operation)\n\n        # Apply processing to data\n        coherence_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=coherence_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Coherence of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def csd(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute cross-spectral density matrix.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the cross-spectral density matrix.\n        \"\"\"\n        from ..processing.time_series import CSD, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"csd\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"CSD\", operation)\n\n        # Apply processing to data\n        csd_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=csd_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def transfer_function(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute transfer function matrix.\n\n        The transfer function characterizes the signal transmission properties\n        between channels in the frequency domain, representing the input-output\n        relationship of a system.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the transfer function matrix.\n        \"\"\"\n        from ..processing.time_series import TransferFunction, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"transfer_function\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"TransferFunction\", operation)\n\n        # Apply processing to data\n        tf_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=tf_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Transfer function of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"Provide additional initialization arguments required for ChannelFrame.\"\"\"\n        return {}\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Returns the duration in seconds.</p>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>Returns the number of samples.</p>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.time","title":"<code>time</code>  <code>property</code>","text":"<p>Get time array for the signal.</p> <p>Returns:</p> Type Description <code>NDArrayReal</code> <p>Array of time points in seconds.</p>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.__init__","title":"<code>__init__(data, sampling_rate, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a ChannelFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>Dask array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate of the data in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>operation_history</code> <code>Optional[list[dict[str, Any]]]</code> <p>History of operations applied to the frame.</p> <code>None</code> <code>channel_metadata</code> <code>Optional[list[ChannelMetadata]]</code> <p>Metadata for each channel.</p> <code>None</code> <code>previous</code> <code>Optional[BaseFrame[Any]]</code> <p>Reference to the previous frame in the processing chain.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has more than 2 dimensions.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"Initialize a ChannelFrame.\n\n    Args:\n        data: Dask array containing channel data.\n        Shape should be (n_channels, n_samples).\n        sampling_rate: The sampling rate of the data in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        operation_history: History of operations applied to the frame.\n        channel_metadata: Metadata for each channel.\n        previous: Reference to the previous frame in the processing chain.\n\n    Raises:\n        ValueError: If data has more than 2 dimensions.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.a_weighting","title":"<code>a_weighting()</code>","text":"<p>Apply A-weighting filter to the signal.</p> <p>A-weighting adjusts the frequency response to approximate human hearing perception, following IEC 61672-1:2013 standard.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with A-weighted signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def a_weighting(self) -&gt; \"ChannelFrame\":\n    \"\"\"Apply A-weighting filter to the signal.\n\n    A-weighting adjusts the frequency response to approximate human hearing\n    perception, following IEC 61672-1:2013 standard.\n\n    Returns:\n        A new ChannelFrame with A-weighted signal.\n    \"\"\"\n    return self.apply_operation(\"a_weighting\")\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.abs","title":"<code>abs()</code>","text":"<p>Calculate the absolute value of the signal.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the absolute values.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def abs(self) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the absolute value of the signal.\n\n    Returns:\n        A new ChannelFrame containing the absolute values.\n    \"\"\"\n    return self.apply_operation(\"abs\")\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.add","title":"<code>add(other, snr=None)</code>","text":"<p>Add another signal or value to the current signal.</p> <p>If SNR is specified, performs addition with consideration for signal-to-noise ratio.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[ChannelFrame, int, float, NDArrayReal, Array]</code> <p>Signal or value to add.</p> required <code>snr</code> <code>Optional[float]</code> <p>Signal-to-noise ratio (dB). If specified, adjusts the scale of the other signal based on this SNR. self is treated as the signal, and other as the noise.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new channel frame containing the addition result (lazy execution).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def add(\n    self,\n    other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n    snr: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Add another signal or value to the current signal.\n\n    If SNR is specified, performs addition with consideration for\n    signal-to-noise ratio.\n\n    Args:\n        other: Signal or value to add.\n        snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n            other signal based on this SNR.\n            self is treated as the signal, and other as the noise.\n\n    Returns:\n        A new channel frame containing the addition result (lazy execution).\n    \"\"\"\n    logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n    # Special processing when SNR is specified\n    if snr is not None:\n        # First convert other to ChannelFrame if it's not\n        if not isinstance(other, ChannelFrame):\n            if isinstance(other, np.ndarray):\n                other = ChannelFrame.from_numpy(\n                    other, self.sampling_rate, label=\"array_data\"\n                )\n            elif isinstance(other, (int, float)):\n                # For scalar values, simply add (ignore SNR)\n                return self + other\n            else:\n                raise TypeError(\n                    \"Addition target with SNR must be a ChannelFrame or \"\n                    f\"NumPy array: {type(other)}\"\n                )\n\n        # Check if sampling rates match\n        if self.sampling_rate != other.sampling_rate:\n            raise ValueError(\n                \"Sampling rates do not match. Cannot perform operation.\"\n            )\n\n        # Apply addition operation with SNR adjustment\n        return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n    # Execute normal addition if SNR is not specified\n    return self + other\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.channel_difference","title":"<code>channel_difference(other_channel=0)</code>","text":"<p>Calculate channel differences relative to a reference channel.</p> <p>Parameters:</p> Name Type Description Default <code>other_channel</code> <code>Union[int, str]</code> <p>Reference channel index or label. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with channel differences.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate channel differences relative to a reference channel.\n\n    Args:\n        other_channel: Reference channel index or label. Default is 0.\n\n    Returns:\n        A new ChannelFrame with channel differences.\n    \"\"\"\n    if isinstance(other_channel, str):\n        return self.apply_operation(\n            \"channel_difference\", other_channel=self.label2index(other_channel)\n        )\n    return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.coherence","title":"<code>coherence(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant')</code>","text":"<p>Compute magnitude squared coherence.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the magnitude squared coherence.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def coherence(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute magnitude squared coherence.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n    Returns:\n        A SpectralFrame containing the magnitude squared coherence.\n    \"\"\"\n    from ..processing.time_series import Coherence, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n    }\n    operation_name = \"coherence\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Coherence\", operation)\n\n    # Apply processing to data\n    coherence_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=coherence_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Coherence of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.csd","title":"<code>csd(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute cross-spectral density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the cross-spectral density matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def csd(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute cross-spectral density matrix.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the cross-spectral density matrix.\n    \"\"\"\n    from ..processing.time_series import CSD, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"csd\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"CSD\", operation)\n\n    # Apply processing to data\n    csd_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=csd_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.describe","title":"<code>describe(normalize=True, **kwargs)</code>","text":"<p>Display visual and audio representation of the frame.</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>Whether to normalize the audio data for playback.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for visualization.</p> <code>{}</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n    \"\"\"Display visual and audio representation of the frame.\n\n    Args:\n        normalize: Whether to normalize the audio data for playback.\n        **kwargs: Additional parameters for visualization.\n    \"\"\"\n    if \"axis_config\" in kwargs:\n        logger.warning(\n            \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        axis_config = kwargs[\"axis_config\"]\n        if \"time_plot\" in axis_config:\n            kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n        if \"freq_plot\" in axis_config:\n            if \"xlim\" in axis_config[\"freq_plot\"]:\n                vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                kwargs[\"vmin\"] = vlim[0]\n                kwargs[\"vmax\"] = vlim[1]\n            if \"ylim\" in axis_config[\"freq_plot\"]:\n                ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                kwargs[\"ylim\"] = ylim\n\n    if \"cbar_config\" in kwargs:\n        logger.warning(\n            \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        cbar_config = kwargs[\"cbar_config\"]\n        if \"vmin\" in cbar_config:\n            kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n        if \"vmax\" in cbar_config:\n            kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n    for ch in self:\n        ax: Axes\n        _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n        if isinstance(_ax, Iterator):\n            ax = next(iter(_ax))\n        elif isinstance(_ax, Axes):\n            ax = _ax\n        else:\n            raise TypeError(\n                f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n            )\n        # Ignore type checks for display and Audio\n        display(ax.figure)  # type: ignore\n        plt.close(ax.figure)  # type: ignore\n        display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.fft","title":"<code>fft(n_fft=None, window='hann')</code>","text":"<p>Compute Fast Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is next power of 2 of data length.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the FFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n    \"\"\"Compute Fast Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is next power of 2 of data length.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectralFrame containing the FFT results.\n    \"\"\"\n    from ..processing.time_series import FFT\n    from .spectral import SpectralFrame\n\n    params = {\"n_fft\": n_fft, \"window\": window}\n    operation_name = \"fft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"FFT\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    if n_fft is None:\n        is_even = spectrum_data.shape[-1] % 2 == 0\n        _n_fft = (\n            spectrum_data.shape[-1] * 2 - 2\n            if is_even\n            else spectrum_data.shape[-1] * 2 - 1\n        )\n    else:\n        _n_fft = n_fft\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=_n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.from_file","title":"<code>from_file(path, channel=None, start=None, end=None, chunk_size=None, ch_labels=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from an audio file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the audio file.</p> required <code>channel</code> <code>Optional[Union[int, list[int]]]</code> <p>Channel(s) to load.</p> <code>None</code> <code>start</code> <code>Optional[float]</code> <p>Start time in seconds.</p> <code>None</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <code>chunk_size</code> <code>Optional[int]</code> <p>Chunk size for processing.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the file reader.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the loaded audio data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If channel selection is invalid.</p> <code>TypeError</code> <p>If channel parameter type is invalid.</p> <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    path: Union[str, Path],\n    channel: Optional[Union[int, list[int]]] = None,\n    start: Optional[float] = None,\n    end: Optional[float] = None,\n    chunk_size: Optional[int] = None,\n    ch_labels: Optional[list[str]] = None,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from an audio file.\n\n    Args:\n        path: Path to the audio file.\n        channel: Channel(s) to load.\n        start: Start time in seconds.\n        end: End time in seconds.\n        chunk_size: Chunk size for processing.\n        Specifies the splitting size for lazy processing.\n        ch_labels: Labels for each channel.\n        **kwargs: Additional arguments passed to the file reader.\n\n    Returns:\n        A new ChannelFrame containing the loaded audio data.\n\n    Raises:\n        ValueError: If channel selection is invalid.\n        TypeError: If channel parameter type is invalid.\n        FileNotFoundError: If the file doesn't exist.\n    \"\"\"\n    from .channel import ChannelFrame\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    # Get file reader\n    reader = get_file_reader(path)\n\n    # Get file info\n    info = reader.get_file_info(path, **kwargs)\n    sr = info[\"samplerate\"]\n    n_channels = info[\"channels\"]\n    n_frames = info[\"frames\"]\n    ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n    logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n    # Channel selection processing\n    all_channels = list(range(n_channels))\n\n    if channel is None:\n        channels_to_load = all_channels\n        logger.debug(f\"Will load all channels: {channels_to_load}\")\n    elif isinstance(channel, int):\n        if channel &lt; 0 or channel &gt;= n_channels:\n            raise ValueError(\n                f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n            )\n        channels_to_load = [channel]\n        logger.debug(f\"Will load single channel: {channel}\")\n    elif isinstance(channel, (list, tuple)):\n        for ch in channel:\n            if ch &lt; 0 or ch &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n        channels_to_load = list(channel)\n        logger.debug(f\"Will load specific channels: {channels_to_load}\")\n    else:\n        raise TypeError(\"channel must be int, list, or None\")\n\n    # Index calculation\n    start_idx = 0 if start is None else max(0, int(start * sr))\n    end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n    frames_to_read = end_idx - start_idx\n\n    logger.debug(\n        f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n        f\"start_idx={start_idx}, end_idx={end_idx}\"\n    )\n\n    # Settings for lazy loading\n    expected_shape = (len(channels_to_load), frames_to_read)\n\n    # Define the loading function using the file reader\n    def _load_audio() -&gt; NDArrayReal:\n        logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n        # Use the reader to get audio data with parameters\n        out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n        if not isinstance(out, np.ndarray):\n            raise ValueError(\"Unexpected data type after reading file\")\n        return out\n\n    logger.debug(\n        f\"Creating delayed dask task with expected shape: {expected_shape}\"\n    )\n\n    # Create delayed operation\n    delayed_data = dask_delayed(_load_audio)()\n    logger.debug(\"Wrapping delayed function in dask array\")\n\n    # Create dask array from delayed computation\n    dask_array = da_from_delayed(\n        delayed_data, shape=expected_shape, dtype=np.float32\n    )\n\n    if chunk_size is not None:\n        if chunk_size &lt;= 0:\n            raise ValueError(\"Chunk size must be a positive integer\")\n        logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n        dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n    logger.debug(\n        \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n    )\n\n    cf = ChannelFrame(\n        data=dask_array,\n        sampling_rate=sr,\n        label=path.stem,\n        metadata={\n            \"filename\": str(path),\n        },\n    )\n    if ch_labels is not None:\n        if len(ch_labels) != len(cf):\n            raise ValueError(\n                \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    return cf\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.from_ndarray","title":"<code>from_ndarray(array, sampling_rate, labels=None, unit=None, frame_label=None, metadata=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>This method is deprecated. Use from_numpy instead.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>NDArrayReal</code> <p>Signal data. Each row corresponds to a channel.</p> required <code>sampling_rate</code> <code>float</code> <p>Sampling rate (Hz).</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>unit</code> <code>Optional[Union[list[str], str]]</code> <p>Unit of the signal.</p> <code>None</code> <code>frame_label</code> <code>Optional[str]</code> <p>Label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_ndarray(\n    cls,\n    array: NDArrayReal,\n    sampling_rate: float,\n    labels: Optional[list[str]] = None,\n    unit: Optional[Union[list[str], str]] = None,\n    frame_label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    This method is deprecated. Use from_numpy instead.\n\n    Args:\n        array: Signal data. Each row corresponds to a channel.\n        sampling_rate: Sampling rate (Hz).\n        labels: Labels for each channel.\n        unit: Unit of the signal.\n        frame_label: Label for the frame.\n        metadata: Optional metadata dictionary.\n\n    Returns:\n        A new ChannelFrame containing the data.\n    \"\"\"\n    # Redirect to from_numpy for compatibility\n    # However, from_ndarray is deprecated\n    logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n    return cls.from_numpy(\n        data=array,\n        sampling_rate=sampling_rate,\n        label=frame_label,\n        metadata=metadata,\n        ch_labels=labels,\n        ch_units=unit,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.from_numpy","title":"<code>from_numpy(data, sampling_rate, label=None, metadata=None, ch_labels=None, ch_units=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArrayReal</code> <p>NumPy array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>ch_units</code> <code>Optional[Union[list[str], str]]</code> <p>Units for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the NumPy data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_numpy(\n    cls,\n    data: NDArrayReal,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    ch_labels: Optional[list[str]] = None,\n    ch_units: Optional[Union[list[str], str]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    Args:\n        data: NumPy array containing channel data.\n        sampling_rate: The sampling rate in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        ch_labels: Labels for each channel.\n        ch_units: Units for each channel.\n\n    Returns:\n        A new ChannelFrame containing the NumPy data.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n\n    # Convert NumPy array to dask array\n    dask_data = da_from_array(data)\n    cf = ChannelFrame(\n        data=dask_data,\n        sampling_rate=sampling_rate,\n        label=label or \"numpy_data\",\n    )\n    if metadata is not None:\n        cf.metadata = metadata\n    if ch_labels is not None:\n        if len(ch_labels) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel labels does not match the number of channels\"\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    if ch_units is not None:\n        if isinstance(ch_units, str):\n            ch_units = [ch_units] * cf.n_channels\n\n        if len(ch_units) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel units does not match the number of channels\"\n            )\n        for i in range(len(ch_units)):\n            cf._channel_metadata[i].unit = ch_units[i]\n\n    return cf\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.high_pass_filter","title":"<code>high_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a high-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a high-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.hpss_harmonic","title":"<code>hpss_harmonic(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract harmonic components using HPSS  (Harmonic-Percussive Source Separation).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_harmonic(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract harmonic components using HPSS\n     (Harmonic-Percussive Source Separation).\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_harmonic\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.hpss_percussive","title":"<code>hpss_percussive(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract percussive components using HPSS (Harmonic-Percussive Source Separation).</p> <p>This method separates the percussive (tonal) components from the signal.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Union[_IntLike_co, tuple[_IntLike_co, _IntLike_co], list[_IntLike_co]]</code> <p>Median filter size for HPSS.</p> <code>31</code> <code>power</code> <code>float</code> <p>Exponent for the Weiner filter used in HPSS.</p> <code>2</code> <code>margin</code> <code>Union[_FloatLike_co, tuple[_FloatLike_co, _FloatLike_co], list[_FloatLike_co]]</code> <p>Margin size for the separation.</p> <code>1</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the harmonic components.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_percussive(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract percussive components using HPSS\n    (Harmonic-Percussive Source Separation).\n\n    This method separates the percussive (tonal) components from the signal.\n\n    Args:\n        kernel_size: Median filter size for HPSS.\n        power: Exponent for the Weiner filter used in HPSS.\n        margin: Margin size for the separation.\n\n    Returns:\n        A new ChannelFrame containing the harmonic components.\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_percussive\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.low_pass_filter","title":"<code>low_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a low-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a low-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.mean","title":"<code>mean()</code>","text":"<p>Average all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with averaged signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def mean(self) -&gt; \"ChannelFrame\":\n    \"\"\"Average all channels.\n\n    Returns:\n        A new ChannelFrame with averaged signal.\n    \"\"\"\n    return self.apply_operation(\"mean\")\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.noct_spectrum","title":"<code>noct_spectrum(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Compute N-octave band spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>fmin</code> <code>float</code> <p>Minimum center frequency in Hz. Default is 20 Hz.</p> required <code>fmax</code> <code>float</code> <p>Maximum center frequency in Hz. Default is 20000 Hz.</p> required <code>n</code> <code>int</code> <p>Band division (1 for octave, 3 for 1/3 octave). Default is 3.</p> <code>3</code> <code>G</code> <code>int</code> <p>Reference gain in dB. Default is 10 dB.</p> <code>10</code> <code>fr</code> <code>int</code> <p>Reference frequency in Hz. Default is 1000 Hz.</p> <code>1000</code> <p>Returns:</p> Type Description <code>NOctFrame</code> <p>A NOctFrame containing the N-octave band spectrum.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def noct_spectrum(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"Compute N-octave band spectrum.\n\n    Args:\n        fmin: Minimum center frequency in Hz. Default is 20 Hz.\n        fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n        n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n        G: Reference gain in dB. Default is 10 dB.\n        fr: Reference frequency in Hz. Default is 1000 Hz.\n\n    Returns:\n        A NOctFrame containing the N-octave band spectrum.\n    \"\"\"\n    from ..processing.time_series import NOctSpectrum\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_spectrum\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSpectrum\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_spectrum\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.normalize","title":"<code>normalize(target_level=-20, channel_wise=True)</code>","text":"<p>Normalize the signal level.</p> <p>This method adjusts the signal amplitude to reach a target RMS level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target RMS level in dB. Default is -20.</p> <code>-20</code> <code>channel_wise</code> <code>bool</code> <p>If True, normalize each channel independently. If False, apply the same scaling to all channels.</p> <code>True</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the normalized signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def normalize(\n    self, target_level: float = -20, channel_wise: bool = True\n) -&gt; \"ChannelFrame\":\n    \"\"\"Normalize the signal level.\n\n    This method adjusts the signal amplitude to reach a target RMS level.\n\n    Args:\n        target_level: Target RMS level in dB. Default is -20.\n        channel_wise: If True, normalize each channel independently.\n            If False, apply the same scaling to all channels.\n\n    Returns:\n        A new ChannelFrame containing the normalized signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n    )\n    return self.apply_operation(\n        \"normalize\", target_level=target_level, channel_wise=channel_wise\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.plot","title":"<code>plot(plot_type='waveform', ax=None, **kwargs)</code>","text":"<p>Plot the frame data.</p> <p>Parameters:</p> Name Type Description Default <code>plot_type</code> <code>str</code> <p>Type of plot. Default is \"waveform\".</p> <code>'waveform'</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def plot(\n    self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Plot the frame data.\n\n    Args:\n        plot_type: Type of plot. Default is \"waveform\".\n        ax: Optional matplotlib axes for plotting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    plot_strategy = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.power","title":"<code>power(exponent=2.0)</code>","text":"<p>Calculate the power of the signal.</p> <p>Parameters:</p> Name Type Description Default <code>exponent</code> <code>float</code> <p>The exponent to raise the signal to. Default is 2.0.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the signal raised to the power.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the power of the signal.\n\n    Args:\n        exponent: The exponent to raise the signal to. Default is 2.0.\n\n    Returns:\n        A new ChannelFrame containing the signal raised to the power.\n    \"\"\"\n    return self.apply_operation(\"power\", exponent=exponent)\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.read_csv","title":"<code>read_csv(filename, time_column=0, labels=None, delimiter=',', header=0)</code>  <code>classmethod</code>","text":"<p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.read_wav","title":"<code>read_wav(filename, labels=None)</code>  <code>classmethod</code>","text":"<p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.resampling","title":"<code>resampling(target_sr, **kwargs)</code>","text":"<p>Resample audio data.</p>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.resampling--parameters","title":"Parameters","text":"<p>target_sr : float     Target sampling rate (Hz) resample_type : str, optional     Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.) **kwargs : dict     Additional resampling parameters</p>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.resampling--returns","title":"Returns","text":"<p>ChannelFrame     Resampled channel frame</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def resampling(\n    self,\n    target_sr: float,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Resample audio data.\n\n    Parameters\n    ----------\n    target_sr : float\n        Target sampling rate (Hz)\n    resample_type : str, optional\n        Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n    **kwargs : dict\n        Additional resampling parameters\n\n    Returns\n    -------\n    ChannelFrame\n        Resampled channel frame\n    \"\"\"\n    return self.apply_operation(\n        \"resampling\",\n        target_sr=target_sr,\n        **kwargs,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.rms_plot","title":"<code>rms_plot(ax=None, title=None, overlay=True, Aw=False, **kwargs)</code>","text":"<p>Generate an RMS plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title for the plot.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay the plot on the existing axis.</p> <code>True</code> <code>Aw</code> <code>bool</code> <p>Apply A-weighting.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_plot(\n    self,\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = True,\n    Aw: bool = False,  # noqa: N803\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Generate an RMS plot.\n\n    Args:\n        ax: Optional matplotlib axes for plotting.\n        title: Title for the plot.\n        overlay: Whether to overlay the plot on the existing axis.\n        Aw: Apply A-weighting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    kwargs = kwargs or {}\n    ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n    rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n    return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.rms_trend","title":"<code>rms_trend(frame_length=2048, hop_length=512, dB=False, Aw=False)</code>","text":"<p>Calculate the RMS trend of the signal.</p> <p>This method computes the root mean square value over sliding windows.</p> <p>Parameters:</p> Name Type Description Default <code>frame_length</code> <code>int</code> <p>The size of the sliding window in samples. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>int</code> <p>The hop length between windows in samples. Default is 512.</p> <code>512</code> <code>dB</code> <code>bool</code> <p>Whether to return the RMS values in decibels. Default is False.</p> <code>False</code> <code>Aw</code> <code>bool</code> <p>Whether to apply A-weighting. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the RMS trend.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_trend(\n    self,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the RMS trend of the signal.\n\n    This method computes the root mean square value over sliding windows.\n\n    Args:\n        frame_length: The size of the sliding window in samples. Default is 2048.\n        hop_length: The hop length between windows in samples. Default is 512.\n        dB: Whether to return the RMS values in decibels. Default is False.\n        Aw: Whether to apply A-weighting. Default is False.\n\n    Returns:\n        A new ChannelFrame containing the RMS trend.\n    \"\"\"\n    cf = self.apply_operation(\n        \"rms_trend\",\n        frame_length=frame_length,\n        hop_length=hop_length,\n        ref=[ch.ref for ch in self._channel_metadata],\n        dB=dB,\n        Aw=Aw,\n    )\n    cf.sampling_rate = self.sampling_rate / hop_length\n    return cf\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.save","title":"<code>save(path, format=None)</code>","text":"<p>Save the audio data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n    data = self.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    sf.write(str(path), data, int(self.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {path}\")\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.stft","title":"<code>stft(n_fft=2048, hop_length=None, win_length=None, window='hann')</code>","text":"<p>Compute Short-Time Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectrogramFrame</code> <p>A SpectrogramFrame containing the STFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def stft(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n) -&gt; \"SpectrogramFrame\":\n    \"\"\"Compute Short-Time Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectrogramFrame containing the STFT results.\n    \"\"\"\n    from ..processing.time_series import STFT, create_operation\n    from .spectrogram import SpectrogramFrame\n\n    # Set hop length and window length\n    _hop_length = hop_length if hop_length is not None else n_fft // 4\n    _win_length = win_length if win_length is not None else n_fft\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": _hop_length,\n        \"win_length\": _win_length,\n        \"window\": window,\n    }\n    operation_name = \"stft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"STFT\", operation)\n\n    # Apply processing to data\n    spectrogram_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n\n    # Create new instance\n    return SpectrogramFrame(\n        data=spectrogram_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=n_fft,\n        hop_length=_hop_length,\n        win_length=_win_length,\n        window=window,\n        label=f\"stft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.sum","title":"<code>sum()</code>","text":"<p>Sum all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with summed signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def sum(self) -&gt; \"ChannelFrame\":\n    \"\"\"Sum all channels.\n\n    Returns:\n        A new ChannelFrame with summed signal.\n    \"\"\"\n    return self.apply_operation(\"sum\")\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.transfer_function","title":"<code>transfer_function(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute transfer function matrix.</p> <p>The transfer function characterizes the signal transmission properties between channels in the frequency domain, representing the input-output relationship of a system.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the transfer function matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def transfer_function(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute transfer function matrix.\n\n    The transfer function characterizes the signal transmission properties\n    between channels in the frequency domain, representing the input-output\n    relationship of a system.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the transfer function matrix.\n    \"\"\"\n    from ..processing.time_series import TransferFunction, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"transfer_function\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"TransferFunction\", operation)\n\n    # Apply processing to data\n    tf_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=tf_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Transfer function of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.trim","title":"<code>trim(start=0, end=None)</code>","text":"<p>Trim the signal to specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>Start time in seconds.</p> <code>0</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with trimmed signal.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If end time is before start time.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def trim(\n    self,\n    start: float = 0,\n    end: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Trim the signal to specified time range.\n\n    Args:\n        start: Start time in seconds.\n        end: End time in seconds.\n\n    Returns:\n        A new ChannelFrame with trimmed signal.\n\n    Raises:\n        ValueError: If end time is before start time.\n    \"\"\"\n    if end is None:\n        end = self.duration\n    if start &gt; end:\n        raise ValueError(\"start must be less than end\")\n    # Apply trim operation\n    return self.apply_operation(\"trim\", start=start, end=end)\n</code></pre>"},{"location":"ja/api/#wandas.frames.channel.ChannelFrame.welch","title":"<code>welch(n_fft=None, hop_length=None, win_length=2048, window='hann', average='mean')</code>","text":"<p>Compute power spectral density using Welch's method.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is 2048.</p> <code>None</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>int</code> <p>Length of window. Default is n_fft.</p> <code>2048</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the power spectral density.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def welch(\n    self,\n    n_fft: Optional[int] = None,\n    hop_length: Optional[int] = None,\n    win_length: int = 2048,\n    window: str = \"hann\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute power spectral density using Welch's method.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the power spectral density.\n    \"\"\"\n    from ..processing.time_series import Welch\n    from .spectral import SpectralFrame\n\n    params = dict(\n        n_fft=n_fft or win_length,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        average=average,\n    )\n    operation_name = \"welch\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Welch\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"welch\", \"params\": params},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/#io","title":"\u5165\u51fa\u529b (I/O)","text":"<p>Wandas\u3067\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u65b9\u6cd5\u3067\u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u3084CSV\u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u3080\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002</p>"},{"location":"ja/api/#wav","title":"WAV\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\u3068\u66f8\u304d\u8fbc\u307f","text":"<pre><code># WAV\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\nfrom wandas.frames.channel import ChannelFrame\nframe = ChannelFrame.read_wav(\"audio.wav\")\n\n# \u307e\u305f\u306f\u76f4\u63a5\u30a4\u30f3\u30dd\u30fc\u30c8\u3092\u4f7f\u7528\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")\n\n# WAV\u30d5\u30a1\u30a4\u30eb\u306e\u66f8\u304d\u8fbc\u307f\nframe.save(\"output.wav\")\n</code></pre> <p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre> <p>Save the audio data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n    data = self.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    sf.write(str(path), data, int(self.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {path}\")\n</code></pre>"},{"location":"ja/api/#csv","title":"CSV\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f","text":"<pre><code># CSV\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\nfrom wandas.frames.channel import ChannelFrame\nframe = ChannelFrame.read_csv(\"data.csv\")\n\n# \u307e\u305f\u306f\u76f4\u63a5\u30a4\u30f3\u30dd\u30fc\u30c8\u3092\u4f7f\u7528\nimport wandas\nframe = wandas.read_csv(\"data.csv\")\n</code></pre> <p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"ja/api/#_3","title":"\u4fe1\u53f7\u51e6\u7406","text":"<p>Wandas\u306f\u69d8\u3005\u306a\u4fe1\u53f7\u51e6\u7406\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"ja/api/#wandas.processing.time_series.ABS","title":"<code>ABS</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Absolute value operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ABS(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Absolute value operation\"\"\"\n\n    name = \"abs\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize absolute value operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        return da.abs(data)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.ABS.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize absolute value operation</p>"},{"location":"ja/api/#wandas.processing.time_series.ABS.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize absolute value operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AWeighting","title":"<code>AWeighting</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>A-weighting filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AWeighting(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"A-weighting filter operation\"\"\"\n\n    name = \"a_weighting\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize A-weighting filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for A-weighting filter\"\"\"\n        logger.debug(f\"Applying A-weighting to array with shape: {x.shape}\")\n        result = A_weight(x, self.sampling_rate)\n\n        # Handle case where A_weight returns a tuple\n        if isinstance(result, tuple):\n            # Use the first element of the tuple\n            result = result[0]\n\n        logger.debug(\n            f\"A-weighting applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AWeighting.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize A-weighting filter</p>"},{"location":"ja/api/#wandas.processing.time_series.AWeighting.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize A-weighting filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AddWithSNR","title":"<code>AddWithSNR</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Addition operation considering SNR</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AddWithSNR(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Addition operation considering SNR\"\"\"\n\n    name = \"add_with_snr\"\n\n    def __init__(self, sampling_rate: float, other: DaArray, snr: float):\n        \"\"\"\n        Initialize addition operation considering SNR\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        other : DaArray\n            Noise signal to add (channel-frame format)\n        snr : float\n            Signal-to-noise ratio (dB)\n        \"\"\"\n        super().__init__(sampling_rate, other=other, snr=snr)\n\n        self.other = other\n        self.snr = snr\n        logger.debug(f\"Initialized AddWithSNR operation with SNR: {snr} dB\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape (same as input)\n        \"\"\"\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Perform addition processing considering SNR\"\"\"\n        logger.debug(f\"Applying SNR-based addition with shape: {x.shape}\")\n        other: NDArrayReal = self.other.compute()\n\n        # Use multi-channel versions of calculate_rms and calculate_desired_noise_rms\n        clean_rms = util.calculate_rms(x)\n        other_rms = util.calculate_rms(other)\n\n        # Adjust noise gain based on specified SNR (apply per channel)\n        desired_noise_rms = util.calculate_desired_noise_rms(clean_rms, self.snr)\n\n        # Apply gain per channel using broadcasting\n        gain = desired_noise_rms / other_rms\n        # Add adjusted noise to signal\n        result: NDArrayReal = x + other * gain\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AddWithSNR.__init__","title":"<code>__init__(sampling_rate, other, snr)</code>","text":"<p>Initialize addition operation considering SNR</p>"},{"location":"ja/api/#wandas.processing.time_series.AddWithSNR.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) other : DaArray     Noise signal to add (channel-frame format) snr : float     Signal-to-noise ratio (dB)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, other: DaArray, snr: float):\n    \"\"\"\n    Initialize addition operation considering SNR\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    other : DaArray\n        Noise signal to add (channel-frame format)\n    snr : float\n        Signal-to-noise ratio (dB)\n    \"\"\"\n    super().__init__(sampling_rate, other=other, snr=snr)\n\n    self.other = other\n    self.snr = snr\n    logger.debug(f\"Initialized AddWithSNR operation with SNR: {snr} dB\")\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AddWithSNR.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.AddWithSNR.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"ja/api/#wandas.processing.time_series.AddWithSNR.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (same as input)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape (same as input)\n    \"\"\"\n    return input_shape\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AudioOperation","title":"<code>AudioOperation</code>","text":"<p>               Bases: <code>Generic[InputArrayType, OutputArrayType]</code></p> <p>Abstract base class for audio processing operations.</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AudioOperation(Generic[InputArrayType, OutputArrayType]):\n    \"\"\"Abstract base class for audio processing operations.\"\"\"\n\n    # Class variable: operation name\n    name: ClassVar[str]\n\n    def __init__(self, sampling_rate: float, **params: Any):\n        \"\"\"\n        Initialize AudioOperation.\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        **params : Any\n            Operation-specific parameters\n        \"\"\"\n        self.sampling_rate = sampling_rate\n        self.params = params\n\n        # Validate parameters during initialization\n        self.validate_params()\n\n        # Create processor function (lazy initialization possible)\n        self._setup_processor()\n\n        logger.debug(\n            f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n        )\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n        pass\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up processor function (implemented by subclasses)\"\"\"\n        pass\n\n    def _process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function (implemented by subclasses)\"\"\"\n        # Default is no-op function\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    @dask.delayed  # type: ignore [misc, unused-ignore]\n    def process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n        # Default is no-op function\n        logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n        return self._process_array(x)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation (implemented by subclasses)\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        \"\"\"\n        Execute operation and return result\n        data shape is (channels, samples)\n        \"\"\"\n        # Add task as delayed processing\n        logger.debug(\"Adding delayed operation to computation graph\")\n        delayed_result = self.process_array(data)\n        # Convert delayed result to dask array and return\n        output_shape = self.calculate_output_shape(data.shape)\n        return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AudioOperation.__init__","title":"<code>__init__(sampling_rate, **params)</code>","text":"<p>Initialize AudioOperation.</p>"},{"location":"ja/api/#wandas.processing.time_series.AudioOperation.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) **params : Any     Operation-specific parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, **params: Any):\n    \"\"\"\n    Initialize AudioOperation.\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    **params : Any\n        Operation-specific parameters\n    \"\"\"\n    self.sampling_rate = sampling_rate\n    self.params = params\n\n    # Validate parameters during initialization\n    self.validate_params()\n\n    # Create processor function (lazy initialization possible)\n    self._setup_processor()\n\n    logger.debug(\n        f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n    )\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AudioOperation.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation (implemented by subclasses)</p>"},{"location":"ja/api/#wandas.processing.time_series.AudioOperation.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"ja/api/#wandas.processing.time_series.AudioOperation.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation (implemented by subclasses)\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AudioOperation.process","title":"<code>process(data)</code>","text":"<p>Execute operation and return result data shape is (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    \"\"\"\n    Execute operation and return result\n    data shape is (channels, samples)\n    \"\"\"\n    # Add task as delayed processing\n    logger.debug(\"Adding delayed operation to computation graph\")\n    delayed_result = self.process_array(data)\n    # Convert delayed result to dask array and return\n    output_shape = self.calculate_output_shape(data.shape)\n    return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AudioOperation.process_array","title":"<code>process_array(x)</code>","text":"<p>Processing function wrapped with @dask.delayed</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>@dask.delayed  # type: ignore [misc, unused-ignore]\ndef process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n    \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n    # Default is no-op function\n    logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n    return self._process_array(x)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.AudioOperation.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters (raises exception if invalid)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n    pass\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.CSD","title":"<code>CSD</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Cross-spectral density estimation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class CSD(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Cross-spectral density estimation operation\"\"\"\n\n    name = \"csd\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n        scaling: str,\n        average: str,\n    ):\n        \"\"\"\n        Initialize cross-spectral density estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        scaling : str\n            Type of scaling\n        average : str\n            Method of averaging\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        self.scaling = scaling\n        self.average = average\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n            scaling=scaling,\n            average=average,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Processor function for cross-spectral density estimation operation\"\"\"\n        logger.debug(f\"Applying CSD estimation to array with shape: {x.shape}\")\n        from scipy import signal as ss\n\n        # Calculate all combinations using scipy's csd function\n        _, csd_result = ss.csd(\n            x=x[:, np.newaxis],\n            y=x[np.newaxis, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n        )\n\n        # Reshape result to (n_channels * n_channels, n_freqs)\n        result: NDArrayComplex = csd_result.transpose(1, 0, 2).reshape(\n            -1, csd_result.shape[-1]\n        )\n\n        logger.debug(f\"CSD estimation applied, result shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.CSD.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend, scaling, average)</code>","text":"<p>Initialize cross-spectral density estimation operation</p>"},{"location":"ja/api/#wandas.processing.time_series.CSD.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend scaling : str     Type of scaling average : str     Method of averaging</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n    scaling: str,\n    average: str,\n):\n    \"\"\"\n    Initialize cross-spectral density estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    scaling : str\n        Type of scaling\n    average : str\n        Method of averaging\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    self.scaling = scaling\n    self.average = average\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n        scaling=scaling,\n        average=average,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.CSD.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.CSD.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"ja/api/#wandas.processing.time_series.CSD.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.ChannelDifference","title":"<code>ChannelDifference</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Channel difference calculation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ChannelDifference(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Channel difference calculation operation\"\"\"\n\n    name = \"channel_difference\"\n    other_channel: int\n\n    def __init__(self, sampling_rate: float, other_channel: int = 0):\n        \"\"\"\n        Initialize channel difference calculation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        other_channel : int\n            Channel to calculate difference with, default is 0\n        \"\"\"\n        self.other_channel = other_channel\n        super().__init__(sampling_rate, other_channel=other_channel)\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        result = data - data[self.other_channel]\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.ChannelDifference.__init__","title":"<code>__init__(sampling_rate, other_channel=0)</code>","text":"<p>Initialize channel difference calculation</p>"},{"location":"ja/api/#wandas.processing.time_series.ChannelDifference.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) other_channel : int     Channel to calculate difference with, default is 0</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, other_channel: int = 0):\n    \"\"\"\n    Initialize channel difference calculation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    other_channel : int\n        Channel to calculate difference with, default is 0\n    \"\"\"\n    self.other_channel = other_channel\n    super().__init__(sampling_rate, other_channel=other_channel)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Coherence","title":"<code>Coherence</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Coherence estimation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Coherence(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Coherence estimation operation\"\"\"\n\n    name = \"coherence\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n    ):\n        \"\"\"\n        Initialize coherence estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Processor function for coherence estimation operation\"\"\"\n        logger.debug(f\"Applying coherence estimation to array with shape: {x.shape}\")\n        from scipy import signal as ss\n\n        _, coh = ss.coherence(\n            x=x[:, np.newaxis],\n            y=x[np.newaxis, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n        )\n\n        # Reshape result to (n_channels * n_channels, n_freqs)\n        result: NDArrayReal = coh.transpose(1, 0, 2).reshape(-1, coh.shape[-1])\n\n        logger.debug(f\"Coherence estimation applied, result shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Coherence.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend)</code>","text":"<p>Initialize coherence estimation operation</p>"},{"location":"ja/api/#wandas.processing.time_series.Coherence.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n):\n    \"\"\"\n    Initialize coherence estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Coherence.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.Coherence.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"ja/api/#wandas.processing.time_series.Coherence.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.FFT","title":"<code>FFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>FFT (Fast Fourier Transform) operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class FFT(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"FFT (Fast Fourier Transform) operation\"\"\"\n\n    name = \"fft\"\n    n_fft: Optional[int]\n    window: str\n\n    def __init__(\n        self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n    ):\n        \"\"\"\n        Initialize FFT operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int, optional\n            FFT size, default is None (determined by input size)\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(sampling_rate, n_fft=n_fft, window=window)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        \u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059\n\n        Parameters\n        ----------\n        input_shape : tuple\n            \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)\n\n        Returns\n        -------\n        tuple\n            \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)\n        \"\"\"\n        n_freqs = self.n_fft // 2 + 1 if self.n_fft else input_shape[-1] // 2 + 1\n        return (*input_shape[:-1], n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"FFT\u64cd\u4f5c\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u95a2\u6570\u3092\u4f5c\u6210\"\"\"\n        from scipy.signal import get_window\n\n        win = get_window(self.window, x.shape[-1])\n        x = x * win\n        result: NDArrayComplex = np.fft.rfft(x, n=self.n_fft, axis=-1)\n        result[..., 1:-1] *= 2.0\n        # \u7a93\u95a2\u6570\u88dc\u6b63\n        scaling_factor = np.sum(win)\n        result = result / scaling_factor\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.FFT.__init__","title":"<code>__init__(sampling_rate, n_fft=None, window='hann')</code>","text":"<p>Initialize FFT operation</p>"},{"location":"ja/api/#wandas.processing.time_series.FFT.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int, optional     FFT size, default is None (determined by input size) window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n):\n    \"\"\"\n    Initialize FFT operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int, optional\n        FFT size, default is None (determined by input size)\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(sampling_rate, n_fft=n_fft, window=window)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.FFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>\u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059</p>"},{"location":"ja/api/#wandas.processing.time_series.FFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)</p>"},{"location":"ja/api/#wandas.processing.time_series.FFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    \u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059\n\n    Parameters\n    ----------\n    input_shape : tuple\n        \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)\n\n    Returns\n    -------\n    tuple\n        \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)\n    \"\"\"\n    n_freqs = self.n_fft // 2 + 1 if self.n_fft else input_shape[-1] // 2 + 1\n    return (*input_shape[:-1], n_freqs)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.HighPassFilter","title":"<code>HighPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>High-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HighPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"High-pass filter operation\"\"\"\n\n    name = \"highpass_filter\"\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize high-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            limit = self.sampling_rate / 2\n            raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up high-pass filter processor\"\"\"\n        # Calculate filter coefficients (once) - safely retrieve from instance variables\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"high\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Highpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying highpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.HighPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize high-pass filter</p>"},{"location":"ja/api/#wandas.processing.time_series.HighPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize high-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.HighPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        limit = self.sampling_rate / 2\n        raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.HpssHarmonic","title":"<code>HpssHarmonic</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>HPSS Harmonic operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HpssHarmonic(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"HPSS Harmonic operation\"\"\"\n\n    name = \"hpss_harmonic\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize HPSS Harmonic\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        self.kwargs = kwargs\n        super().__init__(sampling_rate, **kwargs)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for HPSS Harmonic\"\"\"\n        logger.debug(f\"Applying HPSS Harmonic to array with shape: {x.shape}\")\n        result = librosa.effects.harmonic(x, **self.kwargs)\n        logger.debug(\n            f\"HPSS Harmonic applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.HpssHarmonic.__init__","title":"<code>__init__(sampling_rate, **kwargs)</code>","text":"<p>Initialize HPSS Harmonic</p>"},{"location":"ja/api/#wandas.processing.time_series.HpssHarmonic.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize HPSS Harmonic\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    self.kwargs = kwargs\n    super().__init__(sampling_rate, **kwargs)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.HpssPercussive","title":"<code>HpssPercussive</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>HPSS Percussive operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HpssPercussive(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"HPSS Percussive operation\"\"\"\n\n    name = \"hpss_percussive\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize HPSS Percussive\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        self.kwargs = kwargs\n        super().__init__(sampling_rate, **kwargs)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for HPSS Percussive\"\"\"\n        logger.debug(f\"Applying HPSS Percussive to array with shape: {x.shape}\")\n        result = librosa.effects.percussive(x, **self.kwargs)\n        logger.debug(\n            f\"HPSS Percussive applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.HpssPercussive.__init__","title":"<code>__init__(sampling_rate, **kwargs)</code>","text":"<p>Initialize HPSS Percussive</p>"},{"location":"ja/api/#wandas.processing.time_series.HpssPercussive.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize HPSS Percussive\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    self.kwargs = kwargs\n    super().__init__(sampling_rate, **kwargs)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.IFFT","title":"<code>IFFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayComplex, NDArrayReal]</code></p> <p>IFFT (Inverse Fast Fourier Transform) operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class IFFT(AudioOperation[NDArrayComplex, NDArrayReal]):\n    \"\"\"IFFT (Inverse Fast Fourier Transform) operation\"\"\"\n\n    name = \"ifft\"\n    n_fft: Optional[int]\n    window: str\n\n    def __init__(\n        self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n    ):\n        \"\"\"\n        Initialize IFFT operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : Optional[int], optional\n            IFFT size, default is None (determined based on input size)\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(sampling_rate, n_fft=n_fft, window=window)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, freqs)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, samples)\n        \"\"\"\n        n_samples = 2 * (input_shape[-1] - 1) if self.n_fft is None else self.n_fft\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayComplex) -&gt; NDArrayReal:\n        \"\"\"Create processor function for IFFT operation\"\"\"\n        logger.debug(f\"Applying IFFT to array with shape: {x.shape}\")\n\n        # Restore frequency component scaling (remove the 2.0 multiplier applied in FFT)\n        _x = x.copy()\n        _x[..., 1:-1] /= 2.0\n\n        # Execute IFFT\n        result: NDArrayReal = np.fft.irfft(_x, n=self.n_fft, axis=-1)\n\n        # Window function correction (inverse of FFT operation)\n        from scipy.signal import get_window\n\n        win = get_window(self.window, result.shape[-1])\n\n        # Correct the FFT window function scaling\n        scaling_factor = np.sum(win) / result.shape[-1]\n        result = result / scaling_factor\n\n        logger.debug(f\"IFFT applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.IFFT.__init__","title":"<code>__init__(sampling_rate, n_fft=None, window='hann')</code>","text":"<p>Initialize IFFT operation</p>"},{"location":"ja/api/#wandas.processing.time_series.IFFT.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : Optional[int], optional     IFFT size, default is None (determined based on input size) window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n):\n    \"\"\"\n    Initialize IFFT operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : Optional[int], optional\n        IFFT size, default is None (determined based on input size)\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(sampling_rate, n_fft=n_fft, window=window)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.IFFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.IFFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, freqs)</p>"},{"location":"ja/api/#wandas.processing.time_series.IFFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, freqs)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, samples)\n    \"\"\"\n    n_samples = 2 * (input_shape[-1] - 1) if self.n_fft is None else self.n_fft\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.ISTFT","title":"<code>ISTFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayComplex, NDArrayReal]</code></p> <p>Inverse Short-Time Fourier Transform operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ISTFT(AudioOperation[NDArrayComplex, NDArrayReal]):\n    \"\"\"Inverse Short-Time Fourier Transform operation\"\"\"\n\n    name = \"istft\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        length: Optional[int] = None,\n    ):\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.length = length\n\n        # Instantiate ShortTimeFFT for ISTFT calculation\n        self.SFT = ShortTimeFFT(\n            win=get_window(window, self.win_length),\n            hop=self.hop_length,\n            fs=sampling_rate,\n            mfft=self.n_fft,\n            scale_to=\"magnitude\",  # Consistent scaling with STFT\n        )\n\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n            length=length,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, freqs, time_frames)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, samples)\n        \"\"\"\n        k0: int = 0\n        q_max = input_shape[-1] + self.SFT.p_min\n        k_max = (q_max - 1) * self.SFT.hop + self.SFT.m_num - self.SFT.m_num_mid\n        k_q0, k_q1 = self.SFT.nearest_k_p(k0), self.SFT.nearest_k_p(k_max, left=False)\n        n_pts = k_q1 - k_q0 + self.SFT.m_num - self.SFT.m_num_mid\n\n        return input_shape[:-2] + (n_pts,)\n\n    def _process_array(self, x: NDArrayComplex) -&gt; NDArrayReal:\n        \"\"\"\n        Apply SciPy ISTFT processing to multiple channels at once using ShortTimeFFT\"\"\"\n        logger.debug(\n            f\"Applying SciPy ISTFT (ShortTimeFFT) to array with shape: {x.shape}\"\n        )\n\n        # Convert 2D input to 3D (assume single channel)\n        if x.ndim == 2:\n            x = x.reshape(1, *x.shape)\n\n        # Adjust scaling back if STFT applied factor of 2\n        _x = np.copy(x)\n        _x[..., 1:-1, :] /= 2.0\n\n        # Apply ISTFT using the ShortTimeFFT instance\n        result: NDArrayReal = self.SFT.istft(_x)\n\n        # Trim to desired length if specified\n        if self.length is not None:\n            result = result[..., : self.length]\n\n        logger.debug(\n            f\"ShortTimeFFT applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.ISTFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.ISTFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, freqs, time_frames)</p>"},{"location":"ja/api/#wandas.processing.time_series.ISTFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, freqs, time_frames)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, samples)\n    \"\"\"\n    k0: int = 0\n    q_max = input_shape[-1] + self.SFT.p_min\n    k_max = (q_max - 1) * self.SFT.hop + self.SFT.m_num - self.SFT.m_num_mid\n    k_q0, k_q1 = self.SFT.nearest_k_p(k0), self.SFT.nearest_k_p(k_max, left=False)\n    n_pts = k_q1 - k_q0 + self.SFT.m_num - self.SFT.m_num_mid\n\n    return input_shape[:-2] + (n_pts,)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.LowPassFilter","title":"<code>LowPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Low-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class LowPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Low-pass filter operation\"\"\"\n\n    name = \"lowpass_filter\"\n    a: NDArrayReal\n    b: NDArrayReal\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize low-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            raise ValueError(\n                f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n            )\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up low-pass filter processor\"\"\"\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"low\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Lowpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying lowpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.LowPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize low-pass filter</p>"},{"location":"ja/api/#wandas.processing.time_series.LowPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize low-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.LowPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        raise ValueError(\n            f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n        )\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Mean","title":"<code>Mean</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Mean calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Mean(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Mean calculation\"\"\"\n\n    name = \"mean\"\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # Use Dask's aggregate function directly without map_blocks\n        return data.mean(axis=0, keepdims=True)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.NOctSpectrum","title":"<code>NOctSpectrum</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>N-octave spectrum operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class NOctSpectrum(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"N-octave spectrum operation\"\"\"\n\n    name = \"noct_spectrum\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ):\n        \"\"\"\n        Initialize N-octave spectrum\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        fmin : float\n            Minimum frequency (Hz)\n        fmax : float\n            Maximum frequency (Hz)\n        n : int, optional\n            Number of octave divisions, default is 3\n        G : int, optional\n            Reference level, default is 10\n        fr : int, optional\n            Reference frequency, default is 1000\n        \"\"\"\n        super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n        self.fmin = fmin\n        self.fmax = fmax\n        self.n = n\n        self.G = G\n        self.fr = fr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate output shape for octave spectrum\n        _, fpref = _center_freq(\n            fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n        )\n        return (input_shape[0], fpref.shape[0])\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for octave spectrum\"\"\"\n        logger.debug(f\"Applying NoctSpectrum to array with shape: {x.shape}\")\n        spec, _ = noct_spectrum(\n            sig=x.T,\n            fs=self.sampling_rate,\n            fmin=self.fmin,\n            fmax=self.fmax,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        if spec.ndim == 1:\n            # Add channel dimension for 1D\n            spec = np.expand_dims(spec, axis=0)\n        else:\n            spec = spec.T\n        logger.debug(f\"NoctSpectrum applied, returning result with shape: {spec.shape}\")\n        return np.array(spec)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.NOctSpectrum.__init__","title":"<code>__init__(sampling_rate, fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Initialize N-octave spectrum</p>"},{"location":"ja/api/#wandas.processing.time_series.NOctSpectrum.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) fmin : float     Minimum frequency (Hz) fmax : float     Maximum frequency (Hz) n : int, optional     Number of octave divisions, default is 3 G : int, optional     Reference level, default is 10 fr : int, optional     Reference frequency, default is 1000</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n):\n    \"\"\"\n    Initialize N-octave spectrum\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    fmin : float\n        Minimum frequency (Hz)\n    fmax : float\n        Maximum frequency (Hz)\n    n : int, optional\n        Number of octave divisions, default is 3\n    G : int, optional\n        Reference level, default is 10\n    fr : int, optional\n        Reference frequency, default is 1000\n    \"\"\"\n    super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n    self.fmin = fmin\n    self.fmax = fmax\n    self.n = n\n    self.G = G\n    self.fr = fr\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.NOctSpectrum.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.NOctSpectrum.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"ja/api/#wandas.processing.time_series.NOctSpectrum.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate output shape for octave spectrum\n    _, fpref = _center_freq(\n        fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n    )\n    return (input_shape[0], fpref.shape[0])\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.NOctSynthesis","title":"<code>NOctSynthesis</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Octave synthesis operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class NOctSynthesis(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Octave synthesis operation\"\"\"\n\n    name = \"noct_synthesis\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ):\n        \"\"\"\n        Initialize octave synthesis\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        fmin : float\n            Minimum frequency (Hz)\n        fmax : float\n            Maximum frequency (Hz)\n        n : int, optional\n            Number of octave divisions, default is 3\n        G : int, optional\n            Reference level, default is 10\n        fr : int, optional\n            Reference frequency, default is 1000\n        \"\"\"\n        super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n\n        self.fmin = fmin\n        self.fmax = fmax\n        self.n = n\n        self.G = G\n        self.fr = fr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate output shape for octave spectrum\n        _, fpref = _center_freq(\n            fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n        )\n        return (input_shape[0], fpref.shape[0])\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for octave synthesis\"\"\"\n        logger.debug(f\"Applying NoctSynthesis to array with shape: {x.shape}\")\n        # Calculate n from shape[-1]\n        n = x.shape[-1]  # Calculate n from shape[-1]\n        if n % 2 == 0:\n            n = n * 2 - 1\n        else:\n            n = (n - 1) * 2\n        freqs = np.fft.rfftfreq(n, d=1 / self.sampling_rate)\n        result, _ = noct_synthesis(\n            spectrum=np.abs(x).T,\n            freqs=freqs,\n            fmin=self.fmin,\n            fmax=self.fmax,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        result = result.T\n        logger.debug(\n            f\"NoctSynthesis applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.NOctSynthesis.__init__","title":"<code>__init__(sampling_rate, fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Initialize octave synthesis</p>"},{"location":"ja/api/#wandas.processing.time_series.NOctSynthesis.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) fmin : float     Minimum frequency (Hz) fmax : float     Maximum frequency (Hz) n : int, optional     Number of octave divisions, default is 3 G : int, optional     Reference level, default is 10 fr : int, optional     Reference frequency, default is 1000</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n):\n    \"\"\"\n    Initialize octave synthesis\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    fmin : float\n        Minimum frequency (Hz)\n    fmax : float\n        Maximum frequency (Hz)\n    n : int, optional\n        Number of octave divisions, default is 3\n    G : int, optional\n        Reference level, default is 10\n    fr : int, optional\n        Reference frequency, default is 1000\n    \"\"\"\n    super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n\n    self.fmin = fmin\n    self.fmax = fmax\n    self.n = n\n    self.G = G\n    self.fr = fr\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.NOctSynthesis.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.NOctSynthesis.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"ja/api/#wandas.processing.time_series.NOctSynthesis.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate output shape for octave spectrum\n    _, fpref = _center_freq(\n        fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n    )\n    return (input_shape[0], fpref.shape[0])\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Power","title":"<code>Power</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Power operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Power(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Power operation\"\"\"\n\n    name = \"power\"\n\n    def __init__(self, sampling_rate: float, exponent: float):\n        \"\"\"\n        Initialize power operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        exponent : float\n            Power exponent\n        \"\"\"\n        super().__init__(sampling_rate)\n        self.exp = exponent\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        return da.power(data, self.exp)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Power.__init__","title":"<code>__init__(sampling_rate, exponent)</code>","text":"<p>Initialize power operation</p>"},{"location":"ja/api/#wandas.processing.time_series.Power.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) exponent : float     Power exponent</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, exponent: float):\n    \"\"\"\n    Initialize power operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    exponent : float\n        Power exponent\n    \"\"\"\n    super().__init__(sampling_rate)\n    self.exp = exponent\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.ReSampling","title":"<code>ReSampling</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Resampling operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ReSampling(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Resampling operation\"\"\"\n\n    name = \"resampling\"\n\n    def __init__(self, sampling_rate: float, target_sr: float):\n        \"\"\"\n        Initialize resampling operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        target_sampling_rate : float\n            Target sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate, target_sr=target_sr)\n        self.target_sr = target_sr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after resampling\n        ratio = float(self.target_sr) / float(self.sampling_rate)\n        n_samples = int(np.ceil(input_shape[-1] * ratio))\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for resampling operation\"\"\"\n        logger.debug(f\"Applying resampling to array with shape: {x.shape}\")\n        result = librosa.resample(\n            x, orig_sr=self.sampling_rate, target_sr=self.target_sr\n        )\n        logger.debug(f\"Resampling applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.ReSampling.__init__","title":"<code>__init__(sampling_rate, target_sr)</code>","text":"<p>Initialize resampling operation</p>"},{"location":"ja/api/#wandas.processing.time_series.ReSampling.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) target_sampling_rate : float     Target sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, target_sr: float):\n    \"\"\"\n    Initialize resampling operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    target_sampling_rate : float\n        Target sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate, target_sr=target_sr)\n    self.target_sr = target_sr\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.ReSampling.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.ReSampling.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"ja/api/#wandas.processing.time_series.ReSampling.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after resampling\n    ratio = float(self.target_sr) / float(self.sampling_rate)\n    n_samples = int(np.ceil(input_shape[-1] * ratio))\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.RmsTrend","title":"<code>RmsTrend</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>RMS calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class RmsTrend(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"RMS calculation\"\"\"\n\n    name = \"rms_trend\"\n    frame_length: int\n    hop_length: int\n    Aw: bool\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        ref: Union[list[float], float] = 1.0,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; None:\n        \"\"\"\n        Initialize RMS calculation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        frame_length : int\n            Frame length, default is 2048\n        hop_length : int\n            Hop length, default is 512\n        ref : Union[list[float], float]\n            Reference value(s) for dB calculation\n        dB : bool\n            Whether to convert to decibels\n        Aw : bool\n            Whether to apply A-weighting before RMS calculation\n        \"\"\"\n        self.frame_length = frame_length\n        self.hop_length = hop_length\n        self.dB = dB\n        self.Aw = Aw\n        self.ref = np.array(ref if isinstance(ref, list) else [ref])\n        super().__init__(\n            sampling_rate,\n            frame_length=frame_length,\n            hop_length=hop_length,\n            dB=dB,\n            Aw=Aw,\n            ref=self.ref,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, frames)\n        \"\"\"\n        n_frames = librosa.feature.rms(\n            y=np.ones((1, input_shape[-1])),\n            frame_length=self.frame_length,\n            hop_length=self.hop_length,\n        ).shape[-1]\n        return (*input_shape[:-1], n_frames)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for RMS calculation\"\"\"\n        logger.debug(f\"Applying RMS to array with shape: {x.shape}\")\n\n        if self.Aw:\n            # Apply A-weighting\n            _x = A_weight(x, self.sampling_rate)\n            if isinstance(_x, np.ndarray):\n                # A_weight\u304c\u30bf\u30d7\u30eb\u3092\u8fd4\u3059\u5834\u5408\u3001\u6700\u521d\u306e\u8981\u7d20\u3092\u4f7f\u7528\n                x = _x\n            elif isinstance(_x, tuple):\n                # Use the first element if A_weight returns a tuple\n                x = _x[0]\n            else:\n                raise ValueError(\"A_weighting returned an unexpected type.\")\n\n        # Calculate RMS\n        result = librosa.feature.rms(\n            y=x, frame_length=self.frame_length, hop_length=self.hop_length\n        )[..., 0, :]\n\n        if self.dB:\n            # Convert to dB\n            result = 20 * np.log10(\n                np.maximum(result / self.ref[..., np.newaxis], 1e-12)\n            )\n        #\n        logger.debug(f\"RMS applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.RmsTrend.__init__","title":"<code>__init__(sampling_rate, frame_length=2048, hop_length=512, ref=1.0, dB=False, Aw=False)</code>","text":"<p>Initialize RMS calculation</p>"},{"location":"ja/api/#wandas.processing.time_series.RmsTrend.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) frame_length : int     Frame length, default is 2048 hop_length : int     Hop length, default is 512 ref : Union[list[float], float]     Reference value(s) for dB calculation dB : bool     Whether to convert to decibels Aw : bool     Whether to apply A-weighting before RMS calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    ref: Union[list[float], float] = 1.0,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; None:\n    \"\"\"\n    Initialize RMS calculation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    frame_length : int\n        Frame length, default is 2048\n    hop_length : int\n        Hop length, default is 512\n    ref : Union[list[float], float]\n        Reference value(s) for dB calculation\n    dB : bool\n        Whether to convert to decibels\n    Aw : bool\n        Whether to apply A-weighting before RMS calculation\n    \"\"\"\n    self.frame_length = frame_length\n    self.hop_length = hop_length\n    self.dB = dB\n    self.Aw = Aw\n    self.ref = np.array(ref if isinstance(ref, list) else [ref])\n    super().__init__(\n        sampling_rate,\n        frame_length=frame_length,\n        hop_length=hop_length,\n        dB=dB,\n        Aw=Aw,\n        ref=self.ref,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.RmsTrend.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.RmsTrend.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"ja/api/#wandas.processing.time_series.RmsTrend.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, frames)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, frames)\n    \"\"\"\n    n_frames = librosa.feature.rms(\n        y=np.ones((1, input_shape[-1])),\n        frame_length=self.frame_length,\n        hop_length=self.hop_length,\n    ).shape[-1]\n    return (*input_shape[:-1], n_frames)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.STFT","title":"<code>STFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Short-Time Fourier Transform operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class STFT(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Short-Time Fourier Transform operation\"\"\"\n\n    name = \"stft\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ):\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.noverlap = (\n            self.win_length - self.hop_length if hop_length is not None else None\n        )\n        self.window = window\n\n        self.SFT = ShortTimeFFT(\n            win=get_window(window, self.win_length),\n            hop=self.hop_length,\n            fs=sampling_rate,\n            mfft=self.n_fft,\n            scale_to=\"magnitude\",\n        )\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        n_samples = input_shape[-1]\n        n_f = len(self.SFT.f)\n        n_t = len(self.SFT.t(n_samples))\n        return (input_shape[0], n_f, n_t)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Apply SciPy STFT processing to multiple channels at once\"\"\"\n        logger.debug(f\"Applying SciPy STFT to array with shape: {x.shape}\")\n\n        # Convert 1D input to 2D\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n\n        # Apply STFT to all channels at once\n        result: NDArrayComplex = self.SFT.stft(x)\n        result[..., 1:-1, :] *= 2.0\n        logger.debug(f\"SciPy STFT applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.STFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.STFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"ja/api/#wandas.processing.time_series.STFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    n_samples = input_shape[-1]\n    n_f = len(self.SFT.f)\n    n_t = len(self.SFT.t(n_samples))\n    return (input_shape[0], n_f, n_t)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Sum","title":"<code>Sum</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Sum calculation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Sum(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Sum calculation\"\"\"\n\n    name = \"sum\"\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # Use Dask's aggregate function directly without map_blocks\n        return data.sum(axis=0, keepdims=True)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.TransferFunction","title":"<code>TransferFunction</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Transfer function estimation operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class TransferFunction(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Transfer function estimation operation\"\"\"\n\n    name = \"transfer_function\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ):\n        \"\"\"\n        Initialize transfer function estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        scaling : str\n            Type of scaling\n        average : str\n            Method of averaging\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        self.scaling = scaling\n        self.average = average\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n            scaling=scaling,\n            average=average,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Processor function for transfer function estimation operation\"\"\"\n        logger.debug(\n            f\"Applying transfer function estimation to array with shape: {x.shape}\"\n        )\n        from scipy import signal as ss\n\n        # Calculate cross-spectral density between all channels\n        f, p_yx = ss.csd(\n            x=x[:, np.newaxis, :],\n            y=x[np.newaxis, :, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n            axis=-1,\n        )\n        # p_yx shape: (num_channels, num_channels, num_frequencies)\n\n        # Calculate power spectral density for each channel\n        f, p_xx = ss.welch(\n            x=x,\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n            axis=-1,\n        )\n        # p_xx shape: (num_channels, num_frequencies)\n\n        # Calculate transfer function H(f) = P_yx / P_xx\n        h_f = p_yx / p_xx[np.newaxis, :, :]\n        result: NDArrayComplex = h_f.transpose(1, 0, 2).reshape(-1, h_f.shape[-1])\n\n        logger.debug(\n            f\"Transfer function estimation applied, result shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.TransferFunction.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend, scaling='spectrum', average='mean')</code>","text":"<p>Initialize transfer function estimation operation</p>"},{"location":"ja/api/#wandas.processing.time_series.TransferFunction.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend scaling : str     Type of scaling average : str     Method of averaging</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n):\n    \"\"\"\n    Initialize transfer function estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    scaling : str\n        Type of scaling\n    average : str\n        Method of averaging\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    self.scaling = scaling\n    self.average = average\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n        scaling=scaling,\n        average=average,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.TransferFunction.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.TransferFunction.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"ja/api/#wandas.processing.time_series.TransferFunction.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Trim","title":"<code>Trim</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Trimming operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Trim(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Trimming operation\"\"\"\n\n    name = \"trim\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        start: float,\n        end: float,\n    ):\n        \"\"\"\n        Initialize trimming operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        start : float\n            Start time for trimming (seconds)\n        end : float\n            End time for trimming (seconds)\n        \"\"\"\n        super().__init__(sampling_rate, start=start, end=end)\n        self.start = start\n        self.end = end\n        self.start_sample = int(start * sampling_rate)\n        self.end_sample = int(end * sampling_rate)\n        logger.debug(\n            f\"Initialized Trim operation with start: {self.start}, end: {self.end}\"\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after trimming\n        # Exclude parts where there is no signal\n        end_sample = min(self.end_sample, input_shape[-1])\n        n_samples = end_sample - self.start_sample\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for trimming operation\"\"\"\n        logger.debug(f\"Applying trim to array with shape: {x.shape}\")\n        # Apply trimming\n        result = x[..., self.start_sample : self.end_sample]\n        logger.debug(f\"Trim applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Trim.__init__","title":"<code>__init__(sampling_rate, start, end)</code>","text":"<p>Initialize trimming operation</p>"},{"location":"ja/api/#wandas.processing.time_series.Trim.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) start : float     Start time for trimming (seconds) end : float     End time for trimming (seconds)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    start: float,\n    end: float,\n):\n    \"\"\"\n    Initialize trimming operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    start : float\n        Start time for trimming (seconds)\n    end : float\n        End time for trimming (seconds)\n    \"\"\"\n    super().__init__(sampling_rate, start=start, end=end)\n    self.start = start\n    self.end = end\n    self.start_sample = int(start * sampling_rate)\n    self.end_sample = int(end * sampling_rate)\n    logger.debug(\n        f\"Initialized Trim operation with start: {self.start}, end: {self.end}\"\n    )\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Trim.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.Trim.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"ja/api/#wandas.processing.time_series.Trim.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after trimming\n    # Exclude parts where there is no signal\n    end_sample = min(self.end_sample, input_shape[-1])\n    n_samples = end_sample - self.start_sample\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Welch","title":"<code>Welch</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Welch</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class Welch(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Welch\"\"\"\n\n    name = \"welch\"\n    n_fft: int\n    window: str\n    hop_length: Optional[int]\n    win_length: Optional[int]\n    average: str\n    detrend: str\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        average: str = \"mean\",\n        detrend: str = \"constant\",\n    ):\n        \"\"\"\n        Initialize Welch operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int, optional\n            FFT size, default is 2048\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.noverlap = (\n            self.win_length - self.hop_length if hop_length is not None else None\n        )\n        self.window = window\n        self.average = average\n        self.detrend = detrend\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n            average=average,\n            detrend=detrend,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, freqs)\n        \"\"\"\n        n_freqs = self.n_fft // 2 + 1\n        return (*input_shape[:-1], n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for Welch operation\"\"\"\n        from scipy import signal as ss\n\n        _, result = ss.welch(\n            x,\n            nperseg=self.win_length,\n            noverlap=self.noverlap,\n            nfft=self.n_fft,\n            window=self.window,\n            average=self.average,\n            detrend=self.detrend,\n            scaling=\"spectrum\",\n        )\n\n        if not isinstance(x, np.ndarray):\n            # Trigger computation for Dask array\n            raise ValueError(\n                \"Welch operation requires a Dask array, but received a non-ndarray.\"\n            )\n        return np.array(result)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Welch.__init__","title":"<code>__init__(sampling_rate, n_fft=2048, hop_length=None, win_length=None, window='hann', average='mean', detrend='constant')</code>","text":"<p>Initialize Welch operation</p>"},{"location":"ja/api/#wandas.processing.time_series.Welch.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int, optional     FFT size, default is 2048 window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    average: str = \"mean\",\n    detrend: str = \"constant\",\n):\n    \"\"\"\n    Initialize Welch operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int, optional\n        FFT size, default is 2048\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.noverlap = (\n        self.win_length - self.hop_length if hop_length is not None else None\n    )\n    self.window = window\n    self.average = average\n    self.detrend = detrend\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        win_length=self.win_length,\n        hop_length=self.hop_length,\n        window=window,\n        average=average,\n        detrend=detrend,\n    )\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.Welch.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/#wandas.processing.time_series.Welch.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"ja/api/#wandas.processing.time_series.Welch.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, freqs)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, freqs)\n    \"\"\"\n    n_freqs = self.n_fft // 2 + 1\n    return (*input_shape[:-1], n_freqs)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.create_operation","title":"<code>create_operation(name, sampling_rate, **params)</code>","text":"<p>Create operation instance from name and parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def create_operation(\n    name: str, sampling_rate: float, **params: Any\n) -&gt; AudioOperation[Any, Any]:\n    \"\"\"Create operation instance from name and parameters\"\"\"\n    operation_class = get_operation(name)\n    return operation_class(sampling_rate, **params)\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.get_operation","title":"<code>get_operation(name)</code>","text":"<p>Get operation class by name</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def get_operation(name: str) -&gt; type[AudioOperation[Any, Any]]:\n    \"\"\"Get operation class by name\"\"\"\n    if name not in _OPERATION_REGISTRY:\n        raise ValueError(f\"Unknown operation type: {name}\")\n    return _OPERATION_REGISTRY[name]\n</code></pre>"},{"location":"ja/api/#wandas.processing.time_series.register_operation","title":"<code>register_operation(operation_class)</code>","text":"<p>Register a new operation type</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def register_operation(operation_class: type) -&gt; None:\n    \"\"\"Register a new operation type\"\"\"\n\n    if not issubclass(operation_class, AudioOperation):\n        raise TypeError(\"Strategy class must inherit from AudioOperation.\")\n    if inspect.isabstract(operation_class):\n        raise TypeError(\"Cannot register abstract AudioOperation class.\")\n\n    _OPERATION_REGISTRY[operation_class.name] = operation_class\n</code></pre>"},{"location":"ja/api/#_4","title":"\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3","text":""},{"location":"ja/api/core/","title":"\u30b3\u30a2\u30e2\u30b8\u30e5\u30fc\u30eb\uff08Core\uff09","text":"<p>\u3053\u306e\u30da\u30fc\u30b8\u3067\u306fWandas\u306e\u30b3\u30a2\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002\u30b3\u30a2\u30e2\u30b8\u30e5\u30fc\u30eb\u306fWandas\u306e\u57fa\u672c\u30c7\u30fc\u30bf\u69cb\u9020\u3068\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"ja/api/core/#baseframe","title":"BaseFrame","text":"<p><code>BaseFrame</code>\u306fWandas\u306e\u5168\u3066\u306e\u30d5\u30ec\u30fc\u30e0\u30af\u30e9\u30b9\u306e\u57fa\u5e95\u30af\u30e9\u30b9\u3067\u3059\u3002\u76f4\u63a5\u3053\u306e\u30af\u30e9\u30b9\u3092\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u5316\u3059\u308b\u3053\u3068\u306f\u306a\u304f\u3001\u6d3e\u751f\u30af\u30e9\u30b9\uff08ChannelFrame\u306a\u3069\uff09\u3092\u901a\u3058\u3066\u4f7f\u7528\u3057\u307e\u3059\u3002</p> <pre><code>from wandas.core.base_frame import BaseFrame\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for all signal frame types.</p> <p>This class provides the common interface and functionality for all frame types used in signal processing. It implements basic operations like indexing, iteration, and data manipulation that are shared across all frame types.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The signal data to process. Must be a dask array. sampling_rate : float     The sampling rate of the signal in Hz. label : str, optional     A label for the frame. If not provided, defaults to \"unnamed_frame\". metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame--attributes","title":"Attributes","text":"<p>sampling_rate : float     The sampling rate of the signal in Hz. label : str     The label of the frame. metadata : dict     Additional metadata for the frame. operation_history : list[dict]     History of operations performed on this frame.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>class BaseFrame(ABC, Generic[T]):\n    \"\"\"\n    Abstract base class for all signal frame types.\n\n    This class provides the common interface and functionality for all frame types\n    used in signal processing. It implements basic operations like indexing, iteration,\n    and data manipulation that are shared across all frame types.\n\n    Parameters\n    ----------\n    data : DaArray\n        The signal data to process. Must be a dask array.\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str, optional\n        A label for the frame. If not provided, defaults to \"unnamed_frame\".\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str\n        The label of the frame.\n    metadata : dict\n        Additional metadata for the frame.\n    operation_history : list[dict]\n        History of operations performed on this frame.\n    \"\"\"\n\n    _data: DaArray\n    sampling_rate: float\n    label: str\n    metadata: dict[str, Any]\n    operation_history: list[dict[str, Any]]\n    _channel_metadata: list[ChannelMetadata]\n    _previous: Optional[\"BaseFrame[Any]\"]\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ):\n        self._data = data.rechunk(chunks=-1)  # type: ignore [unused-ignore]\n        if self._data.ndim == 1:\n            self._data = self._data.reshape((1, -1))\n        self.sampling_rate = sampling_rate\n        self.label = label or \"unnamed_frame\"\n        self.metadata = metadata or {}\n        self.operation_history = operation_history or []\n        self._previous = previous\n\n        if channel_metadata:\n            self._channel_metadata = copy.deepcopy(channel_metadata)\n        else:\n            self._channel_metadata = [\n                ChannelMetadata(label=f\"ch{i}\", unit=\"\", extra={})\n                for i in range(self._n_channels)\n            ]\n\n        try:\n            # Display information for newer dask versions\n            logger.debug(f\"Dask graph layers: {list(self._data.dask.layers.keys())}\")\n            logger.debug(\n                f\"Dask graph dependencies: {len(self._data.dask.dependencies)}\"\n            )\n        except Exception as e:\n            logger.debug(f\"Dask graph visualization details unavailable: {e}\")\n\n    @property\n    @abstractmethod\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n\n    @property\n    def n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return len(self)\n\n    @property\n    def channels(self) -&gt; list[ChannelMetadata]:\n        \"\"\"Property to access channel metadata.\"\"\"\n        return self._channel_metadata\n\n    @property\n    def previous(self) -&gt; Optional[\"BaseFrame[Any]\"]:\n        \"\"\"\n        Returns the previous frame.\n        \"\"\"\n        return self._previous\n\n    def get_channel(self: S, channel_idx: int) -&gt; S:\n        n_channels = len(self)\n        if channel_idx &lt; 0 or channel_idx &gt;= n_channels:\n            range_max = n_channels - 1\n            raise ValueError(\n                f\"Channel index out of range: {channel_idx} \"\n                f\"(valid range: 0-{range_max})\"\n            )\n        logger.debug(f\"Extracting channel index={channel_idx} (lazy operation).\")\n        channel_data = self._data[channel_idx : channel_idx + 1]\n\n        return self._create_new_instance(\n            data=channel_data,\n            operation_history=self.operation_history,\n            channel_metadata=[self._channel_metadata[channel_idx]],\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Returns the number of channels.\n        \"\"\"\n        return len(self._channel_metadata)\n\n    def __iter__(self: S) -&gt; Iterator[S]:\n        for idx in range(len(self)):\n            yield self[idx]\n\n    def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n        \"\"\"\n        Method to get a channel by name or index.\n\n        Parameters\n        ----------\n        key : str, int, slice, or tuple of slices\n            Channel name (label) or index number.\n\n        Returns\n        -------\n        BaseFrame\n            The corresponding channel.\n\n        Raises\n        ------\n        ValueError\n            If the key length is invalid for the shape.\n        IndexError\n            If the channel index is out of range.\n        TypeError\n            If the key type is invalid.\n        \"\"\"\n        if isinstance(key, str):\n            index = self.label2index(key)\n            return self.get_channel(index)\n\n        elif isinstance(key, tuple):\n            # When key is a tuple, treat the first element as an index\n            if len(key) &gt; len(self.shape):\n                raise ValueError(\n                    f\"Invalid key length: {len(key)} for shape {self.shape}\"\n                )\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key[0]]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, slice):\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, numbers.Integral):\n            # Access by index number\n            if key &lt; 0 or key &gt;= len(self):\n                raise IndexError(f\"Channel index {key} out of range.\")\n            return self.get_channel(key)\n        else:\n            raise TypeError(\n                f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n            )\n\n    def label2index(self, label: str) -&gt; int:\n        \"\"\"\n        Get the index from a channel label.\n\n        Parameters\n        ----------\n        label : str\n            Channel label.\n\n        Returns\n        -------\n        int\n            Corresponding index.\n\n        Raises\n        ------\n        KeyError\n            If the channel label is not found.\n        \"\"\"\n        for idx, ch in enumerate(self._channel_metadata):\n            if ch.label == label:\n                return idx\n        raise KeyError(f\"Channel label '{label}' not found.\")\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        _shape: tuple[int, ...] = self._data.shape\n        return _shape\n\n    @property\n    def data(self) -&gt; T:\n        \"\"\"\n        Returns the computed data.\n        Calculation is executed the first time this is accessed.\n        \"\"\"\n        return self.compute()\n\n    @property\n    def labels(self) -&gt; list[str]:\n        \"\"\"Get a list of all channel labels.\"\"\"\n        return [ch.label for ch in self._channel_metadata]\n\n    def compute(self) -&gt; T:\n        \"\"\"\n        Compute and return the data.\n        This method materializes lazily computed data into a concrete NumPy array.\n\n        Returns\n        -------\n        NDArrayReal\n            The computed data.\n\n        Raises\n        ------\n        ValueError\n            If the computed result is not a NumPy array.\n        \"\"\"\n        logger.debug(\n            \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n        )\n        result = self._data.compute()\n\n        if not isinstance(result, np.ndarray):\n            raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n        logger.debug(f\"Computation complete, result shape: {result.shape}\")\n        return cast(T, result)\n\n    @abstractmethod\n    def plot(\n        self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n    ) -&gt; Union[Axes, Iterator[Axes]]:\n        \"\"\"Plot the data\"\"\"\n        pass\n\n    def persist(self: S) -&gt; S:\n        \"\"\"Persist the data in memory\"\"\"\n        persisted_data = self._data.persist()\n        return self._create_new_instance(data=persisted_data)\n\n    @abstractmethod\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Abstract method for derived classes to provide\n        additional initialization arguments.\n        \"\"\"\n        pass\n\n    def _create_new_instance(self: S, data: DaArray, **kwargs: Any) -&gt; S:\n        \"\"\"\n        Create a new channel instance based on an existing channel.\n        Keyword arguments can override or extend the original attributes.\n        \"\"\"\n\n        sampling_rate = kwargs.pop(\"sampling_rate\", self.sampling_rate)\n        # if not isinstance(sampling_rate, int):\n        #     raise TypeError(\"Sampling rate must be an integer\")\n\n        label = kwargs.pop(\"label\", self.label)\n        if not isinstance(label, str):\n            raise TypeError(\"Label must be a string\")\n\n        metadata = kwargs.pop(\"metadata\", copy.deepcopy(self.metadata))\n        if not isinstance(metadata, dict):\n            raise TypeError(\"Metadata must be a dictionary\")\n\n        # Get additional initialization arguments from derived classes\n        additional_kwargs = self._get_additional_init_kwargs()\n        kwargs.update(additional_kwargs)\n\n        return type(self)(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            previous=self,\n            **kwargs,\n        )\n\n    def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n        \"\"\"Implicit conversion to NumPy array\"\"\"\n        result = self.compute()\n        if dtype is not None:\n            return result.astype(dtype)\n        return result\n\n    def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n        \"\"\"Visualize the computation graph and save it to a file\"\"\"\n        try:\n            filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n            self._data.visualize(filename=filename)\n            return filename\n        except Exception as e:\n            logger.warning(f\"Failed to visualize the graph: {e}\")\n            return None\n\n    @abstractmethod\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"Basic implementation of binary operations\"\"\"\n        # Basic logic\n        # Actual implementation is left to derived classes\n        pass\n\n    def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Addition operator\"\"\"\n        return self._binary_op(other, lambda x, y: x + y, \"+\")\n\n    def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Subtraction operator\"\"\"\n        return self._binary_op(other, lambda x, y: x - y, \"-\")\n\n    def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Multiplication operator\"\"\"\n        return self._binary_op(other, lambda x, y: x * y, \"*\")\n\n    def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Division operator\"\"\"\n        return self._binary_op(other, lambda x, y: x / y, \"/\")\n\n    def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Apply a named operation.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters to pass to the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        # Apply the operation through abstract method\n        return self._apply_operation_impl(operation_name, **params)\n\n    @abstractmethod\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"Implementation of operation application\"\"\"\n        pass\n\n    def debug_info(self) -&gt; None:\n        \"\"\"Output detailed debug information\"\"\"\n        logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n        logger.debug(f\"Label: {self.label}\")\n        logger.debug(f\"Shape: {self.shape}\")\n        logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n        logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n        self._debug_info_impl()\n        logger.debug(\"=== End Debug Info ===\")\n\n    def _debug_info_impl(self) -&gt; None:\n        \"\"\"Implement derived class-specific debug information\"\"\"\n        pass\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.channels","title":"<code>channels</code>  <code>property</code>","text":"<p>Property to access channel metadata.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.data","title":"<code>data</code>  <code>property</code>","text":"<p>Returns the computed data. Calculation is executed the first time this is accessed.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>Get a list of all channel labels.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.n_channels","title":"<code>n_channels</code>  <code>property</code>","text":"<p>Returns the number of channels.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.previous","title":"<code>previous</code>  <code>property</code>","text":"<p>Returns the previous frame.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__add__","title":"<code>__add__(other)</code>","text":"<p>Addition operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Addition operator\"\"\"\n    return self._binary_op(other, lambda x, y: x + y, \"+\")\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__array__","title":"<code>__array__(dtype=None)</code>","text":"<p>Implicit conversion to NumPy array</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n    \"\"\"Implicit conversion to NumPy array\"\"\"\n    result = self.compute()\n    if dtype is not None:\n        return result.astype(dtype)\n    return result\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Method to get a channel by name or index.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__getitem__--parameters","title":"Parameters","text":"<p>key : str, int, slice, or tuple of slices     Channel name (label) or index number.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__getitem__--returns","title":"Returns","text":"<p>BaseFrame     The corresponding channel.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__getitem__--raises","title":"Raises","text":"<p>ValueError     If the key length is invalid for the shape. IndexError     If the channel index is out of range. TypeError     If the key type is invalid.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n    \"\"\"\n    Method to get a channel by name or index.\n\n    Parameters\n    ----------\n    key : str, int, slice, or tuple of slices\n        Channel name (label) or index number.\n\n    Returns\n    -------\n    BaseFrame\n        The corresponding channel.\n\n    Raises\n    ------\n    ValueError\n        If the key length is invalid for the shape.\n    IndexError\n        If the channel index is out of range.\n    TypeError\n        If the key type is invalid.\n    \"\"\"\n    if isinstance(key, str):\n        index = self.label2index(key)\n        return self.get_channel(index)\n\n    elif isinstance(key, tuple):\n        # When key is a tuple, treat the first element as an index\n        if len(key) &gt; len(self.shape):\n            raise ValueError(\n                f\"Invalid key length: {len(key)} for shape {self.shape}\"\n            )\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key[0]]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, slice):\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, numbers.Integral):\n        # Access by index number\n        if key &lt; 0 or key &gt;= len(self):\n            raise IndexError(f\"Channel index {key} out of range.\")\n        return self.get_channel(key)\n    else:\n        raise TypeError(\n            f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n        )\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of channels.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of channels.\n    \"\"\"\n    return len(self._channel_metadata)\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplication operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Multiplication operator\"\"\"\n    return self._binary_op(other, lambda x, y: x * y, \"*\")\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtraction operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Subtraction operator\"\"\"\n    return self._binary_op(other, lambda x, y: x - y, \"-\")\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Division operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Division operator\"\"\"\n    return self._binary_op(other, lambda x, y: x / y, \"/\")\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.apply_operation","title":"<code>apply_operation(operation_name, **params)</code>","text":"<p>Apply a named operation.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.apply_operation--parameters","title":"Parameters","text":"<p>operation_name : str     Name of the operation to apply. **params : Any     Parameters to pass to the operation.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.apply_operation--returns","title":"Returns","text":"<p>S     A new instance with the operation applied.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n    \"\"\"\n    Apply a named operation.\n\n    Parameters\n    ----------\n    operation_name : str\n        Name of the operation to apply.\n    **params : Any\n        Parameters to pass to the operation.\n\n    Returns\n    -------\n    S\n        A new instance with the operation applied.\n    \"\"\"\n    # Apply the operation through abstract method\n    return self._apply_operation_impl(operation_name, **params)\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.compute","title":"<code>compute()</code>","text":"<p>Compute and return the data. This method materializes lazily computed data into a concrete NumPy array.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.compute--returns","title":"Returns","text":"<p>NDArrayReal     The computed data.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.compute--raises","title":"Raises","text":"<p>ValueError     If the computed result is not a NumPy array.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def compute(self) -&gt; T:\n    \"\"\"\n    Compute and return the data.\n    This method materializes lazily computed data into a concrete NumPy array.\n\n    Returns\n    -------\n    NDArrayReal\n        The computed data.\n\n    Raises\n    ------\n    ValueError\n        If the computed result is not a NumPy array.\n    \"\"\"\n    logger.debug(\n        \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n    )\n    result = self._data.compute()\n\n    if not isinstance(result, np.ndarray):\n        raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n    logger.debug(f\"Computation complete, result shape: {result.shape}\")\n    return cast(T, result)\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.debug_info","title":"<code>debug_info()</code>","text":"<p>Output detailed debug information</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def debug_info(self) -&gt; None:\n    \"\"\"Output detailed debug information\"\"\"\n    logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n    logger.debug(f\"Label: {self.label}\")\n    logger.debug(f\"Shape: {self.shape}\")\n    logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n    logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n    self._debug_info_impl()\n    logger.debug(\"=== End Debug Info ===\")\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.label2index","title":"<code>label2index(label)</code>","text":"<p>Get the index from a channel label.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.label2index--parameters","title":"Parameters","text":"<p>label : str     Channel label.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.label2index--returns","title":"Returns","text":"<p>int     Corresponding index.</p>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.label2index--raises","title":"Raises","text":"<p>KeyError     If the channel label is not found.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def label2index(self, label: str) -&gt; int:\n    \"\"\"\n    Get the index from a channel label.\n\n    Parameters\n    ----------\n    label : str\n        Channel label.\n\n    Returns\n    -------\n    int\n        Corresponding index.\n\n    Raises\n    ------\n    KeyError\n        If the channel label is not found.\n    \"\"\"\n    for idx, ch in enumerate(self._channel_metadata):\n        if ch.label == label:\n            return idx\n    raise KeyError(f\"Channel label '{label}' not found.\")\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.persist","title":"<code>persist()</code>","text":"<p>Persist the data in memory</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def persist(self: S) -&gt; S:\n    \"\"\"Persist the data in memory\"\"\"\n    persisted_data = self._data.persist()\n    return self._create_new_instance(data=persisted_data)\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.plot","title":"<code>plot(plot_type='default', ax=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Plot the data</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>@abstractmethod\ndef plot(\n    self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n) -&gt; Union[Axes, Iterator[Axes]]:\n    \"\"\"Plot the data\"\"\"\n    pass\n</code></pre>"},{"location":"ja/api/core/#wandas.core.base_frame.BaseFrame.visualize_graph","title":"<code>visualize_graph(filename=None)</code>","text":"<p>Visualize the computation graph and save it to a file</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"Visualize the computation graph and save it to a file\"\"\"\n    try:\n        filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n        self._data.visualize(filename=filename)\n        return filename\n    except Exception as e:\n        logger.warning(f\"Failed to visualize the graph: {e}\")\n        return None\n</code></pre>"},{"location":"ja/api/core/#channelmetadata","title":"ChannelMetadata","text":"<p><code>ChannelMetadata</code>\u306f\u30c1\u30e3\u30f3\u30cd\u30eb\u3054\u3068\u306e\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u7ba1\u7406\u3059\u308b\u305f\u3081\u306e\u30af\u30e9\u30b9\u3067\u3059\u3002\u30c1\u30e3\u30f3\u30cd\u30eb\u540d\u3001\u5358\u4f4d\u3001\u305d\u306e\u4ed6\u306e\u4ed8\u52a0\u60c5\u5831\u3092\u4fdd\u6301\u3057\u307e\u3059\u3002</p> <pre><code>from wandas.core.metadata import ChannelMetadata\n\n# \u4f7f\u7528\u4f8b\nmetadata = ChannelMetadata(label=\"\u5de6\u30c1\u30e3\u30f3\u30cd\u30eb\", unit=\"dB\", extra={\"\u30c7\u30d0\u30a4\u30b9\": \"\u30de\u30a4\u30af\"})\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>Data class for storing channel metadata</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>class ChannelMetadata(BaseModel):\n    \"\"\"\n    Data class for storing channel metadata\n    \"\"\"\n\n    label: str = \"\"\n    unit: str = \"\"\n    ref: float = 1.0\n    # Additional metadata for extensibility\n    extra: dict[str, Any] = Field(default_factory=dict)\n\n    def __getitem__(self, key: str) -&gt; Any:\n        \"\"\"Provide dictionary-like behavior\"\"\"\n        if key == \"label\":\n            return self.label\n        elif key == \"unit\":\n            return self.unit\n        elif key == \"ref\":\n            return self.ref\n        else:\n            return self.extra.get(key)\n\n    def __setitem__(self, key: str, value: Any) -&gt; None:\n        \"\"\"Provide dictionary-like behavior\"\"\"\n        if key == \"label\":\n            self.label = value\n        elif key == \"unit\":\n            self.unit = value\n        elif key == \"ref\":\n            self.ref = value\n        else:\n            self.extra[key] = value\n\n    def to_json(self) -&gt; str:\n        \"\"\"Convert to JSON format\"\"\"\n        json_data: str = self.model_dump_json(indent=4)\n        return json_data\n\n    @classmethod\n    def from_json(cls, json_data: str) -&gt; \"ChannelMetadata\":\n        \"\"\"Convert from JSON format\"\"\"\n        root_model: ChannelMetadata = ChannelMetadata.model_validate_json(json_data)\n\n        return root_model\n</code></pre>"},{"location":"ja/api/core/#wandas.core.metadata.ChannelMetadata.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Provide dictionary-like behavior</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Any:\n    \"\"\"Provide dictionary-like behavior\"\"\"\n    if key == \"label\":\n        return self.label\n    elif key == \"unit\":\n        return self.unit\n    elif key == \"ref\":\n        return self.ref\n    else:\n        return self.extra.get(key)\n</code></pre>"},{"location":"ja/api/core/#wandas.core.metadata.ChannelMetadata.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Provide dictionary-like behavior</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def __setitem__(self, key: str, value: Any) -&gt; None:\n    \"\"\"Provide dictionary-like behavior\"\"\"\n    if key == \"label\":\n        self.label = value\n    elif key == \"unit\":\n        self.unit = value\n    elif key == \"ref\":\n        self.ref = value\n    else:\n        self.extra[key] = value\n</code></pre>"},{"location":"ja/api/core/#wandas.core.metadata.ChannelMetadata.from_json","title":"<code>from_json(json_data)</code>  <code>classmethod</code>","text":"<p>Convert from JSON format</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>@classmethod\ndef from_json(cls, json_data: str) -&gt; \"ChannelMetadata\":\n    \"\"\"Convert from JSON format\"\"\"\n    root_model: ChannelMetadata = ChannelMetadata.model_validate_json(json_data)\n\n    return root_model\n</code></pre>"},{"location":"ja/api/core/#wandas.core.metadata.ChannelMetadata.to_json","title":"<code>to_json()</code>","text":"<p>Convert to JSON format</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Convert to JSON format\"\"\"\n    json_data: str = self.model_dump_json(indent=4)\n    return json_data\n</code></pre>"},{"location":"ja/api/frames/","title":"\u30d5\u30ec\u30fc\u30e0\u30e2\u30b8\u30e5\u30fc\u30eb\uff08Frames\uff09","text":"<p>\u3053\u306e\u30da\u30fc\u30b8\u3067\u306fWandas\u306e\u30d5\u30ec\u30fc\u30e0\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002\u30d5\u30ec\u30fc\u30e0\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u306f\u3001\u3055\u307e\u3056\u307e\u306a\u30bf\u30a4\u30d7\u306e\u30c7\u30fc\u30bf\u30d5\u30ec\u30fc\u30e0\u304c\u542b\u307e\u308c\u3066\u3044\u307e\u3059\u3002</p>"},{"location":"ja/api/frames/#channelframe","title":"ChannelFrame","text":"<p><code>ChannelFrame</code>\u306f\u6642\u9593\u9818\u57df\u306e\u4fe1\u53f7\u30c7\u30fc\u30bf\u3092\u6271\u3046\u30d5\u30ec\u30fc\u30e0\u3067\u3059\u3002</p> <pre><code>from wandas.frames.channel import ChannelFrame\n\n# \u307e\u305f\u306f\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")  # ChannelFrame\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u8fd4\u3057\u307e\u3059\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Channel-based data frame for handling audio signals and time series data.</p> <p>This frame represents channel-based data such as audio signals and time series data, with each channel containing data samples in the time domain.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>class ChannelFrame(BaseFrame[NDArrayReal]):\n    \"\"\"Channel-based data frame for handling audio signals and time series data.\n\n    This frame represents channel-based data such as audio signals and time series data,\n    with each channel containing data samples in the time domain.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"Initialize a ChannelFrame.\n\n        Args:\n            data: Dask array containing channel data.\n            Shape should be (n_channels, n_samples).\n            sampling_rate: The sampling rate of the data in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            operation_history: History of operations applied to the frame.\n            channel_metadata: Metadata for each channel.\n            previous: Reference to the previous frame in the processing chain.\n\n        Raises:\n            ValueError: If data has more than 2 dimensions.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return self.shape[-2]\n\n    @property\n    def time(self) -&gt; NDArrayReal:\n        \"\"\"Get time array for the signal.\n\n        Returns:\n            Array of time points in seconds.\n        \"\"\"\n        return np.arange(self.n_samples) / self.sampling_rate\n\n    @property\n    def n_samples(self) -&gt; int:\n        \"\"\"Returns the number of samples.\"\"\"\n        n: int = self._data.shape[-1]\n        return n\n\n    @property\n    def duration(self) -&gt; float:\n        \"\"\"Returns the duration in seconds.\"\"\"\n        return self.n_samples / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # Apply processing to data\n        processed_data = operation.process(self._data)\n\n        # Update metadata\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        if operation_name == \"resampling\":\n            # For resampling, update sampling rate\n            return self._create_new_instance(\n                sampling_rate=params[\"target_sr\"],\n                data=processed_data,\n                metadata=new_metadata,\n                operation_history=new_history,\n            )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Common implementation for binary operations\n        - utilizing dask's lazy evaluation.\n\n        Args:\n            other: Right operand for the operation.\n            op: Function to execute the operation (e.g., lambda a, b: a + b).\n            symbol: Symbolic representation of the operation (e.g., '+').\n\n        Returns:\n            A new channel containing the operation result (lazy execution).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, ChannelFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Perform operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other._data)\n\n            # Merge channel metadata\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # Perform operation with scalar, NumPy array, or other types\n        else:\n            # Apply operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other)\n\n            # Operand display string\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # Check for dask.array.Array\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # Update channel metadata\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n                previous=self,\n            )\n\n    def add(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n        snr: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Add another signal or value to the current signal.\n\n        If SNR is specified, performs addition with consideration for\n        signal-to-noise ratio.\n\n        Args:\n            other: Signal or value to add.\n            snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n                other signal based on this SNR.\n                self is treated as the signal, and other as the noise.\n\n        Returns:\n            A new channel frame containing the addition result (lazy execution).\n        \"\"\"\n        logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n        # Special processing when SNR is specified\n        if snr is not None:\n            # First convert other to ChannelFrame if it's not\n            if not isinstance(other, ChannelFrame):\n                if isinstance(other, np.ndarray):\n                    other = ChannelFrame.from_numpy(\n                        other, self.sampling_rate, label=\"array_data\"\n                    )\n                elif isinstance(other, (int, float)):\n                    # For scalar values, simply add (ignore SNR)\n                    return self + other\n                else:\n                    raise TypeError(\n                        \"Addition target with SNR must be a ChannelFrame or \"\n                        f\"NumPy array: {type(other)}\"\n                    )\n\n            # Check if sampling rates match\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Apply addition operation with SNR adjustment\n            return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n        # Execute normal addition if SNR is not specified\n        return self + other\n\n    def plot(\n        self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Plot the frame data.\n\n        Args:\n            plot_type: Type of plot. Default is \"waveform\".\n            ax: Optional matplotlib axes for plotting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        plot_strategy = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def rms_plot(\n        self,\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = True,\n        Aw: bool = False,  # noqa: N803\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Generate an RMS plot.\n\n        Args:\n            ax: Optional matplotlib axes for plotting.\n            title: Title for the plot.\n            overlay: Whether to overlay the plot on the existing axis.\n            Aw: Apply A-weighting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        kwargs = kwargs or {}\n        ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n        rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n        return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n\n    def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n        \"\"\"Display visual and audio representation of the frame.\n\n        Args:\n            normalize: Whether to normalize the audio data for playback.\n            **kwargs: Additional parameters for visualization.\n        \"\"\"\n        if \"axis_config\" in kwargs:\n            logger.warning(\n                \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            axis_config = kwargs[\"axis_config\"]\n            if \"time_plot\" in axis_config:\n                kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n            if \"freq_plot\" in axis_config:\n                if \"xlim\" in axis_config[\"freq_plot\"]:\n                    vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                    kwargs[\"vmin\"] = vlim[0]\n                    kwargs[\"vmax\"] = vlim[1]\n                if \"ylim\" in axis_config[\"freq_plot\"]:\n                    ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                    kwargs[\"ylim\"] = ylim\n\n        if \"cbar_config\" in kwargs:\n            logger.warning(\n                \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            cbar_config = kwargs[\"cbar_config\"]\n            if \"vmin\" in cbar_config:\n                kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n            if \"vmax\" in cbar_config:\n                kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n        for ch in self:\n            ax: Axes\n            _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n            if isinstance(_ax, Iterator):\n                ax = next(iter(_ax))\n            elif isinstance(_ax, Axes):\n                ax = _ax\n            else:\n                raise TypeError(\n                    f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n                )\n            # Ignore type checks for display and Audio\n            display(ax.figure)  # type: ignore\n            plt.close(ax.figure)  # type: ignore\n            display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n\n    @classmethod\n    def from_numpy(\n        cls,\n        data: NDArrayReal,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        ch_labels: Optional[list[str]] = None,\n        ch_units: Optional[Union[list[str], str]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        Args:\n            data: NumPy array containing channel data.\n            sampling_rate: The sampling rate in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            ch_labels: Labels for each channel.\n            ch_units: Units for each channel.\n\n        Returns:\n            A new ChannelFrame containing the NumPy data.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n\n        # Convert NumPy array to dask array\n        dask_data = da_from_array(data)\n        cf = ChannelFrame(\n            data=dask_data,\n            sampling_rate=sampling_rate,\n            label=label or \"numpy_data\",\n        )\n        if metadata is not None:\n            cf.metadata = metadata\n        if ch_labels is not None:\n            if len(ch_labels) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel labels does not match the number of channels\"\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        if ch_units is not None:\n            if isinstance(ch_units, str):\n                ch_units = [ch_units] * cf.n_channels\n\n            if len(ch_units) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel units does not match the number of channels\"\n                )\n            for i in range(len(ch_units)):\n                cf._channel_metadata[i].unit = ch_units[i]\n\n        return cf\n\n    @classmethod\n    def from_ndarray(\n        cls,\n        array: NDArrayReal,\n        sampling_rate: float,\n        labels: Optional[list[str]] = None,\n        unit: Optional[Union[list[str], str]] = None,\n        frame_label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        This method is deprecated. Use from_numpy instead.\n\n        Args:\n            array: Signal data. Each row corresponds to a channel.\n            sampling_rate: Sampling rate (Hz).\n            labels: Labels for each channel.\n            unit: Unit of the signal.\n            frame_label: Label for the frame.\n            metadata: Optional metadata dictionary.\n\n        Returns:\n            A new ChannelFrame containing the data.\n        \"\"\"\n        # Redirect to from_numpy for compatibility\n        # However, from_ndarray is deprecated\n        logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n        return cls.from_numpy(\n            data=array,\n            sampling_rate=sampling_rate,\n            label=frame_label,\n            metadata=metadata,\n            ch_labels=labels,\n            ch_units=unit,\n        )\n\n    @classmethod\n    def from_file(\n        cls,\n        path: Union[str, Path],\n        channel: Optional[Union[int, list[int]]] = None,\n        start: Optional[float] = None,\n        end: Optional[float] = None,\n        chunk_size: Optional[int] = None,\n        ch_labels: Optional[list[str]] = None,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from an audio file.\n\n        Args:\n            path: Path to the audio file.\n            channel: Channel(s) to load.\n            start: Start time in seconds.\n            end: End time in seconds.\n            chunk_size: Chunk size for processing.\n            Specifies the splitting size for lazy processing.\n            ch_labels: Labels for each channel.\n            **kwargs: Additional arguments passed to the file reader.\n\n        Returns:\n            A new ChannelFrame containing the loaded audio data.\n\n        Raises:\n            ValueError: If channel selection is invalid.\n            TypeError: If channel parameter type is invalid.\n            FileNotFoundError: If the file doesn't exist.\n        \"\"\"\n        from .channel import ChannelFrame\n\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"File not found: {path}\")\n\n        # Get file reader\n        reader = get_file_reader(path)\n\n        # Get file info\n        info = reader.get_file_info(path, **kwargs)\n        sr = info[\"samplerate\"]\n        n_channels = info[\"channels\"]\n        n_frames = info[\"frames\"]\n        ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n        logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n        # Channel selection processing\n        all_channels = list(range(n_channels))\n\n        if channel is None:\n            channels_to_load = all_channels\n            logger.debug(f\"Will load all channels: {channels_to_load}\")\n        elif isinstance(channel, int):\n            if channel &lt; 0 or channel &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n            channels_to_load = [channel]\n            logger.debug(f\"Will load single channel: {channel}\")\n        elif isinstance(channel, (list, tuple)):\n            for ch in channel:\n                if ch &lt; 0 or ch &gt;= n_channels:\n                    raise ValueError(\n                        f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                    )\n            channels_to_load = list(channel)\n            logger.debug(f\"Will load specific channels: {channels_to_load}\")\n        else:\n            raise TypeError(\"channel must be int, list, or None\")\n\n        # Index calculation\n        start_idx = 0 if start is None else max(0, int(start * sr))\n        end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n        frames_to_read = end_idx - start_idx\n\n        logger.debug(\n            f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n            f\"start_idx={start_idx}, end_idx={end_idx}\"\n        )\n\n        # Settings for lazy loading\n        expected_shape = (len(channels_to_load), frames_to_read)\n\n        # Define the loading function using the file reader\n        def _load_audio() -&gt; NDArrayReal:\n            logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n            # Use the reader to get audio data with parameters\n            out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n            if not isinstance(out, np.ndarray):\n                raise ValueError(\"Unexpected data type after reading file\")\n            return out\n\n        logger.debug(\n            f\"Creating delayed dask task with expected shape: {expected_shape}\"\n        )\n\n        # Create delayed operation\n        delayed_data = dask_delayed(_load_audio)()\n        logger.debug(\"Wrapping delayed function in dask array\")\n\n        # Create dask array from delayed computation\n        dask_array = da_from_delayed(\n            delayed_data, shape=expected_shape, dtype=np.float32\n        )\n\n        if chunk_size is not None:\n            if chunk_size &lt;= 0:\n                raise ValueError(\"Chunk size must be a positive integer\")\n            logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n            dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n        logger.debug(\n            \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n        )\n\n        cf = ChannelFrame(\n            data=dask_array,\n            sampling_rate=sr,\n            label=path.stem,\n            metadata={\n                \"filename\": str(path),\n            },\n        )\n        if ch_labels is not None:\n            if len(ch_labels) != len(cf):\n                raise ValueError(\n                    \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        return cf\n\n    @classmethod\n    def read_wav(\n        cls, filename: str, labels: Optional[list[str]] = None\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a WAV file.\n\n        Args:\n            filename: Path to the WAV file.\n            labels: Labels to set for each channel.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(filename, ch_labels=labels)\n        return cf\n\n    @classmethod\n    def read_csv(\n        cls,\n        filename: str,\n        time_column: Union[int, str] = 0,\n        labels: Optional[list[str]] = None,\n        delimiter: str = \",\",\n        header: Optional[int] = 0,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a CSV file.\n\n        Args:\n            filename: Path to the CSV file.\n            time_column: Index or name of the time column.\n            labels: Labels to set for each channel.\n            delimiter: Delimiter character.\n            header: Row number to use as header.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(\n            filename,\n            ch_labels=labels,\n            time_column=time_column,\n            delimiter=delimiter,\n            header=header,\n        )\n        return cf\n\n    def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n        \"\"\"Save the audio data to a file.\n\n        Args:\n            path: Path to save the file.\n            format: File format. If None, determined from file extension.\n        \"\"\"\n        logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n        data = self.compute()\n        data = data.T\n        if data.shape[1] == 1:\n            data = data.squeeze(axis=1)\n        sf.write(str(path), data, int(self.sampling_rate), format=format)\n        logger.debug(f\"Save complete: {path}\")\n\n    def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a high-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n\n    def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n        \"\"\"Apply a low-pass filter to the signal.\n\n        Args:\n            cutoff: The cutoff frequency of the filter in Hz.\n            order: The order of the filter. Default is 4.\n\n        Returns:\n            A new ChannelFrame with the filtered signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n\n    def normalize(\n        self, target_level: float = -20, channel_wise: bool = True\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Normalize the signal level.\n\n        This method adjusts the signal amplitude to reach a target RMS level.\n\n        Args:\n            target_level: Target RMS level in dB. Default is -20.\n            channel_wise: If True, normalize each channel independently.\n                If False, apply the same scaling to all channels.\n\n        Returns:\n            A new ChannelFrame containing the normalized signal.\n        \"\"\"\n        logger.debug(\n            f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n        )\n        return self.apply_operation(\n            \"normalize\", target_level=target_level, channel_wise=channel_wise\n        )\n\n    def a_weighting(self) -&gt; \"ChannelFrame\":\n        \"\"\"Apply A-weighting filter to the signal.\n\n        A-weighting adjusts the frequency response to approximate human hearing\n        perception, following IEC 61672-1:2013 standard.\n\n        Returns:\n            A new ChannelFrame with A-weighted signal.\n        \"\"\"\n        return self.apply_operation(\"a_weighting\")\n\n    def hpss_harmonic(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract harmonic components using HPSS\n         (Harmonic-Percussive Source Separation).\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_harmonic\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def hpss_percussive(\n        self,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Extract percussive components using HPSS\n        (Harmonic-Percussive Source Separation).\n\n        This method separates the percussive (tonal) components from the signal.\n\n        Args:\n            kernel_size: Median filter size for HPSS.\n            power: Exponent for the Weiner filter used in HPSS.\n            margin: Margin size for the separation.\n\n        Returns:\n            A new ChannelFrame containing the harmonic components.\n        \"\"\"\n        return self.apply_operation(\n            \"hpss_percussive\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n\n    def resampling(\n        self,\n        target_sr: float,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Resample audio data.\n\n        Parameters\n        ----------\n        target_sr : float\n            Target sampling rate (Hz)\n        resample_type : str, optional\n            Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n        **kwargs : dict\n            Additional resampling parameters\n\n        Returns\n        -------\n        ChannelFrame\n            Resampled channel frame\n        \"\"\"\n        return self.apply_operation(\n            \"resampling\",\n            target_sr=target_sr,\n            **kwargs,\n        )\n\n    def abs(self) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the absolute value of the signal.\n\n        Returns:\n            A new ChannelFrame containing the absolute values.\n        \"\"\"\n        return self.apply_operation(\"abs\")\n\n    def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the power of the signal.\n\n        Args:\n            exponent: The exponent to raise the signal to. Default is 2.0.\n\n        Returns:\n            A new ChannelFrame containing the signal raised to the power.\n        \"\"\"\n        return self.apply_operation(\"power\", exponent=exponent)\n\n    def trim(\n        self,\n        start: float = 0,\n        end: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Trim the signal to specified time range.\n\n        Args:\n            start: Start time in seconds.\n            end: End time in seconds.\n\n        Returns:\n            A new ChannelFrame with trimmed signal.\n\n        Raises:\n            ValueError: If end time is before start time.\n        \"\"\"\n        if end is None:\n            end = self.duration\n        if start &gt; end:\n            raise ValueError(\"start must be less than end\")\n        # Apply trim operation\n        return self.apply_operation(\"trim\", start=start, end=end)\n\n    def rms_trend(\n        self,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate the RMS trend of the signal.\n\n        This method computes the root mean square value over sliding windows.\n\n        Args:\n            frame_length: The size of the sliding window in samples. Default is 2048.\n            hop_length: The hop length between windows in samples. Default is 512.\n            dB: Whether to return the RMS values in decibels. Default is False.\n            Aw: Whether to apply A-weighting. Default is False.\n\n        Returns:\n            A new ChannelFrame containing the RMS trend.\n        \"\"\"\n        cf = self.apply_operation(\n            \"rms_trend\",\n            frame_length=frame_length,\n            hop_length=hop_length,\n            ref=[ch.ref for ch in self._channel_metadata],\n            dB=dB,\n            Aw=Aw,\n        )\n        cf.sampling_rate = self.sampling_rate / hop_length\n        return cf\n\n    def sum(self) -&gt; \"ChannelFrame\":\n        \"\"\"Sum all channels.\n\n        Returns:\n            A new ChannelFrame with summed signal.\n        \"\"\"\n        return self.apply_operation(\"sum\")\n\n    def mean(self) -&gt; \"ChannelFrame\":\n        \"\"\"Average all channels.\n\n        Returns:\n            A new ChannelFrame with averaged signal.\n        \"\"\"\n        return self.apply_operation(\"mean\")\n\n    def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n        \"\"\"Calculate channel differences relative to a reference channel.\n\n        Args:\n            other_channel: Reference channel index or label. Default is 0.\n\n        Returns:\n            A new ChannelFrame with channel differences.\n        \"\"\"\n        if isinstance(other_channel, str):\n            return self.apply_operation(\n                \"channel_difference\", other_channel=self.label2index(other_channel)\n            )\n        return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n\n    def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n        \"\"\"Compute Fast Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is next power of 2 of data length.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectralFrame containing the FFT results.\n        \"\"\"\n        from ..processing.time_series import FFT\n        from .spectral import SpectralFrame\n\n        params = {\"n_fft\": n_fft, \"window\": window}\n        operation_name = \"fft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"FFT\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        if n_fft is None:\n            is_even = spectrum_data.shape[-1] % 2 == 0\n            _n_fft = (\n                spectrum_data.shape[-1] * 2 - 2\n                if is_even\n                else spectrum_data.shape[-1] * 2 - 1\n            )\n        else:\n            _n_fft = n_fft\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=_n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def welch(\n        self,\n        n_fft: Optional[int] = None,\n        hop_length: Optional[int] = None,\n        win_length: int = 2048,\n        window: str = \"hann\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute power spectral density using Welch's method.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the power spectral density.\n        \"\"\"\n        from ..processing.time_series import Welch\n        from .spectral import SpectralFrame\n\n        params = dict(\n            n_fft=n_fft or win_length,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            average=average,\n        )\n        operation_name = \"welch\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Welch\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"welch\", \"params\": params},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def noct_spectrum(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"Compute N-octave band spectrum.\n\n        Args:\n            fmin: Minimum center frequency in Hz. Default is 20 Hz.\n            fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n            n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n            G: Reference gain in dB. Default is 10 dB.\n            fr: Reference frequency in Hz. Default is 1000 Hz.\n\n        Returns:\n            A NOctFrame containing the N-octave band spectrum.\n        \"\"\"\n        from ..processing.time_series import NOctSpectrum\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_spectrum\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSpectrum\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_spectrum\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def stft(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"Compute Short-Time Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            A SpectrogramFrame containing the STFT results.\n        \"\"\"\n        from ..processing.time_series import STFT, create_operation\n        from .spectrogram import SpectrogramFrame\n\n        # Set hop length and window length\n        _hop_length = hop_length if hop_length is not None else n_fft // 4\n        _win_length = win_length if win_length is not None else n_fft\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": _hop_length,\n            \"win_length\": _win_length,\n            \"window\": window,\n        }\n        operation_name = \"stft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"STFT\", operation)\n\n        # Apply processing to data\n        spectrogram_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n\n        # Create new instance\n        return SpectrogramFrame(\n            data=spectrogram_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=n_fft,\n            hop_length=_hop_length,\n            win_length=_win_length,\n            window=window,\n            label=f\"stft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def coherence(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute magnitude squared coherence.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n        Returns:\n            A SpectralFrame containing the magnitude squared coherence.\n        \"\"\"\n        from ..processing.time_series import Coherence, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n        }\n        operation_name = \"coherence\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Coherence\", operation)\n\n        # Apply processing to data\n        coherence_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=coherence_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Coherence of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def csd(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute cross-spectral density matrix.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the cross-spectral density matrix.\n        \"\"\"\n        from ..processing.time_series import CSD, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"csd\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"CSD\", operation)\n\n        # Apply processing to data\n        csd_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=csd_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def transfer_function(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Compute transfer function matrix.\n\n        The transfer function characterizes the signal transmission properties\n        between channels in the frequency domain, representing the input-output\n        relationship of a system.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between successive frames.\n            Default is n_fft//4.\n            win_length: Length of window. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrending method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            A SpectralFrame containing the transfer function matrix.\n        \"\"\"\n        from ..processing.time_series import TransferFunction, create_operation\n        from .spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"transfer_function\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"TransferFunction\", operation)\n\n        # Apply processing to data\n        tf_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=tf_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Transfer function of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=self,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"Provide additional initialization arguments required for ChannelFrame.\"\"\"\n        return {}\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Returns the duration in seconds.</p>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>Returns the number of samples.</p>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.time","title":"<code>time</code>  <code>property</code>","text":"<p>Get time array for the signal.</p> <p>Returns:</p> Type Description <code>NDArrayReal</code> <p>Array of time points in seconds.</p>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.__init__","title":"<code>__init__(data, sampling_rate, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a ChannelFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>Dask array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate of the data in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>operation_history</code> <code>Optional[list[dict[str, Any]]]</code> <p>History of operations applied to the frame.</p> <code>None</code> <code>channel_metadata</code> <code>Optional[list[ChannelMetadata]]</code> <p>Metadata for each channel.</p> <code>None</code> <code>previous</code> <code>Optional[BaseFrame[Any]]</code> <p>Reference to the previous frame in the processing chain.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has more than 2 dimensions.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"Initialize a ChannelFrame.\n\n    Args:\n        data: Dask array containing channel data.\n        Shape should be (n_channels, n_samples).\n        sampling_rate: The sampling rate of the data in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        operation_history: History of operations applied to the frame.\n        channel_metadata: Metadata for each channel.\n        previous: Reference to the previous frame in the processing chain.\n\n    Raises:\n        ValueError: If data has more than 2 dimensions.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.a_weighting","title":"<code>a_weighting()</code>","text":"<p>Apply A-weighting filter to the signal.</p> <p>A-weighting adjusts the frequency response to approximate human hearing perception, following IEC 61672-1:2013 standard.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with A-weighted signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def a_weighting(self) -&gt; \"ChannelFrame\":\n    \"\"\"Apply A-weighting filter to the signal.\n\n    A-weighting adjusts the frequency response to approximate human hearing\n    perception, following IEC 61672-1:2013 standard.\n\n    Returns:\n        A new ChannelFrame with A-weighted signal.\n    \"\"\"\n    return self.apply_operation(\"a_weighting\")\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.abs","title":"<code>abs()</code>","text":"<p>Calculate the absolute value of the signal.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the absolute values.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def abs(self) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the absolute value of the signal.\n\n    Returns:\n        A new ChannelFrame containing the absolute values.\n    \"\"\"\n    return self.apply_operation(\"abs\")\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.add","title":"<code>add(other, snr=None)</code>","text":"<p>Add another signal or value to the current signal.</p> <p>If SNR is specified, performs addition with consideration for signal-to-noise ratio.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[ChannelFrame, int, float, NDArrayReal, Array]</code> <p>Signal or value to add.</p> required <code>snr</code> <code>Optional[float]</code> <p>Signal-to-noise ratio (dB). If specified, adjusts the scale of the other signal based on this SNR. self is treated as the signal, and other as the noise.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new channel frame containing the addition result (lazy execution).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def add(\n    self,\n    other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaArray\"],\n    snr: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Add another signal or value to the current signal.\n\n    If SNR is specified, performs addition with consideration for\n    signal-to-noise ratio.\n\n    Args:\n        other: Signal or value to add.\n        snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n            other signal based on this SNR.\n            self is treated as the signal, and other as the noise.\n\n    Returns:\n        A new channel frame containing the addition result (lazy execution).\n    \"\"\"\n    logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n    # Special processing when SNR is specified\n    if snr is not None:\n        # First convert other to ChannelFrame if it's not\n        if not isinstance(other, ChannelFrame):\n            if isinstance(other, np.ndarray):\n                other = ChannelFrame.from_numpy(\n                    other, self.sampling_rate, label=\"array_data\"\n                )\n            elif isinstance(other, (int, float)):\n                # For scalar values, simply add (ignore SNR)\n                return self + other\n            else:\n                raise TypeError(\n                    \"Addition target with SNR must be a ChannelFrame or \"\n                    f\"NumPy array: {type(other)}\"\n                )\n\n        # Check if sampling rates match\n        if self.sampling_rate != other.sampling_rate:\n            raise ValueError(\n                \"Sampling rates do not match. Cannot perform operation.\"\n            )\n\n        # Apply addition operation with SNR adjustment\n        return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n    # Execute normal addition if SNR is not specified\n    return self + other\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.channel_difference","title":"<code>channel_difference(other_channel=0)</code>","text":"<p>Calculate channel differences relative to a reference channel.</p> <p>Parameters:</p> Name Type Description Default <code>other_channel</code> <code>Union[int, str]</code> <p>Reference channel index or label. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with channel differences.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def channel_difference(self, other_channel: Union[int, str] = 0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate channel differences relative to a reference channel.\n\n    Args:\n        other_channel: Reference channel index or label. Default is 0.\n\n    Returns:\n        A new ChannelFrame with channel differences.\n    \"\"\"\n    if isinstance(other_channel, str):\n        return self.apply_operation(\n            \"channel_difference\", other_channel=self.label2index(other_channel)\n        )\n    return self.apply_operation(\"channel_difference\", other_channel=other_channel)\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.coherence","title":"<code>coherence(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant')</code>","text":"<p>Compute magnitude squared coherence.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the magnitude squared coherence.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def coherence(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute magnitude squared coherence.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n\n    Returns:\n        A SpectralFrame containing the magnitude squared coherence.\n    \"\"\"\n    from ..processing.time_series import Coherence, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n    }\n    operation_name = \"coherence\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Coherence\", operation)\n\n    # Apply processing to data\n    coherence_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=coherence_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Coherence of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.csd","title":"<code>csd(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute cross-spectral density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the cross-spectral density matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def csd(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute cross-spectral density matrix.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the cross-spectral density matrix.\n    \"\"\"\n    from ..processing.time_series import CSD, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"csd\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"CSD\", operation)\n\n    # Apply processing to data\n    csd_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=csd_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.describe","title":"<code>describe(normalize=True, **kwargs)</code>","text":"<p>Display visual and audio representation of the frame.</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>Whether to normalize the audio data for playback.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for visualization.</p> <code>{}</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def describe(self, normalize: bool = True, **kwargs: Any) -&gt; None:\n    \"\"\"Display visual and audio representation of the frame.\n\n    Args:\n        normalize: Whether to normalize the audio data for playback.\n        **kwargs: Additional parameters for visualization.\n    \"\"\"\n    if \"axis_config\" in kwargs:\n        logger.warning(\n            \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        axis_config = kwargs[\"axis_config\"]\n        if \"time_plot\" in axis_config:\n            kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n        if \"freq_plot\" in axis_config:\n            if \"xlim\" in axis_config[\"freq_plot\"]:\n                vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                kwargs[\"vmin\"] = vlim[0]\n                kwargs[\"vmax\"] = vlim[1]\n            if \"ylim\" in axis_config[\"freq_plot\"]:\n                ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                kwargs[\"ylim\"] = ylim\n\n    if \"cbar_config\" in kwargs:\n        logger.warning(\n            \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        cbar_config = kwargs[\"cbar_config\"]\n        if \"vmin\" in cbar_config:\n            kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n        if \"vmax\" in cbar_config:\n            kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n    for ch in self:\n        ax: Axes\n        _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n        if isinstance(_ax, Iterator):\n            ax = next(iter(_ax))\n        elif isinstance(_ax, Axes):\n            ax = _ax\n        else:\n            raise TypeError(\n                f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n            )\n        # Ignore type checks for display and Audio\n        display(ax.figure)  # type: ignore\n        plt.close(ax.figure)  # type: ignore\n        display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))  # type: ignore\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.fft","title":"<code>fft(n_fft=None, window='hann')</code>","text":"<p>Compute Fast Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is next power of 2 of data length.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the FFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def fft(self, n_fft: Optional[int] = None, window: str = \"hann\") -&gt; \"SpectralFrame\":\n    \"\"\"Compute Fast Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is next power of 2 of data length.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectralFrame containing the FFT results.\n    \"\"\"\n    from ..processing.time_series import FFT\n    from .spectral import SpectralFrame\n\n    params = {\"n_fft\": n_fft, \"window\": window}\n    operation_name = \"fft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"FFT\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    if n_fft is None:\n        is_even = spectrum_data.shape[-1] % 2 == 0\n        _n_fft = (\n            spectrum_data.shape[-1] * 2 - 2\n            if is_even\n            else spectrum_data.shape[-1] * 2 - 1\n        )\n    else:\n        _n_fft = n_fft\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=_n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.from_file","title":"<code>from_file(path, channel=None, start=None, end=None, chunk_size=None, ch_labels=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from an audio file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the audio file.</p> required <code>channel</code> <code>Optional[Union[int, list[int]]]</code> <p>Channel(s) to load.</p> <code>None</code> <code>start</code> <code>Optional[float]</code> <p>Start time in seconds.</p> <code>None</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <code>chunk_size</code> <code>Optional[int]</code> <p>Chunk size for processing.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the file reader.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the loaded audio data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If channel selection is invalid.</p> <code>TypeError</code> <p>If channel parameter type is invalid.</p> <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    path: Union[str, Path],\n    channel: Optional[Union[int, list[int]]] = None,\n    start: Optional[float] = None,\n    end: Optional[float] = None,\n    chunk_size: Optional[int] = None,\n    ch_labels: Optional[list[str]] = None,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from an audio file.\n\n    Args:\n        path: Path to the audio file.\n        channel: Channel(s) to load.\n        start: Start time in seconds.\n        end: End time in seconds.\n        chunk_size: Chunk size for processing.\n        Specifies the splitting size for lazy processing.\n        ch_labels: Labels for each channel.\n        **kwargs: Additional arguments passed to the file reader.\n\n    Returns:\n        A new ChannelFrame containing the loaded audio data.\n\n    Raises:\n        ValueError: If channel selection is invalid.\n        TypeError: If channel parameter type is invalid.\n        FileNotFoundError: If the file doesn't exist.\n    \"\"\"\n    from .channel import ChannelFrame\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    # Get file reader\n    reader = get_file_reader(path)\n\n    # Get file info\n    info = reader.get_file_info(path, **kwargs)\n    sr = info[\"samplerate\"]\n    n_channels = info[\"channels\"]\n    n_frames = info[\"frames\"]\n    ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n    logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n    # Channel selection processing\n    all_channels = list(range(n_channels))\n\n    if channel is None:\n        channels_to_load = all_channels\n        logger.debug(f\"Will load all channels: {channels_to_load}\")\n    elif isinstance(channel, int):\n        if channel &lt; 0 or channel &gt;= n_channels:\n            raise ValueError(\n                f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n            )\n        channels_to_load = [channel]\n        logger.debug(f\"Will load single channel: {channel}\")\n    elif isinstance(channel, (list, tuple)):\n        for ch in channel:\n            if ch &lt; 0 or ch &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n        channels_to_load = list(channel)\n        logger.debug(f\"Will load specific channels: {channels_to_load}\")\n    else:\n        raise TypeError(\"channel must be int, list, or None\")\n\n    # Index calculation\n    start_idx = 0 if start is None else max(0, int(start * sr))\n    end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n    frames_to_read = end_idx - start_idx\n\n    logger.debug(\n        f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n        f\"start_idx={start_idx}, end_idx={end_idx}\"\n    )\n\n    # Settings for lazy loading\n    expected_shape = (len(channels_to_load), frames_to_read)\n\n    # Define the loading function using the file reader\n    def _load_audio() -&gt; NDArrayReal:\n        logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n        # Use the reader to get audio data with parameters\n        out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n        if not isinstance(out, np.ndarray):\n            raise ValueError(\"Unexpected data type after reading file\")\n        return out\n\n    logger.debug(\n        f\"Creating delayed dask task with expected shape: {expected_shape}\"\n    )\n\n    # Create delayed operation\n    delayed_data = dask_delayed(_load_audio)()\n    logger.debug(\"Wrapping delayed function in dask array\")\n\n    # Create dask array from delayed computation\n    dask_array = da_from_delayed(\n        delayed_data, shape=expected_shape, dtype=np.float32\n    )\n\n    if chunk_size is not None:\n        if chunk_size &lt;= 0:\n            raise ValueError(\"Chunk size must be a positive integer\")\n        logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n        dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n    logger.debug(\n        \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n    )\n\n    cf = ChannelFrame(\n        data=dask_array,\n        sampling_rate=sr,\n        label=path.stem,\n        metadata={\n            \"filename\": str(path),\n        },\n    )\n    if ch_labels is not None:\n        if len(ch_labels) != len(cf):\n            raise ValueError(\n                \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    return cf\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.from_ndarray","title":"<code>from_ndarray(array, sampling_rate, labels=None, unit=None, frame_label=None, metadata=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>This method is deprecated. Use from_numpy instead.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>NDArrayReal</code> <p>Signal data. Each row corresponds to a channel.</p> required <code>sampling_rate</code> <code>float</code> <p>Sampling rate (Hz).</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>unit</code> <code>Optional[Union[list[str], str]]</code> <p>Unit of the signal.</p> <code>None</code> <code>frame_label</code> <code>Optional[str]</code> <p>Label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_ndarray(\n    cls,\n    array: NDArrayReal,\n    sampling_rate: float,\n    labels: Optional[list[str]] = None,\n    unit: Optional[Union[list[str], str]] = None,\n    frame_label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    This method is deprecated. Use from_numpy instead.\n\n    Args:\n        array: Signal data. Each row corresponds to a channel.\n        sampling_rate: Sampling rate (Hz).\n        labels: Labels for each channel.\n        unit: Unit of the signal.\n        frame_label: Label for the frame.\n        metadata: Optional metadata dictionary.\n\n    Returns:\n        A new ChannelFrame containing the data.\n    \"\"\"\n    # Redirect to from_numpy for compatibility\n    # However, from_ndarray is deprecated\n    logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n    return cls.from_numpy(\n        data=array,\n        sampling_rate=sampling_rate,\n        label=frame_label,\n        metadata=metadata,\n        ch_labels=labels,\n        ch_units=unit,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.from_numpy","title":"<code>from_numpy(data, sampling_rate, label=None, metadata=None, ch_labels=None, ch_units=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArrayReal</code> <p>NumPy array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>ch_units</code> <code>Optional[Union[list[str], str]]</code> <p>Units for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the NumPy data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_numpy(\n    cls,\n    data: NDArrayReal,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    ch_labels: Optional[list[str]] = None,\n    ch_units: Optional[Union[list[str], str]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    Args:\n        data: NumPy array containing channel data.\n        sampling_rate: The sampling rate in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        ch_labels: Labels for each channel.\n        ch_units: Units for each channel.\n\n    Returns:\n        A new ChannelFrame containing the NumPy data.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n\n    # Convert NumPy array to dask array\n    dask_data = da_from_array(data)\n    cf = ChannelFrame(\n        data=dask_data,\n        sampling_rate=sampling_rate,\n        label=label or \"numpy_data\",\n    )\n    if metadata is not None:\n        cf.metadata = metadata\n    if ch_labels is not None:\n        if len(ch_labels) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel labels does not match the number of channels\"\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    if ch_units is not None:\n        if isinstance(ch_units, str):\n            ch_units = [ch_units] * cf.n_channels\n\n        if len(ch_units) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel units does not match the number of channels\"\n            )\n        for i in range(len(ch_units)):\n            cf._channel_metadata[i].unit = ch_units[i]\n\n    return cf\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.high_pass_filter","title":"<code>high_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a high-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def high_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a high-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.hpss_harmonic","title":"<code>hpss_harmonic(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract harmonic components using HPSS  (Harmonic-Percussive Source Separation).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_harmonic(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract harmonic components using HPSS\n     (Harmonic-Percussive Source Separation).\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_harmonic\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.hpss_percussive","title":"<code>hpss_percussive(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract percussive components using HPSS (Harmonic-Percussive Source Separation).</p> <p>This method separates the percussive (tonal) components from the signal.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Union[_IntLike_co, tuple[_IntLike_co, _IntLike_co], list[_IntLike_co]]</code> <p>Median filter size for HPSS.</p> <code>31</code> <code>power</code> <code>float</code> <p>Exponent for the Weiner filter used in HPSS.</p> <code>2</code> <code>margin</code> <code>Union[_FloatLike_co, tuple[_FloatLike_co, _FloatLike_co], list[_FloatLike_co]]</code> <p>Margin size for the separation.</p> <code>1</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the harmonic components.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def hpss_percussive(\n    self,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Extract percussive components using HPSS\n    (Harmonic-Percussive Source Separation).\n\n    This method separates the percussive (tonal) components from the signal.\n\n    Args:\n        kernel_size: Median filter size for HPSS.\n        power: Exponent for the Weiner filter used in HPSS.\n        margin: Margin size for the separation.\n\n    Returns:\n        A new ChannelFrame containing the harmonic components.\n    \"\"\"\n    return self.apply_operation(\n        \"hpss_percussive\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.low_pass_filter","title":"<code>low_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a low-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>The cutoff frequency of the filter in Hz.</p> required <code>order</code> <code>int</code> <p>The order of the filter. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with the filtered signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def low_pass_filter(self, cutoff: float, order: int = 4) -&gt; \"ChannelFrame\":\n    \"\"\"Apply a low-pass filter to the signal.\n\n    Args:\n        cutoff: The cutoff frequency of the filter in Hz.\n        order: The order of the filter. Default is 4.\n\n    Returns:\n        A new ChannelFrame with the filtered signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    return self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.mean","title":"<code>mean()</code>","text":"<p>Average all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with averaged signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def mean(self) -&gt; \"ChannelFrame\":\n    \"\"\"Average all channels.\n\n    Returns:\n        A new ChannelFrame with averaged signal.\n    \"\"\"\n    return self.apply_operation(\"mean\")\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.noct_spectrum","title":"<code>noct_spectrum(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Compute N-octave band spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>fmin</code> <code>float</code> <p>Minimum center frequency in Hz. Default is 20 Hz.</p> required <code>fmax</code> <code>float</code> <p>Maximum center frequency in Hz. Default is 20000 Hz.</p> required <code>n</code> <code>int</code> <p>Band division (1 for octave, 3 for 1/3 octave). Default is 3.</p> <code>3</code> <code>G</code> <code>int</code> <p>Reference gain in dB. Default is 10 dB.</p> <code>10</code> <code>fr</code> <code>int</code> <p>Reference frequency in Hz. Default is 1000 Hz.</p> <code>1000</code> <p>Returns:</p> Type Description <code>NOctFrame</code> <p>A NOctFrame containing the N-octave band spectrum.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def noct_spectrum(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"Compute N-octave band spectrum.\n\n    Args:\n        fmin: Minimum center frequency in Hz. Default is 20 Hz.\n        fmax: Maximum center frequency in Hz. Default is 20000 Hz.\n        n: Band division (1 for octave, 3 for 1/3 octave). Default is 3.\n        G: Reference gain in dB. Default is 10 dB.\n        fr: Reference frequency in Hz. Default is 1000 Hz.\n\n    Returns:\n        A NOctFrame containing the N-octave band spectrum.\n    \"\"\"\n    from ..processing.time_series import NOctSpectrum\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_spectrum\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSpectrum\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_spectrum\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.normalize","title":"<code>normalize(target_level=-20, channel_wise=True)</code>","text":"<p>Normalize the signal level.</p> <p>This method adjusts the signal amplitude to reach a target RMS level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target RMS level in dB. Default is -20.</p> <code>-20</code> <code>channel_wise</code> <code>bool</code> <p>If True, normalize each channel independently. If False, apply the same scaling to all channels.</p> <code>True</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the normalized signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def normalize(\n    self, target_level: float = -20, channel_wise: bool = True\n) -&gt; \"ChannelFrame\":\n    \"\"\"Normalize the signal level.\n\n    This method adjusts the signal amplitude to reach a target RMS level.\n\n    Args:\n        target_level: Target RMS level in dB. Default is -20.\n        channel_wise: If True, normalize each channel independently.\n            If False, apply the same scaling to all channels.\n\n    Returns:\n        A new ChannelFrame containing the normalized signal.\n    \"\"\"\n    logger.debug(\n        f\"Setting up normalize: target_level={target_level}, channel_wise={channel_wise} (lazy)\"  # noqa: E501\n    )\n    return self.apply_operation(\n        \"normalize\", target_level=target_level, channel_wise=channel_wise\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.plot","title":"<code>plot(plot_type='waveform', ax=None, **kwargs)</code>","text":"<p>Plot the frame data.</p> <p>Parameters:</p> Name Type Description Default <code>plot_type</code> <code>str</code> <p>Type of plot. Default is \"waveform\".</p> <code>'waveform'</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def plot(\n    self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Plot the frame data.\n\n    Args:\n        plot_type: Type of plot. Default is \"waveform\".\n        ax: Optional matplotlib axes for plotting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    plot_strategy = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.power","title":"<code>power(exponent=2.0)</code>","text":"<p>Calculate the power of the signal.</p> <p>Parameters:</p> Name Type Description Default <code>exponent</code> <code>float</code> <p>The exponent to raise the signal to. Default is 2.0.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the signal raised to the power.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def power(self, exponent: float = 2.0) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the power of the signal.\n\n    Args:\n        exponent: The exponent to raise the signal to. Default is 2.0.\n\n    Returns:\n        A new ChannelFrame containing the signal raised to the power.\n    \"\"\"\n    return self.apply_operation(\"power\", exponent=exponent)\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.read_csv","title":"<code>read_csv(filename, time_column=0, labels=None, delimiter=',', header=0)</code>  <code>classmethod</code>","text":"<p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.read_wav","title":"<code>read_wav(filename, labels=None)</code>  <code>classmethod</code>","text":"<p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.resampling","title":"<code>resampling(target_sr, **kwargs)</code>","text":"<p>Resample audio data.</p>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.resampling--parameters","title":"Parameters","text":"<p>target_sr : float     Target sampling rate (Hz) resample_type : str, optional     Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.) **kwargs : dict     Additional resampling parameters</p>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.resampling--returns","title":"Returns","text":"<p>ChannelFrame     Resampled channel frame</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def resampling(\n    self,\n    target_sr: float,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Resample audio data.\n\n    Parameters\n    ----------\n    target_sr : float\n        Target sampling rate (Hz)\n    resample_type : str, optional\n        Resampling method ('soxr_hq', 'linear', 'sinc', 'fft', etc.)\n    **kwargs : dict\n        Additional resampling parameters\n\n    Returns\n    -------\n    ChannelFrame\n        Resampled channel frame\n    \"\"\"\n    return self.apply_operation(\n        \"resampling\",\n        target_sr=target_sr,\n        **kwargs,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.rms_plot","title":"<code>rms_plot(ax=None, title=None, overlay=True, Aw=False, **kwargs)</code>","text":"<p>Generate an RMS plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title for the plot.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay the plot on the existing axis.</p> <code>True</code> <code>Aw</code> <code>bool</code> <p>Apply A-weighting.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_plot(\n    self,\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = True,\n    Aw: bool = False,  # noqa: N803\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Generate an RMS plot.\n\n    Args:\n        ax: Optional matplotlib axes for plotting.\n        title: Title for the plot.\n        overlay: Whether to overlay the plot on the existing axis.\n        Aw: Apply A-weighting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    kwargs = kwargs or {}\n    ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n    rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n    return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.rms_trend","title":"<code>rms_trend(frame_length=2048, hop_length=512, dB=False, Aw=False)</code>","text":"<p>Calculate the RMS trend of the signal.</p> <p>This method computes the root mean square value over sliding windows.</p> <p>Parameters:</p> Name Type Description Default <code>frame_length</code> <code>int</code> <p>The size of the sliding window in samples. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>int</code> <p>The hop length between windows in samples. Default is 512.</p> <code>512</code> <code>dB</code> <code>bool</code> <p>Whether to return the RMS values in decibels. Default is False.</p> <code>False</code> <code>Aw</code> <code>bool</code> <p>Whether to apply A-weighting. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the RMS trend.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_trend(\n    self,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; \"ChannelFrame\":\n    \"\"\"Calculate the RMS trend of the signal.\n\n    This method computes the root mean square value over sliding windows.\n\n    Args:\n        frame_length: The size of the sliding window in samples. Default is 2048.\n        hop_length: The hop length between windows in samples. Default is 512.\n        dB: Whether to return the RMS values in decibels. Default is False.\n        Aw: Whether to apply A-weighting. Default is False.\n\n    Returns:\n        A new ChannelFrame containing the RMS trend.\n    \"\"\"\n    cf = self.apply_operation(\n        \"rms_trend\",\n        frame_length=frame_length,\n        hop_length=hop_length,\n        ref=[ch.ref for ch in self._channel_metadata],\n        dB=dB,\n        Aw=Aw,\n    )\n    cf.sampling_rate = self.sampling_rate / hop_length\n    return cf\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.save","title":"<code>save(path, format=None)</code>","text":"<p>Save the audio data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    logger.debug(f\"Saving audio data to file: {path} (will compute now)\")\n    data = self.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    sf.write(str(path), data, int(self.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {path}\")\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.stft","title":"<code>stft(n_fft=2048, hop_length=None, win_length=None, window='hann')</code>","text":"<p>Compute Short-Time Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectrogramFrame</code> <p>A SpectrogramFrame containing the STFT results.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def stft(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n) -&gt; \"SpectrogramFrame\":\n    \"\"\"Compute Short-Time Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        A SpectrogramFrame containing the STFT results.\n    \"\"\"\n    from ..processing.time_series import STFT, create_operation\n    from .spectrogram import SpectrogramFrame\n\n    # Set hop length and window length\n    _hop_length = hop_length if hop_length is not None else n_fft // 4\n    _win_length = win_length if win_length is not None else n_fft\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": _hop_length,\n        \"win_length\": _win_length,\n        \"window\": window,\n    }\n    operation_name = \"stft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"STFT\", operation)\n\n    # Apply processing to data\n    spectrogram_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n\n    # Create new instance\n    return SpectrogramFrame(\n        data=spectrogram_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=n_fft,\n        hop_length=_hop_length,\n        win_length=_win_length,\n        window=window,\n        label=f\"stft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.sum","title":"<code>sum()</code>","text":"<p>Sum all channels.</p> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with summed signal.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def sum(self) -&gt; \"ChannelFrame\":\n    \"\"\"Sum all channels.\n\n    Returns:\n        A new ChannelFrame with summed signal.\n    \"\"\"\n    return self.apply_operation(\"sum\")\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.transfer_function","title":"<code>transfer_function(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Compute transfer function matrix.</p> <p>The transfer function characterizes the signal transmission properties between channels in the frequency domain, representing the input-output relationship of a system.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Length of window. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrending method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the transfer function matrix.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def transfer_function(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute transfer function matrix.\n\n    The transfer function characterizes the signal transmission properties\n    between channels in the frequency domain, representing the input-output\n    relationship of a system.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrending method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the transfer function matrix.\n    \"\"\"\n    from ..processing.time_series import TransferFunction, create_operation\n    from .spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"transfer_function\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"TransferFunction\", operation)\n\n    # Apply processing to data\n    tf_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=tf_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Transfer function of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.trim","title":"<code>trim(start=0, end=None)</code>","text":"<p>Trim the signal to specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>Start time in seconds.</p> <code>0</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with trimmed signal.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If end time is before start time.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def trim(\n    self,\n    start: float = 0,\n    end: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Trim the signal to specified time range.\n\n    Args:\n        start: Start time in seconds.\n        end: End time in seconds.\n\n    Returns:\n        A new ChannelFrame with trimmed signal.\n\n    Raises:\n        ValueError: If end time is before start time.\n    \"\"\"\n    if end is None:\n        end = self.duration\n    if start &gt; end:\n        raise ValueError(\"start must be less than end\")\n    # Apply trim operation\n    return self.apply_operation(\"trim\", start=start, end=end)\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.channel.ChannelFrame.welch","title":"<code>welch(n_fft=None, hop_length=None, win_length=2048, window='hann', average='mean')</code>","text":"<p>Compute power spectral density using Welch's method.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is 2048.</p> <code>None</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between successive frames.</p> <code>None</code> <code>win_length</code> <code>int</code> <p>Length of window. Default is n_fft.</p> <code>2048</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>A SpectralFrame containing the power spectral density.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def welch(\n    self,\n    n_fft: Optional[int] = None,\n    hop_length: Optional[int] = None,\n    win_length: int = 2048,\n    window: str = \"hann\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Compute power spectral density using Welch's method.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between successive frames.\n        Default is n_fft//4.\n        win_length: Length of window. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        A SpectralFrame containing the power spectral density.\n    \"\"\"\n    from ..processing.time_series import Welch\n    from .spectral import SpectralFrame\n\n    params = dict(\n        n_fft=n_fft or win_length,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        average=average,\n    )\n    operation_name = \"welch\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Welch\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"welch\", \"params\": params},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/frames/#spectralframe","title":"SpectralFrame","text":"<p><code>SpectralFrame</code>\u306f\u5468\u6ce2\u6570\u9818\u57df\u306e\u30c7\u30fc\u30bf\u3092\u6271\u3046\u30d5\u30ec\u30fc\u30e0\u3067\u3059\u3002</p> <pre><code>from wandas.frames.spectral import SpectralFrame\n\n# \u307e\u305f\u306f ChannelFrame\u304b\u3089\u5909\u63db\nchannel_frame = wandas.read_wav(\"audio.wav\")\nspectral_frame = channel_frame.to_spectral()\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayComplex]</code></p> <p>Class for handling frequency-domain signal data.</p> <p>This class represents spectral data, providing methods for spectral analysis, manipulation, and visualization. It handles complex-valued frequency domain data obtained through operations like FFT.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The spectral data. Must be a dask array with shape:     - (channels, frequency_bins) for multi-channel data     - (frequency_bins,) for single-channel data, which will be       reshaped to (1, frequency_bins) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. n_fft : int     The FFT size used to generate this spectral data. window : str, default=\"hann\"     The window function used in the FFT. label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame--attributes","title":"Attributes","text":"<p>magnitude : NDArrayReal     The magnitude spectrum of the data. phase : NDArrayReal     The phase spectrum in radians. power : NDArrayReal     The power spectrum (magnitude squared). dB : NDArrayReal     The spectrum in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrum in decibels. freqs : NDArrayReal     The frequency axis values in Hz.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame--examples","title":"Examples","text":"<p>Create a SpectralFrame from FFT:</p> <p>signal = ChannelFrame.from_numpy(data, sampling_rate=44100) spectrum = signal.fft(n_fft=2048)</p> <p>Plot the magnitude spectrum:</p> <p>spectrum.plot()</p> <p>Perform binary operations:</p> <p>scaled = spectrum * 2.0 summed = spectrum1 + spectrum2  # Must have matching sampling rates</p> <p>Convert back to time domain:</p> <p>time_signal = spectrum.ifft()</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame--notes","title":"Notes","text":"<ul> <li>All operations are performed lazily using dask arrays for efficient memory usage.</li> <li>Binary operations (+, -, *, /) can be performed between SpectralFrames or with   scalar values.</li> <li>The class maintains the processing history and metadata through all operations.</li> </ul> Source code in <code>wandas/frames/spectral.py</code> <pre><code>class SpectralFrame(BaseFrame[NDArrayComplex]):\n    \"\"\"\n    Class for handling frequency-domain signal data.\n\n    This class represents spectral data, providing methods for spectral analysis,\n    manipulation, and visualization. It handles complex-valued frequency domain data\n    obtained through operations like FFT.\n\n    Parameters\n    ----------\n    data : DaArray\n        The spectral data. Must be a dask array with shape:\n        - (channels, frequency_bins) for multi-channel data\n        - (frequency_bins,) for single-channel data, which will be\n          reshaped to (1, frequency_bins)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    n_fft : int\n        The FFT size used to generate this spectral data.\n    window : str, default=\"hann\"\n        The window function used in the FFT.\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    magnitude : NDArrayReal\n        The magnitude spectrum of the data.\n    phase : NDArrayReal\n        The phase spectrum in radians.\n    power : NDArrayReal\n        The power spectrum (magnitude squared).\n    dB : NDArrayReal\n        The spectrum in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrum in decibels.\n    freqs : NDArrayReal\n        The frequency axis values in Hz.\n\n    Examples\n    --------\n    Create a SpectralFrame from FFT:\n    &gt;&gt;&gt; signal = ChannelFrame.from_numpy(data, sampling_rate=44100)\n    &gt;&gt;&gt; spectrum = signal.fft(n_fft=2048)\n\n    Plot the magnitude spectrum:\n    &gt;&gt;&gt; spectrum.plot()\n\n    Perform binary operations:\n    &gt;&gt;&gt; scaled = spectrum * 2.0\n    &gt;&gt;&gt; summed = spectrum1 + spectrum2  # Must have matching sampling rates\n\n    Convert back to time domain:\n    &gt;&gt;&gt; time_signal = spectrum.ifft()\n\n    Notes\n    -----\n    - All operations are performed lazily using dask arrays for efficient memory usage.\n    - Binary operations (+, -, *, /) can be performed between SpectralFrames or with\n      scalar values.\n    - The class maintains the processing history and metadata through all operations.\n    \"\"\"\n\n    n_fft: int\n    window: str\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        n_fft: int,\n        window: str = \"hann\",\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306f1\u6b21\u5143\u307e\u305f\u306f2\u6b21\u5143\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u5f62\u72b6: {data.shape}\"\n            )\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def magnitude(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the magnitude spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The absolute values of the complex spectrum.\n        \"\"\"\n        return np.abs(self.data)\n\n    @property\n    def phase(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the phase spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The phase angles of the complex spectrum in radians.\n        \"\"\"\n        return np.angle(self.data)\n\n    @property\n    def power(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the power spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The squared magnitude spectrum.\n        \"\"\"\n        return self.magnitude**2\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrum in decibels.\n\n        The reference values are taken from channel metadata. If no reference\n        is specified, uses 1.0.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrum in dB relative to channel references.\n        \"\"\"\n        mag: NDArrayReal = self.magnitude\n        ref_values: NDArrayReal = np.array([ch.ref for ch in self._channel_metadata])\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(mag / ref_values[:, np.newaxis], 1e-12)\n        )\n\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrum in decibels.\n\n        Applies A-weighting filter to the spectrum for better correlation with\n        perceived loudness.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrum in dB.\n        \"\"\"\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels.\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the frequency axis values in Hz.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of frequency values corresponding to each frequency bin.\n        \"\"\"\n        return np.fft.rfftfreq(self.n_fft, 1.0 / self.sampling_rate)\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Implementation of operation application for spectral data.\n\n        This internal method handles the application of various operations to\n        spectral data, maintaining lazy evaluation through dask.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters for the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        processed_data = operation.process(self._data)\n\n        # \u30e1\u30bf\u30c7\u30fc\u30bf\u66f4\u65b0\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\n            \"SpectralFrame\", int, float, complex, NDArrayComplex, NDArrayReal, \"DaArray\"\n        ],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"\n        Common implementation for binary operations.\n\n        This method handles binary operations between SpectralFrames and various types\n        of operands, maintaining lazy evaluation through dask arrays.\n\n        Parameters\n        ----------\n        other : Union[SpectralFrame, int, float, complex,\n                        NDArrayComplex, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation (e.g., lambda a, b: a + b)\n        symbol : str\n            String representation of the operation (e.g., '+')\n\n        Returns\n        -------\n        SpectralFrame\n            A new SpectralFrame containing the result of the operation.\n\n        Raises\n        ------\n        ValueError\n            If attempting to operate with a SpectralFrame\n            with a different sampling rate.\n        \"\"\"\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, SpectralFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u304c\u4e00\u81f4\u3057\u3066\u3044\u307e\u305b\u3093\u3002\u6f14\u7b97\u3067\u304d\u307e\u305b\u3093\u3002\"\n                )\n\n            # dask array\u3092\u76f4\u63a5\u6f14\u7b97\uff08\u9045\u5ef6\u5b9f\u884c\u3092\u7dad\u6301\uff09\n            result_data = op(self._data, other._data)\n\n            # \u30c1\u30e3\u30cd\u30eb\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u7d50\u5408\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return SpectralFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # \u30b9\u30ab\u30e9\u30fc\u3001NumPy\u914d\u5217\u3001\u307e\u305f\u306f\u4ed6\u306e\u30bf\u30a4\u30d7\u3068\u306e\u6f14\u7b97\n        else:\n            # dask array\u306b\u76f4\u63a5\u6f14\u7b97\u3092\u9069\u7528\uff08\u9045\u5ef6\u5b9f\u884c\u3092\u7dad\u6301\uff09\n            result_data = op(self._data, other)\n\n            # \u30aa\u30da\u30e9\u30f3\u30c9\u306e\u8868\u793a\u7528\u6587\u5b57\u5217\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, complex):\n                other_str = f\"complex({other.real}, {other.imag})\"\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # dask.array.Array\u306e\u30c1\u30a7\u30c3\u30af\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # \u30c1\u30e3\u30cd\u30eb\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u66f4\u65b0\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return SpectralFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n            )\n\n    def plot(\n        self,\n        plot_type: str = \"frequency\",\n        ax: Optional[\"Axes\"] = None,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the spectral data using various visualization strategies.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"frequency\"\n            Type of plot to create. Options include:\n            - \"frequency\": Standard frequency plot\n            - \"matrix\": Matrix plot for comparing channels\n            - Other types as defined by available plot strategies\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - title: Plot title\n            - xlabel, ylabel: Axis labels\n            - vmin, vmax: Value limits for plots\n            - cmap: Colormap name\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def ifft(self) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.\n\n        This method transforms the frequency-domain data back to the time domain using\n        the inverse FFT operation. The window function used in the forward FFT is\n        taken into account to ensure proper reconstruction.\n\n        Returns\n        -------\n        ChannelFrame\n            A new ChannelFrame containing the time-domain signal.\n        \"\"\"\n        from ..processing.time_series import IFFT, create_operation\n        from .channel import ChannelFrame\n\n        params = {\"n_fft\": self.n_fft, \"window\": self.window}\n        operation_name = \"ifft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"IFFT\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        time_series = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        return ChannelFrame(\n            data=time_series,\n            sampling_rate=self.sampling_rate,\n            label=f\"ifft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        SpectralFrame \u306b\u5fc5\u8981\u306a\u8ffd\u52a0\u306e\u521d\u671f\u5316\u5f15\u6570\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments for SpectralFrame.\n        \"\"\"\n        return {\n            \"n_fft\": self.n_fft,\n            \"window\": self.window,\n        }\n\n    def noct_synthesis(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"\n        Synthesize N-octave band spectrum.\n\n        This method combines frequency components into N-octave bands according to\n        standard acoustical band definitions. This is commonly used in noise and\n        vibration analysis.\n\n        Parameters\n        ----------\n        fmin : float\n            Lower frequency bound in Hz.\n        fmax : float\n            Upper frequency bound in Hz.\n        n : int, default=3\n            Number of bands per octave (e.g., 3 for third-octave bands).\n        G : int, default=10\n            Reference band number.\n        fr : int, default=1000\n            Reference frequency in Hz.\n\n        Returns\n        -------\n        NOctFrame\n            A new NOctFrame containing the N-octave band spectrum.\n\n        Raises\n        ------\n        ValueError\n            If the sampling rate is not 48000 Hz, which is required for this operation.\n        \"\"\"\n        if self.sampling_rate != 48000:\n            raise ValueError(\n                \"noct_synthesis\u306f48000Hz\u306e\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u3067\u306e\u307f\u4f7f\u7528\u3067\u304d\u307e\u3059\u3002\"\n            )\n        from ..processing.time_series import NOctSynthesis\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_synthesis\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing.time_series import create_operation\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSynthesis\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_synthesis\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def plot_matrix(\n        self,\n        plot_type: str = \"matrix\",\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot channel relationships in matrix format.\n\n        This method creates a matrix plot showing relationships between channels,\n        such as coherence, transfer functions, or cross-spectral density.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"matrix\"\n            Type of matrix plot to create.\n        **kwargs : dict\n            Additional plot parameters:\n            - vmin, vmax: Color scale limits\n            - cmap: Colormap name\n            - title: Plot title\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrum in decibels.</p> <p>The reference values are taken from channel metadata. If no reference is specified, uses 1.0.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrum in dB relative to channel references.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrum in decibels.</p> <p>Applies A-weighting filter to the spectrum for better correlation with perceived loudness.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrum in dB.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the frequency axis values in Hz.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of frequency values corresponding to each frequency bin.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.magnitude","title":"<code>magnitude</code>  <code>property</code>","text":"<p>Get the magnitude spectrum.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.magnitude--returns","title":"Returns","text":"<p>NDArrayReal     The absolute values of the complex spectrum.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.phase","title":"<code>phase</code>  <code>property</code>","text":"<p>Get the phase spectrum.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.phase--returns","title":"Returns","text":"<p>NDArrayReal     The phase angles of the complex spectrum in radians.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.power","title":"<code>power</code>  <code>property</code>","text":"<p>Get the power spectrum.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.power--returns","title":"Returns","text":"<p>NDArrayReal     The squared magnitude spectrum.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.ifft","title":"<code>ifft()</code>","text":"<p>Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.</p> <p>This method transforms the frequency-domain data back to the time domain using the inverse FFT operation. The window function used in the forward FFT is taken into account to ensure proper reconstruction.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.ifft--returns","title":"Returns","text":"<p>ChannelFrame     A new ChannelFrame containing the time-domain signal.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def ifft(self) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.\n\n    This method transforms the frequency-domain data back to the time domain using\n    the inverse FFT operation. The window function used in the forward FFT is\n    taken into account to ensure proper reconstruction.\n\n    Returns\n    -------\n    ChannelFrame\n        A new ChannelFrame containing the time-domain signal.\n    \"\"\"\n    from ..processing.time_series import IFFT, create_operation\n    from .channel import ChannelFrame\n\n    params = {\"n_fft\": self.n_fft, \"window\": self.window}\n    operation_name = \"ifft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"IFFT\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    time_series = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    return ChannelFrame(\n        data=time_series,\n        sampling_rate=self.sampling_rate,\n        label=f\"ifft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis","title":"<code>noct_synthesis(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Synthesize N-octave band spectrum.</p> <p>This method combines frequency components into N-octave bands according to standard acoustical band definitions. This is commonly used in noise and vibration analysis.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--parameters","title":"Parameters","text":"<p>fmin : float     Lower frequency bound in Hz. fmax : float     Upper frequency bound in Hz. n : int, default=3     Number of bands per octave (e.g., 3 for third-octave bands). G : int, default=10     Reference band number. fr : int, default=1000     Reference frequency in Hz.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--returns","title":"Returns","text":"<p>NOctFrame     A new NOctFrame containing the N-octave band spectrum.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--raises","title":"Raises","text":"<p>ValueError     If the sampling rate is not 48000 Hz, which is required for this operation.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def noct_synthesis(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"\n    Synthesize N-octave band spectrum.\n\n    This method combines frequency components into N-octave bands according to\n    standard acoustical band definitions. This is commonly used in noise and\n    vibration analysis.\n\n    Parameters\n    ----------\n    fmin : float\n        Lower frequency bound in Hz.\n    fmax : float\n        Upper frequency bound in Hz.\n    n : int, default=3\n        Number of bands per octave (e.g., 3 for third-octave bands).\n    G : int, default=10\n        Reference band number.\n    fr : int, default=1000\n        Reference frequency in Hz.\n\n    Returns\n    -------\n    NOctFrame\n        A new NOctFrame containing the N-octave band spectrum.\n\n    Raises\n    ------\n    ValueError\n        If the sampling rate is not 48000 Hz, which is required for this operation.\n    \"\"\"\n    if self.sampling_rate != 48000:\n        raise ValueError(\n            \"noct_synthesis\u306f48000Hz\u306e\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u3067\u306e\u307f\u4f7f\u7528\u3067\u304d\u307e\u3059\u3002\"\n        )\n    from ..processing.time_series import NOctSynthesis\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_synthesis\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing.time_series import create_operation\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSynthesis\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_synthesis\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.plot","title":"<code>plot(plot_type='frequency', ax=None, **kwargs)</code>","text":"<p>Plot the spectral data using various visualization strategies.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"frequency\"     Type of plot to create. Options include:     - \"frequency\": Standard frequency plot     - \"matrix\": Matrix plot for comparing channels     - Other types as defined by available plot strategies ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - title: Plot title     - xlabel, ylabel: Axis labels     - vmin, vmax: Value limits for plots     - cmap: Colormap name     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def plot(\n    self,\n    plot_type: str = \"frequency\",\n    ax: Optional[\"Axes\"] = None,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the spectral data using various visualization strategies.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"frequency\"\n        Type of plot to create. Options include:\n        - \"frequency\": Standard frequency plot\n        - \"matrix\": Matrix plot for comparing channels\n        - Other types as defined by available plot strategies\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - title: Plot title\n        - xlabel, ylabel: Axis labels\n        - vmin, vmax: Value limits for plots\n        - cmap: Colormap name\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix","title":"<code>plot_matrix(plot_type='matrix', **kwargs)</code>","text":"<p>Plot channel relationships in matrix format.</p> <p>This method creates a matrix plot showing relationships between channels, such as coherence, transfer functions, or cross-spectral density.</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"matrix\"     Type of matrix plot to create. **kwargs : dict     Additional plot parameters:     - vmin, vmax: Color scale limits     - cmap: Colormap name     - title: Plot title</p>"},{"location":"ja/api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def plot_matrix(\n    self,\n    plot_type: str = \"matrix\",\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot channel relationships in matrix format.\n\n    This method creates a matrix plot showing relationships between channels,\n    such as coherence, transfer functions, or cross-spectral density.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"matrix\"\n        Type of matrix plot to create.\n    **kwargs : dict\n        Additional plot parameters:\n        - vmin, vmax: Color scale limits\n        - cmap: Colormap name\n        - title: Plot title\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"ja/api/frames/#spectrogramframe","title":"SpectrogramFrame","text":"<p><code>SpectrogramFrame</code>\u306f\u6642\u9593\u5468\u6ce2\u6570\u8868\u73fe\uff08\u30b9\u30da\u30af\u30c8\u30ed\u30b0\u30e9\u30e0\uff09\u306e\u30c7\u30fc\u30bf\u3092\u6271\u3046\u30d5\u30ec\u30fc\u30e0\u3067\u3059\u3002</p> <pre><code>from wandas.frames.spectrogram import SpectrogramFrame\n\n# \u307e\u305f\u306f ChannelFrame\u304b\u3089\u5909\u63db\nchannel_frame = wandas.read_wav(\"audio.wav\")\nspectrogram_frame = channel_frame.to_spectrogram()\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayComplex]</code></p> <p>Class for handling time-frequency domain data (spectrograms).</p> <p>This class represents spectrogram data obtained through Short-Time Fourier Transform (STFT) or similar time-frequency analysis methods. It provides methods for visualization, manipulation, and conversion back to time domain.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The spectrogram data. Must be a dask array with shape:     - (channels, frequency_bins, time_frames) for multi-channel data     - (frequency_bins, time_frames) for single-channel data, which will be       reshaped to (1, frequency_bins, time_frames) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. n_fft : int     The FFT size used to generate this spectrogram. hop_length : int     Number of samples between successive frames. win_length : int, optional     The window length in samples. If None, defaults to n_fft. window : str, default=\"hann\"     The window function to use (e.g., \"hann\", \"hamming\", \"blackman\"). label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame--attributes","title":"Attributes","text":"<p>magnitude : NDArrayReal     The magnitude spectrogram. phase : NDArrayReal     The phase spectrogram in radians. power : NDArrayReal     The power spectrogram. dB : NDArrayReal     The spectrogram in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrogram in decibels. n_frames : int     Number of time frames. n_freq_bins : int     Number of frequency bins. freqs : NDArrayReal     The frequency axis values in Hz. times : NDArrayReal     The time axis values in seconds.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame--examples","title":"Examples","text":"<p>Create a spectrogram from a time-domain signal:</p> <p>signal = ChannelFrame.from_wav(\"audio.wav\") spectrogram = signal.stft(n_fft=2048, hop_length=512)</p> <p>Extract a specific time frame:</p> <p>frame_at_1s = spectrogram.get_frame_at(int(1.0 * sampling_rate / hop_length))</p> <p>Convert back to time domain:</p> <p>reconstructed = spectrogram.to_channel_frame()</p> <p>Plot the spectrogram:</p> <p>spectrogram.plot()</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>class SpectrogramFrame(BaseFrame[NDArrayComplex]):\n    \"\"\"\n    Class for handling time-frequency domain data (spectrograms).\n\n    This class represents spectrogram data obtained through\n    Short-Time Fourier Transform (STFT)\n    or similar time-frequency analysis methods. It provides methods for visualization,\n    manipulation, and conversion back to time domain.\n\n    Parameters\n    ----------\n    data : DaArray\n        The spectrogram data. Must be a dask array with shape:\n        - (channels, frequency_bins, time_frames) for multi-channel data\n        - (frequency_bins, time_frames) for single-channel data, which will be\n          reshaped to (1, frequency_bins, time_frames)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    n_fft : int\n        The FFT size used to generate this spectrogram.\n    hop_length : int\n        Number of samples between successive frames.\n    win_length : int, optional\n        The window length in samples. If None, defaults to n_fft.\n    window : str, default=\"hann\"\n        The window function to use (e.g., \"hann\", \"hamming\", \"blackman\").\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    magnitude : NDArrayReal\n        The magnitude spectrogram.\n    phase : NDArrayReal\n        The phase spectrogram in radians.\n    power : NDArrayReal\n        The power spectrogram.\n    dB : NDArrayReal\n        The spectrogram in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrogram in decibels.\n    n_frames : int\n        Number of time frames.\n    n_freq_bins : int\n        Number of frequency bins.\n    freqs : NDArrayReal\n        The frequency axis values in Hz.\n    times : NDArrayReal\n        The time axis values in seconds.\n\n    Examples\n    --------\n    Create a spectrogram from a time-domain signal:\n    &gt;&gt;&gt; signal = ChannelFrame.from_wav(\"audio.wav\")\n    &gt;&gt;&gt; spectrogram = signal.stft(n_fft=2048, hop_length=512)\n\n    Extract a specific time frame:\n    &gt;&gt;&gt; frame_at_1s = spectrogram.get_frame_at(int(1.0 * sampling_rate / hop_length))\n\n    Convert back to time domain:\n    &gt;&gt;&gt; reconstructed = spectrogram.to_channel_frame()\n\n    Plot the spectrogram:\n    &gt;&gt;&gt; spectrogram.plot()\n    \"\"\"\n\n    n_fft: int\n    hop_length: int\n    win_length: int\n    window: str\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        if data.ndim == 2:\n            data = da.expand_dims(data, axis=0)  # type: ignore [unused-ignore]\n        elif data.ndim != 3:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306f2\u6b21\u5143\u307e\u305f\u306f3\u6b21\u5143\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u5f62\u72b6: {data.shape}\"\n            )\n        if not data.shape[-2] == n_fft // 2 + 1:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u304c\u7121\u52b9\u3067\u3059\u3002\u5468\u6ce2\u6570\u30d3\u30f3\u6570\u306f {n_fft // 2 + 1} \u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\"  # noqa: E501\n            )\n\n        self.n_fft = n_fft\n        self.hop_length = hop_length\n        self.win_length = win_length if win_length is not None else n_fft\n        self.window = window\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def magnitude(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the magnitude spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The absolute values of the complex spectrogram.\n        \"\"\"\n        return np.abs(self.data)\n\n    @property\n    def phase(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the phase spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The phase angles of the complex spectrogram in radians.\n        \"\"\"\n        return np.angle(self.data)\n\n    @property\n    def power(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the power spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The squared magnitude of the complex spectrogram.\n        \"\"\"\n        return np.abs(self.data) ** 2\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrogram in decibels relative to each channel's reference value.\n\n        The reference value for each channel is specified in its metadata.\n        A minimum value of -120 dB is enforced to avoid numerical issues.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrogram in decibels.\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        ref = np.array([ch.ref for ch in self._channel_metadata])\n        # dB\u5909\u63db\n        # 0\u9664\u7b97\u3092\u907f\u3051\u308b\u305f\u3081\u306b\u3001\u6700\u5927\u5024\u30681e-12\u306e\u3044\u305a\u308c\u304b\u3092\u4f7f\u7528\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(self.magnitude / ref[..., np.newaxis, np.newaxis], 1e-12)\n        )\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrogram in decibels.\n\n        A-weighting applies a frequency-dependent weighting filter that approximates\n        the human ear's response. This is particularly useful for analyzing noise\n        and acoustic measurements.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrogram in decibels.\n        \"\"\"\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted[:, np.newaxis]  # \u5468\u6ce2\u6570\u8ef8\u306b\u6cbf\u3063\u3066\u30d6\u30ed\u30fc\u30c9\u30ad\u30e3\u30b9\u30c8\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels.\n        \"\"\"\n        return self.shape[0]\n\n    @property\n    def n_frames(self) -&gt; int:\n        \"\"\"\n        Get the number of time frames.\n\n        Returns\n        -------\n        int\n            The number of time frames in the spectrogram.\n        \"\"\"\n        return self.shape[-1]\n\n    @property\n    def n_freq_bins(self) -&gt; int:\n        \"\"\"\n        Get the number of frequency bins.\n\n        Returns\n        -------\n        int\n            The number of frequency bins (n_fft // 2 + 1).\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the frequency axis values in Hz.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of frequency values corresponding to each frequency bin.\n        \"\"\"\n        return np.fft.rfftfreq(self.n_fft, 1.0 / self.sampling_rate)\n\n    @property\n    def times(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the time axis values in seconds.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of time values corresponding to each time frame.\n        \"\"\"\n        return np.arange(self.n_frames) * self.hop_length / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Implementation of operation application for spectrogram data.\n\n        This internal method handles the application of various operations to\n        spectrogram data, maintaining lazy evaluation through dask.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters for the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from wandas.processing.time_series import create_operation\n\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        processed_data = operation.process(self._data)\n\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\n            \"SpectrogramFrame\",\n            int,\n            float,\n            complex,\n            NDArrayComplex,\n            NDArrayReal,\n            \"DaArray\",\n        ],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"\n        Common implementation for binary operations.\n\n        This method handles binary operations between\n        SpectrogramFrames and various types\n        of operands, maintaining lazy evaluation through dask arrays.\n\n        Parameters\n        ----------\n        other : Union[SpectrogramFrame, int, float, complex,\n            NDArrayComplex, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation (e.g., lambda a, b: a + b)\n        symbol : str\n            String representation of the operation (e.g., '+')\n\n        Returns\n        -------\n        SpectrogramFrame\n            A new SpectrogramFrame containing the result of the operation.\n\n        Raises\n        ------\n        ValueError\n            If attempting to operate with a SpectrogramFrame\n            with a different sampling rate.\n        \"\"\"\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        if isinstance(other, SpectrogramFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u304c\u4e00\u81f4\u3057\u3066\u3044\u307e\u305b\u3093\u3002\u6f14\u7b97\u3067\u304d\u307e\u305b\u3093\u3002\"\n                )\n\n            result_data = op(self._data, other._data)\n\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return SpectrogramFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                hop_length=self.hop_length,\n                win_length=self.win_length,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n        else:\n            result_data = op(self._data, other)\n\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, complex):\n                other_str = f\"complex({other.real}, {other.imag})\"\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return SpectrogramFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                hop_length=self.hop_length,\n                win_length=self.win_length,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n            )\n\n    def plot(\n        self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the spectrogram using various visualization strategies.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"spectrogram\"\n            Type of plot to create.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - vmin, vmax: Colormap scaling\n            - cmap: Colormap name\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectrogramFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def plot_Aw(  # noqa: N802\n        self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the A-weighted spectrogram.\n\n        A convenience method that calls plot() with Aw=True, applying A-weighting\n        to the spectrogram before plotting.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"spectrogram\"\n            Type of plot to create.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to plot().\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot.\n        \"\"\"\n        return self.plot(plot_type=plot_type, ax=ax, Aw=True, **kwargs)\n\n    def get_frame_at(self, time_idx: int) -&gt; \"SpectralFrame\":\n        \"\"\"\n        Extract spectral data at a specific time frame.\n\n        Parameters\n        ----------\n        time_idx : int\n            Index of the time frame to extract.\n\n        Returns\n        -------\n        SpectralFrame\n            A new SpectralFrame containing the spectral data at the specified time.\n\n        Raises\n        ------\n        IndexError\n            If time_idx is out of range.\n        \"\"\"\n        from wandas.frames.spectral import SpectralFrame\n\n        if time_idx &lt; 0 or time_idx &gt;= self.n_frames:\n            raise IndexError(\n                f\"\u6642\u9593\u30a4\u30f3\u30c7\u30c3\u30af\u30b9 {time_idx} \u304c\u7bc4\u56f2\u5916\u3067\u3059\u3002\u6709\u52b9\u7bc4\u56f2: 0-{self.n_frames - 1}\"  # noqa: E501\n            )\n\n        frame_data = self._data[..., time_idx]\n\n        return SpectralFrame(\n            data=frame_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=self.n_fft,\n            window=self.window,\n            label=f\"{self.label} (Frame {time_idx}, Time {self.times[time_idx]:.3f}s)\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def to_channel_frame(self) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Convert the spectrogram back to time domain using inverse STFT.\n\n        This method performs an inverse Short-Time Fourier Transform (ISTFT) to\n        reconstruct the time-domain signal from the spectrogram.\n\n        Returns\n        -------\n        ChannelFrame\n            A new ChannelFrame containing the reconstructed time-domain signal.\n        \"\"\"\n        from wandas.frames.channel import ChannelFrame\n        from wandas.processing.time_series import ISTFT, create_operation\n\n        params = {\n            \"n_fft\": self.n_fft,\n            \"hop_length\": self.hop_length,\n            \"win_length\": self.win_length,\n            \"window\": self.window,\n        }\n        operation_name = \"istft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"ISTFT\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        time_series = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n\n        # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        return ChannelFrame(\n            data=time_series,\n            sampling_rate=self.sampling_rate,\n            label=f\"istft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get additional initialization arguments for SpectrogramFrame.\n\n        This internal method provides the additional initialization arguments\n        required by SpectrogramFrame beyond those required by BaseFrame.\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments.\n        \"\"\"\n        return {\n            \"n_fft\": self.n_fft,\n            \"hop_length\": self.hop_length,\n            \"win_length\": self.win_length,\n            \"window\": self.window,\n        }\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrogram in decibels relative to each channel's reference value.</p> <p>The reference value for each channel is specified in its metadata. A minimum value of -120 dB is enforced to avoid numerical issues.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrogram in decibels.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrogram in decibels.</p> <p>A-weighting applies a frequency-dependent weighting filter that approximates the human ear's response. This is particularly useful for analyzing noise and acoustic measurements.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrogram in decibels.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the frequency axis values in Hz.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of frequency values corresponding to each frequency bin.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.magnitude","title":"<code>magnitude</code>  <code>property</code>","text":"<p>Get the magnitude spectrogram.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.magnitude--returns","title":"Returns","text":"<p>NDArrayReal     The absolute values of the complex spectrogram.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_frames","title":"<code>n_frames</code>  <code>property</code>","text":"<p>Get the number of time frames.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_frames--returns","title":"Returns","text":"<p>int     The number of time frames in the spectrogram.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_freq_bins","title":"<code>n_freq_bins</code>  <code>property</code>","text":"<p>Get the number of frequency bins.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_freq_bins--returns","title":"Returns","text":"<p>int     The number of frequency bins (n_fft // 2 + 1).</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.phase","title":"<code>phase</code>  <code>property</code>","text":"<p>Get the phase spectrogram.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.phase--returns","title":"Returns","text":"<p>NDArrayReal     The phase angles of the complex spectrogram in radians.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.power","title":"<code>power</code>  <code>property</code>","text":"<p>Get the power spectrogram.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.power--returns","title":"Returns","text":"<p>NDArrayReal     The squared magnitude of the complex spectrogram.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.times","title":"<code>times</code>  <code>property</code>","text":"<p>Get the time axis values in seconds.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.times--returns","title":"Returns","text":"<p>NDArrayReal     Array of time values corresponding to each time frame.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at","title":"<code>get_frame_at(time_idx)</code>","text":"<p>Extract spectral data at a specific time frame.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--parameters","title":"Parameters","text":"<p>time_idx : int     Index of the time frame to extract.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--returns","title":"Returns","text":"<p>SpectralFrame     A new SpectralFrame containing the spectral data at the specified time.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--raises","title":"Raises","text":"<p>IndexError     If time_idx is out of range.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def get_frame_at(self, time_idx: int) -&gt; \"SpectralFrame\":\n    \"\"\"\n    Extract spectral data at a specific time frame.\n\n    Parameters\n    ----------\n    time_idx : int\n        Index of the time frame to extract.\n\n    Returns\n    -------\n    SpectralFrame\n        A new SpectralFrame containing the spectral data at the specified time.\n\n    Raises\n    ------\n    IndexError\n        If time_idx is out of range.\n    \"\"\"\n    from wandas.frames.spectral import SpectralFrame\n\n    if time_idx &lt; 0 or time_idx &gt;= self.n_frames:\n        raise IndexError(\n            f\"\u6642\u9593\u30a4\u30f3\u30c7\u30c3\u30af\u30b9 {time_idx} \u304c\u7bc4\u56f2\u5916\u3067\u3059\u3002\u6709\u52b9\u7bc4\u56f2: 0-{self.n_frames - 1}\"  # noqa: E501\n        )\n\n    frame_data = self._data[..., time_idx]\n\n    return SpectralFrame(\n        data=frame_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=self.n_fft,\n        window=self.window,\n        label=f\"{self.label} (Frame {time_idx}, Time {self.times[time_idx]:.3f}s)\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot","title":"<code>plot(plot_type='spectrogram', ax=None, **kwargs)</code>","text":"<p>Plot the spectrogram using various visualization strategies.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"spectrogram\"     Type of plot to create. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - vmin, vmax: Colormap scaling     - cmap: Colormap name     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def plot(\n    self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the spectrogram using various visualization strategies.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"spectrogram\"\n        Type of plot to create.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - vmin, vmax: Colormap scaling\n        - cmap: Colormap name\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectrogramFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw","title":"<code>plot_Aw(plot_type='spectrogram', ax=None, **kwargs)</code>","text":"<p>Plot the A-weighted spectrogram.</p> <p>A convenience method that calls plot() with Aw=True, applying A-weighting to the spectrogram before plotting.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"spectrogram\"     Type of plot to create. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to plot().</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def plot_Aw(  # noqa: N802\n    self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the A-weighted spectrogram.\n\n    A convenience method that calls plot() with Aw=True, applying A-weighting\n    to the spectrogram before plotting.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"spectrogram\"\n        Type of plot to create.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to plot().\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot.\n    \"\"\"\n    return self.plot(plot_type=plot_type, ax=ax, Aw=True, **kwargs)\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.to_channel_frame","title":"<code>to_channel_frame()</code>","text":"<p>Convert the spectrogram back to time domain using inverse STFT.</p> <p>This method performs an inverse Short-Time Fourier Transform (ISTFT) to reconstruct the time-domain signal from the spectrogram.</p>"},{"location":"ja/api/frames/#wandas.frames.spectrogram.SpectrogramFrame.to_channel_frame--returns","title":"Returns","text":"<p>ChannelFrame     A new ChannelFrame containing the reconstructed time-domain signal.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def to_channel_frame(self) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Convert the spectrogram back to time domain using inverse STFT.\n\n    This method performs an inverse Short-Time Fourier Transform (ISTFT) to\n    reconstruct the time-domain signal from the spectrogram.\n\n    Returns\n    -------\n    ChannelFrame\n        A new ChannelFrame containing the reconstructed time-domain signal.\n    \"\"\"\n    from wandas.frames.channel import ChannelFrame\n    from wandas.processing.time_series import ISTFT, create_operation\n\n    params = {\n        \"n_fft\": self.n_fft,\n        \"hop_length\": self.hop_length,\n        \"win_length\": self.win_length,\n        \"window\": self.window,\n    }\n    operation_name = \"istft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"ISTFT\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    time_series = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n    )\n\n    # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    return ChannelFrame(\n        data=time_series,\n        sampling_rate=self.sampling_rate,\n        label=f\"istft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"ja/api/frames/#noctframe","title":"NOctFrame","text":"<p><code>NOctFrame</code>\u306fN\u30aa\u30af\u30bf\u30fc\u30d6\u5206\u6790\u306e\u30c7\u30fc\u30bf\u3092\u6271\u3046\u30d5\u30ec\u30fc\u30e0\u3067\u3059\u3002</p> <pre><code>from wandas.frames.noct import NOctFrame\n\n# \u307e\u305f\u306f ChannelFrame\u304b\u3089\u5909\u63db\nchannel_frame = wandas.read_wav(\"audio.wav\")\nnoct_frame = channel_frame.to_noct()\n</code></pre> <p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Class for handling N-octave band analysis data.</p> <p>This class represents frequency data analyzed in fractional octave bands, typically used in acoustic and vibration analysis. It handles real-valued data representing energy or power in each frequency band, following standard acoustical band definitions.</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The N-octave band data. Must be a dask array with shape:     - (channels, frequency_bins) for multi-channel data     - (frequency_bins,) for single-channel data, which will be       reshaped to (1, frequency_bins) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. fmin : float, default=0     Lower frequency bound in Hz. fmax : float, default=0     Upper frequency bound in Hz. n : int, default=3     Number of bands per octave (e.g., 3 for third-octave bands). G : int, default=10     Reference band number according to IEC 61260-1:2014. fr : int, default=1000     Reference frequency in Hz, typically 1000 Hz for acoustic analysis. label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame--attributes","title":"Attributes","text":"<p>freqs : NDArrayReal     The center frequencies of each band in Hz, calculated according to     the standard fractional octave band definitions. dB : NDArrayReal     The spectrum in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrum in decibels, applying frequency weighting     for better correlation with perceived loudness. fmin : float     Lower frequency bound in Hz. fmax : float     Upper frequency bound in Hz. n : int     Number of bands per octave. G : int     Reference band number. fr : int     Reference frequency in Hz.</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame--examples","title":"Examples","text":"<p>Create an N-octave band spectrum from a time-domain signal:</p> <p>signal = ChannelFrame.from_wav(\"audio.wav\") spectrum = signal.noct_spectrum(fmin=20, fmax=20000, n=3)</p> <p>Plot the N-octave band spectrum:</p> <p>spectrum.plot()</p> <p>Plot with A-weighting applied:</p> <p>spectrum.plot(Aw=True)</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame--notes","title":"Notes","text":"<ul> <li>Binary operations (addition, multiplication, etc.) are not currently   supported for N-octave band data.</li> <li>The actual frequency bands are determined by the parameters n, G, and fr   according to IEC 61260-1:2014 standard for fractional octave band filters.</li> <li>The class follows acoustic standards for band definitions and analysis,   making it suitable for noise measurements and sound level analysis.</li> <li>A-weighting is available for better correlation with human hearing   perception, following IEC 61672-1:2013.</li> </ul> Source code in <code>wandas/frames/noct.py</code> <pre><code>class NOctFrame(BaseFrame[NDArrayReal]):\n    \"\"\"\n    Class for handling N-octave band analysis data.\n\n    This class represents frequency data analyzed in fractional octave bands,\n    typically used in acoustic and vibration analysis. It handles real-valued\n    data representing energy or power in each frequency band, following standard\n    acoustical band definitions.\n\n    Parameters\n    ----------\n    data : DaArray\n        The N-octave band data. Must be a dask array with shape:\n        - (channels, frequency_bins) for multi-channel data\n        - (frequency_bins,) for single-channel data, which will be\n          reshaped to (1, frequency_bins)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    fmin : float, default=0\n        Lower frequency bound in Hz.\n    fmax : float, default=0\n        Upper frequency bound in Hz.\n    n : int, default=3\n        Number of bands per octave (e.g., 3 for third-octave bands).\n    G : int, default=10\n        Reference band number according to IEC 61260-1:2014.\n    fr : int, default=1000\n        Reference frequency in Hz, typically 1000 Hz for acoustic analysis.\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    freqs : NDArrayReal\n        The center frequencies of each band in Hz, calculated according to\n        the standard fractional octave band definitions.\n    dB : NDArrayReal\n        The spectrum in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrum in decibels, applying frequency weighting\n        for better correlation with perceived loudness.\n    fmin : float\n        Lower frequency bound in Hz.\n    fmax : float\n        Upper frequency bound in Hz.\n    n : int\n        Number of bands per octave.\n    G : int\n        Reference band number.\n    fr : int\n        Reference frequency in Hz.\n\n    Examples\n    --------\n    Create an N-octave band spectrum from a time-domain signal:\n    &gt;&gt;&gt; signal = ChannelFrame.from_wav(\"audio.wav\")\n    &gt;&gt;&gt; spectrum = signal.noct_spectrum(fmin=20, fmax=20000, n=3)\n\n    Plot the N-octave band spectrum:\n    &gt;&gt;&gt; spectrum.plot()\n\n    Plot with A-weighting applied:\n    &gt;&gt;&gt; spectrum.plot(Aw=True)\n\n    Notes\n    -----\n    - Binary operations (addition, multiplication, etc.) are not currently\n      supported for N-octave band data.\n    - The actual frequency bands are determined by the parameters n, G, and fr\n      according to IEC 61260-1:2014 standard for fractional octave band filters.\n    - The class follows acoustic standards for band definitions and analysis,\n      making it suitable for noise measurements and sound level analysis.\n    - A-weighting is available for better correlation with human hearing\n      perception, following IEC 61672-1:2013.\n    \"\"\"\n\n    fmin: float\n    fmax: float\n    n: int\n    G: int\n    fr: int\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        fmin: float = 0,\n        fmax: float = 0,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a NOctFrame instance.\n\n        Sets up N-octave band analysis parameters and prepares the frame for\n        storing band-filtered data. Data shape is validated to ensure compatibility\n        with N-octave band analysis.\n\n        See class docstring for parameter descriptions.\n        \"\"\"\n        self.n = n\n        self.G = G\n        self.fr = fr\n        self.fmin = fmin\n        self.fmax = fmax\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrum in decibels relative to each channel's reference value.\n\n        The reference value for each channel is specified in its metadata.\n        A minimum value of -120 dB is enforced to avoid numerical issues.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrum in decibels. Shape matches the input data shape:\n            (channels, frequency_bins).\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        ref = np.array([ch.ref for ch in self._channel_metadata])\n        # dB\u5909\u63db\n        # 0\u9664\u7b97\u3092\u907f\u3051\u308b\u305f\u3081\u306b\u3001\u6700\u5927\u5024\u30681e-12\u306e\u3044\u305a\u308c\u304b\u3092\u4f7f\u7528\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(self.data / ref[..., np.newaxis], 1e-12)\n        )\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrum in decibels.\n\n        A-weighting applies a frequency-dependent weighting filter that approximates\n        the human ear's response to different frequencies. This is particularly useful\n        for analyzing noise and acoustic measurements as it provides a better\n        correlation with perceived loudness.\n\n        The weighting is applied according to IEC 61672-1:2013 standard.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrum in decibels. Shape matches the input data shape:\n            (channels, frequency_bins).\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels in the N-octave band data.\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the center frequencies of each band in Hz.\n\n        These frequencies are calculated based on the N-octave band parameters\n        (n, G, fr) and the frequency bounds (fmin, fmax) according to\n        IEC 61260-1:2014 standard for fractional octave band filters.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of center frequencies for each frequency band.\n\n        Raises\n        ------\n        ValueError\n            If the center frequencies cannot be calculated or the result\n            is not a numpy array.\n        \"\"\"\n        _, freqs = _center_freq(\n            fmax=self.fmax,\n            fmin=self.fmin,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        if isinstance(freqs, np.ndarray):\n            return freqs\n        else:\n            raise ValueError(\"freqs is not numpy array.\")\n\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"\n        Binary operations are not currently supported for N-octave band data.\n\n        Parameters\n        ----------\n        other : Union[S, int, float, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation.\n        symbol : str\n            String representation of the operation (e.g., '+', '-', '*', '/').\n\n        Raises\n        ------\n        NotImplementedError\n            Always raises this error as operations are not implemented\n            for N-octave band data.\n        \"\"\"\n        raise NotImplementedError(\n            f\"Operation {symbol} is not implemented for NOctFrame.\"\n        )\n        return self\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        \u9045\u5ef6\u8a55\u4fa1\u3092\u4f7f\u7528\u3057\u3066\u64cd\u4f5c\u3092\u9069\u7528\u3057\u307e\u3059\u3002\n        \"\"\"\n        # \u9045\u5ef6\u8a55\u4fa1\u3092\u4f7f\u7528\u3057\u3066\u64cd\u4f5c\u3092\u9069\u7528\n        raise NotImplementedError(\n            f\"Operation {operation_name} is not implemented for NOctFrame.\"\n        )\n        return self\n\n    def plot(\n        self, plot_type: str = \"noct\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the N-octave band data using various visualization strategies.\n\n        Supports standard plotting configurations for acoustic analysis,\n        including decibel scales and A-weighting.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"noct\"\n            Type of plot to create. The default \"noct\" type creates a bar plot\n            suitable for displaying N-octave band data.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n            - title: Plot title\n            - xlabel, ylabel: Axis labels\n            - xscale: Set to \"log\" for logarithmic frequency axis\n            - grid: Whether to show grid lines\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[NOctFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get additional initialization arguments for NOctFrame.\n\n        This internal method provides the additional initialization arguments\n        required by NOctFrame beyond those required by BaseFrame. These include\n        the N-octave band analysis parameters that define the frequency bands.\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments specific to NOctFrame:\n            - n: Number of bands per octave\n            - G: Reference band number\n            - fr: Reference frequency\n            - fmin: Lower frequency bound\n            - fmax: Upper frequency bound\n        \"\"\"\n        return {\n            \"n\": self.n,\n            \"G\": self.G,\n            \"fr\": self.fr,\n            \"fmin\": self.fmin,\n            \"fmax\": self.fmax,\n        }\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrum in decibels relative to each channel's reference value.</p> <p>The reference value for each channel is specified in its metadata. A minimum value of -120 dB is enforced to avoid numerical issues.</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrum in decibels. Shape matches the input data shape:     (channels, frequency_bins).</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrum in decibels.</p> <p>A-weighting applies a frequency-dependent weighting filter that approximates the human ear's response to different frequencies. This is particularly useful for analyzing noise and acoustic measurements as it provides a better correlation with perceived loudness.</p> <p>The weighting is applied according to IEC 61672-1:2013 standard.</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrum in decibels. Shape matches the input data shape:     (channels, frequency_bins).</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the center frequencies of each band in Hz.</p> <p>These frequencies are calculated based on the N-octave band parameters (n, G, fr) and the frequency bounds (fmin, fmax) according to IEC 61260-1:2014 standard for fractional octave band filters.</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of center frequencies for each frequency band.</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.freqs--raises","title":"Raises","text":"<p>ValueError     If the center frequencies cannot be calculated or the result     is not a numpy array.</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.__init__","title":"<code>__init__(data, sampling_rate, fmin=0, fmax=0, n=3, G=10, fr=1000, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a NOctFrame instance.</p> <p>Sets up N-octave band analysis parameters and prepares the frame for storing band-filtered data. Data shape is validated to ensure compatibility with N-octave band analysis.</p> <p>See class docstring for parameter descriptions.</p> Source code in <code>wandas/frames/noct.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    fmin: float = 0,\n    fmax: float = 0,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a NOctFrame instance.\n\n    Sets up N-octave band analysis parameters and prepares the frame for\n    storing band-filtered data. Data shape is validated to ensure compatibility\n    with N-octave band analysis.\n\n    See class docstring for parameter descriptions.\n    \"\"\"\n    self.n = n\n    self.G = G\n    self.fr = fr\n    self.fmin = fmin\n    self.fmax = fmax\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.plot","title":"<code>plot(plot_type='noct', ax=None, **kwargs)</code>","text":"<p>Plot the N-octave band data using various visualization strategies.</p> <p>Supports standard plotting configurations for acoustic analysis, including decibel scales and A-weighting.</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"noct\"     Type of plot to create. The default \"noct\" type creates a bar plot     suitable for displaying N-octave band data. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting     - title: Plot title     - xlabel, ylabel: Axis labels     - xscale: Set to \"log\" for logarithmic frequency axis     - grid: Whether to show grid lines</p>"},{"location":"ja/api/frames/#wandas.frames.noct.NOctFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/noct.py</code> <pre><code>def plot(\n    self, plot_type: str = \"noct\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the N-octave band data using various visualization strategies.\n\n    Supports standard plotting configurations for acoustic analysis,\n    including decibel scales and A-weighting.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"noct\"\n        Type of plot to create. The default \"noct\" type creates a bar plot\n        suitable for displaying N-octave band data.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n        - title: Plot title\n        - xlabel, ylabel: Axis labels\n        - xscale: Set to \"log\" for logarithmic frequency axis\n        - grid: Whether to show grid lines\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[NOctFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"ja/api/processing/","title":"\u4fe1\u53f7\u51e6\u7406\u30e2\u30b8\u30e5\u30fc\u30eb\uff08Processing\uff09","text":"<p>\u3053\u306e\u30da\u30fc\u30b8\u3067\u306fWandas\u306e\u4fe1\u53f7\u51e6\u7406\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002\u4fe1\u53f7\u51e6\u7406\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u3001\u6642\u7cfb\u5217\u30c7\u30fc\u30bf\u306b\u5bfe\u3059\u308b\u69d8\u3005\u306a\u51e6\u7406\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"ja/api/processing/#_1","title":"\u6642\u7cfb\u5217\u51e6\u7406","text":"<p>\u6642\u7cfb\u5217\u30c7\u30fc\u30bf\u306b\u5bfe\u3059\u308b\u51e6\u7406\u95a2\u6570\u3067\u3059\u3002\u3053\u308c\u3089\u306e\u95a2\u6570\u306f\u57fa\u672c\u7684\u306b<code>ChannelFrame</code>\u30e1\u30bd\u30c3\u30c9\u3092\u901a\u3058\u3066\u4f7f\u7528\u3057\u307e\u3059\u3002</p> <pre><code># \u4e00\u822c\u7684\u306a\u4f7f\u7528\u65b9\u6cd5\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")\nfiltered_frame = frame.filter(cutoff=1000, filter_type=\"lowpass\")\nresampled_frame = frame.resample(target_rate=16000)\n</code></pre>"},{"location":"ja/api/processing/#_2","title":"\u4e3b\u8981\u306a\u51e6\u7406\u30af\u30e9\u30b9","text":"<p>\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3084\u4ed6\u306e\u4fe1\u53f7\u51e6\u7406\u6a5f\u80fd\u306f\u3001\u5185\u90e8\u7684\u306b\u306f\u4ee5\u4e0b\u306e\u30af\u30e9\u30b9\u306b\u3088\u3063\u3066\u5b9f\u88c5\u3055\u308c\u3066\u3044\u307e\u3059\uff1a</p> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>High-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class HighPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"High-pass filter operation\"\"\"\n\n    name = \"highpass_filter\"\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize high-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            limit = self.sampling_rate / 2\n            raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up high-pass filter processor\"\"\"\n        # Calculate filter coefficients (once) - safely retrieve from instance variables\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"high\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Highpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying highpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Low-pass filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class LowPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Low-pass filter operation\"\"\"\n\n    name = \"lowpass_filter\"\n    a: NDArrayReal\n    b: NDArrayReal\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize low-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            raise ValueError(\n                f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n            )\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up low-pass filter processor\"\"\"\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # \u30d5\u30a3\u30eb\u30bf\u4fc2\u6570\u3092\u4e8b\u524d\u8a08\u7b97\u3057\u3066\u4fdd\u5b58\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"low\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Lowpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying lowpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Resampling operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class ReSampling(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Resampling operation\"\"\"\n\n    name = \"resampling\"\n\n    def __init__(self, sampling_rate: float, target_sr: float):\n        \"\"\"\n        Initialize resampling operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        target_sampling_rate : float\n            Target sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate, target_sr=target_sr)\n        self.target_sr = target_sr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after resampling\n        ratio = float(self.target_sr) / float(self.sampling_rate)\n        n_samples = int(np.ceil(input_shape[-1] * ratio))\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for resampling operation\"\"\"\n        logger.debug(f\"Applying resampling to array with shape: {x.shape}\")\n        result = librosa.resample(\n            x, orig_sr=self.sampling_rate, target_sr=self.target_sr\n        )\n        logger.debug(f\"Resampling applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> <p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>A-weighting filter operation</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AWeighting(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"A-weighting filter operation\"\"\"\n\n    name = \"a_weighting\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize A-weighting filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for A-weighting filter\"\"\"\n        logger.debug(f\"Applying A-weighting to array with shape: {x.shape}\")\n        result = A_weight(x, self.sampling_rate)\n\n        # Handle case where A_weight returns a tuple\n        if isinstance(result, tuple):\n            # Use the first element of the tuple\n            result = result[0]\n\n        logger.debug(\n            f\"A-weighting applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.HighPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize high-pass filter</p>"},{"location":"ja/api/processing/#wandas.processing.time_series.HighPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize high-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.HighPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        limit = self.sampling_rate / 2\n        raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.LowPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize low-pass filter</p>"},{"location":"ja/api/processing/#wandas.processing.time_series.LowPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize low-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.LowPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        raise ValueError(\n            f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n        )\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.ReSampling.__init__","title":"<code>__init__(sampling_rate, target_sr)</code>","text":"<p>Initialize resampling operation</p>"},{"location":"ja/api/processing/#wandas.processing.time_series.ReSampling.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) target_sampling_rate : float     Target sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, target_sr: float):\n    \"\"\"\n    Initialize resampling operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    target_sampling_rate : float\n        Target sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate, target_sr=target_sr)\n    self.target_sr = target_sr\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.ReSampling.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"ja/api/processing/#wandas.processing.time_series.ReSampling.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"ja/api/processing/#wandas.processing.time_series.ReSampling.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after resampling\n    ratio = float(self.target_sr) / float(self.sampling_rate)\n    n_samples = int(np.ceil(input_shape[-1] * ratio))\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.AWeighting.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize A-weighting filter</p>"},{"location":"ja/api/processing/#wandas.processing.time_series.AWeighting.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize A-weighting filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"ja/api/processing/#audiooperation","title":"AudioOperation","text":"<p><code>AudioOperation</code> \u30af\u30e9\u30b9\u306f\u97f3\u58f0\u51e6\u7406\u64cd\u4f5c\u306e\u62bd\u8c61\u5316\u3068\u9023\u9396\u51e6\u7406\u3092\u53ef\u80fd\u306b\u3057\u307e\u3059\u3002</p> <pre><code>from wandas.processing.time_series import AudioOperation\n\n# \u4f7f\u7528\u4f8b\nimport wandas\nframe = wandas.read_wav(\"audio.wav\")\n\n# \u8907\u6570\u306e\u51e6\u7406\u3092\u9023\u9396\u3055\u305b\u308b\noperation = (\n    AudioOperation()\n    .add_step(\"filter\", cutoff=1000, filter_type=\"lowpass\")\n    .add_step(\"normalize\")\n)\n\n# \u51e6\u7406\u3092\u9069\u7528\nprocessed_frame = operation.apply(frame)\n</code></pre> <p>               Bases: <code>Generic[InputArrayType, OutputArrayType]</code></p> <p>Abstract base class for audio processing operations.</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>class AudioOperation(Generic[InputArrayType, OutputArrayType]):\n    \"\"\"Abstract base class for audio processing operations.\"\"\"\n\n    # Class variable: operation name\n    name: ClassVar[str]\n\n    def __init__(self, sampling_rate: float, **params: Any):\n        \"\"\"\n        Initialize AudioOperation.\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        **params : Any\n            Operation-specific parameters\n        \"\"\"\n        self.sampling_rate = sampling_rate\n        self.params = params\n\n        # Validate parameters during initialization\n        self.validate_params()\n\n        # Create processor function (lazy initialization possible)\n        self._setup_processor()\n\n        logger.debug(\n            f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n        )\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n        pass\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up processor function (implemented by subclasses)\"\"\"\n        pass\n\n    def _process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function (implemented by subclasses)\"\"\"\n        # Default is no-op function\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    @dask.delayed  # type: ignore [misc, unused-ignore]\n    def process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n        # Default is no-op function\n        logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n        return self._process_array(x)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation (implemented by subclasses)\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        \"\"\"\n        Execute operation and return result\n        data shape is (channels, samples)\n        \"\"\"\n        # Add task as delayed processing\n        logger.debug(\"Adding delayed operation to computation graph\")\n        delayed_result = self.process_array(data)\n        # Convert delayed result to dask array and return\n        output_shape = self.calculate_output_shape(data.shape)\n        return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.AudioOperation.__init__","title":"<code>__init__(sampling_rate, **params)</code>","text":"<p>Initialize AudioOperation.</p>"},{"location":"ja/api/processing/#wandas.processing.time_series.AudioOperation.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) **params : Any     Operation-specific parameters</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def __init__(self, sampling_rate: float, **params: Any):\n    \"\"\"\n    Initialize AudioOperation.\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    **params : Any\n        Operation-specific parameters\n    \"\"\"\n    self.sampling_rate = sampling_rate\n    self.params = params\n\n    # Validate parameters during initialization\n    self.validate_params()\n\n    # Create processor function (lazy initialization possible)\n    self._setup_processor()\n\n    logger.debug(\n        f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n    )\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.AudioOperation.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation (implemented by subclasses)</p>"},{"location":"ja/api/processing/#wandas.processing.time_series.AudioOperation.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"ja/api/processing/#wandas.processing.time_series.AudioOperation.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation (implemented by subclasses)\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.AudioOperation.process","title":"<code>process(data)</code>","text":"<p>Execute operation and return result data shape is (channels, samples)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    \"\"\"\n    Execute operation and return result\n    data shape is (channels, samples)\n    \"\"\"\n    # Add task as delayed processing\n    logger.debug(\"Adding delayed operation to computation graph\")\n    delayed_result = self.process_array(data)\n    # Convert delayed result to dask array and return\n    output_shape = self.calculate_output_shape(data.shape)\n    return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.AudioOperation.process_array","title":"<code>process_array(x)</code>","text":"<p>Processing function wrapped with @dask.delayed</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>@dask.delayed  # type: ignore [misc, unused-ignore]\ndef process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n    \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n    # Default is no-op function\n    logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n    return self._process_array(x)\n</code></pre>"},{"location":"ja/api/processing/#wandas.processing.time_series.AudioOperation.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters (raises exception if invalid)</p> Source code in <code>wandas/processing/time_series.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n    pass\n</code></pre>"},{"location":"ja/explanation/","title":"\u7406\u8ad6\u80cc\u666f\u3068\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3","text":"<p>\u3053\u306e\u30bb\u30af\u30b7\u30e7\u30f3\u3067\u306f\u3001Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u8a2d\u8a08\u601d\u60f3\u3001\u5185\u90e8\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u3001\u304a\u3088\u3073\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u4f7f\u7528\u3055\u308c\u3066\u3044\u308b\u7406\u8ad6\u7684\u80cc\u666f\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002</p>"},{"location":"ja/explanation/#_2","title":"\u8a2d\u8a08\u601d\u60f3","text":"<p>Wandas\u306f\u4ee5\u4e0b\u306e\u8a2d\u8a08\u539f\u5247\u306b\u57fa\u3065\u3044\u3066\u958b\u767a\u3055\u308c\u3066\u3044\u307e\u3059\uff1a</p> <ol> <li>\u76f4\u611f\u7684\u306aAPI\u8a2d\u8a08 - \u30e6\u30fc\u30b6\u30fc\u304c\u7c21\u5358\u306b\u4f7f\u3048\u308b\u4e00\u8cab\u6027\u306e\u3042\u308b\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9</li> <li>\u52b9\u7387\u7684\u306a\u30e1\u30e2\u30ea\u4f7f\u7528 - \u5927\u898f\u6a21\u30c7\u30fc\u30bf\u306e\u51e6\u7406\u306b\u9069\u3057\u305f\u30e1\u30e2\u30ea\u52b9\u7387\u306e\u826f\u3044\u5b9f\u88c5</li> <li>\u62e1\u5f35\u6027 - \u65b0\u3057\u3044\u6a5f\u80fd\u3084\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u8ffd\u52a0\u3057\u3084\u3059\u3044\u62e1\u5f35\u53ef\u80fd\u306a\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3</li> <li>\u79d1\u5b66\u7684\u6b63\u78ba\u6027 - \u97f3\u97ff\u4fe1\u53f7\u51e6\u7406\u306e\u7406\u8ad6\u306b\u57fa\u3065\u304f\u6b63\u78ba\u306a\u5b9f\u88c5</li> </ol>"},{"location":"ja/explanation/#_3","title":"\u30b3\u30a2\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3","text":""},{"location":"ja/explanation/#_4","title":"\u30c7\u30fc\u30bf\u30e2\u30c7\u30eb","text":"<p>Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u4e2d\u5fc3\u3068\u306a\u308b\u30c7\u30fc\u30bf\u30e2\u30c7\u30eb\u306f\u968e\u5c64\u7684\u306b\u69cb\u6210\u3055\u308c\u3066\u3044\u307e\u3059\uff1a</p> <pre><code>BaseChannel (\u57fa\u5e95\u30af\u30e9\u30b9)\n \u251c\u2500\u2500 Channel (\u6642\u9593\u9818\u57df\u4fe1\u53f7)\n \u2502    \u2514\u2500\u2500 FrequencyChannel (\u5468\u6ce2\u6570\u9818\u57df\u4fe1\u53f7)\n \u2502         \u2514\u2500\u2500 TimeFrequencyChannel (\u6642\u9593-\u5468\u6ce2\u6570\u9818\u57df\u4fe1\u53f7)\n \u2514\u2500\u2500 ChannelFrame (\u8907\u6570\u30c1\u30e3\u30f3\u30cd\u30eb\u306e\u30b3\u30f3\u30c6\u30ca)\n      \u251c\u2500\u2500 FileFrame (\u30d5\u30a1\u30a4\u30eb\u30d9\u30fc\u30b9\u306e\u8907\u6570\u30c1\u30e3\u30f3\u30cd\u30eb)\n      \u2514\u2500\u2500 FrequencyChannelFrame (\u5468\u6ce2\u6570\u9818\u57df\u306e\u8907\u6570\u30c1\u30e3\u30f3\u30cd\u30eb)\n</code></pre> <p>\u5404\u30af\u30e9\u30b9\u306e\u8cac\u4efb\uff1a</p> <ul> <li>BaseChannel: \u3059\u3079\u3066\u306e\u30c1\u30e3\u30f3\u30cd\u30eb\u306e\u57fa\u5e95\u30af\u30e9\u30b9\u3002\u30c7\u30fc\u30bf\u30a2\u30af\u30bb\u30b9\u3001\u30e1\u30bf\u30c7\u30fc\u30bf\u7ba1\u7406\u306e\u57fa\u672c\u6a5f\u80fd\u3092\u63d0\u4f9b</li> <li>Channel: \u6642\u9593\u9818\u57df\u306e\u4fe1\u53f7\u30c7\u30fc\u30bf\u3068\u3001\u305d\u308c\u306b\u5bfe\u3059\u308b\u51e6\u7406\u30e1\u30bd\u30c3\u30c9\u3092\u5b9f\u88c5</li> <li>FrequencyChannel: FFT\u30d9\u30fc\u30b9\u306e\u5468\u6ce2\u6570\u9818\u57df\u30c7\u30fc\u30bf\u3068\u51e6\u7406\u3092\u5b9f\u88c5</li> <li>TimeFrequencyChannel: \u77ed\u6642\u9593\u30d5\u30fc\u30ea\u30a8\u5909\u63db\uff08STFT\uff09\u306a\u3069\u306e\u6642\u9593-\u5468\u6ce2\u6570\u9818\u57df\u8868\u73fe\u3092\u5b9f\u88c5</li> <li>ChannelFrame: \u8907\u6570\u306e\u30c1\u30e3\u30f3\u30cd\u30eb\u3092\u7ba1\u7406\u3057\u3001\u4e00\u62ec\u51e6\u7406\u3092\u53ef\u80fd\u306b\u3059\u308b\u30b3\u30f3\u30c6\u30ca</li> </ul>"},{"location":"ja/explanation/#_5","title":"\u30c7\u30fc\u30bf\u51e6\u7406\u30d5\u30ed\u30fc","text":"<ol> <li>\u5165\u529b\u6bb5\u968e: WAV\u3084CSV\u306a\u3069\u306e\u30d5\u30a1\u30a4\u30eb\u304b\u3089<code>Channel</code>\u307e\u305f\u306f<code>ChannelFrame</code>\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210</li> <li>\u51e6\u7406\u6bb5\u968e: \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3001\u30ea\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u306a\u3069\u306e\u51e6\u7406\u3092\u9069\u7528</li> <li>\u5206\u6790\u6bb5\u968e: \u4fe1\u53f7\u306e\u7279\u6027\uff08\u30b9\u30da\u30af\u30c8\u30eb\u3001\u30ec\u30d9\u30eb\u7b49\uff09\u3092\u5206\u6790</li> <li>\u51fa\u529b\u6bb5\u968e: \u51e6\u7406\u7d50\u679c\u3092\u30d5\u30a1\u30a4\u30eb\u306b\u4fdd\u5b58\u307e\u305f\u306f\u30b0\u30e9\u30d5\u3068\u3057\u3066\u53ef\u8996\u5316</li> </ol>"},{"location":"ja/explanation/#_6","title":"\u5b9f\u88c5\u8a73\u7d30","text":""},{"location":"ja/explanation/#_7","title":"\u30e1\u30e2\u30ea\u52b9\u7387","text":"<p>Wandas\u306f\u5927\u898f\u6a21\u306a\u30aa\u30fc\u30c7\u30a3\u30aa\u30c7\u30fc\u30bf\u3092\u6271\u3046\u305f\u3081\u306b\u3001\u4ee5\u4e0b\u306e\u65b9\u6cd5\u3067\u30e1\u30e2\u30ea\u52b9\u7387\u3092\u78ba\u4fdd\u3057\u3066\u3044\u307e\u3059\uff1a</p> <ul> <li>\u9045\u5ef6\u8a55\u4fa1: \u5fc5\u8981\u306b\u306a\u308b\u307e\u3067\u8a08\u7b97\u3092\u9045\u5ef6\u3055\u305b\u308b\u4ed5\u7d44\u307f</li> <li>\u30e1\u30e2\u30ea\u30de\u30c3\u30d4\u30f3\u30b0: \u5927\u304d\u306a\u30d5\u30a1\u30a4\u30eb\u3067\u3082\u30e1\u30e2\u30ea\u306b\u5168\u3066\u8aad\u307f\u8fbc\u307e\u305a\u306b\u30a2\u30af\u30bb\u30b9</li> <li>dask\u3068H5PY: \u5927\u898f\u6a21\u30c7\u30fc\u30bf\u306e\u51e6\u7406\u306b\u9069\u3057\u305f\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u6d3b\u7528</li> </ul>"},{"location":"ja/explanation/#_8","title":"\u4fe1\u53f7\u51e6\u7406\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0","text":"<p>Wandas\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u4fe1\u53f7\u51e6\u7406\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u5b9f\u88c5\u3057\u3066\u3044\u307e\u3059\uff1a</p> <ul> <li>\u30c7\u30b8\u30bf\u30eb\u30d5\u30a3\u30eb\u30bf: \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf\u306a\u3069\u306eIIR/FIR\u30d5\u30a3\u30eb\u30bf</li> <li>\u30b9\u30da\u30af\u30c8\u30eb\u5206\u6790: \u9ad8\u901f\u30d5\u30fc\u30ea\u30a8\u5909\u63db\uff08FFT\uff09\u306b\u57fa\u3065\u304f\u5468\u6ce2\u6570\u5206\u6790</li> <li>\u6642\u9593-\u5468\u6ce2\u6570\u5206\u6790: \u77ed\u6642\u9593\u30d5\u30fc\u30ea\u30a8\u5909\u63db\uff08STFT\uff09\u3001\u30b9\u30da\u30af\u30c8\u30ed\u30b0\u30e9\u30e0</li> <li>\u7d71\u8a08\u7684\u5206\u6790: RMS\u3001\u30d4\u30fc\u30af\u5024\u3001\u30af\u30ec\u30b9\u30c8\u30d5\u30a1\u30af\u30bf\u30fc\u306a\u3069\u306e\u4fe1\u53f7\u7279\u6027\u306e\u8a08\u7b97</li> </ul>"},{"location":"ja/explanation/#_9","title":"\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u306e\u8003\u616e\u4e8b\u9805","text":"<p>Wandas\u3092\u4f7f\u7528\u3059\u308b\u969b\u306e\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u306b\u95a2\u3059\u308b\u8003\u616e\u4e8b\u9805\uff1a</p> <ul> <li>\u5927\u91cf\u306e\u30c7\u30fc\u30bf\u3092\u51e6\u7406\u3059\u308b\u5834\u5408\u306f\u3001\u51e6\u7406\u3092\u30c1\u30e3\u30f3\u30af\u5358\u4f4d\u3067\u884c\u3046\u3053\u3068\u3092\u691c\u8a0e</li> <li>\u8907\u96d1\u306a\u51e6\u7406\u30c1\u30a7\u30fc\u30f3\u3092\u69cb\u7bc9\u3059\u308b\u5834\u5408\u306f\u3001\u4e2d\u9593\u7d50\u679c\u3092\u30ad\u30e3\u30c3\u30b7\u30e5\u3059\u308b\u3053\u3068\u3067\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u3092\u5411\u4e0a</li> <li>\u30de\u30eb\u30c1\u30c1\u30e3\u30f3\u30cd\u30eb\u51e6\u7406\u306f\u30de\u30eb\u30c1\u30b3\u30a2\u30d7\u30ed\u30bb\u30c3\u30b5\u3092\u52b9\u7387\u7684\u306b\u6d3b\u7528</li> </ul>"},{"location":"ja/explanation/#_10","title":"\u53c2\u8003\u6587\u732e","text":"<ol> <li>Smith, J. O. (2011). Spectral Audio Signal Processing. W3K Publishing.</li> <li>M\u00fcller, M. (2015). Fundamentals of Music Processing: Audio, Analysis, Algorithms, Applications. Springer.</li> <li>Z\u00f6lzer, U. (2008). Digital Audio Signal Processing. Wiley.</li> </ol>"},{"location":"ja/how_to/","title":"\u30af\u30c3\u30af\u30d6\u30c3\u30af\uff08\u7528\u9014\u5225\u30ec\u30b7\u30d4\u96c6\uff09","text":"<p>\u3053\u306e\u30bb\u30af\u30b7\u30e7\u30f3\u3067\u306f\u3001Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u4f7f\u7528\u3057\u305f\u69d8\u3005\u306a\u5b9f\u8df5\u7684\u306a\u30bf\u30b9\u30af\u306e\u4f8b\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"ja/how_to/#_2","title":"\u57fa\u672c\u7684\u306a\u97f3\u58f0\u5206\u6790","text":"<ul> <li>\u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u306e\u57fa\u672c\u60c5\u5831\u3092\u53d6\u5f97\u3059\u308b</li> <li>\u97f3\u58f0\u306e\u5468\u6ce2\u6570\u30b9\u30da\u30af\u30c8\u30eb\u3092\u5206\u6790\u3059\u308b</li> <li>RMS\u30ec\u30d9\u30eb\u3084\u30d4\u30fc\u30af\u30ec\u30d9\u30eb\u306a\u3069\u306e\u97f3\u91cf\u7279\u6027\u3092\u6e2c\u5b9a\u3059\u308b</li> </ul>"},{"location":"ja/how_to/#_3","title":"\u4fe1\u53f7\u51e6\u7406","text":"<ul> <li>\u30ed\u30fc\u30d1\u30b9/\u30cf\u30a4\u30d1\u30b9/\u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3092\u9069\u7528\u3059\u308b</li> <li>\u7279\u5b9a\u5468\u6ce2\u6570\u5e2f\u57df\u306e\u97f3\u91cf\u3092\u8abf\u6574\u3059\u308b\uff08\u30a4\u30b3\u30e9\u30a4\u30b6\u30fc\uff09</li> <li>\u30ce\u30a4\u30ba\u9664\u53bb\u3092\u884c\u3046</li> <li>\u97f3\u58f0\u306e\u30d4\u30c3\u30c1\u3092\u5909\u66f4\u3059\u308b</li> </ul>"},{"location":"ja/how_to/#_4","title":"\u97f3\u58f0\u30c7\u30fc\u30bf\u306e\u64cd\u4f5c","text":"<ul> <li>\u8907\u6570\u306e\u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u3092\u9023\u7d50\u3059\u308b</li> <li>\u7279\u5b9a\u306e\u90e8\u5206\u3092\u5207\u308a\u51fa\u3059</li> <li>\u97f3\u58f0\u3092\u30d5\u30a7\u30fc\u30c9\u30a4\u30f3/\u30d5\u30a7\u30fc\u30c9\u30a2\u30a6\u30c8\u3055\u305b\u308b</li> <li>\u7570\u306a\u308b\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u9593\u3067\u5909\u63db\u3059\u308b</li> </ul>"},{"location":"ja/how_to/#_5","title":"\u7279\u6b8a\u52b9\u679c","text":"<ul> <li>\u30ea\u30d0\u30fc\u30d6\uff08\u6b8b\u97ff\uff09\u52b9\u679c\u3092\u8ffd\u52a0\u3059\u308b</li> <li>\u30a8\u30b3\u30fc\u52b9\u679c\u3092\u8ffd\u52a0\u3059\u308b</li> <li>\u30c7\u30a3\u30b9\u30c8\u30fc\u30b7\u30e7\u30f3\u52b9\u679c\u3092\u9069\u7528\u3059\u308b</li> </ul>"},{"location":"ja/how_to/#_6","title":"\u9ad8\u5ea6\u306a\u5fdc\u7528","text":"<ul> <li>\u97f3\u58f0\u8a8d\u8b58\u524d\u51e6\u7406\u3068\u3057\u3066\u4f7f\u7528\u3059\u308b</li> <li>\u5927\u898f\u6a21\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3092\u52b9\u7387\u7684\u306b\u51e6\u7406\u3059\u308b</li> <li>\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u51e6\u7406\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u3092\u69cb\u7bc9\u3059\u308b</li> </ul>"},{"location":"ja/how_to/#_7","title":"\u30ab\u30b9\u30bf\u30e0\u51e6\u7406\u306e\u8ffd\u52a0","text":"<ul> <li>\u72ec\u81ea\u306e\u30d5\u30a3\u30eb\u30bf\u3092\u5b9a\u7fa9\u3059\u308b</li> <li>\u65b0\u3057\u3044\u51e6\u7406\u95a2\u6570\u3092\u5b9f\u88c5\u3059\u308b</li> <li>wandas\u3068\u4ed6\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u9023\u643a\u3055\u305b\u308b</li> </ul> <p>\u30d2\u30f3\u30c8</p> <p>\u5404\u30ec\u30b7\u30d4\u306f\u72ec\u7acb\u3057\u3066\u304a\u308a\u3001\u5fc5\u8981\u306b\u5fdc\u3058\u3066\u53c2\u7167\u3067\u304d\u307e\u3059\u3002\u57fa\u672c\u7684\u306a\u4f7f\u3044\u65b9\u304c\u308f\u304b\u3089\u306a\u3044\u5834\u5408\u306f\u3001\u307e\u305a\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3092\u3054\u89a7\u304f\u3060\u3055\u3044\u3002</p>"},{"location":"ja/tutorial/","title":"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb","text":"<p>\u3053\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3067\u306f\u3001Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u57fa\u672c\u7684\u306a\u4f7f\u3044\u65b9\u30925\u5206\u3067\u5b66\u3079\u307e\u3059\u3002</p>"},{"location":"ja/tutorial/#_2","title":"\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb","text":"<pre><code>pip install wandas\n</code></pre>"},{"location":"ja/tutorial/#_3","title":"\u57fa\u672c\u7684\u306a\u4f7f\u3044\u65b9","text":""},{"location":"ja/tutorial/#1","title":"1. \u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u30a4\u30f3\u30dd\u30fc\u30c8","text":"<pre><code>import wandas as wd\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"ja/tutorial/#2","title":"2. \u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f","text":"<pre><code># WAV\u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u3080\naudio = wd.io.read_wav(\"path/to/audio.wav\")\nprint(f\"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8: {audio.sampling_rate} Hz\")\nprint(f\"\u30c1\u30e3\u30f3\u30cd\u30eb\u6570: {len(audio)}\")\n</code></pre>"},{"location":"ja/tutorial/#3","title":"3. \u4fe1\u53f7\u306e\u53ef\u8996\u5316","text":"<pre><code># \u6ce2\u5f62\u3092\u8868\u793a\naudio.plot()\nplt.show()\n</code></pre>"},{"location":"ja/tutorial/#4","title":"4. \u57fa\u672c\u7684\u306a\u4fe1\u53f7\u51e6\u7406","text":"<pre><code># \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3092\u9069\u7528\uff081kHz\u4ee5\u4e0b\u306e\u5468\u6ce2\u6570\u3092\u901a\u904e\uff09\nfiltered = audio.filter(lowpass=1000)\n\n# \u7d50\u679c\u3092\u53ef\u8996\u5316\u3057\u3066\u6bd4\u8f03\nfig, axes = plt.subplots(2, 1, figsize=(10, 6))\naudio.plot(ax=axes[0], title=\"\u30aa\u30ea\u30b8\u30ca\u30eb\u4fe1\u53f7\")\nfiltered.plot(ax=axes[1], title=\"\u30d5\u30a3\u30eb\u30bf\u5f8c\u306e\u4fe1\u53f7\")\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"ja/tutorial/#5","title":"5. \u51e6\u7406\u7d50\u679c\u306e\u4fdd\u5b58","text":"<pre><code># \u51e6\u7406\u3057\u305f\u4fe1\u53f7\u3092WAV\u30d5\u30a1\u30a4\u30eb\u3068\u3057\u3066\u4fdd\u5b58\nwd.io.write_wav(filtered, \"filtered_audio.wav\")\n</code></pre>"},{"location":"ja/tutorial/#_4","title":"\u6b21\u306e\u30b9\u30c6\u30c3\u30d7","text":"<ul> <li>\u30af\u30c3\u30af\u30d6\u30c3\u30af \u3067\u69d8\u3005\u306a\u5fdc\u7528\u4f8b\u3092\u78ba\u8a8d\u3059\u308b</li> <li>API\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9 \u3067\u8a73\u7d30\u306a\u6a5f\u80fd\u3092\u8abf\u3079\u308b</li> <li>\u7406\u8ad6\u80cc\u666f \u3067\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u8a2d\u8a08\u601d\u60f3\u3092\u7406\u89e3\u3059\u308b</li> </ul>"}]}