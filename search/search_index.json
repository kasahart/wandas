{"config":{"lang":["en","ja"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Wandas: Waveform Analysis Data Structures","text":"<p>Wandas \u306f\u3001Python\u306b\u3088\u308b\u52b9\u7387\u7684\u306a\u4fe1\u53f7\u89e3\u6790\u306e\u305f\u3081\u306e\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3059\u3002Wandas \u306f\u3001\u4fe1\u53f7\u51e6\u7406\u306e\u305f\u3081\u306e\u5305\u62ec\u7684\u306a\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u3001Matplotlib\u3068\u306e\u30b7\u30fc\u30e0\u30ec\u30b9\u306a\u7d71\u5408\u3092\u5b9f\u73fe\u3057\u3066\u3044\u307e\u3059\u3002</p>"},{"location":"#_1","title":"\u6a5f\u80fd","text":"<ul> <li>\u5305\u62ec\u7684\u306a\u4fe1\u53f7\u51e6\u7406\u6a5f\u80fd: \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3001\u30d5\u30fc\u30ea\u30a8\u5909\u63db\u3001STFT\u306a\u3069\u3001\u57fa\u672c\u7684\u306a\u4fe1\u53f7\u51e6\u7406\u64cd\u4f5c\u3092\u7c21\u5358\u306b\u5b9f\u884c\u53ef\u80fd</li> <li>\u53ef\u8996\u5316\u30e9\u30a4\u30d6\u30e9\u30ea\u3068\u306e\u7d71\u5408: Matplotlib\u3068\u30b7\u30fc\u30e0\u30ec\u30b9\u306b\u7d71\u5408\u3057\u3066\u30c7\u30fc\u30bf\u3092\u7c21\u5358\u306b\u53ef\u8996\u5316\u53ef\u80fd</li> <li>\u9045\u5ef6\u8a55\u4fa1: dask\u3092\u6d3b\u7528\u3057\u305f\u52b9\u7387\u7684\u306a\u5927\u898f\u6a21\u30c7\u30fc\u30bf\u51e6\u7406</li> <li>\u591a\u69d8\u306a\u5206\u6790\u30c4\u30fc\u30eb: \u5468\u6ce2\u6570\u5206\u6790\u3001\u30aa\u30af\u30bf\u30fc\u30d6\u30d0\u30f3\u30c9\u5206\u6790\u3001\u6642\u9593-\u5468\u6ce2\u6570\u5206\u6790\u306a\u3069</li> </ul>"},{"location":"#_2","title":"\u4f7f\u7528\u4f8b","text":""},{"location":"#_3","title":"\u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\u3068\u53ef\u8996\u5316","text":"<pre><code>import wandas as wd\n\n# docs/docs/ja/index.md \u304b\u3089\u306e\u76f8\u5bfe\u30d1\u30b9\u3067\u30b5\u30f3\u30d7\u30eb\u30c7\u30fc\u30bf\u3092\u6307\u5b9a\n# \u5b9f\u969b\u306e\u4f7f\u7528\u6642\u306f\u9069\u5207\u306a\u30d1\u30b9\u306b\u5909\u66f4\u3057\u3066\u304f\u3060\u3055\u3044\n# cf = wd.read_wav(\"../../examples/data/summer_streets1.wav\")\n# cf.describe()\n</code></pre>"},{"location":"#_4","title":"\u30d5\u30a3\u30eb\u30bf\u51e6\u7406","text":"<pre><code># import wandas as wd\n# import numpy as np\n# signal = wd.generate_sin(freqs=[5000, 1000], duration=1)\n# \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3092\u9069\u7528\n# filtered_signal = signal.low_pass_filter(cutoff=1000)\n# filtered_signal.fft().plot()\n</code></pre> <p>\u8a73\u7d30\u306a\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3084\u4f7f\u7528\u4f8b\u306b\u3064\u3044\u3066\u306f\u3001\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3092\u3054\u89a7\u304f\u3060\u3055\u3044\u3002</p>"},{"location":"#_5","title":"\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u69cb\u6210","text":"<ul> <li>\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb - 5\u5206\u3067\u59cb\u3081\u3089\u308c\u308b\u5165\u9580\u30ac\u30a4\u30c9\u3068\u4e00\u822c\u7684\u306a\u30bf\u30b9\u30af\u306e\u30ec\u30b7\u30d4\u96c6</li> <li>API\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9 - \u8a73\u7d30\u306aAPI\u4ed5\u69d8</li> <li>\u7406\u8ad6\u80cc\u666f/\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3 - \u8a2d\u8a08\u601d\u60f3\u3068\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u89e3\u8aac</li> <li>\u8ca2\u732e\u30ac\u30a4\u30c9 - \u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30b7\u30e7\u30f3\u306e\u30eb\u30fc\u30eb\u3068\u65b9\u6cd5</li> </ul>"},{"location":"#_6","title":"\u30e9\u30a4\u30bb\u30f3\u30b9","text":"<p>\u3053\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306f MIT\u30e9\u30a4\u30bb\u30f3\u30b9 \u306e\u4e0b\u3067\u516c\u958b\u3055\u308c\u3066\u3044\u307e\u3059\u3002</p>"},{"location":"contributing/","title":"Wandas\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3078\u306e\u8ca2\u732e\\n\\n\u3053\u306e\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3067\u306f\u3001Wandas\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3078\u306e\u8ca2\u732e\u65b9\u6cd5\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002","text":""},{"location":"api/","title":"API\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9","text":"<p>Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u4e3b\u8981\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u3068\u95a2\u6570\u306eAPI\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\u3067\u3059\u3002</p>"},{"location":"api/#_1","title":"\u30b3\u30a2\u30e2\u30b8\u30e5\u30fc\u30eb","text":"<p>\u30b3\u30a2\u30e2\u30b8\u30e5\u30fc\u30eb\u306fWandas\u306e\u57fa\u672c\u7684\u306a\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/#wandas.core","title":"<code>wandas.core</code>","text":""},{"location":"api/#wandas.core-attributes","title":"Attributes","text":""},{"location":"api/#wandas.core.__all__","title":"<code>__all__ = ['BaseFrame']</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.core-classes","title":"Classes","text":""},{"location":"api/#wandas.core.BaseFrame","title":"<code>BaseFrame</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for all signal frame types.</p> <p>This class provides the common interface and functionality for all frame types used in signal processing. It implements basic operations like indexing, iteration, and data manipulation that are shared across all frame types.</p>"},{"location":"api/#wandas.core.BaseFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The signal data to process. Must be a dask array. sampling_rate : float     The sampling rate of the signal in Hz. label : str, optional     A label for the frame. If not provided, defaults to \"unnamed_frame\". metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"api/#wandas.core.BaseFrame--attributes","title":"Attributes","text":"<p>sampling_rate : float     The sampling rate of the signal in Hz. label : str     The label of the frame. metadata : dict     Additional metadata for the frame. operation_history : list[dict]     History of operations performed on this frame.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>class BaseFrame(ABC, Generic[T]):\n    \"\"\"\n    Abstract base class for all signal frame types.\n\n    This class provides the common interface and functionality for all frame types\n    used in signal processing. It implements basic operations like indexing, iteration,\n    and data manipulation that are shared across all frame types.\n\n    Parameters\n    ----------\n    data : DaArray\n        The signal data to process. Must be a dask array.\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str, optional\n        A label for the frame. If not provided, defaults to \"unnamed_frame\".\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str\n        The label of the frame.\n    metadata : dict\n        Additional metadata for the frame.\n    operation_history : list[dict]\n        History of operations performed on this frame.\n    \"\"\"\n\n    _data: DaArray\n    sampling_rate: float\n    label: str\n    metadata: dict[str, Any]\n    operation_history: list[dict[str, Any]]\n    _channel_metadata: list[ChannelMetadata]\n    _previous: Optional[\"BaseFrame[Any]\"]\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ):\n        self._data = data.rechunk(chunks=-1)  # type: ignore [unused-ignore]\n        if self._data.ndim == 1:\n            self._data = self._data.reshape((1, -1))\n        self.sampling_rate = sampling_rate\n        self.label = label or \"unnamed_frame\"\n        self.metadata = metadata or {}\n        self.operation_history = operation_history or []\n        self._previous = previous\n\n        if channel_metadata:\n            self._channel_metadata = copy.deepcopy(channel_metadata)\n        else:\n            self._channel_metadata = [\n                ChannelMetadata(label=f\"ch{i}\", unit=\"\", extra={})\n                for i in range(self._n_channels)\n            ]\n\n        try:\n            # Display information for newer dask versions\n            logger.debug(f\"Dask graph layers: {list(self._data.dask.layers.keys())}\")\n            logger.debug(\n                f\"Dask graph dependencies: {len(self._data.dask.dependencies)}\"\n            )\n        except Exception as e:\n            logger.debug(f\"Dask graph visualization details unavailable: {e}\")\n\n    @property\n    @abstractmethod\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n\n    @property\n    def n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return len(self)\n\n    @property\n    def channels(self) -&gt; list[ChannelMetadata]:\n        \"\"\"Property to access channel metadata.\"\"\"\n        return self._channel_metadata\n\n    @property\n    def previous(self) -&gt; Optional[\"BaseFrame[Any]\"]:\n        \"\"\"\n        Returns the previous frame.\n        \"\"\"\n        return self._previous\n\n    def get_channel(self: S, channel_idx: int) -&gt; S:\n        n_channels = len(self)\n        if channel_idx &lt; 0 or channel_idx &gt;= n_channels:\n            range_max = n_channels - 1\n            raise ValueError(\n                f\"Channel index out of range: {channel_idx} \"\n                f\"(valid range: 0-{range_max})\"\n            )\n        logger.debug(f\"Extracting channel index={channel_idx} (lazy operation).\")\n        channel_data = self._data[channel_idx : channel_idx + 1]\n\n        return self._create_new_instance(\n            data=channel_data,\n            operation_history=self.operation_history,\n            channel_metadata=[self._channel_metadata[channel_idx]],\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Returns the number of channels.\n        \"\"\"\n        return len(self._channel_metadata)\n\n    def __iter__(self: S) -&gt; Iterator[S]:\n        for idx in range(len(self)):\n            yield self[idx]\n\n    def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n        \"\"\"\n        Method to get a channel by name or index.\n\n        Parameters\n        ----------\n        key : str, int, slice, or tuple of slices\n            Channel name (label) or index number.\n\n        Returns\n        -------\n        BaseFrame\n            The corresponding channel.\n\n        Raises\n        ------\n        ValueError\n            If the key length is invalid for the shape.\n        IndexError\n            If the channel index is out of range.\n        TypeError\n            If the key type is invalid.\n        \"\"\"\n        if isinstance(key, str):\n            index = self.label2index(key)\n            return self.get_channel(index)\n\n        elif isinstance(key, tuple):\n            # When key is a tuple, treat the first element as an index\n            if len(key) &gt; len(self.shape):\n                raise ValueError(\n                    f\"Invalid key length: {len(key)} for shape {self.shape}\"\n                )\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key[0]]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, slice):\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, numbers.Integral):\n            # Access by index number\n            if key &lt; 0 or key &gt;= len(self):\n                raise IndexError(f\"Channel index {key} out of range.\")\n            return self.get_channel(key)\n        else:\n            raise TypeError(\n                f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n            )\n\n    def label2index(self, label: str) -&gt; int:\n        \"\"\"\n        Get the index from a channel label.\n\n        Parameters\n        ----------\n        label : str\n            Channel label.\n\n        Returns\n        -------\n        int\n            Corresponding index.\n\n        Raises\n        ------\n        KeyError\n            If the channel label is not found.\n        \"\"\"\n        for idx, ch in enumerate(self._channel_metadata):\n            if ch.label == label:\n                return idx\n        raise KeyError(f\"Channel label '{label}' not found.\")\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        _shape: tuple[int, ...] = self._data.shape\n        return _shape\n\n    @property\n    def data(self) -&gt; T:\n        \"\"\"\n        Returns the computed data.\n        Calculation is executed the first time this is accessed.\n        \"\"\"\n        return self.compute()\n\n    @property\n    def labels(self) -&gt; list[str]:\n        \"\"\"Get a list of all channel labels.\"\"\"\n        return [ch.label for ch in self._channel_metadata]\n\n    def compute(self) -&gt; T:\n        \"\"\"\n        Compute and return the data.\n        This method materializes lazily computed data into a concrete NumPy array.\n\n        Returns\n        -------\n        NDArrayReal\n            The computed data.\n\n        Raises\n        ------\n        ValueError\n            If the computed result is not a NumPy array.\n        \"\"\"\n        logger.debug(\n            \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n        )\n        result = self._data.compute()\n\n        if not isinstance(result, np.ndarray):\n            raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n        logger.debug(f\"Computation complete, result shape: {result.shape}\")\n        return cast(T, result)\n\n    @abstractmethod\n    def plot(\n        self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n    ) -&gt; Union[Axes, Iterator[Axes]]:\n        \"\"\"Plot the data\"\"\"\n        pass\n\n    def persist(self: S) -&gt; S:\n        \"\"\"Persist the data in memory\"\"\"\n        persisted_data = self._data.persist()\n        return self._create_new_instance(data=persisted_data)\n\n    @abstractmethod\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Abstract method for derived classes to provide\n        additional initialization arguments.\n        \"\"\"\n        pass\n\n    def _create_new_instance(self: S, data: DaArray, **kwargs: Any) -&gt; S:\n        \"\"\"\n        Create a new channel instance based on an existing channel.\n        Keyword arguments can override or extend the original attributes.\n        \"\"\"\n\n        sampling_rate = kwargs.pop(\"sampling_rate\", self.sampling_rate)\n        # if not isinstance(sampling_rate, int):\n        #     raise TypeError(\"Sampling rate must be an integer\")\n\n        label = kwargs.pop(\"label\", self.label)\n        if not isinstance(label, str):\n            raise TypeError(\"Label must be a string\")\n\n        metadata = kwargs.pop(\"metadata\", copy.deepcopy(self.metadata))\n        if not isinstance(metadata, dict):\n            raise TypeError(\"Metadata must be a dictionary\")\n\n        channel_metadata = kwargs.pop(\n            \"channel_metadata\", copy.deepcopy(self._channel_metadata)\n        )\n        if not isinstance(channel_metadata, list):\n            raise TypeError(\"Channel metadata must be a list\")\n\n        # Get additional initialization arguments from derived classes\n        additional_kwargs = self._get_additional_init_kwargs()\n        kwargs.update(additional_kwargs)\n\n        return type(self)(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            channel_metadata=channel_metadata,\n            previous=self,\n            **kwargs,\n        )\n\n    def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n        \"\"\"Implicit conversion to NumPy array\"\"\"\n        result = self.compute()\n        if dtype is not None:\n            return result.astype(dtype)\n        return result\n\n    def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n        \"\"\"Visualize the computation graph and save it to a file\"\"\"\n        try:\n            filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n            self._data.visualize(filename=filename)\n            return filename\n        except Exception as e:\n            logger.warning(f\"Failed to visualize the graph: {e}\")\n            return None\n\n    @abstractmethod\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"Basic implementation of binary operations\"\"\"\n        # Basic logic\n        # Actual implementation is left to derived classes\n        pass\n\n    def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Addition operator\"\"\"\n        return self._binary_op(other, lambda x, y: x + y, \"+\")\n\n    def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Subtraction operator\"\"\"\n        return self._binary_op(other, lambda x, y: x - y, \"-\")\n\n    def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Multiplication operator\"\"\"\n        return self._binary_op(other, lambda x, y: x * y, \"*\")\n\n    def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Division operator\"\"\"\n        return self._binary_op(other, lambda x, y: x / y, \"/\")\n\n    def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Apply a named operation.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters to pass to the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        # Apply the operation through abstract method\n        return self._apply_operation_impl(operation_name, **params)\n\n    @abstractmethod\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"Implementation of operation application\"\"\"\n        pass\n\n    def debug_info(self) -&gt; None:\n        \"\"\"Output detailed debug information\"\"\"\n        logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n        logger.debug(f\"Label: {self.label}\")\n        logger.debug(f\"Shape: {self.shape}\")\n        logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n        logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n        self._debug_info_impl()\n        logger.debug(\"=== End Debug Info ===\")\n\n    def _debug_info_impl(self) -&gt; None:\n        \"\"\"Implement derived class-specific debug information\"\"\"\n        pass\n</code></pre>"},{"location":"api/#wandas.core.BaseFrame-attributes","title":"Attributes","text":""},{"location":"api/#wandas.core.BaseFrame.sampling_rate","title":"<code>sampling_rate = sampling_rate</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.core.BaseFrame.label","title":"<code>label = label or 'unnamed_frame'</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.core.BaseFrame.metadata","title":"<code>metadata = metadata or {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.core.BaseFrame.operation_history","title":"<code>operation_history = operation_history or []</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.core.BaseFrame.n_channels","title":"<code>n_channels</code>  <code>property</code>","text":"<p>Returns the number of channels.</p>"},{"location":"api/#wandas.core.BaseFrame.channels","title":"<code>channels</code>  <code>property</code>","text":"<p>Property to access channel metadata.</p>"},{"location":"api/#wandas.core.BaseFrame.previous","title":"<code>previous</code>  <code>property</code>","text":"<p>Returns the previous frame.</p>"},{"location":"api/#wandas.core.BaseFrame.shape","title":"<code>shape</code>  <code>property</code>","text":""},{"location":"api/#wandas.core.BaseFrame.data","title":"<code>data</code>  <code>property</code>","text":"<p>Returns the computed data. Calculation is executed the first time this is accessed.</p>"},{"location":"api/#wandas.core.BaseFrame.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>Get a list of all channel labels.</p>"},{"location":"api/#wandas.core.BaseFrame-functions","title":"Functions","text":""},{"location":"api/#wandas.core.BaseFrame.__init__","title":"<code>__init__(data, sampling_rate, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n):\n    self._data = data.rechunk(chunks=-1)  # type: ignore [unused-ignore]\n    if self._data.ndim == 1:\n        self._data = self._data.reshape((1, -1))\n    self.sampling_rate = sampling_rate\n    self.label = label or \"unnamed_frame\"\n    self.metadata = metadata or {}\n    self.operation_history = operation_history or []\n    self._previous = previous\n\n    if channel_metadata:\n        self._channel_metadata = copy.deepcopy(channel_metadata)\n    else:\n        self._channel_metadata = [\n            ChannelMetadata(label=f\"ch{i}\", unit=\"\", extra={})\n            for i in range(self._n_channels)\n        ]\n\n    try:\n        # Display information for newer dask versions\n        logger.debug(f\"Dask graph layers: {list(self._data.dask.layers.keys())}\")\n        logger.debug(\n            f\"Dask graph dependencies: {len(self._data.dask.dependencies)}\"\n        )\n    except Exception as e:\n        logger.debug(f\"Dask graph visualization details unavailable: {e}\")\n</code></pre>"},{"location":"api/#wandas.core.BaseFrame.get_channel","title":"<code>get_channel(channel_idx)</code>","text":"Source code in <code>wandas/core/base_frame.py</code> <pre><code>def get_channel(self: S, channel_idx: int) -&gt; S:\n    n_channels = len(self)\n    if channel_idx &lt; 0 or channel_idx &gt;= n_channels:\n        range_max = n_channels - 1\n        raise ValueError(\n            f\"Channel index out of range: {channel_idx} \"\n            f\"(valid range: 0-{range_max})\"\n        )\n    logger.debug(f\"Extracting channel index={channel_idx} (lazy operation).\")\n    channel_data = self._data[channel_idx : channel_idx + 1]\n\n    return self._create_new_instance(\n        data=channel_data,\n        operation_history=self.operation_history,\n        channel_metadata=[self._channel_metadata[channel_idx]],\n    )\n</code></pre>"},{"location":"api/#wandas.core.BaseFrame.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of channels.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of channels.\n    \"\"\"\n    return len(self._channel_metadata)\n</code></pre>"},{"location":"api/#wandas.core.BaseFrame.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __iter__(self: S) -&gt; Iterator[S]:\n    for idx in range(len(self)):\n        yield self[idx]\n</code></pre>"},{"location":"api/#wandas.core.BaseFrame.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Method to get a channel by name or index.</p>"},{"location":"api/#wandas.core.BaseFrame.__getitem__--parameters","title":"Parameters","text":"<p>key : str, int, slice, or tuple of slices     Channel name (label) or index number.</p>"},{"location":"api/#wandas.core.BaseFrame.__getitem__--returns","title":"Returns","text":"<p>BaseFrame     The corresponding channel.</p>"},{"location":"api/#wandas.core.BaseFrame.__getitem__--raises","title":"Raises","text":"<p>ValueError     If the key length is invalid for the shape. IndexError     If the channel index is out of range. TypeError     If the key type is invalid.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n    \"\"\"\n    Method to get a channel by name or index.\n\n    Parameters\n    ----------\n    key : str, int, slice, or tuple of slices\n        Channel name (label) or index number.\n\n    Returns\n    -------\n    BaseFrame\n        The corresponding channel.\n\n    Raises\n    ------\n    ValueError\n        If the key length is invalid for the shape.\n    IndexError\n        If the channel index is out of range.\n    TypeError\n        If the key type is invalid.\n    \"\"\"\n    if isinstance(key, str):\n        index = self.label2index(key)\n        return self.get_channel(index)\n\n    elif isinstance(key, tuple):\n        # When key is a tuple, treat the first element as an index\n        if len(key) &gt; len(self.shape):\n            raise ValueError(\n                f\"Invalid key length: {len(key)} for shape {self.shape}\"\n            )\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key[0]]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, slice):\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, numbers.Integral):\n        # Access by index number\n        if key &lt; 0 or key &gt;= len(self):\n            raise IndexError(f\"Channel index {key} out of range.\")\n        return self.get_channel(key)\n    else:\n        raise TypeError(\n            f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n        )\n</code></pre>"},{"location":"api/#wandas.core.BaseFrame.label2index","title":"<code>label2index(label)</code>","text":"<p>Get the index from a channel label.</p>"},{"location":"api/#wandas.core.BaseFrame.label2index--parameters","title":"Parameters","text":"<p>label : str     Channel label.</p>"},{"location":"api/#wandas.core.BaseFrame.label2index--returns","title":"Returns","text":"<p>int     Corresponding index.</p>"},{"location":"api/#wandas.core.BaseFrame.label2index--raises","title":"Raises","text":"<p>KeyError     If the channel label is not found.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def label2index(self, label: str) -&gt; int:\n    \"\"\"\n    Get the index from a channel label.\n\n    Parameters\n    ----------\n    label : str\n        Channel label.\n\n    Returns\n    -------\n    int\n        Corresponding index.\n\n    Raises\n    ------\n    KeyError\n        If the channel label is not found.\n    \"\"\"\n    for idx, ch in enumerate(self._channel_metadata):\n        if ch.label == label:\n            return idx\n    raise KeyError(f\"Channel label '{label}' not found.\")\n</code></pre>"},{"location":"api/#wandas.core.BaseFrame.compute","title":"<code>compute()</code>","text":"<p>Compute and return the data. This method materializes lazily computed data into a concrete NumPy array.</p>"},{"location":"api/#wandas.core.BaseFrame.compute--returns","title":"Returns","text":"<p>NDArrayReal     The computed data.</p>"},{"location":"api/#wandas.core.BaseFrame.compute--raises","title":"Raises","text":"<p>ValueError     If the computed result is not a NumPy array.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def compute(self) -&gt; T:\n    \"\"\"\n    Compute and return the data.\n    This method materializes lazily computed data into a concrete NumPy array.\n\n    Returns\n    -------\n    NDArrayReal\n        The computed data.\n\n    Raises\n    ------\n    ValueError\n        If the computed result is not a NumPy array.\n    \"\"\"\n    logger.debug(\n        \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n    )\n    result = self._data.compute()\n\n    if not isinstance(result, np.ndarray):\n        raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n    logger.debug(f\"Computation complete, result shape: {result.shape}\")\n    return cast(T, result)\n</code></pre>"},{"location":"api/#wandas.core.BaseFrame.plot","title":"<code>plot(plot_type='default', ax=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Plot the data</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>@abstractmethod\ndef plot(\n    self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n) -&gt; Union[Axes, Iterator[Axes]]:\n    \"\"\"Plot the data\"\"\"\n    pass\n</code></pre>"},{"location":"api/#wandas.core.BaseFrame.persist","title":"<code>persist()</code>","text":"<p>Persist the data in memory</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def persist(self: S) -&gt; S:\n    \"\"\"Persist the data in memory\"\"\"\n    persisted_data = self._data.persist()\n    return self._create_new_instance(data=persisted_data)\n</code></pre>"},{"location":"api/#wandas.core.BaseFrame.__array__","title":"<code>__array__(dtype=None)</code>","text":"<p>Implicit conversion to NumPy array</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n    \"\"\"Implicit conversion to NumPy array\"\"\"\n    result = self.compute()\n    if dtype is not None:\n        return result.astype(dtype)\n    return result\n</code></pre>"},{"location":"api/#wandas.core.BaseFrame.visualize_graph","title":"<code>visualize_graph(filename=None)</code>","text":"<p>Visualize the computation graph and save it to a file</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"Visualize the computation graph and save it to a file\"\"\"\n    try:\n        filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n        self._data.visualize(filename=filename)\n        return filename\n    except Exception as e:\n        logger.warning(f\"Failed to visualize the graph: {e}\")\n        return None\n</code></pre>"},{"location":"api/#wandas.core.BaseFrame.__add__","title":"<code>__add__(other)</code>","text":"<p>Addition operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Addition operator\"\"\"\n    return self._binary_op(other, lambda x, y: x + y, \"+\")\n</code></pre>"},{"location":"api/#wandas.core.BaseFrame.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtraction operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Subtraction operator\"\"\"\n    return self._binary_op(other, lambda x, y: x - y, \"-\")\n</code></pre>"},{"location":"api/#wandas.core.BaseFrame.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplication operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Multiplication operator\"\"\"\n    return self._binary_op(other, lambda x, y: x * y, \"*\")\n</code></pre>"},{"location":"api/#wandas.core.BaseFrame.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Division operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Division operator\"\"\"\n    return self._binary_op(other, lambda x, y: x / y, \"/\")\n</code></pre>"},{"location":"api/#wandas.core.BaseFrame.apply_operation","title":"<code>apply_operation(operation_name, **params)</code>","text":"<p>Apply a named operation.</p>"},{"location":"api/#wandas.core.BaseFrame.apply_operation--parameters","title":"Parameters","text":"<p>operation_name : str     Name of the operation to apply. **params : Any     Parameters to pass to the operation.</p>"},{"location":"api/#wandas.core.BaseFrame.apply_operation--returns","title":"Returns","text":"<p>S     A new instance with the operation applied.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n    \"\"\"\n    Apply a named operation.\n\n    Parameters\n    ----------\n    operation_name : str\n        Name of the operation to apply.\n    **params : Any\n        Parameters to pass to the operation.\n\n    Returns\n    -------\n    S\n        A new instance with the operation applied.\n    \"\"\"\n    # Apply the operation through abstract method\n    return self._apply_operation_impl(operation_name, **params)\n</code></pre>"},{"location":"api/#wandas.core.BaseFrame.debug_info","title":"<code>debug_info()</code>","text":"<p>Output detailed debug information</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def debug_info(self) -&gt; None:\n    \"\"\"Output detailed debug information\"\"\"\n    logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n    logger.debug(f\"Label: {self.label}\")\n    logger.debug(f\"Shape: {self.shape}\")\n    logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n    logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n    self._debug_info_impl()\n    logger.debug(\"=== End Debug Info ===\")\n</code></pre>"},{"location":"api/#wandas.core-modules","title":"Modules","text":""},{"location":"api/#wandas.core.base_frame","title":"<code>base_frame</code>","text":""},{"location":"api/#wandas.core.base_frame-attributes","title":"Attributes","text":""},{"location":"api/#wandas.core.base_frame.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.core.base_frame.T","title":"<code>T = TypeVar('T', NDArrayComplex, NDArrayReal)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.core.base_frame.S","title":"<code>S = TypeVar('S', bound='BaseFrame[Any]')</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.core.base_frame-classes","title":"Classes","text":""},{"location":"api/#wandas.core.base_frame.BaseFrame","title":"<code>BaseFrame</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for all signal frame types.</p> <p>This class provides the common interface and functionality for all frame types used in signal processing. It implements basic operations like indexing, iteration, and data manipulation that are shared across all frame types.</p>"},{"location":"api/#wandas.core.base_frame.BaseFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The signal data to process. Must be a dask array. sampling_rate : float     The sampling rate of the signal in Hz. label : str, optional     A label for the frame. If not provided, defaults to \"unnamed_frame\". metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"api/#wandas.core.base_frame.BaseFrame--attributes","title":"Attributes","text":"<p>sampling_rate : float     The sampling rate of the signal in Hz. label : str     The label of the frame. metadata : dict     Additional metadata for the frame. operation_history : list[dict]     History of operations performed on this frame.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>class BaseFrame(ABC, Generic[T]):\n    \"\"\"\n    Abstract base class for all signal frame types.\n\n    This class provides the common interface and functionality for all frame types\n    used in signal processing. It implements basic operations like indexing, iteration,\n    and data manipulation that are shared across all frame types.\n\n    Parameters\n    ----------\n    data : DaArray\n        The signal data to process. Must be a dask array.\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str, optional\n        A label for the frame. If not provided, defaults to \"unnamed_frame\".\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str\n        The label of the frame.\n    metadata : dict\n        Additional metadata for the frame.\n    operation_history : list[dict]\n        History of operations performed on this frame.\n    \"\"\"\n\n    _data: DaArray\n    sampling_rate: float\n    label: str\n    metadata: dict[str, Any]\n    operation_history: list[dict[str, Any]]\n    _channel_metadata: list[ChannelMetadata]\n    _previous: Optional[\"BaseFrame[Any]\"]\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ):\n        self._data = data.rechunk(chunks=-1)  # type: ignore [unused-ignore]\n        if self._data.ndim == 1:\n            self._data = self._data.reshape((1, -1))\n        self.sampling_rate = sampling_rate\n        self.label = label or \"unnamed_frame\"\n        self.metadata = metadata or {}\n        self.operation_history = operation_history or []\n        self._previous = previous\n\n        if channel_metadata:\n            self._channel_metadata = copy.deepcopy(channel_metadata)\n        else:\n            self._channel_metadata = [\n                ChannelMetadata(label=f\"ch{i}\", unit=\"\", extra={})\n                for i in range(self._n_channels)\n            ]\n\n        try:\n            # Display information for newer dask versions\n            logger.debug(f\"Dask graph layers: {list(self._data.dask.layers.keys())}\")\n            logger.debug(\n                f\"Dask graph dependencies: {len(self._data.dask.dependencies)}\"\n            )\n        except Exception as e:\n            logger.debug(f\"Dask graph visualization details unavailable: {e}\")\n\n    @property\n    @abstractmethod\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n\n    @property\n    def n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return len(self)\n\n    @property\n    def channels(self) -&gt; list[ChannelMetadata]:\n        \"\"\"Property to access channel metadata.\"\"\"\n        return self._channel_metadata\n\n    @property\n    def previous(self) -&gt; Optional[\"BaseFrame[Any]\"]:\n        \"\"\"\n        Returns the previous frame.\n        \"\"\"\n        return self._previous\n\n    def get_channel(self: S, channel_idx: int) -&gt; S:\n        n_channels = len(self)\n        if channel_idx &lt; 0 or channel_idx &gt;= n_channels:\n            range_max = n_channels - 1\n            raise ValueError(\n                f\"Channel index out of range: {channel_idx} \"\n                f\"(valid range: 0-{range_max})\"\n            )\n        logger.debug(f\"Extracting channel index={channel_idx} (lazy operation).\")\n        channel_data = self._data[channel_idx : channel_idx + 1]\n\n        return self._create_new_instance(\n            data=channel_data,\n            operation_history=self.operation_history,\n            channel_metadata=[self._channel_metadata[channel_idx]],\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Returns the number of channels.\n        \"\"\"\n        return len(self._channel_metadata)\n\n    def __iter__(self: S) -&gt; Iterator[S]:\n        for idx in range(len(self)):\n            yield self[idx]\n\n    def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n        \"\"\"\n        Method to get a channel by name or index.\n\n        Parameters\n        ----------\n        key : str, int, slice, or tuple of slices\n            Channel name (label) or index number.\n\n        Returns\n        -------\n        BaseFrame\n            The corresponding channel.\n\n        Raises\n        ------\n        ValueError\n            If the key length is invalid for the shape.\n        IndexError\n            If the channel index is out of range.\n        TypeError\n            If the key type is invalid.\n        \"\"\"\n        if isinstance(key, str):\n            index = self.label2index(key)\n            return self.get_channel(index)\n\n        elif isinstance(key, tuple):\n            # When key is a tuple, treat the first element as an index\n            if len(key) &gt; len(self.shape):\n                raise ValueError(\n                    f\"Invalid key length: {len(key)} for shape {self.shape}\"\n                )\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key[0]]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, slice):\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, numbers.Integral):\n            # Access by index number\n            if key &lt; 0 or key &gt;= len(self):\n                raise IndexError(f\"Channel index {key} out of range.\")\n            return self.get_channel(key)\n        else:\n            raise TypeError(\n                f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n            )\n\n    def label2index(self, label: str) -&gt; int:\n        \"\"\"\n        Get the index from a channel label.\n\n        Parameters\n        ----------\n        label : str\n            Channel label.\n\n        Returns\n        -------\n        int\n            Corresponding index.\n\n        Raises\n        ------\n        KeyError\n            If the channel label is not found.\n        \"\"\"\n        for idx, ch in enumerate(self._channel_metadata):\n            if ch.label == label:\n                return idx\n        raise KeyError(f\"Channel label '{label}' not found.\")\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        _shape: tuple[int, ...] = self._data.shape\n        return _shape\n\n    @property\n    def data(self) -&gt; T:\n        \"\"\"\n        Returns the computed data.\n        Calculation is executed the first time this is accessed.\n        \"\"\"\n        return self.compute()\n\n    @property\n    def labels(self) -&gt; list[str]:\n        \"\"\"Get a list of all channel labels.\"\"\"\n        return [ch.label for ch in self._channel_metadata]\n\n    def compute(self) -&gt; T:\n        \"\"\"\n        Compute and return the data.\n        This method materializes lazily computed data into a concrete NumPy array.\n\n        Returns\n        -------\n        NDArrayReal\n            The computed data.\n\n        Raises\n        ------\n        ValueError\n            If the computed result is not a NumPy array.\n        \"\"\"\n        logger.debug(\n            \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n        )\n        result = self._data.compute()\n\n        if not isinstance(result, np.ndarray):\n            raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n        logger.debug(f\"Computation complete, result shape: {result.shape}\")\n        return cast(T, result)\n\n    @abstractmethod\n    def plot(\n        self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n    ) -&gt; Union[Axes, Iterator[Axes]]:\n        \"\"\"Plot the data\"\"\"\n        pass\n\n    def persist(self: S) -&gt; S:\n        \"\"\"Persist the data in memory\"\"\"\n        persisted_data = self._data.persist()\n        return self._create_new_instance(data=persisted_data)\n\n    @abstractmethod\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Abstract method for derived classes to provide\n        additional initialization arguments.\n        \"\"\"\n        pass\n\n    def _create_new_instance(self: S, data: DaArray, **kwargs: Any) -&gt; S:\n        \"\"\"\n        Create a new channel instance based on an existing channel.\n        Keyword arguments can override or extend the original attributes.\n        \"\"\"\n\n        sampling_rate = kwargs.pop(\"sampling_rate\", self.sampling_rate)\n        # if not isinstance(sampling_rate, int):\n        #     raise TypeError(\"Sampling rate must be an integer\")\n\n        label = kwargs.pop(\"label\", self.label)\n        if not isinstance(label, str):\n            raise TypeError(\"Label must be a string\")\n\n        metadata = kwargs.pop(\"metadata\", copy.deepcopy(self.metadata))\n        if not isinstance(metadata, dict):\n            raise TypeError(\"Metadata must be a dictionary\")\n\n        channel_metadata = kwargs.pop(\n            \"channel_metadata\", copy.deepcopy(self._channel_metadata)\n        )\n        if not isinstance(channel_metadata, list):\n            raise TypeError(\"Channel metadata must be a list\")\n\n        # Get additional initialization arguments from derived classes\n        additional_kwargs = self._get_additional_init_kwargs()\n        kwargs.update(additional_kwargs)\n\n        return type(self)(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            channel_metadata=channel_metadata,\n            previous=self,\n            **kwargs,\n        )\n\n    def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n        \"\"\"Implicit conversion to NumPy array\"\"\"\n        result = self.compute()\n        if dtype is not None:\n            return result.astype(dtype)\n        return result\n\n    def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n        \"\"\"Visualize the computation graph and save it to a file\"\"\"\n        try:\n            filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n            self._data.visualize(filename=filename)\n            return filename\n        except Exception as e:\n            logger.warning(f\"Failed to visualize the graph: {e}\")\n            return None\n\n    @abstractmethod\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"Basic implementation of binary operations\"\"\"\n        # Basic logic\n        # Actual implementation is left to derived classes\n        pass\n\n    def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Addition operator\"\"\"\n        return self._binary_op(other, lambda x, y: x + y, \"+\")\n\n    def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Subtraction operator\"\"\"\n        return self._binary_op(other, lambda x, y: x - y, \"-\")\n\n    def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Multiplication operator\"\"\"\n        return self._binary_op(other, lambda x, y: x * y, \"*\")\n\n    def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Division operator\"\"\"\n        return self._binary_op(other, lambda x, y: x / y, \"/\")\n\n    def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Apply a named operation.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters to pass to the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        # Apply the operation through abstract method\n        return self._apply_operation_impl(operation_name, **params)\n\n    @abstractmethod\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"Implementation of operation application\"\"\"\n        pass\n\n    def debug_info(self) -&gt; None:\n        \"\"\"Output detailed debug information\"\"\"\n        logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n        logger.debug(f\"Label: {self.label}\")\n        logger.debug(f\"Shape: {self.shape}\")\n        logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n        logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n        self._debug_info_impl()\n        logger.debug(\"=== End Debug Info ===\")\n\n    def _debug_info_impl(self) -&gt; None:\n        \"\"\"Implement derived class-specific debug information\"\"\"\n        pass\n</code></pre> Attributes\u00b6 <code></code> <code>sampling_rate = sampling_rate</code> <code>instance-attribute</code> \u00b6 <code></code> <code>label = label or 'unnamed_frame'</code> <code>instance-attribute</code> \u00b6 <code></code> <code>metadata = metadata or {}</code> <code>instance-attribute</code> \u00b6 <code></code> <code>operation_history = operation_history or []</code> <code>instance-attribute</code> \u00b6 <code></code> <code>n_channels</code> <code>property</code> \u00b6 <p>Returns the number of channels.</p> <code></code> <code>channels</code> <code>property</code> \u00b6 <p>Property to access channel metadata.</p> <code></code> <code>previous</code> <code>property</code> \u00b6 <p>Returns the previous frame.</p> <code></code> <code>shape</code> <code>property</code> \u00b6 <code></code> <code>data</code> <code>property</code> \u00b6 <p>Returns the computed data. Calculation is executed the first time this is accessed.</p> <code></code> <code>labels</code> <code>property</code> \u00b6 <p>Get a list of all channel labels.</p> Functions\u00b6 <code></code> <code>__init__(data, sampling_rate, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code> \u00b6 Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n):\n    self._data = data.rechunk(chunks=-1)  # type: ignore [unused-ignore]\n    if self._data.ndim == 1:\n        self._data = self._data.reshape((1, -1))\n    self.sampling_rate = sampling_rate\n    self.label = label or \"unnamed_frame\"\n    self.metadata = metadata or {}\n    self.operation_history = operation_history or []\n    self._previous = previous\n\n    if channel_metadata:\n        self._channel_metadata = copy.deepcopy(channel_metadata)\n    else:\n        self._channel_metadata = [\n            ChannelMetadata(label=f\"ch{i}\", unit=\"\", extra={})\n            for i in range(self._n_channels)\n        ]\n\n    try:\n        # Display information for newer dask versions\n        logger.debug(f\"Dask graph layers: {list(self._data.dask.layers.keys())}\")\n        logger.debug(\n            f\"Dask graph dependencies: {len(self._data.dask.dependencies)}\"\n        )\n    except Exception as e:\n        logger.debug(f\"Dask graph visualization details unavailable: {e}\")\n</code></pre> <code></code> <code>get_channel(channel_idx)</code> \u00b6 Source code in <code>wandas/core/base_frame.py</code> <pre><code>def get_channel(self: S, channel_idx: int) -&gt; S:\n    n_channels = len(self)\n    if channel_idx &lt; 0 or channel_idx &gt;= n_channels:\n        range_max = n_channels - 1\n        raise ValueError(\n            f\"Channel index out of range: {channel_idx} \"\n            f\"(valid range: 0-{range_max})\"\n        )\n    logger.debug(f\"Extracting channel index={channel_idx} (lazy operation).\")\n    channel_data = self._data[channel_idx : channel_idx + 1]\n\n    return self._create_new_instance(\n        data=channel_data,\n        operation_history=self.operation_history,\n        channel_metadata=[self._channel_metadata[channel_idx]],\n    )\n</code></pre> <code></code> <code>__len__()</code> \u00b6 <p>Returns the number of channels.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of channels.\n    \"\"\"\n    return len(self._channel_metadata)\n</code></pre> <code></code> <code>__iter__()</code> \u00b6 Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __iter__(self: S) -&gt; Iterator[S]:\n    for idx in range(len(self)):\n        yield self[idx]\n</code></pre> <code></code> <code>__getitem__(key)</code> \u00b6 <p>Method to get a channel by name or index.</p> <code></code> <code>label2index(label)</code> \u00b6 <p>Get the index from a channel label.</p> <code></code> <code>compute()</code> \u00b6 <p>Compute and return the data. This method materializes lazily computed data into a concrete NumPy array.</p> <code></code> <code>plot(plot_type='default', ax=None, **kwargs)</code> <code>abstractmethod</code> \u00b6 <p>Plot the data</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>@abstractmethod\ndef plot(\n    self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n) -&gt; Union[Axes, Iterator[Axes]]:\n    \"\"\"Plot the data\"\"\"\n    pass\n</code></pre> <code></code> <code>persist()</code> \u00b6 <p>Persist the data in memory</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def persist(self: S) -&gt; S:\n    \"\"\"Persist the data in memory\"\"\"\n    persisted_data = self._data.persist()\n    return self._create_new_instance(data=persisted_data)\n</code></pre> <code></code> <code>__array__(dtype=None)</code> \u00b6 <p>Implicit conversion to NumPy array</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n    \"\"\"Implicit conversion to NumPy array\"\"\"\n    result = self.compute()\n    if dtype is not None:\n        return result.astype(dtype)\n    return result\n</code></pre> <code></code> <code>visualize_graph(filename=None)</code> \u00b6 <p>Visualize the computation graph and save it to a file</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"Visualize the computation graph and save it to a file\"\"\"\n    try:\n        filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n        self._data.visualize(filename=filename)\n        return filename\n    except Exception as e:\n        logger.warning(f\"Failed to visualize the graph: {e}\")\n        return None\n</code></pre> <code></code> <code>__add__(other)</code> \u00b6 <p>Addition operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Addition operator\"\"\"\n    return self._binary_op(other, lambda x, y: x + y, \"+\")\n</code></pre> <code></code> <code>__sub__(other)</code> \u00b6 <p>Subtraction operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Subtraction operator\"\"\"\n    return self._binary_op(other, lambda x, y: x - y, \"-\")\n</code></pre> <code></code> <code>__mul__(other)</code> \u00b6 <p>Multiplication operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Multiplication operator\"\"\"\n    return self._binary_op(other, lambda x, y: x * y, \"*\")\n</code></pre> <code></code> <code>__truediv__(other)</code> \u00b6 <p>Division operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Division operator\"\"\"\n    return self._binary_op(other, lambda x, y: x / y, \"/\")\n</code></pre> <code></code> <code>apply_operation(operation_name, **params)</code> \u00b6 <p>Apply a named operation.</p> <code></code> <code>debug_info()</code> \u00b6 <p>Output detailed debug information</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def debug_info(self) -&gt; None:\n    \"\"\"Output detailed debug information\"\"\"\n    logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n    logger.debug(f\"Label: {self.label}\")\n    logger.debug(f\"Shape: {self.shape}\")\n    logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n    logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n    self._debug_info_impl()\n    logger.debug(\"=== End Debug Info ===\")\n</code></pre>"},{"location":"api/#wandas.core.base_frame.BaseFrame.__getitem__--parameters","title":"Parameters","text":"<p>key : str, int, slice, or tuple of slices     Channel name (label) or index number.</p>"},{"location":"api/#wandas.core.base_frame.BaseFrame.__getitem__--returns","title":"Returns","text":"<p>BaseFrame     The corresponding channel.</p>"},{"location":"api/#wandas.core.base_frame.BaseFrame.__getitem__--raises","title":"Raises","text":"<p>ValueError     If the key length is invalid for the shape. IndexError     If the channel index is out of range. TypeError     If the key type is invalid.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n    \"\"\"\n    Method to get a channel by name or index.\n\n    Parameters\n    ----------\n    key : str, int, slice, or tuple of slices\n        Channel name (label) or index number.\n\n    Returns\n    -------\n    BaseFrame\n        The corresponding channel.\n\n    Raises\n    ------\n    ValueError\n        If the key length is invalid for the shape.\n    IndexError\n        If the channel index is out of range.\n    TypeError\n        If the key type is invalid.\n    \"\"\"\n    if isinstance(key, str):\n        index = self.label2index(key)\n        return self.get_channel(index)\n\n    elif isinstance(key, tuple):\n        # When key is a tuple, treat the first element as an index\n        if len(key) &gt; len(self.shape):\n            raise ValueError(\n                f\"Invalid key length: {len(key)} for shape {self.shape}\"\n            )\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key[0]]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, slice):\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, numbers.Integral):\n        # Access by index number\n        if key &lt; 0 or key &gt;= len(self):\n            raise IndexError(f\"Channel index {key} out of range.\")\n        return self.get_channel(key)\n    else:\n        raise TypeError(\n            f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n        )\n</code></pre>"},{"location":"api/#wandas.core.base_frame.BaseFrame.label2index--parameters","title":"Parameters","text":"<p>label : str     Channel label.</p>"},{"location":"api/#wandas.core.base_frame.BaseFrame.label2index--returns","title":"Returns","text":"<p>int     Corresponding index.</p>"},{"location":"api/#wandas.core.base_frame.BaseFrame.label2index--raises","title":"Raises","text":"<p>KeyError     If the channel label is not found.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def label2index(self, label: str) -&gt; int:\n    \"\"\"\n    Get the index from a channel label.\n\n    Parameters\n    ----------\n    label : str\n        Channel label.\n\n    Returns\n    -------\n    int\n        Corresponding index.\n\n    Raises\n    ------\n    KeyError\n        If the channel label is not found.\n    \"\"\"\n    for idx, ch in enumerate(self._channel_metadata):\n        if ch.label == label:\n            return idx\n    raise KeyError(f\"Channel label '{label}' not found.\")\n</code></pre>"},{"location":"api/#wandas.core.base_frame.BaseFrame.compute--returns","title":"Returns","text":"<p>NDArrayReal     The computed data.</p>"},{"location":"api/#wandas.core.base_frame.BaseFrame.compute--raises","title":"Raises","text":"<p>ValueError     If the computed result is not a NumPy array.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def compute(self) -&gt; T:\n    \"\"\"\n    Compute and return the data.\n    This method materializes lazily computed data into a concrete NumPy array.\n\n    Returns\n    -------\n    NDArrayReal\n        The computed data.\n\n    Raises\n    ------\n    ValueError\n        If the computed result is not a NumPy array.\n    \"\"\"\n    logger.debug(\n        \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n    )\n    result = self._data.compute()\n\n    if not isinstance(result, np.ndarray):\n        raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n    logger.debug(f\"Computation complete, result shape: {result.shape}\")\n    return cast(T, result)\n</code></pre>"},{"location":"api/#wandas.core.base_frame.BaseFrame.apply_operation--parameters","title":"Parameters","text":"<p>operation_name : str     Name of the operation to apply. **params : Any     Parameters to pass to the operation.</p>"},{"location":"api/#wandas.core.base_frame.BaseFrame.apply_operation--returns","title":"Returns","text":"<p>S     A new instance with the operation applied.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n    \"\"\"\n    Apply a named operation.\n\n    Parameters\n    ----------\n    operation_name : str\n        Name of the operation to apply.\n    **params : Any\n        Parameters to pass to the operation.\n\n    Returns\n    -------\n    S\n        A new instance with the operation applied.\n    \"\"\"\n    # Apply the operation through abstract method\n    return self._apply_operation_impl(operation_name, **params)\n</code></pre>"},{"location":"api/#wandas.core.metadata","title":"<code>metadata</code>","text":""},{"location":"api/#wandas.core.metadata-classes","title":"Classes","text":""},{"location":"api/#wandas.core.metadata.ChannelMetadata","title":"<code>ChannelMetadata</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data class for storing channel metadata</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>class ChannelMetadata(BaseModel):\n    \"\"\"\n    Data class for storing channel metadata\n    \"\"\"\n\n    label: str = \"\"\n    unit: str = \"\"\n    ref: float = 1.0\n    # Additional metadata for extensibility\n    extra: dict[str, Any] = Field(default_factory=dict)\n\n    def __init__(self, **data: Any):\n        super().__init__(**data)\n        # unit\u304c\u6307\u5b9a\u3055\u308c\u3066\u3044\u3066ref\u304c\u30c7\u30d5\u30a9\u30eb\u30c8\u5024\u306a\u3089unit_to_ref\u3067\u81ea\u52d5\u8a2d\u5b9a\n        if self.unit and (\"ref\" not in data or data.get(\"ref\", 1.0) == 1.0):\n            self.ref = unit_to_ref(self.unit)\n\n    def __getitem__(self, key: str) -&gt; Any:\n        \"\"\"Provide dictionary-like behavior\"\"\"\n        if key == \"label\":\n            return self.label\n        elif key == \"unit\":\n            return self.unit\n        elif key == \"ref\":\n            return self.ref\n        else:\n            return self.extra.get(key)\n\n    def __setitem__(self, key: str, value: Any) -&gt; None:\n        \"\"\"Provide dictionary-like behavior\"\"\"\n        if key == \"label\":\n            self.label = value\n        elif key == \"unit\":\n            self.unit = value\n            self.ref = unit_to_ref(value)\n        elif key == \"ref\":\n            self.ref = value\n        else:\n            self.extra[key] = value\n\n    def to_json(self) -&gt; str:\n        \"\"\"Convert to JSON format\"\"\"\n        json_data: str = self.model_dump_json(indent=4)\n        return json_data\n\n    @classmethod\n    def from_json(cls, json_data: str) -&gt; \"ChannelMetadata\":\n        \"\"\"Convert from JSON format\"\"\"\n        root_model: ChannelMetadata = ChannelMetadata.model_validate_json(json_data)\n\n        return root_model\n</code></pre> Attributes\u00b6 <code></code> <code>label = ''</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>unit = ''</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>ref = 1.0</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>extra = Field(default_factory=dict)</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(**data)</code> \u00b6 Source code in <code>wandas/core/metadata.py</code> <pre><code>def __init__(self, **data: Any):\n    super().__init__(**data)\n    # unit\u304c\u6307\u5b9a\u3055\u308c\u3066\u3044\u3066ref\u304c\u30c7\u30d5\u30a9\u30eb\u30c8\u5024\u306a\u3089unit_to_ref\u3067\u81ea\u52d5\u8a2d\u5b9a\n    if self.unit and (\"ref\" not in data or data.get(\"ref\", 1.0) == 1.0):\n        self.ref = unit_to_ref(self.unit)\n</code></pre> <code></code> <code>__getitem__(key)</code> \u00b6 <p>Provide dictionary-like behavior</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Any:\n    \"\"\"Provide dictionary-like behavior\"\"\"\n    if key == \"label\":\n        return self.label\n    elif key == \"unit\":\n        return self.unit\n    elif key == \"ref\":\n        return self.ref\n    else:\n        return self.extra.get(key)\n</code></pre> <code></code> <code>__setitem__(key, value)</code> \u00b6 <p>Provide dictionary-like behavior</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def __setitem__(self, key: str, value: Any) -&gt; None:\n    \"\"\"Provide dictionary-like behavior\"\"\"\n    if key == \"label\":\n        self.label = value\n    elif key == \"unit\":\n        self.unit = value\n        self.ref = unit_to_ref(value)\n    elif key == \"ref\":\n        self.ref = value\n    else:\n        self.extra[key] = value\n</code></pre> <code></code> <code>to_json()</code> \u00b6 <p>Convert to JSON format</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Convert to JSON format\"\"\"\n    json_data: str = self.model_dump_json(indent=4)\n    return json_data\n</code></pre> <code></code> <code>from_json(json_data)</code> <code>classmethod</code> \u00b6 <p>Convert from JSON format</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>@classmethod\ndef from_json(cls, json_data: str) -&gt; \"ChannelMetadata\":\n    \"\"\"Convert from JSON format\"\"\"\n    root_model: ChannelMetadata = ChannelMetadata.model_validate_json(json_data)\n\n    return root_model\n</code></pre>"},{"location":"api/#wandas.core.metadata-functions","title":"Functions","text":""},{"location":"api/#_2","title":"\u30d5\u30ec\u30fc\u30e0\u30e2\u30b8\u30e5\u30fc\u30eb","text":"<p>\u30d5\u30ec\u30fc\u30e0\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u7570\u306a\u308b\u30bf\u30a4\u30d7\u306e\u30c7\u30fc\u30bf\u30d5\u30ec\u30fc\u30e0\u3092\u5b9a\u7fa9\u3057\u307e\u3059\u3002</p>"},{"location":"api/#wandas.frames","title":"<code>wandas.frames</code>","text":""},{"location":"api/#wandas.frames-modules","title":"Modules","text":""},{"location":"api/#wandas.frames.channel","title":"<code>channel</code>","text":""},{"location":"api/#wandas.frames.channel-attributes","title":"Attributes","text":""},{"location":"api/#wandas.frames.channel.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.frames.channel.dask_delayed","title":"<code>dask_delayed = dask.delayed</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.frames.channel.da_from_delayed","title":"<code>da_from_delayed = da.from_delayed</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.frames.channel.da_from_array","title":"<code>da_from_array = da.from_array</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.frames.channel.S","title":"<code>S = TypeVar('S', bound='BaseFrame[Any]')</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.frames.channel-classes","title":"Classes","text":""},{"location":"api/#wandas.frames.channel.ChannelFrame","title":"<code>ChannelFrame</code>","text":"<p>               Bases: <code>BaseFrame[NDArrayReal]</code>, <code>ChannelProcessingMixin</code>, <code>ChannelTransformMixin</code></p> <p>Channel-based data frame for handling audio signals and time series data.</p> <p>This frame represents channel-based data such as audio signals and time series data, with each channel containing data samples in the time domain.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>class ChannelFrame(\n    BaseFrame[NDArrayReal], ChannelProcessingMixin, ChannelTransformMixin\n):\n    \"\"\"Channel-based data frame for handling audio signals and time series data.\n\n    This frame represents channel-based data such as audio signals and time series data,\n    with each channel containing data samples in the time domain.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: DaskArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"Initialize a ChannelFrame.\n\n        Args:\n            data: Dask array containing channel data.\n            Shape should be (n_channels, n_samples).\n            sampling_rate: The sampling rate of the data in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            operation_history: History of operations applied to the frame.\n            channel_metadata: Metadata for each channel.\n            previous: Reference to the previous frame in the processing chain.\n\n        Raises:\n            ValueError: If data has more than 2 dimensions.\n        \"\"\"\n        if data.ndim == 1:\n            data = da.reshape(data, (1, -1))\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return self.shape[-2]\n\n    @property\n    def time(self) -&gt; NDArrayReal:\n        \"\"\"Get time array for the signal.\n\n        Returns:\n            Array of time points in seconds.\n        \"\"\"\n        return np.arange(self.n_samples) / self.sampling_rate\n\n    @property\n    def n_samples(self) -&gt; int:\n        \"\"\"Returns the number of samples.\"\"\"\n        n: int = self._data.shape[-1]\n        return n\n\n    @property\n    def duration(self) -&gt; float:\n        \"\"\"Returns the duration in seconds.\"\"\"\n        return self.n_samples / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # Apply processing to data\n        processed_data = operation.process(self._data)\n\n        # Update metadata\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        if operation_name == \"resampling\":\n            # For resampling, update sampling rate\n            return self._create_new_instance(\n                sampling_rate=params[\"target_sr\"],\n                data=processed_data,\n                metadata=new_metadata,\n                operation_history=new_history,\n            )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaskArray\"],\n        op: Callable[[\"DaskArray\", Any], \"DaskArray\"],\n        symbol: str,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Common implementation for binary operations\n        - utilizing dask's lazy evaluation.\n\n        Args:\n            other: Right operand for the operation.\n            op: Function to execute the operation (e.g., lambda a, b: a + b).\n            symbol: Symbolic representation of the operation (e.g., '+').\n\n        Returns:\n            A new channel containing the operation result (lazy execution).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, ChannelFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Perform operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other._data)\n\n            # Merge channel metadata\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # Perform operation with scalar, NumPy array, or other types\n        else:\n            # Apply operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other)\n\n            # Operand display string\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # Check for dask.array.Array\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # Update channel metadata\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n                previous=self,\n            )\n\n    def add(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal],\n        snr: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Add another signal or value to the current signal.\n\n        If SNR is specified, performs addition with consideration for\n        signal-to-noise ratio.\n\n        Args:\n            other: Signal or value to add.\n            snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n                other signal based on this SNR.\n                self is treated as the signal, and other as the noise.\n\n        Returns:\n            A new channel frame containing the addition result (lazy execution).\n        \"\"\"\n        logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n        if isinstance(other, ChannelFrame):\n            # Check if sampling rates match\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n        elif isinstance(other, np.ndarray):\n            other = ChannelFrame.from_numpy(\n                other, self.sampling_rate, label=\"array_data\"\n            )\n        elif isinstance(other, (int, float)):\n            return self + other\n        else:\n            raise TypeError(\n                \"Addition target with SNR must be a ChannelFrame or \"\n                f\"NumPy array: {type(other)}\"\n            )\n\n        # If SNR is specified, adjust the length of the other signal\n        if other.duration != self.duration:\n            other = other.fix_length(length=self.n_samples)\n\n        if snr is None:\n            return self + other\n        return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n    def plot(\n        self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Plot the frame data.\n\n        Args:\n            plot_type: Type of plot. Default is \"waveform\".\n            ax: Optional matplotlib axes for plotting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        from ..visualization.plotting import create_operation\n\n        plot_strategy = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def rms_plot(\n        self,\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = True,\n        Aw: bool = False,  # noqa: N803\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Generate an RMS plot.\n\n        Args:\n            ax: Optional matplotlib axes for plotting.\n            title: Title for the plot.\n            overlay: Whether to overlay the plot on the existing axis.\n            Aw: Apply A-weighting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        kwargs = kwargs or {}\n        ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n        rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n        return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n\n    def describe(\n        self, normalize: bool = True, is_close: bool = True, **kwargs: Any\n    ) -&gt; None:\n        \"\"\"Display visual and audio representation of the frame.\n\n        Args:\n            normalize: Whether to normalize the audio data for playback.\n            is_close: Whether to close the figure after displaying.\n            **kwargs: Additional parameters for visualization.\n        \"\"\"\n        if \"axis_config\" in kwargs:\n            logger.warning(\n                \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            axis_config = kwargs[\"axis_config\"]\n            if \"time_plot\" in axis_config:\n                kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n            if \"freq_plot\" in axis_config:\n                if \"xlim\" in axis_config[\"freq_plot\"]:\n                    vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                    kwargs[\"vmin\"] = vlim[0]\n                    kwargs[\"vmax\"] = vlim[1]\n                if \"ylim\" in axis_config[\"freq_plot\"]:\n                    ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                    kwargs[\"ylim\"] = ylim\n\n        if \"cbar_config\" in kwargs:\n            logger.warning(\n                \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            cbar_config = kwargs[\"cbar_config\"]\n            if \"vmin\" in cbar_config:\n                kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n            if \"vmax\" in cbar_config:\n                kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n        for ch in self:\n            ax: Axes\n            _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n            if isinstance(_ax, Iterator):\n                ax = next(iter(_ax))\n            elif isinstance(_ax, Axes):\n                ax = _ax\n            else:\n                raise TypeError(\n                    f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n                )\n            # display\u95a2\u6570\u3068Audio\u30af\u30e9\u30b9\u3092\u4f7f\u7528\n            display(ax.figure)\n            if is_close:\n                plt.close(ax.figure)\n            display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))\n\n    @classmethod\n    def from_numpy(\n        cls,\n        data: NDArrayReal,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        ch_labels: Optional[list[str]] = None,\n        ch_units: Optional[Union[list[str], str]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        Args:\n            data: NumPy array containing channel data.\n            sampling_rate: The sampling rate in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            ch_labels: Labels for each channel.\n            ch_units: Units for each channel.\n\n        Returns:\n            A new ChannelFrame containing the NumPy data.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n\n        # Convert NumPy array to dask array\n        dask_data = da_from_array(data)\n        cf = cls(\n            data=dask_data,\n            sampling_rate=sampling_rate,\n            label=label or \"numpy_data\",\n        )\n        if metadata is not None:\n            cf.metadata = metadata\n        if ch_labels is not None:\n            if len(ch_labels) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel labels does not match the number of channels\"\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        if ch_units is not None:\n            if isinstance(ch_units, str):\n                ch_units = [ch_units] * cf.n_channels\n\n            if len(ch_units) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel units does not match the number of channels\"\n                )\n            for i in range(len(ch_units)):\n                cf._channel_metadata[i].unit = ch_units[i]\n\n        return cf\n\n    @classmethod\n    def from_ndarray(\n        cls,\n        array: NDArrayReal,\n        sampling_rate: float,\n        labels: Optional[list[str]] = None,\n        unit: Optional[Union[list[str], str]] = None,\n        frame_label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        This method is deprecated. Use from_numpy instead.\n\n        Args:\n            array: Signal data. Each row corresponds to a channel.\n            sampling_rate: Sampling rate (Hz).\n            labels: Labels for each channel.\n            unit: Unit of the signal.\n            frame_label: Label for the frame.\n            metadata: Optional metadata dictionary.\n\n        Returns:\n            A new ChannelFrame containing the data.\n        \"\"\"\n        # Redirect to from_numpy for compatibility\n        # However, from_ndarray is deprecated\n        logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n        return cls.from_numpy(\n            data=array,\n            sampling_rate=sampling_rate,\n            label=frame_label,\n            metadata=metadata,\n            ch_labels=labels,\n            ch_units=unit,\n        )\n\n    @classmethod\n    def from_file(\n        cls,\n        path: Union[str, Path],\n        channel: Optional[Union[int, list[int]]] = None,\n        start: Optional[float] = None,\n        end: Optional[float] = None,\n        chunk_size: Optional[int] = None,\n        ch_labels: Optional[list[str]] = None,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from an audio file.\n\n        Args:\n            path: Path to the audio file.\n            channel: Channel(s) to load.\n            start: Start time in seconds.\n            end: End time in seconds.\n            chunk_size: Chunk size for processing.\n            Specifies the splitting size for lazy processing.\n            ch_labels: Labels for each channel.\n            **kwargs: Additional arguments passed to the file reader.\n\n        Returns:\n            A new ChannelFrame containing the loaded audio data.\n\n        Raises:\n            ValueError: If channel specification is invalid.\n            TypeError: If channel parameter type is invalid.\n            FileNotFoundError: If the file doesn't exist.\n        \"\"\"\n        from .channel import ChannelFrame\n\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"File not found: {path}\")\n\n        # Get file reader\n        reader = get_file_reader(path)\n\n        # Get file info\n        info = reader.get_file_info(path, **kwargs)\n        sr = info[\"samplerate\"]\n        n_channels = info[\"channels\"]\n        n_frames = info[\"frames\"]\n        ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n        logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n        # Channel selection processing\n        all_channels = list(range(n_channels))\n\n        if channel is None:\n            channels_to_load = all_channels\n            logger.debug(f\"Will load all channels: {channels_to_load}\")\n        elif isinstance(channel, int):\n            if channel &lt; 0 or channel &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n            channels_to_load = [channel]\n            logger.debug(f\"Will load single channel: {channel}\")\n        elif isinstance(channel, (list, tuple)):\n            for ch in channel:\n                if ch &lt; 0 or ch &gt;= n_channels:\n                    raise ValueError(\n                        f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                    )\n            channels_to_load = list(channel)\n            logger.debug(f\"Will load specific channels: {channels_to_load}\")\n        else:\n            raise TypeError(\"channel must be int, list, or None\")\n\n        # Index calculation\n        start_idx = 0 if start is None else max(0, int(start * sr))\n        end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n        frames_to_read = end_idx - start_idx\n\n        logger.debug(\n            f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n            f\"start_idx={start_idx}, end_idx={end_idx}\"\n        )\n\n        # Settings for lazy loading\n        expected_shape = (len(channels_to_load), frames_to_read)\n\n        # Define the loading function using the file reader\n        def _load_audio() -&gt; NDArrayReal:\n            logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n            # Use the reader to get audio data with parameters\n            out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n            if not isinstance(out, np.ndarray):\n                raise ValueError(\"Unexpected data type after reading file\")\n            return out\n\n        logger.debug(\n            f\"Creating delayed dask task with expected shape: {expected_shape}\"\n        )\n\n        # Create delayed operation\n        delayed_data = dask_delayed(_load_audio)()\n        logger.debug(\"Wrapping delayed function in dask array\")\n\n        # Create dask array from delayed computation\n        dask_array = da_from_delayed(\n            delayed_data, shape=expected_shape, dtype=np.float32\n        )\n\n        if chunk_size is not None:\n            if chunk_size &lt;= 0:\n                raise ValueError(\"Chunk size must be a positive integer\")\n            logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n            dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n        logger.debug(\n            \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n        )\n\n        cf = ChannelFrame(\n            data=dask_array,\n            sampling_rate=sr,\n            label=path.stem,\n            metadata={\n                \"filename\": str(path),\n            },\n        )\n        if ch_labels is not None:\n            if len(ch_labels) != len(cf):\n                raise ValueError(\n                    \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        return cf\n\n    @classmethod\n    def read_wav(\n        cls, filename: str, labels: Optional[list[str]] = None\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a WAV file.\n\n        Args:\n            filename: Path to the WAV file.\n            labels: Labels to set for each channel.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(filename, ch_labels=labels)\n        return cf\n\n    @classmethod\n    def read_csv(\n        cls,\n        filename: str,\n        time_column: Union[int, str] = 0,\n        labels: Optional[list[str]] = None,\n        delimiter: str = \",\",\n        header: Optional[int] = 0,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a CSV file.\n\n        Args:\n            filename: Path to the CSV file.\n            time_column: Index or name of the time column.\n            labels: Labels to set for each channel.\n            delimiter: Delimiter character.\n            header: Row number to use as header.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(\n            filename,\n            ch_labels=labels,\n            time_column=time_column,\n            delimiter=delimiter,\n            header=header,\n        )\n        return cf\n\n    def to_wav(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n        \"\"\"Save the audio data to a WAV file.\n\n        Args:\n            path: Path to save the file.\n            format: File format. If None, determined from file extension.\n        \"\"\"\n        from wandas.io.wav_io import write_wav\n\n        write_wav(str(path), self, format=format)\n\n    def save(\n        self,\n        path: Union[str, Path],\n        *,\n        format: str = \"hdf5\",\n        compress: Optional[str] = \"gzip\",\n        overwrite: bool = False,\n        dtype: Optional[Union[str, np.dtype[Any]]] = None,\n    ) -&gt; None:\n        \"\"\"Save the ChannelFrame to a WDF (Wandas Data File) format.\n\n        This saves the complete frame including all channel data and metadata\n        in a format that can be loaded back with full fidelity.\n\n        Args:\n            path: Path to save the file. '.wdf' extension will be added if not present.\n            format: Format to use (currently only 'hdf5' is supported)\n            compress: Compression method ('gzip' by default, None for no compression)\n            overwrite: Whether to overwrite existing file\n            dtype: Optional data type conversion before saving (e.g. 'float32')\n\n        Raises:\n            FileExistsError: If the file exists and overwrite=False.\n            NotImplementedError: For unsupported formats.\n\n        Example:\n            &gt;&gt;&gt; cf = ChannelFrame.read_wav(\"audio.wav\")\n            &gt;&gt;&gt; cf.save(\"audio_analysis.wdf\")\n        \"\"\"\n        from ..io.wdf_io import save as wdf_save\n\n        wdf_save(\n            self,\n            path,\n            format=format,\n            compress=compress,\n            overwrite=overwrite,\n            dtype=dtype,\n        )\n\n    @classmethod\n    def load(cls, path: Union[str, Path], *, format: str = \"hdf5\") -&gt; \"ChannelFrame\":\n        \"\"\"Load a ChannelFrame from a WDF (Wandas Data File) file.\n\n        This loads data saved with the save() method, preserving all channel data,\n        metadata, labels, and units.\n\n        Args:\n            path: Path to the WDF file\n            format: Format of the file (currently only 'hdf5' is supported)\n\n        Returns:\n            A new ChannelFrame with all data and metadata loaded\n\n        Raises:\n            FileNotFoundError: If the file doesn't exist\n            NotImplementedError: For unsupported formats\n\n        Example:\n            &gt;&gt;&gt; cf = ChannelFrame.load(\"audio_analysis.wdf\")\n        \"\"\"\n        from ..io.wdf_io import load as wdf_load\n\n        return wdf_load(path, format=format)\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"Provide additional initialization arguments required for ChannelFrame.\"\"\"\n        return {}\n\n    def add_channel(\n        self,\n        data: Union[np.ndarray[Any, Any], DaskArray, \"ChannelFrame\"],\n        label: Optional[str] = None,\n        align: str = \"strict\",\n        suffix_on_dup: Optional[str] = None,\n        inplace: bool = False,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        # ndarray/dask/\u540c\u578bFrame\u5bfe\u5fdc\n        if isinstance(data, ChannelFrame):\n            if self.sampling_rate != data.sampling_rate:\n                raise ValueError(\"sampling_rate\u4e0d\u4e00\u81f4\")\n            if data.n_samples != self.n_samples:\n                if align == \"pad\":\n                    pad_len = self.n_samples - data.n_samples\n                    arr = data._data\n                    if pad_len &gt; 0:\n                        arr = concatenate(\n                            [\n                                arr,\n                                from_array(\n                                    np.zeros((arr.shape[0], pad_len), dtype=arr.dtype)\n                                ),\n                            ],\n                            axis=1,\n                        )\n                    else:\n                        arr = arr[:, : self.n_samples]\n                elif align == \"truncate\":\n                    arr = data._data[:, : self.n_samples]\n                    if arr.shape[1] &lt; self.n_samples:\n                        pad_len = self.n_samples - arr.shape[1]\n                        arr = concatenate(\n                            [\n                                arr,\n                                from_array(\n                                    np.zeros((arr.shape[0], pad_len), dtype=arr.dtype)\n                                ),\n                            ],\n                            axis=1,\n                        )\n                else:\n                    raise ValueError(\"\u30c7\u30fc\u30bf\u9577\u4e0d\u4e00\u81f4: align\u6307\u5b9a\u3092\u78ba\u8a8d\")\n            else:\n                arr = data._data\n            labels = [ch.label for ch in self._channel_metadata]\n            new_labels = []\n            for chmeta in data._channel_metadata:\n                new_label = chmeta.label\n                if new_label in labels or new_label in new_labels:\n                    if suffix_on_dup:\n                        new_label += suffix_on_dup\n                    else:\n                        raise ValueError(f\"label\u91cd\u8907: {new_label}\")\n                new_labels.append(new_label)\n            new_data = concatenate([self._data, arr], axis=0)\n            from ..core.metadata import ChannelMetadata\n\n            new_chmeta = self._channel_metadata + [\n                ChannelMetadata(label=lbl) for lbl in new_labels\n            ]\n            if inplace:\n                self._data = new_data\n                self._channel_metadata = new_chmeta\n                return self\n            else:\n                return ChannelFrame(\n                    data=new_data,\n                    sampling_rate=self.sampling_rate,\n                    label=self.label,\n                    metadata=self.metadata,\n                    operation_history=self.operation_history,\n                    channel_metadata=new_chmeta,\n                    previous=self,\n                )\n        if isinstance(data, np.ndarray):\n            arr = from_array(data.reshape(1, -1))\n        elif isinstance(data, DaskArray):\n            arr = data[None, ...] if data.ndim == 1 else data\n            if arr.shape[0] != 1:\n                arr = arr.reshape((1, -1))\n        else:\n            raise TypeError(\"add_channel: ndarray/dask/\u540c\u578bFrame\u306e\u307f\u5bfe\u5fdc\")\n        if arr.shape[1] != self.n_samples:\n            if align == \"pad\":\n                pad_len = self.n_samples - arr.shape[1]\n                if pad_len &gt; 0:\n                    arr = concatenate(\n                        [arr, from_array(np.zeros((1, pad_len), dtype=arr.dtype))],\n                        axis=1,\n                    )\n                else:\n                    arr = arr[:, : self.n_samples]\n            elif align == \"truncate\":\n                arr = arr[:, : self.n_samples]\n                if arr.shape[1] &lt; self.n_samples:\n                    pad_len = self.n_samples - arr.shape[1]\n                    arr = concatenate(\n                        [arr, from_array(np.zeros((1, pad_len), dtype=arr.dtype))],\n                        axis=1,\n                    )\n            else:\n                raise ValueError(\"\u30c7\u30fc\u30bf\u9577\u4e0d\u4e00\u81f4: align\u6307\u5b9a\u3092\u78ba\u8a8d\")\n        labels = [ch.label for ch in self._channel_metadata]\n        new_label = label or f\"ch{len(labels)}\"\n        if new_label in labels:\n            if suffix_on_dup:\n                new_label += suffix_on_dup\n            else:\n                raise ValueError(\"label\u91cd\u8907\")\n        new_data = concatenate([self._data, arr], axis=0)\n        from ..core.metadata import ChannelMetadata\n\n        new_chmeta = self._channel_metadata + [ChannelMetadata(label=new_label)]\n        if inplace:\n            self._data = new_data\n            self._channel_metadata = new_chmeta\n            return self\n        else:\n            return ChannelFrame(\n                data=new_data,\n                sampling_rate=self.sampling_rate,\n                label=self.label,\n                metadata=self.metadata,\n                operation_history=self.operation_history,\n                channel_metadata=new_chmeta,\n                previous=self,\n            )\n\n    def remove_channel(\n        self, key: Union[int, str], inplace: bool = False\n    ) -&gt; \"ChannelFrame\":\n        if isinstance(key, int):\n            if not (0 &lt;= key &lt; self.n_channels):\n                raise IndexError(f\"index {key} out of range\")\n            idx = key\n        else:\n            labels = [ch.label for ch in self._channel_metadata]\n            if key not in labels:\n                raise KeyError(f\"label {key} not found\")\n            idx = labels.index(key)\n        new_data = self._data[[i for i in range(self.n_channels) if i != idx], :]\n        new_chmeta = [ch for i, ch in enumerate(self._channel_metadata) if i != idx]\n        if inplace:\n            self._data = new_data\n            self._channel_metadata = new_chmeta\n            return self\n        else:\n            return ChannelFrame(\n                data=new_data,\n                sampling_rate=self.sampling_rate,\n                label=self.label,\n                metadata=self.metadata,\n                operation_history=self.operation_history,\n                channel_metadata=new_chmeta,\n                previous=self,\n            )\n</code></pre> Attributes\u00b6 <code></code> <code>time</code> <code>property</code> \u00b6 <p>Get time array for the signal.</p> <p>Returns:</p> Type Description <code>NDArrayReal</code> <p>Array of time points in seconds.</p> <code></code> <code>n_samples</code> <code>property</code> \u00b6 <p>Returns the number of samples.</p> <code></code> <code>duration</code> <code>property</code> \u00b6 <p>Returns the duration in seconds.</p> Functions\u00b6 <code></code> <code>__init__(data, sampling_rate, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code> \u00b6 <p>Initialize a ChannelFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>Dask array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate of the data in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>operation_history</code> <code>Optional[list[dict[str, Any]]]</code> <p>History of operations applied to the frame.</p> <code>None</code> <code>channel_metadata</code> <code>Optional[list[ChannelMetadata]]</code> <p>Metadata for each channel.</p> <code>None</code> <code>previous</code> <code>Optional[BaseFrame[Any]]</code> <p>Reference to the previous frame in the processing chain.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has more than 2 dimensions.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def __init__(\n    self,\n    data: DaskArray,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"Initialize a ChannelFrame.\n\n    Args:\n        data: Dask array containing channel data.\n        Shape should be (n_channels, n_samples).\n        sampling_rate: The sampling rate of the data in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        operation_history: History of operations applied to the frame.\n        channel_metadata: Metadata for each channel.\n        previous: Reference to the previous frame in the processing chain.\n\n    Raises:\n        ValueError: If data has more than 2 dimensions.\n    \"\"\"\n    if data.ndim == 1:\n        data = da.reshape(data, (1, -1))\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre> <code></code> <code>add(other, snr=None)</code> \u00b6 <p>Add another signal or value to the current signal.</p> <p>If SNR is specified, performs addition with consideration for signal-to-noise ratio.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[ChannelFrame, int, float, NDArrayReal]</code> <p>Signal or value to add.</p> required <code>snr</code> <code>Optional[float]</code> <p>Signal-to-noise ratio (dB). If specified, adjusts the scale of the other signal based on this SNR. self is treated as the signal, and other as the noise.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new channel frame containing the addition result (lazy execution).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def add(\n    self,\n    other: Union[\"ChannelFrame\", int, float, NDArrayReal],\n    snr: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Add another signal or value to the current signal.\n\n    If SNR is specified, performs addition with consideration for\n    signal-to-noise ratio.\n\n    Args:\n        other: Signal or value to add.\n        snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n            other signal based on this SNR.\n            self is treated as the signal, and other as the noise.\n\n    Returns:\n        A new channel frame containing the addition result (lazy execution).\n    \"\"\"\n    logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n    if isinstance(other, ChannelFrame):\n        # Check if sampling rates match\n        if self.sampling_rate != other.sampling_rate:\n            raise ValueError(\n                \"Sampling rates do not match. Cannot perform operation.\"\n            )\n\n    elif isinstance(other, np.ndarray):\n        other = ChannelFrame.from_numpy(\n            other, self.sampling_rate, label=\"array_data\"\n        )\n    elif isinstance(other, (int, float)):\n        return self + other\n    else:\n        raise TypeError(\n            \"Addition target with SNR must be a ChannelFrame or \"\n            f\"NumPy array: {type(other)}\"\n        )\n\n    # If SNR is specified, adjust the length of the other signal\n    if other.duration != self.duration:\n        other = other.fix_length(length=self.n_samples)\n\n    if snr is None:\n        return self + other\n    return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n</code></pre> <code></code> <code>plot(plot_type='waveform', ax=None, **kwargs)</code> \u00b6 <p>Plot the frame data.</p> <p>Parameters:</p> Name Type Description Default <code>plot_type</code> <code>str</code> <p>Type of plot. Default is \"waveform\".</p> <code>'waveform'</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def plot(\n    self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Plot the frame data.\n\n    Args:\n        plot_type: Type of plot. Default is \"waveform\".\n        ax: Optional matplotlib axes for plotting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    from ..visualization.plotting import create_operation\n\n    plot_strategy = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre> <code></code> <code>rms_plot(ax=None, title=None, overlay=True, Aw=False, **kwargs)</code> \u00b6 <p>Generate an RMS plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title for the plot.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay the plot on the existing axis.</p> <code>True</code> <code>Aw</code> <code>bool</code> <p>Apply A-weighting.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_plot(\n    self,\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = True,\n    Aw: bool = False,  # noqa: N803\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Generate an RMS plot.\n\n    Args:\n        ax: Optional matplotlib axes for plotting.\n        title: Title for the plot.\n        overlay: Whether to overlay the plot on the existing axis.\n        Aw: Apply A-weighting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    kwargs = kwargs or {}\n    ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n    rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n    return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n</code></pre> <code></code> <code>describe(normalize=True, is_close=True, **kwargs)</code> \u00b6 <p>Display visual and audio representation of the frame.</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>Whether to normalize the audio data for playback.</p> <code>True</code> <code>is_close</code> <code>bool</code> <p>Whether to close the figure after displaying.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for visualization.</p> <code>{}</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def describe(\n    self, normalize: bool = True, is_close: bool = True, **kwargs: Any\n) -&gt; None:\n    \"\"\"Display visual and audio representation of the frame.\n\n    Args:\n        normalize: Whether to normalize the audio data for playback.\n        is_close: Whether to close the figure after displaying.\n        **kwargs: Additional parameters for visualization.\n    \"\"\"\n    if \"axis_config\" in kwargs:\n        logger.warning(\n            \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        axis_config = kwargs[\"axis_config\"]\n        if \"time_plot\" in axis_config:\n            kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n        if \"freq_plot\" in axis_config:\n            if \"xlim\" in axis_config[\"freq_plot\"]:\n                vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                kwargs[\"vmin\"] = vlim[0]\n                kwargs[\"vmax\"] = vlim[1]\n            if \"ylim\" in axis_config[\"freq_plot\"]:\n                ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                kwargs[\"ylim\"] = ylim\n\n    if \"cbar_config\" in kwargs:\n        logger.warning(\n            \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        cbar_config = kwargs[\"cbar_config\"]\n        if \"vmin\" in cbar_config:\n            kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n        if \"vmax\" in cbar_config:\n            kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n    for ch in self:\n        ax: Axes\n        _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n        if isinstance(_ax, Iterator):\n            ax = next(iter(_ax))\n        elif isinstance(_ax, Axes):\n            ax = _ax\n        else:\n            raise TypeError(\n                f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n            )\n        # display\u95a2\u6570\u3068Audio\u30af\u30e9\u30b9\u3092\u4f7f\u7528\n        display(ax.figure)\n        if is_close:\n            plt.close(ax.figure)\n        display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))\n</code></pre> <code></code> <code>from_numpy(data, sampling_rate, label=None, metadata=None, ch_labels=None, ch_units=None)</code> <code>classmethod</code> \u00b6 <p>Create a ChannelFrame from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArrayReal</code> <p>NumPy array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>ch_units</code> <code>Optional[Union[list[str], str]]</code> <p>Units for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the NumPy data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_numpy(\n    cls,\n    data: NDArrayReal,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    ch_labels: Optional[list[str]] = None,\n    ch_units: Optional[Union[list[str], str]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    Args:\n        data: NumPy array containing channel data.\n        sampling_rate: The sampling rate in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        ch_labels: Labels for each channel.\n        ch_units: Units for each channel.\n\n    Returns:\n        A new ChannelFrame containing the NumPy data.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n\n    # Convert NumPy array to dask array\n    dask_data = da_from_array(data)\n    cf = cls(\n        data=dask_data,\n        sampling_rate=sampling_rate,\n        label=label or \"numpy_data\",\n    )\n    if metadata is not None:\n        cf.metadata = metadata\n    if ch_labels is not None:\n        if len(ch_labels) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel labels does not match the number of channels\"\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    if ch_units is not None:\n        if isinstance(ch_units, str):\n            ch_units = [ch_units] * cf.n_channels\n\n        if len(ch_units) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel units does not match the number of channels\"\n            )\n        for i in range(len(ch_units)):\n            cf._channel_metadata[i].unit = ch_units[i]\n\n    return cf\n</code></pre> <code></code> <code>from_ndarray(array, sampling_rate, labels=None, unit=None, frame_label=None, metadata=None)</code> <code>classmethod</code> \u00b6 <p>Create a ChannelFrame from a NumPy array.</p> <p>This method is deprecated. Use from_numpy instead.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>NDArrayReal</code> <p>Signal data. Each row corresponds to a channel.</p> required <code>sampling_rate</code> <code>float</code> <p>Sampling rate (Hz).</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>unit</code> <code>Optional[Union[list[str], str]]</code> <p>Unit of the signal.</p> <code>None</code> <code>frame_label</code> <code>Optional[str]</code> <p>Label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_ndarray(\n    cls,\n    array: NDArrayReal,\n    sampling_rate: float,\n    labels: Optional[list[str]] = None,\n    unit: Optional[Union[list[str], str]] = None,\n    frame_label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    This method is deprecated. Use from_numpy instead.\n\n    Args:\n        array: Signal data. Each row corresponds to a channel.\n        sampling_rate: Sampling rate (Hz).\n        labels: Labels for each channel.\n        unit: Unit of the signal.\n        frame_label: Label for the frame.\n        metadata: Optional metadata dictionary.\n\n    Returns:\n        A new ChannelFrame containing the data.\n    \"\"\"\n    # Redirect to from_numpy for compatibility\n    # However, from_ndarray is deprecated\n    logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n    return cls.from_numpy(\n        data=array,\n        sampling_rate=sampling_rate,\n        label=frame_label,\n        metadata=metadata,\n        ch_labels=labels,\n        ch_units=unit,\n    )\n</code></pre> <code></code> <code>from_file(path, channel=None, start=None, end=None, chunk_size=None, ch_labels=None, **kwargs)</code> <code>classmethod</code> \u00b6 <p>Create a ChannelFrame from an audio file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the audio file.</p> required <code>channel</code> <code>Optional[Union[int, list[int]]]</code> <p>Channel(s) to load.</p> <code>None</code> <code>start</code> <code>Optional[float]</code> <p>Start time in seconds.</p> <code>None</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <code>chunk_size</code> <code>Optional[int]</code> <p>Chunk size for processing.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the file reader.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the loaded audio data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If channel specification is invalid.</p> <code>TypeError</code> <p>If channel parameter type is invalid.</p> <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    path: Union[str, Path],\n    channel: Optional[Union[int, list[int]]] = None,\n    start: Optional[float] = None,\n    end: Optional[float] = None,\n    chunk_size: Optional[int] = None,\n    ch_labels: Optional[list[str]] = None,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from an audio file.\n\n    Args:\n        path: Path to the audio file.\n        channel: Channel(s) to load.\n        start: Start time in seconds.\n        end: End time in seconds.\n        chunk_size: Chunk size for processing.\n        Specifies the splitting size for lazy processing.\n        ch_labels: Labels for each channel.\n        **kwargs: Additional arguments passed to the file reader.\n\n    Returns:\n        A new ChannelFrame containing the loaded audio data.\n\n    Raises:\n        ValueError: If channel specification is invalid.\n        TypeError: If channel parameter type is invalid.\n        FileNotFoundError: If the file doesn't exist.\n    \"\"\"\n    from .channel import ChannelFrame\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    # Get file reader\n    reader = get_file_reader(path)\n\n    # Get file info\n    info = reader.get_file_info(path, **kwargs)\n    sr = info[\"samplerate\"]\n    n_channels = info[\"channels\"]\n    n_frames = info[\"frames\"]\n    ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n    logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n    # Channel selection processing\n    all_channels = list(range(n_channels))\n\n    if channel is None:\n        channels_to_load = all_channels\n        logger.debug(f\"Will load all channels: {channels_to_load}\")\n    elif isinstance(channel, int):\n        if channel &lt; 0 or channel &gt;= n_channels:\n            raise ValueError(\n                f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n            )\n        channels_to_load = [channel]\n        logger.debug(f\"Will load single channel: {channel}\")\n    elif isinstance(channel, (list, tuple)):\n        for ch in channel:\n            if ch &lt; 0 or ch &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n        channels_to_load = list(channel)\n        logger.debug(f\"Will load specific channels: {channels_to_load}\")\n    else:\n        raise TypeError(\"channel must be int, list, or None\")\n\n    # Index calculation\n    start_idx = 0 if start is None else max(0, int(start * sr))\n    end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n    frames_to_read = end_idx - start_idx\n\n    logger.debug(\n        f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n        f\"start_idx={start_idx}, end_idx={end_idx}\"\n    )\n\n    # Settings for lazy loading\n    expected_shape = (len(channels_to_load), frames_to_read)\n\n    # Define the loading function using the file reader\n    def _load_audio() -&gt; NDArrayReal:\n        logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n        # Use the reader to get audio data with parameters\n        out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n        if not isinstance(out, np.ndarray):\n            raise ValueError(\"Unexpected data type after reading file\")\n        return out\n\n    logger.debug(\n        f\"Creating delayed dask task with expected shape: {expected_shape}\"\n    )\n\n    # Create delayed operation\n    delayed_data = dask_delayed(_load_audio)()\n    logger.debug(\"Wrapping delayed function in dask array\")\n\n    # Create dask array from delayed computation\n    dask_array = da_from_delayed(\n        delayed_data, shape=expected_shape, dtype=np.float32\n    )\n\n    if chunk_size is not None:\n        if chunk_size &lt;= 0:\n            raise ValueError(\"Chunk size must be a positive integer\")\n        logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n        dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n    logger.debug(\n        \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n    )\n\n    cf = ChannelFrame(\n        data=dask_array,\n        sampling_rate=sr,\n        label=path.stem,\n        metadata={\n            \"filename\": str(path),\n        },\n    )\n    if ch_labels is not None:\n        if len(ch_labels) != len(cf):\n            raise ValueError(\n                \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    return cf\n</code></pre> <code></code> <code>read_wav(filename, labels=None)</code> <code>classmethod</code> \u00b6 <p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre> <code></code> <code>read_csv(filename, time_column=0, labels=None, delimiter=',', header=0)</code> <code>classmethod</code> \u00b6 <p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre> <code></code> <code>to_wav(path, format=None)</code> \u00b6 <p>Save the audio data to a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def to_wav(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a WAV file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    from wandas.io.wav_io import write_wav\n\n    write_wav(str(path), self, format=format)\n</code></pre> <code></code> <code>save(path, *, format='hdf5', compress='gzip', overwrite=False, dtype=None)</code> \u00b6 <p>Save the ChannelFrame to a WDF (Wandas Data File) format.</p> <p>This saves the complete frame including all channel data and metadata in a format that can be loaded back with full fidelity.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file. '.wdf' extension will be added if not present.</p> required <code>format</code> <code>str</code> <p>Format to use (currently only 'hdf5' is supported)</p> <code>'hdf5'</code> <code>compress</code> <code>Optional[str]</code> <p>Compression method ('gzip' by default, None for no compression)</p> <code>'gzip'</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing file</p> <code>False</code> <code>dtype</code> <code>Optional[Union[str, dtype[Any]]]</code> <p>Optional data type conversion before saving (e.g. 'float32')</p> <code>None</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If the file exists and overwrite=False.</p> <code>NotImplementedError</code> <p>For unsupported formats.</p> Example <p>cf = ChannelFrame.read_wav(\"audio.wav\") cf.save(\"audio_analysis.wdf\")</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(\n    self,\n    path: Union[str, Path],\n    *,\n    format: str = \"hdf5\",\n    compress: Optional[str] = \"gzip\",\n    overwrite: bool = False,\n    dtype: Optional[Union[str, np.dtype[Any]]] = None,\n) -&gt; None:\n    \"\"\"Save the ChannelFrame to a WDF (Wandas Data File) format.\n\n    This saves the complete frame including all channel data and metadata\n    in a format that can be loaded back with full fidelity.\n\n    Args:\n        path: Path to save the file. '.wdf' extension will be added if not present.\n        format: Format to use (currently only 'hdf5' is supported)\n        compress: Compression method ('gzip' by default, None for no compression)\n        overwrite: Whether to overwrite existing file\n        dtype: Optional data type conversion before saving (e.g. 'float32')\n\n    Raises:\n        FileExistsError: If the file exists and overwrite=False.\n        NotImplementedError: For unsupported formats.\n\n    Example:\n        &gt;&gt;&gt; cf = ChannelFrame.read_wav(\"audio.wav\")\n        &gt;&gt;&gt; cf.save(\"audio_analysis.wdf\")\n    \"\"\"\n    from ..io.wdf_io import save as wdf_save\n\n    wdf_save(\n        self,\n        path,\n        format=format,\n        compress=compress,\n        overwrite=overwrite,\n        dtype=dtype,\n    )\n</code></pre> <code></code> <code>load(path, *, format='hdf5')</code> <code>classmethod</code> \u00b6 <p>Load a ChannelFrame from a WDF (Wandas Data File) file.</p> <p>This loads data saved with the save() method, preserving all channel data, metadata, labels, and units.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the WDF file</p> required <code>format</code> <code>str</code> <p>Format of the file (currently only 'hdf5' is supported)</p> <code>'hdf5'</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with all data and metadata loaded</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist</p> <code>NotImplementedError</code> <p>For unsupported formats</p> Example <p>cf = ChannelFrame.load(\"audio_analysis.wdf\")</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef load(cls, path: Union[str, Path], *, format: str = \"hdf5\") -&gt; \"ChannelFrame\":\n    \"\"\"Load a ChannelFrame from a WDF (Wandas Data File) file.\n\n    This loads data saved with the save() method, preserving all channel data,\n    metadata, labels, and units.\n\n    Args:\n        path: Path to the WDF file\n        format: Format of the file (currently only 'hdf5' is supported)\n\n    Returns:\n        A new ChannelFrame with all data and metadata loaded\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n        NotImplementedError: For unsupported formats\n\n    Example:\n        &gt;&gt;&gt; cf = ChannelFrame.load(\"audio_analysis.wdf\")\n    \"\"\"\n    from ..io.wdf_io import load as wdf_load\n\n    return wdf_load(path, format=format)\n</code></pre> <code></code> <code>add_channel(data, label=None, align='strict', suffix_on_dup=None, inplace=False, **kwargs)</code> \u00b6 Source code in <code>wandas/frames/channel.py</code> <pre><code>def add_channel(\n    self,\n    data: Union[np.ndarray[Any, Any], DaskArray, \"ChannelFrame\"],\n    label: Optional[str] = None,\n    align: str = \"strict\",\n    suffix_on_dup: Optional[str] = None,\n    inplace: bool = False,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    # ndarray/dask/\u540c\u578bFrame\u5bfe\u5fdc\n    if isinstance(data, ChannelFrame):\n        if self.sampling_rate != data.sampling_rate:\n            raise ValueError(\"sampling_rate\u4e0d\u4e00\u81f4\")\n        if data.n_samples != self.n_samples:\n            if align == \"pad\":\n                pad_len = self.n_samples - data.n_samples\n                arr = data._data\n                if pad_len &gt; 0:\n                    arr = concatenate(\n                        [\n                            arr,\n                            from_array(\n                                np.zeros((arr.shape[0], pad_len), dtype=arr.dtype)\n                            ),\n                        ],\n                        axis=1,\n                    )\n                else:\n                    arr = arr[:, : self.n_samples]\n            elif align == \"truncate\":\n                arr = data._data[:, : self.n_samples]\n                if arr.shape[1] &lt; self.n_samples:\n                    pad_len = self.n_samples - arr.shape[1]\n                    arr = concatenate(\n                        [\n                            arr,\n                            from_array(\n                                np.zeros((arr.shape[0], pad_len), dtype=arr.dtype)\n                            ),\n                        ],\n                        axis=1,\n                    )\n            else:\n                raise ValueError(\"\u30c7\u30fc\u30bf\u9577\u4e0d\u4e00\u81f4: align\u6307\u5b9a\u3092\u78ba\u8a8d\")\n        else:\n            arr = data._data\n        labels = [ch.label for ch in self._channel_metadata]\n        new_labels = []\n        for chmeta in data._channel_metadata:\n            new_label = chmeta.label\n            if new_label in labels or new_label in new_labels:\n                if suffix_on_dup:\n                    new_label += suffix_on_dup\n                else:\n                    raise ValueError(f\"label\u91cd\u8907: {new_label}\")\n            new_labels.append(new_label)\n        new_data = concatenate([self._data, arr], axis=0)\n        from ..core.metadata import ChannelMetadata\n\n        new_chmeta = self._channel_metadata + [\n            ChannelMetadata(label=lbl) for lbl in new_labels\n        ]\n        if inplace:\n            self._data = new_data\n            self._channel_metadata = new_chmeta\n            return self\n        else:\n            return ChannelFrame(\n                data=new_data,\n                sampling_rate=self.sampling_rate,\n                label=self.label,\n                metadata=self.metadata,\n                operation_history=self.operation_history,\n                channel_metadata=new_chmeta,\n                previous=self,\n            )\n    if isinstance(data, np.ndarray):\n        arr = from_array(data.reshape(1, -1))\n    elif isinstance(data, DaskArray):\n        arr = data[None, ...] if data.ndim == 1 else data\n        if arr.shape[0] != 1:\n            arr = arr.reshape((1, -1))\n    else:\n        raise TypeError(\"add_channel: ndarray/dask/\u540c\u578bFrame\u306e\u307f\u5bfe\u5fdc\")\n    if arr.shape[1] != self.n_samples:\n        if align == \"pad\":\n            pad_len = self.n_samples - arr.shape[1]\n            if pad_len &gt; 0:\n                arr = concatenate(\n                    [arr, from_array(np.zeros((1, pad_len), dtype=arr.dtype))],\n                    axis=1,\n                )\n            else:\n                arr = arr[:, : self.n_samples]\n        elif align == \"truncate\":\n            arr = arr[:, : self.n_samples]\n            if arr.shape[1] &lt; self.n_samples:\n                pad_len = self.n_samples - arr.shape[1]\n                arr = concatenate(\n                    [arr, from_array(np.zeros((1, pad_len), dtype=arr.dtype))],\n                    axis=1,\n                )\n        else:\n            raise ValueError(\"\u30c7\u30fc\u30bf\u9577\u4e0d\u4e00\u81f4: align\u6307\u5b9a\u3092\u78ba\u8a8d\")\n    labels = [ch.label for ch in self._channel_metadata]\n    new_label = label or f\"ch{len(labels)}\"\n    if new_label in labels:\n        if suffix_on_dup:\n            new_label += suffix_on_dup\n        else:\n            raise ValueError(\"label\u91cd\u8907\")\n    new_data = concatenate([self._data, arr], axis=0)\n    from ..core.metadata import ChannelMetadata\n\n    new_chmeta = self._channel_metadata + [ChannelMetadata(label=new_label)]\n    if inplace:\n        self._data = new_data\n        self._channel_metadata = new_chmeta\n        return self\n    else:\n        return ChannelFrame(\n            data=new_data,\n            sampling_rate=self.sampling_rate,\n            label=self.label,\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=new_chmeta,\n            previous=self,\n        )\n</code></pre> <code></code> <code>remove_channel(key, inplace=False)</code> \u00b6 Source code in <code>wandas/frames/channel.py</code> <pre><code>def remove_channel(\n    self, key: Union[int, str], inplace: bool = False\n) -&gt; \"ChannelFrame\":\n    if isinstance(key, int):\n        if not (0 &lt;= key &lt; self.n_channels):\n            raise IndexError(f\"index {key} out of range\")\n        idx = key\n    else:\n        labels = [ch.label for ch in self._channel_metadata]\n        if key not in labels:\n            raise KeyError(f\"label {key} not found\")\n        idx = labels.index(key)\n    new_data = self._data[[i for i in range(self.n_channels) if i != idx], :]\n    new_chmeta = [ch for i, ch in enumerate(self._channel_metadata) if i != idx]\n    if inplace:\n        self._data = new_data\n        self._channel_metadata = new_chmeta\n        return self\n    else:\n        return ChannelFrame(\n            data=new_data,\n            sampling_rate=self.sampling_rate,\n            label=self.label,\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=new_chmeta,\n            previous=self,\n        )\n</code></pre>"},{"location":"api/#wandas.frames.channel-functions","title":"Functions","text":""},{"location":"api/#wandas.frames.mixins","title":"<code>mixins</code>","text":"<p>Channel frame mixins module.</p>"},{"location":"api/#wandas.frames.mixins-attributes","title":"Attributes","text":""},{"location":"api/#wandas.frames.mixins.__all__","title":"<code>__all__ = ['ChannelProcessingMixin', 'ChannelTransformMixin']</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.frames.mixins-classes","title":"Classes","text":""},{"location":"api/#wandas.frames.mixins.ChannelProcessingMixin","title":"<code>ChannelProcessingMixin</code>","text":"<p>Mixin that provides methods related to signal processing.</p> <p>This mixin provides processing methods applied to audio signals and other time-series data, such as signal processing filters and transformation operations.</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>class ChannelProcessingMixin:\n    \"\"\"Mixin that provides methods related to signal processing.\n\n    This mixin provides processing methods applied to audio signals and\n    other time-series data, such as signal processing filters and\n    transformation operations.\n    \"\"\"\n\n    def high_pass_filter(\n        self: T_Processing, cutoff: float, order: int = 4\n    ) -&gt; T_Processing:\n        \"\"\"Apply a high-pass filter to the signal.\n\n        Args:\n            cutoff: Filter cutoff frequency (Hz)\n            order: Filter order. Default is 4.\n\n        Returns:\n            New ChannelFrame after filter application\n        \"\"\"\n        logger.debug(\n            f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        result = self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n        return cast(T_Processing, result)\n\n    def low_pass_filter(\n        self: T_Processing, cutoff: float, order: int = 4\n    ) -&gt; T_Processing:\n        \"\"\"Apply a low-pass filter to the signal.\n\n        Args:\n            cutoff: Filter cutoff frequency (Hz)\n            order: Filter order. Default is 4.\n\n        Returns:\n            New ChannelFrame after filter application\n        \"\"\"\n        logger.debug(\n            f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        result = self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n        return cast(T_Processing, result)\n\n    def band_pass_filter(\n        self: T_Processing, low_cutoff: float, high_cutoff: float, order: int = 4\n    ) -&gt; T_Processing:\n        \"\"\"Apply a band-pass filter to the signal.\n\n        Args:\n            low_cutoff: Lower cutoff frequency (Hz)\n            high_cutoff: Higher cutoff frequency (Hz)\n            order: Filter order. Default is 4.\n\n        Returns:\n            New ChannelFrame after filter application\n        \"\"\"\n        logger.debug(\n            f\"Setting up bandpass filter: low_cutoff={low_cutoff}, \"\n            f\"high_cutoff={high_cutoff}, order={order} (lazy)\"\n        )\n        result = self.apply_operation(\n            \"bandpass_filter\",\n            low_cutoff=low_cutoff,\n            high_cutoff=high_cutoff,\n            order=order,\n        )\n        return cast(T_Processing, result)\n\n    def normalize(\n        self: T_Processing, target_level: float = -20, channel_wise: bool = True\n    ) -&gt; T_Processing:\n        \"\"\"Normalize signal levels.\n\n        This method adjusts the signal amplitude to reach the target RMS level.\n\n        Args:\n            target_level: Target RMS level (dB). Default is -20.\n            channel_wise: If True, normalize each channel individually.\n                If False, apply the same scaling to all channels.\n\n        Returns:\n            New ChannelFrame containing the normalized signal\n        \"\"\"\n        logger.debug(\n            f\"Setting up normalize: target_level={target_level}, \"\n            f\"channel_wise={channel_wise} (lazy)\"\n        )\n        result = self.apply_operation(\n            \"normalize\", target_level=target_level, channel_wise=channel_wise\n        )\n        return cast(T_Processing, result)\n\n    def a_weighting(self: T_Processing) -&gt; T_Processing:\n        \"\"\"Apply A-weighting filter to the signal.\n\n        A-weighting adjusts the frequency response to approximate human\n        auditory perception, according to the IEC 61672-1:2013 standard.\n\n        Returns:\n            New ChannelFrame containing the A-weighted signal\n        \"\"\"\n        result = self.apply_operation(\"a_weighting\")\n        return cast(T_Processing, result)\n\n    def abs(self: T_Processing) -&gt; T_Processing:\n        \"\"\"Compute the absolute value of the signal.\n\n        Returns:\n            New ChannelFrame containing the absolute values\n        \"\"\"\n        result = self.apply_operation(\"abs\")\n        return cast(T_Processing, result)\n\n    def power(self: T_Processing, exponent: float = 2.0) -&gt; T_Processing:\n        \"\"\"Compute the power of the signal.\n\n        Args:\n            exponent: Exponent to raise the signal to. Default is 2.0.\n\n        Returns:\n            New ChannelFrame containing the powered signal\n        \"\"\"\n        result = self.apply_operation(\"power\", exponent=exponent)\n        return cast(T_Processing, result)\n\n    def _reduce_channels(self: T_Processing, op: str) -&gt; T_Processing:\n        \"\"\"Helper to reduce all channels with the given operation ('sum' or 'mean').\"\"\"\n        if op == \"sum\":\n            reduced_data = self._data.sum(axis=0, keepdims=True)\n            label = \"sum\"\n        elif op == \"mean\":\n            reduced_data = self._data.mean(axis=0, keepdims=True)\n            label = \"mean\"\n        else:\n            raise ValueError(f\"Unsupported reduction operation: {op}\")\n\n        units = [ch.unit for ch in self._channel_metadata]\n        if all(u == units[0] for u in units):\n            reduced_unit = units[0]\n        else:\n            reduced_unit = \"\"\n\n        reduced_extra = {\"source_extras\": [ch.extra for ch in self._channel_metadata]}\n        new_channel_metadata = [\n            ChannelMetadata(\n                label=label,\n                unit=reduced_unit,\n                extra=reduced_extra,\n            )\n        ]\n        new_history = (\n            self.operation_history.copy() if hasattr(self, \"operation_history\") else []\n        )\n        new_history.append({\"operation\": op})\n        new_metadata = self.metadata.copy() if hasattr(self, \"metadata\") else {}\n        result = self._create_new_instance(\n            data=reduced_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n            channel_metadata=new_channel_metadata,\n        )\n        return result\n\n    def sum(self: T_Processing) -&gt; T_Processing:\n        \"\"\"Sum all channels.\n\n        Returns:\n            A new ChannelFrame with summed signal.\n        \"\"\"\n        return cast(T_Processing, cast(Any, self)._reduce_channels(\"sum\"))\n\n    def mean(self: T_Processing) -&gt; T_Processing:\n        \"\"\"Average all channels.\n\n        Returns:\n            A new ChannelFrame with averaged signal.\n        \"\"\"\n        return cast(T_Processing, cast(Any, self)._reduce_channels(\"mean\"))\n\n    def trim(\n        self: T_Processing,\n        start: float = 0,\n        end: Optional[float] = None,\n    ) -&gt; T_Processing:\n        \"\"\"Trim the signal to the specified time range.\n\n        Args:\n            start: Start time (seconds)\n            end: End time (seconds)\n\n        Returns:\n            New ChannelFrame containing the trimmed signal\n\n        Raises:\n            ValueError: If end time is earlier than start time\n        \"\"\"\n        if end is None:\n            end = self.duration\n        if start &gt; end:\n            raise ValueError(\"start must be less than end\")\n        result = self.apply_operation(\"trim\", start=start, end=end)\n        return cast(T_Processing, result)\n\n    def fix_length(\n        self: T_Processing,\n        length: Optional[int] = None,\n        duration: Optional[float] = None,\n    ) -&gt; T_Processing:\n        \"\"\"Adjust the signal to the specified length.\n\n        Args:\n            duration: Signal length in seconds\n            length: Signal length in samples\n\n        Returns:\n            New ChannelFrame containing the adjusted signal\n        \"\"\"\n\n        result = self.apply_operation(\"fix_length\", length=length, duration=duration)\n        return cast(T_Processing, result)\n\n    def rms_trend(\n        self: T_Processing,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; T_Processing:\n        \"\"\"Compute the RMS trend of the signal.\n\n        This method calculates the root mean square value over a sliding window.\n\n        Args:\n            frame_length: Size of the sliding window in samples. Default is 2048.\n            hop_length: Hop length between windows in samples. Default is 512.\n            dB: Whether to return RMS values in decibels. Default is False.\n            Aw: Whether to apply A-weighting. Default is False.\n\n        Returns:\n            New ChannelFrame containing the RMS trend\n        \"\"\"\n        # Access _channel_metadata to retrieve reference values\n        frame = cast(ProcessingFrameProtocol, self)\n\n        # Ensure _channel_metadata exists before referencing\n        ref_values = []\n        if hasattr(frame, \"_channel_metadata\") and frame._channel_metadata:\n            ref_values = [ch.ref for ch in frame._channel_metadata]\n\n        result = self.apply_operation(\n            \"rms_trend\",\n            frame_length=frame_length,\n            hop_length=hop_length,\n            ref=ref_values,\n            dB=dB,\n            Aw=Aw,\n        )\n\n        # Update sampling rate\n        result_obj = cast(T_Processing, result)\n        if hasattr(result_obj, \"sampling_rate\"):\n            result_obj.sampling_rate = frame.sampling_rate / hop_length\n\n        return result_obj\n\n    def channel_difference(\n        self: T_Processing, other_channel: Union[int, str] = 0\n    ) -&gt; T_Processing:\n        \"\"\"Compute the difference between channels.\n\n        Args:\n            other_channel: Index or label of the reference channel. Default is 0.\n\n        Returns:\n            New ChannelFrame containing the channel difference\n        \"\"\"\n        # label2index is a method of BaseFrame\n        if isinstance(other_channel, str):\n            if hasattr(self, \"label2index\"):\n                other_channel = self.label2index(other_channel)\n\n        result = self.apply_operation(\"channel_difference\", other_channel=other_channel)\n        return cast(T_Processing, result)\n\n    def resampling(\n        self: T_Processing,\n        target_sr: float,\n        **kwargs: Any,\n    ) -&gt; T_Processing:\n        \"\"\"Resample audio data.\n\n        Args:\n            target_sr: Target sampling rate (Hz)\n            **kwargs: Additional resampling parameters\n\n        Returns:\n            Resampled ChannelFrame\n        \"\"\"\n        return cast(\n            T_Processing,\n            self.apply_operation(\n                \"resampling\",\n                target_sr=target_sr,\n                **kwargs,\n            ),\n        )\n\n    def hpss_harmonic(\n        self: T_Processing,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; T_Processing:\n        \"\"\"\n        Extract harmonic components using HPSS\n         (Harmonic-Percussive Source Separation).\n\n        This method separates the harmonic (tonal) components from the signal.\n\n        Args:\n            kernel_size: Median filter size for HPSS.\n            power: Exponent for the Weiner filter used in HPSS.\n            margin: Margin size for the separation.\n            n_fft: Size of FFT window.\n            hop_length: Hop length for STFT.\n            win_length: Window length for STFT.\n            window: Window type for STFT.\n            center: If True, center the frames.\n            pad_mode: Padding mode for STFT.\n\n        Returns:\n            A new ChannelFrame containing the harmonic components.\n        \"\"\"\n        result = self.apply_operation(\n            \"hpss_harmonic\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n        return cast(T_Processing, result)\n\n    def hpss_percussive(\n        self: T_Processing,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; T_Processing:\n        \"\"\"\n        Extract percussive components using HPSS\n        (Harmonic-Percussive Source Separation).\n\n        This method separates the percussive (tonal) components from the signal.\n\n        Args:\n            kernel_size: Median filter size for HPSS.\n            power: Exponent for the Weiner filter used in HPSS.\n            margin: Margin size for the separation.\n\n        Returns:\n            A new ChannelFrame containing the harmonic components.\n        \"\"\"\n        result = self.apply_operation(\n            \"hpss_percussive\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n        return cast(T_Processing, result)\n</code></pre> Functions\u00b6 <code></code> <code>high_pass_filter(cutoff, order=4)</code> \u00b6 <p>Apply a high-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>Filter cutoff frequency (Hz)</p> required <code>order</code> <code>int</code> <p>Filter order. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame after filter application</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def high_pass_filter(\n    self: T_Processing, cutoff: float, order: int = 4\n) -&gt; T_Processing:\n    \"\"\"Apply a high-pass filter to the signal.\n\n    Args:\n        cutoff: Filter cutoff frequency (Hz)\n        order: Filter order. Default is 4.\n\n    Returns:\n        New ChannelFrame after filter application\n    \"\"\"\n    logger.debug(\n        f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    result = self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>low_pass_filter(cutoff, order=4)</code> \u00b6 <p>Apply a low-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>Filter cutoff frequency (Hz)</p> required <code>order</code> <code>int</code> <p>Filter order. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame after filter application</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def low_pass_filter(\n    self: T_Processing, cutoff: float, order: int = 4\n) -&gt; T_Processing:\n    \"\"\"Apply a low-pass filter to the signal.\n\n    Args:\n        cutoff: Filter cutoff frequency (Hz)\n        order: Filter order. Default is 4.\n\n    Returns:\n        New ChannelFrame after filter application\n    \"\"\"\n    logger.debug(\n        f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    result = self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>band_pass_filter(low_cutoff, high_cutoff, order=4)</code> \u00b6 <p>Apply a band-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>low_cutoff</code> <code>float</code> <p>Lower cutoff frequency (Hz)</p> required <code>high_cutoff</code> <code>float</code> <p>Higher cutoff frequency (Hz)</p> required <code>order</code> <code>int</code> <p>Filter order. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame after filter application</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def band_pass_filter(\n    self: T_Processing, low_cutoff: float, high_cutoff: float, order: int = 4\n) -&gt; T_Processing:\n    \"\"\"Apply a band-pass filter to the signal.\n\n    Args:\n        low_cutoff: Lower cutoff frequency (Hz)\n        high_cutoff: Higher cutoff frequency (Hz)\n        order: Filter order. Default is 4.\n\n    Returns:\n        New ChannelFrame after filter application\n    \"\"\"\n    logger.debug(\n        f\"Setting up bandpass filter: low_cutoff={low_cutoff}, \"\n        f\"high_cutoff={high_cutoff}, order={order} (lazy)\"\n    )\n    result = self.apply_operation(\n        \"bandpass_filter\",\n        low_cutoff=low_cutoff,\n        high_cutoff=high_cutoff,\n        order=order,\n    )\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>normalize(target_level=-20, channel_wise=True)</code> \u00b6 <p>Normalize signal levels.</p> <p>This method adjusts the signal amplitude to reach the target RMS level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target RMS level (dB). Default is -20.</p> <code>-20</code> <code>channel_wise</code> <code>bool</code> <p>If True, normalize each channel individually. If False, apply the same scaling to all channels.</p> <code>True</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the normalized signal</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def normalize(\n    self: T_Processing, target_level: float = -20, channel_wise: bool = True\n) -&gt; T_Processing:\n    \"\"\"Normalize signal levels.\n\n    This method adjusts the signal amplitude to reach the target RMS level.\n\n    Args:\n        target_level: Target RMS level (dB). Default is -20.\n        channel_wise: If True, normalize each channel individually.\n            If False, apply the same scaling to all channels.\n\n    Returns:\n        New ChannelFrame containing the normalized signal\n    \"\"\"\n    logger.debug(\n        f\"Setting up normalize: target_level={target_level}, \"\n        f\"channel_wise={channel_wise} (lazy)\"\n    )\n    result = self.apply_operation(\n        \"normalize\", target_level=target_level, channel_wise=channel_wise\n    )\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>a_weighting()</code> \u00b6 <p>Apply A-weighting filter to the signal.</p> <p>A-weighting adjusts the frequency response to approximate human auditory perception, according to the IEC 61672-1:2013 standard.</p> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the A-weighted signal</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def a_weighting(self: T_Processing) -&gt; T_Processing:\n    \"\"\"Apply A-weighting filter to the signal.\n\n    A-weighting adjusts the frequency response to approximate human\n    auditory perception, according to the IEC 61672-1:2013 standard.\n\n    Returns:\n        New ChannelFrame containing the A-weighted signal\n    \"\"\"\n    result = self.apply_operation(\"a_weighting\")\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>abs()</code> \u00b6 <p>Compute the absolute value of the signal.</p> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the absolute values</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def abs(self: T_Processing) -&gt; T_Processing:\n    \"\"\"Compute the absolute value of the signal.\n\n    Returns:\n        New ChannelFrame containing the absolute values\n    \"\"\"\n    result = self.apply_operation(\"abs\")\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>power(exponent=2.0)</code> \u00b6 <p>Compute the power of the signal.</p> <p>Parameters:</p> Name Type Description Default <code>exponent</code> <code>float</code> <p>Exponent to raise the signal to. Default is 2.0.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the powered signal</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def power(self: T_Processing, exponent: float = 2.0) -&gt; T_Processing:\n    \"\"\"Compute the power of the signal.\n\n    Args:\n        exponent: Exponent to raise the signal to. Default is 2.0.\n\n    Returns:\n        New ChannelFrame containing the powered signal\n    \"\"\"\n    result = self.apply_operation(\"power\", exponent=exponent)\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>sum()</code> \u00b6 <p>Sum all channels.</p> <p>Returns:</p> Type Description <code>T_Processing</code> <p>A new ChannelFrame with summed signal.</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def sum(self: T_Processing) -&gt; T_Processing:\n    \"\"\"Sum all channels.\n\n    Returns:\n        A new ChannelFrame with summed signal.\n    \"\"\"\n    return cast(T_Processing, cast(Any, self)._reduce_channels(\"sum\"))\n</code></pre> <code></code> <code>mean()</code> \u00b6 <p>Average all channels.</p> <p>Returns:</p> Type Description <code>T_Processing</code> <p>A new ChannelFrame with averaged signal.</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def mean(self: T_Processing) -&gt; T_Processing:\n    \"\"\"Average all channels.\n\n    Returns:\n        A new ChannelFrame with averaged signal.\n    \"\"\"\n    return cast(T_Processing, cast(Any, self)._reduce_channels(\"mean\"))\n</code></pre> <code></code> <code>trim(start=0, end=None)</code> \u00b6 <p>Trim the signal to the specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>Start time (seconds)</p> <code>0</code> <code>end</code> <code>Optional[float]</code> <p>End time (seconds)</p> <code>None</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the trimmed signal</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If end time is earlier than start time</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def trim(\n    self: T_Processing,\n    start: float = 0,\n    end: Optional[float] = None,\n) -&gt; T_Processing:\n    \"\"\"Trim the signal to the specified time range.\n\n    Args:\n        start: Start time (seconds)\n        end: End time (seconds)\n\n    Returns:\n        New ChannelFrame containing the trimmed signal\n\n    Raises:\n        ValueError: If end time is earlier than start time\n    \"\"\"\n    if end is None:\n        end = self.duration\n    if start &gt; end:\n        raise ValueError(\"start must be less than end\")\n    result = self.apply_operation(\"trim\", start=start, end=end)\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>fix_length(length=None, duration=None)</code> \u00b6 <p>Adjust the signal to the specified length.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>Optional[float]</code> <p>Signal length in seconds</p> <code>None</code> <code>length</code> <code>Optional[int]</code> <p>Signal length in samples</p> <code>None</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the adjusted signal</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def fix_length(\n    self: T_Processing,\n    length: Optional[int] = None,\n    duration: Optional[float] = None,\n) -&gt; T_Processing:\n    \"\"\"Adjust the signal to the specified length.\n\n    Args:\n        duration: Signal length in seconds\n        length: Signal length in samples\n\n    Returns:\n        New ChannelFrame containing the adjusted signal\n    \"\"\"\n\n    result = self.apply_operation(\"fix_length\", length=length, duration=duration)\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>rms_trend(frame_length=2048, hop_length=512, dB=False, Aw=False)</code> \u00b6 <p>Compute the RMS trend of the signal.</p> <p>This method calculates the root mean square value over a sliding window.</p> <p>Parameters:</p> Name Type Description Default <code>frame_length</code> <code>int</code> <p>Size of the sliding window in samples. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>int</code> <p>Hop length between windows in samples. Default is 512.</p> <code>512</code> <code>dB</code> <code>bool</code> <p>Whether to return RMS values in decibels. Default is False.</p> <code>False</code> <code>Aw</code> <code>bool</code> <p>Whether to apply A-weighting. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the RMS trend</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def rms_trend(\n    self: T_Processing,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; T_Processing:\n    \"\"\"Compute the RMS trend of the signal.\n\n    This method calculates the root mean square value over a sliding window.\n\n    Args:\n        frame_length: Size of the sliding window in samples. Default is 2048.\n        hop_length: Hop length between windows in samples. Default is 512.\n        dB: Whether to return RMS values in decibels. Default is False.\n        Aw: Whether to apply A-weighting. Default is False.\n\n    Returns:\n        New ChannelFrame containing the RMS trend\n    \"\"\"\n    # Access _channel_metadata to retrieve reference values\n    frame = cast(ProcessingFrameProtocol, self)\n\n    # Ensure _channel_metadata exists before referencing\n    ref_values = []\n    if hasattr(frame, \"_channel_metadata\") and frame._channel_metadata:\n        ref_values = [ch.ref for ch in frame._channel_metadata]\n\n    result = self.apply_operation(\n        \"rms_trend\",\n        frame_length=frame_length,\n        hop_length=hop_length,\n        ref=ref_values,\n        dB=dB,\n        Aw=Aw,\n    )\n\n    # Update sampling rate\n    result_obj = cast(T_Processing, result)\n    if hasattr(result_obj, \"sampling_rate\"):\n        result_obj.sampling_rate = frame.sampling_rate / hop_length\n\n    return result_obj\n</code></pre> <code></code> <code>channel_difference(other_channel=0)</code> \u00b6 <p>Compute the difference between channels.</p> <p>Parameters:</p> Name Type Description Default <code>other_channel</code> <code>Union[int, str]</code> <p>Index or label of the reference channel. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the channel difference</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def channel_difference(\n    self: T_Processing, other_channel: Union[int, str] = 0\n) -&gt; T_Processing:\n    \"\"\"Compute the difference between channels.\n\n    Args:\n        other_channel: Index or label of the reference channel. Default is 0.\n\n    Returns:\n        New ChannelFrame containing the channel difference\n    \"\"\"\n    # label2index is a method of BaseFrame\n    if isinstance(other_channel, str):\n        if hasattr(self, \"label2index\"):\n            other_channel = self.label2index(other_channel)\n\n    result = self.apply_operation(\"channel_difference\", other_channel=other_channel)\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>resampling(target_sr, **kwargs)</code> \u00b6 <p>Resample audio data.</p> <p>Parameters:</p> Name Type Description Default <code>target_sr</code> <code>float</code> <p>Target sampling rate (Hz)</p> required <code>**kwargs</code> <code>Any</code> <p>Additional resampling parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>Resampled ChannelFrame</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def resampling(\n    self: T_Processing,\n    target_sr: float,\n    **kwargs: Any,\n) -&gt; T_Processing:\n    \"\"\"Resample audio data.\n\n    Args:\n        target_sr: Target sampling rate (Hz)\n        **kwargs: Additional resampling parameters\n\n    Returns:\n        Resampled ChannelFrame\n    \"\"\"\n    return cast(\n        T_Processing,\n        self.apply_operation(\n            \"resampling\",\n            target_sr=target_sr,\n            **kwargs,\n        ),\n    )\n</code></pre> <code></code> <code>hpss_harmonic(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code> \u00b6 <p>Extract harmonic components using HPSS  (Harmonic-Percussive Source Separation).</p> <p>This method separates the harmonic (tonal) components from the signal.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Union[_IntLike_co, tuple[_IntLike_co, _IntLike_co], list[_IntLike_co]]</code> <p>Median filter size for HPSS.</p> <code>31</code> <code>power</code> <code>float</code> <p>Exponent for the Weiner filter used in HPSS.</p> <code>2</code> <code>margin</code> <code>Union[_FloatLike_co, tuple[_FloatLike_co, _FloatLike_co], list[_FloatLike_co]]</code> <p>Margin size for the separation.</p> <code>1</code> <code>n_fft</code> <code>int</code> <p>Size of FFT window.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Hop length for STFT.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Window length for STFT.</p> <code>None</code> <code>window</code> <code>_WindowSpec</code> <p>Window type for STFT.</p> <code>'hann'</code> <code>center</code> <code>bool</code> <p>If True, center the frames.</p> <code>True</code> <code>pad_mode</code> <code>_PadModeSTFT</code> <p>Padding mode for STFT.</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>A new ChannelFrame containing the harmonic components.</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def hpss_harmonic(\n    self: T_Processing,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; T_Processing:\n    \"\"\"\n    Extract harmonic components using HPSS\n     (Harmonic-Percussive Source Separation).\n\n    This method separates the harmonic (tonal) components from the signal.\n\n    Args:\n        kernel_size: Median filter size for HPSS.\n        power: Exponent for the Weiner filter used in HPSS.\n        margin: Margin size for the separation.\n        n_fft: Size of FFT window.\n        hop_length: Hop length for STFT.\n        win_length: Window length for STFT.\n        window: Window type for STFT.\n        center: If True, center the frames.\n        pad_mode: Padding mode for STFT.\n\n    Returns:\n        A new ChannelFrame containing the harmonic components.\n    \"\"\"\n    result = self.apply_operation(\n        \"hpss_harmonic\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>hpss_percussive(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code> \u00b6 <p>Extract percussive components using HPSS (Harmonic-Percussive Source Separation).</p> <p>This method separates the percussive (tonal) components from the signal.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Union[_IntLike_co, tuple[_IntLike_co, _IntLike_co], list[_IntLike_co]]</code> <p>Median filter size for HPSS.</p> <code>31</code> <code>power</code> <code>float</code> <p>Exponent for the Weiner filter used in HPSS.</p> <code>2</code> <code>margin</code> <code>Union[_FloatLike_co, tuple[_FloatLike_co, _FloatLike_co], list[_FloatLike_co]]</code> <p>Margin size for the separation.</p> <code>1</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>A new ChannelFrame containing the harmonic components.</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def hpss_percussive(\n    self: T_Processing,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; T_Processing:\n    \"\"\"\n    Extract percussive components using HPSS\n    (Harmonic-Percussive Source Separation).\n\n    This method separates the percussive (tonal) components from the signal.\n\n    Args:\n        kernel_size: Median filter size for HPSS.\n        power: Exponent for the Weiner filter used in HPSS.\n        margin: Margin size for the separation.\n\n    Returns:\n        A new ChannelFrame containing the harmonic components.\n    \"\"\"\n    result = self.apply_operation(\n        \"hpss_percussive\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n    return cast(T_Processing, result)\n</code></pre>"},{"location":"api/#wandas.frames.mixins.ChannelTransformMixin","title":"<code>ChannelTransformMixin</code>","text":"<p>Mixin providing methods related to frequency transformations.</p> <p>This mixin provides operations related to frequency analysis and transformations such as FFT, STFT, and Welch method.</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>class ChannelTransformMixin:\n    \"\"\"Mixin providing methods related to frequency transformations.\n\n    This mixin provides operations related to frequency analysis and\n    transformations such as FFT, STFT, and Welch method.\n    \"\"\"\n\n    def fft(\n        self: T_Transform, n_fft: Optional[int] = None, window: str = \"hann\"\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Calculate Fast Fourier Transform (FFT).\n\n        Args:\n            n_fft: Number of FFT points. Default is the next power of 2 of the data\n                length.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            SpectralFrame containing FFT results\n        \"\"\"\n        from wandas.frames.spectral import SpectralFrame\n        from wandas.processing import FFT, create_operation\n\n        params = {\"n_fft\": n_fft, \"window\": window}\n        operation_name = \"fft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"FFT\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        if n_fft is None:\n            is_even = spectrum_data.shape[-1] % 2 == 0\n            _n_fft = (\n                spectrum_data.shape[-1] * 2 - 2\n                if is_even\n                else spectrum_data.shape[-1] * 2 - 1\n            )\n        else:\n            _n_fft = n_fft\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=_n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=base_self,\n        )\n\n    def welch(\n        self: T_Transform,\n        n_fft: Optional[int] = None,\n        hop_length: Optional[int] = None,\n        win_length: int = 2048,\n        window: str = \"hann\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Calculate power spectral density using Welch's method.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between frames.\n                Default is n_fft//4.\n            win_length: Window length. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            SpectralFrame containing power spectral density\n        \"\"\"\n        from wandas.frames.spectral import SpectralFrame\n        from wandas.processing import Welch, create_operation\n\n        params = dict(\n            n_fft=n_fft or win_length,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            average=average,\n        )\n        operation_name = \"welch\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Welch\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"welch\", \"params\": params},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=base_self,\n        )\n\n    def noct_spectrum(\n        self: T_Transform,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"Calculate N-octave band spectrum.\n\n        Args:\n            fmin: Minimum center frequency (Hz). Default is 20 Hz.\n            fmax: Maximum center frequency (Hz). Default is 20000 Hz.\n            n: Band division (1: octave, 3: 1/3 octave). Default is 3.\n            G: Reference gain (dB). Default is 10 dB.\n            fr: Reference frequency (Hz). Default is 1000 Hz.\n\n        Returns:\n            NOctFrame containing N-octave band spectrum\n        \"\"\"\n        from wandas.processing import NOctSpectrum, create_operation\n\n        from ..noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_spectrum\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSpectrum\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_spectrum\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=base_self,\n        )\n\n    def stft(\n        self: T_Transform,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"Calculate Short-Time Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between frames.\n                Default is n_fft//4.\n            win_length: Window length. Default is n_fft.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            SpectrogramFrame containing STFT results\n        \"\"\"\n        from wandas.processing import STFT, create_operation\n\n        from ..spectrogram import SpectrogramFrame\n\n        # Set hop length and window length\n        _hop_length = hop_length if hop_length is not None else n_fft // 4\n        _win_length = win_length if win_length is not None else n_fft\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": _hop_length,\n            \"win_length\": _win_length,\n            \"window\": window,\n        }\n        operation_name = \"stft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"STFT\", operation)\n\n        # Apply processing to data\n        spectrogram_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        # Create new instance\n        return SpectrogramFrame(\n            data=spectrogram_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=n_fft,\n            hop_length=_hop_length,\n            win_length=_win_length,\n            window=window,\n            label=f\"stft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n            previous=base_self,\n        )\n\n    def coherence(\n        self: T_Transform,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Calculate magnitude squared coherence.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between frames.\n                Default is n_fft//4.\n            win_length: Window length. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrend method. Options: \"constant\", \"linear\", None.\n\n        Returns:\n            SpectralFrame containing magnitude squared coherence\n        \"\"\"\n        from wandas.core.metadata import ChannelMetadata\n        from wandas.processing import Coherence, create_operation\n\n        from ..spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n        }\n        operation_name = \"coherence\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Coherence\", operation)\n\n        # Apply processing to data\n        coherence_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=coherence_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Coherence of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=base_self,\n        )\n\n    def csd(\n        self: T_Transform,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Calculate cross-spectral density matrix.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between frames.\n                Default is n_fft//4.\n            win_length: Window length. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrend method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            SpectralFrame containing cross-spectral density matrix\n        \"\"\"\n        from wandas.core.metadata import ChannelMetadata\n        from wandas.frames.spectral import SpectralFrame\n        from wandas.processing import CSD, create_operation\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"csd\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"CSD\", operation)\n\n        # Apply processing to data\n        csd_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=csd_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=base_self,\n        )\n\n    def transfer_function(\n        self: T_Transform,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Calculate transfer function matrix.\n\n        The transfer function represents the signal transfer characteristics between\n        channels in the frequency domain and represents the input-output relationship\n        of the system.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between frames.\n                Default is n_fft//4.\n            win_length: Window length. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrend method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            SpectralFrame containing transfer function matrix\n        \"\"\"\n        from wandas.core.metadata import ChannelMetadata\n        from wandas.frames.spectral import SpectralFrame\n        from wandas.processing import TransferFunction, create_operation\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"transfer_function\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"TransferFunction\", operation)\n\n        # Apply processing to data\n        tf_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=tf_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Transfer function of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=base_self,\n        )\n</code></pre> Functions\u00b6 <code></code> <code>fft(n_fft=None, window='hann')</code> \u00b6 <p>Calculate Fast Fourier Transform (FFT).</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is the next power of 2 of the data length.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>SpectralFrame containing FFT results</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def fft(\n    self: T_Transform, n_fft: Optional[int] = None, window: str = \"hann\"\n) -&gt; \"SpectralFrame\":\n    \"\"\"Calculate Fast Fourier Transform (FFT).\n\n    Args:\n        n_fft: Number of FFT points. Default is the next power of 2 of the data\n            length.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        SpectralFrame containing FFT results\n    \"\"\"\n    from wandas.frames.spectral import SpectralFrame\n    from wandas.processing import FFT, create_operation\n\n    params = {\"n_fft\": n_fft, \"window\": window}\n    operation_name = \"fft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"FFT\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    if n_fft is None:\n        is_even = spectrum_data.shape[-1] % 2 == 0\n        _n_fft = (\n            spectrum_data.shape[-1] * 2 - 2\n            if is_even\n            else spectrum_data.shape[-1] * 2 - 1\n        )\n    else:\n        _n_fft = n_fft\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=_n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=base_self,\n    )\n</code></pre> <code></code> <code>welch(n_fft=None, hop_length=None, win_length=2048, window='hann', average='mean')</code> \u00b6 <p>Calculate power spectral density using Welch's method.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is 2048.</p> <code>None</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between frames. Default is n_fft//4.</p> <code>None</code> <code>win_length</code> <code>int</code> <p>Window length. Default is n_fft.</p> <code>2048</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>SpectralFrame containing power spectral density</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def welch(\n    self: T_Transform,\n    n_fft: Optional[int] = None,\n    hop_length: Optional[int] = None,\n    win_length: int = 2048,\n    window: str = \"hann\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Calculate power spectral density using Welch's method.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between frames.\n            Default is n_fft//4.\n        win_length: Window length. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        SpectralFrame containing power spectral density\n    \"\"\"\n    from wandas.frames.spectral import SpectralFrame\n    from wandas.processing import Welch, create_operation\n\n    params = dict(\n        n_fft=n_fft or win_length,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        average=average,\n    )\n    operation_name = \"welch\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Welch\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"welch\", \"params\": params},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=base_self,\n    )\n</code></pre> <code></code> <code>noct_spectrum(fmin, fmax, n=3, G=10, fr=1000)</code> \u00b6 <p>Calculate N-octave band spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>fmin</code> <code>float</code> <p>Minimum center frequency (Hz). Default is 20 Hz.</p> required <code>fmax</code> <code>float</code> <p>Maximum center frequency (Hz). Default is 20000 Hz.</p> required <code>n</code> <code>int</code> <p>Band division (1: octave, 3: 1/3 octave). Default is 3.</p> <code>3</code> <code>G</code> <code>int</code> <p>Reference gain (dB). Default is 10 dB.</p> <code>10</code> <code>fr</code> <code>int</code> <p>Reference frequency (Hz). Default is 1000 Hz.</p> <code>1000</code> <p>Returns:</p> Type Description <code>NOctFrame</code> <p>NOctFrame containing N-octave band spectrum</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def noct_spectrum(\n    self: T_Transform,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"Calculate N-octave band spectrum.\n\n    Args:\n        fmin: Minimum center frequency (Hz). Default is 20 Hz.\n        fmax: Maximum center frequency (Hz). Default is 20000 Hz.\n        n: Band division (1: octave, 3: 1/3 octave). Default is 3.\n        G: Reference gain (dB). Default is 10 dB.\n        fr: Reference frequency (Hz). Default is 1000 Hz.\n\n    Returns:\n        NOctFrame containing N-octave band spectrum\n    \"\"\"\n    from wandas.processing import NOctSpectrum, create_operation\n\n    from ..noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_spectrum\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSpectrum\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_spectrum\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=base_self,\n    )\n</code></pre> <code></code> <code>stft(n_fft=2048, hop_length=None, win_length=None, window='hann')</code> \u00b6 <p>Calculate Short-Time Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between frames. Default is n_fft//4.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Window length. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectrogramFrame</code> <p>SpectrogramFrame containing STFT results</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def stft(\n    self: T_Transform,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n) -&gt; \"SpectrogramFrame\":\n    \"\"\"Calculate Short-Time Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between frames.\n            Default is n_fft//4.\n        win_length: Window length. Default is n_fft.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        SpectrogramFrame containing STFT results\n    \"\"\"\n    from wandas.processing import STFT, create_operation\n\n    from ..spectrogram import SpectrogramFrame\n\n    # Set hop length and window length\n    _hop_length = hop_length if hop_length is not None else n_fft // 4\n    _win_length = win_length if win_length is not None else n_fft\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": _hop_length,\n        \"win_length\": _win_length,\n        \"window\": window,\n    }\n    operation_name = \"stft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"STFT\", operation)\n\n    # Apply processing to data\n    spectrogram_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    # Create new instance\n    return SpectrogramFrame(\n        data=spectrogram_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=n_fft,\n        hop_length=_hop_length,\n        win_length=_win_length,\n        window=window,\n        label=f\"stft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n        previous=base_self,\n    )\n</code></pre> <code></code> <code>coherence(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant')</code> \u00b6 <p>Calculate magnitude squared coherence.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between frames. Default is n_fft//4.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Window length. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrend method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>SpectralFrame containing magnitude squared coherence</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def coherence(\n    self: T_Transform,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Calculate magnitude squared coherence.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between frames.\n            Default is n_fft//4.\n        win_length: Window length. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrend method. Options: \"constant\", \"linear\", None.\n\n    Returns:\n        SpectralFrame containing magnitude squared coherence\n    \"\"\"\n    from wandas.core.metadata import ChannelMetadata\n    from wandas.processing import Coherence, create_operation\n\n    from ..spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n    }\n    operation_name = \"coherence\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Coherence\", operation)\n\n    # Apply processing to data\n    coherence_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=coherence_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Coherence of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=base_self,\n    )\n</code></pre> <code></code> <code>csd(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code> \u00b6 <p>Calculate cross-spectral density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between frames. Default is n_fft//4.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Window length. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrend method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>SpectralFrame containing cross-spectral density matrix</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def csd(\n    self: T_Transform,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Calculate cross-spectral density matrix.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between frames.\n            Default is n_fft//4.\n        win_length: Window length. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrend method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        SpectralFrame containing cross-spectral density matrix\n    \"\"\"\n    from wandas.core.metadata import ChannelMetadata\n    from wandas.frames.spectral import SpectralFrame\n    from wandas.processing import CSD, create_operation\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"csd\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"CSD\", operation)\n\n    # Apply processing to data\n    csd_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=csd_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=base_self,\n    )\n</code></pre> <code></code> <code>transfer_function(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code> \u00b6 <p>Calculate transfer function matrix.</p> <p>The transfer function represents the signal transfer characteristics between channels in the frequency domain and represents the input-output relationship of the system.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between frames. Default is n_fft//4.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Window length. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrend method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>SpectralFrame containing transfer function matrix</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def transfer_function(\n    self: T_Transform,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Calculate transfer function matrix.\n\n    The transfer function represents the signal transfer characteristics between\n    channels in the frequency domain and represents the input-output relationship\n    of the system.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between frames.\n            Default is n_fft//4.\n        win_length: Window length. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrend method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        SpectralFrame containing transfer function matrix\n    \"\"\"\n    from wandas.core.metadata import ChannelMetadata\n    from wandas.frames.spectral import SpectralFrame\n    from wandas.processing import TransferFunction, create_operation\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"transfer_function\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"TransferFunction\", operation)\n\n    # Apply processing to data\n    tf_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=tf_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Transfer function of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=base_self,\n    )\n</code></pre>"},{"location":"api/#wandas.frames.mixins-modules","title":"Modules","text":""},{"location":"api/#wandas.frames.mixins.channel_collection_mixin","title":"<code>channel_collection_mixin</code>","text":"<p>ChannelCollectionMixin: Common functionality for adding/removing channels in ChannelFrame</p> Attributes\u00b6 <code>T = TypeVar('T', bound='ChannelCollectionMixin')</code> <code>module-attribute</code> \u00b6 Classes\u00b6 <code></code> <code>ChannelCollectionMixin</code> \u00b6 Source code in <code>wandas/frames/mixins/channel_collection_mixin.py</code> <pre><code>class ChannelCollectionMixin:\n    def add_channel(\n        self: T,\n        data: Union[np.ndarray[Any, Any], da.Array, T],\n        label: Optional[str] = None,\n        align: Literal[\"strict\", \"pad\", \"truncate\"] = \"strict\",\n        suffix_on_dup: Optional[str] = None,\n        inplace: bool = False,\n        **kwargs: Any,\n    ) -&gt; T:\n        \"\"\"\n        Add a channel\n        Args:\n            data: Channel to add (1ch ndarray/dask/ChannelFrame)\n            label: Label for the added channel\n            align: Behavior when lengths don't match\n            suffix_on_dup: Suffix when label is duplicated\n            inplace: True for self-modification\n        Returns:\n            New Frame or self\n        Raises:\n            ValueError, TypeError\n        \"\"\"\n        raise NotImplementedError(\"add_channel() must be implemented in subclasses\")\n\n    def remove_channel(\n        self: T,\n        key: Union[int, str],\n        inplace: bool = False,\n    ) -&gt; T:\n        \"\"\"\n        Remove a channel\n        Args:\n            key: Target to remove (index or label)\n            inplace: True for self-modification\n        Returns:\n            New Frame or self\n        Raises:\n            ValueError, KeyError, IndexError\n        \"\"\"\n        raise NotImplementedError(\"remove_channel() must be implemented in subclasses\")\n</code></pre> Functions\u00b6 <code></code> <code>add_channel(data, label=None, align='strict', suffix_on_dup=None, inplace=False, **kwargs)</code> \u00b6 <p>Add a channel Args:     data: Channel to add (1ch ndarray/dask/ChannelFrame)     label: Label for the added channel     align: Behavior when lengths don't match     suffix_on_dup: Suffix when label is duplicated     inplace: True for self-modification Returns:     New Frame or self Raises:     ValueError, TypeError</p> Source code in <code>wandas/frames/mixins/channel_collection_mixin.py</code> <pre><code>def add_channel(\n    self: T,\n    data: Union[np.ndarray[Any, Any], da.Array, T],\n    label: Optional[str] = None,\n    align: Literal[\"strict\", \"pad\", \"truncate\"] = \"strict\",\n    suffix_on_dup: Optional[str] = None,\n    inplace: bool = False,\n    **kwargs: Any,\n) -&gt; T:\n    \"\"\"\n    Add a channel\n    Args:\n        data: Channel to add (1ch ndarray/dask/ChannelFrame)\n        label: Label for the added channel\n        align: Behavior when lengths don't match\n        suffix_on_dup: Suffix when label is duplicated\n        inplace: True for self-modification\n    Returns:\n        New Frame or self\n    Raises:\n        ValueError, TypeError\n    \"\"\"\n    raise NotImplementedError(\"add_channel() must be implemented in subclasses\")\n</code></pre> <code></code> <code>remove_channel(key, inplace=False)</code> \u00b6 <p>Remove a channel Args:     key: Target to remove (index or label)     inplace: True for self-modification Returns:     New Frame or self Raises:     ValueError, KeyError, IndexError</p> Source code in <code>wandas/frames/mixins/channel_collection_mixin.py</code> <pre><code>def remove_channel(\n    self: T,\n    key: Union[int, str],\n    inplace: bool = False,\n) -&gt; T:\n    \"\"\"\n    Remove a channel\n    Args:\n        key: Target to remove (index or label)\n        inplace: True for self-modification\n    Returns:\n        New Frame or self\n    Raises:\n        ValueError, KeyError, IndexError\n    \"\"\"\n    raise NotImplementedError(\"remove_channel() must be implemented in subclasses\")\n</code></pre>"},{"location":"api/#wandas.frames.mixins.channel_processing_mixin","title":"<code>channel_processing_mixin</code>","text":"<p>Module providing mixins related to signal processing.</p> Attributes\u00b6 <code>logger = logging.getLogger(__name__)</code> <code>module-attribute</code> \u00b6 Classes\u00b6 <code></code> <code>ChannelProcessingMixin</code> \u00b6 <p>Mixin that provides methods related to signal processing.</p> <p>This mixin provides processing methods applied to audio signals and other time-series data, such as signal processing filters and transformation operations.</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>class ChannelProcessingMixin:\n    \"\"\"Mixin that provides methods related to signal processing.\n\n    This mixin provides processing methods applied to audio signals and\n    other time-series data, such as signal processing filters and\n    transformation operations.\n    \"\"\"\n\n    def high_pass_filter(\n        self: T_Processing, cutoff: float, order: int = 4\n    ) -&gt; T_Processing:\n        \"\"\"Apply a high-pass filter to the signal.\n\n        Args:\n            cutoff: Filter cutoff frequency (Hz)\n            order: Filter order. Default is 4.\n\n        Returns:\n            New ChannelFrame after filter application\n        \"\"\"\n        logger.debug(\n            f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        result = self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n        return cast(T_Processing, result)\n\n    def low_pass_filter(\n        self: T_Processing, cutoff: float, order: int = 4\n    ) -&gt; T_Processing:\n        \"\"\"Apply a low-pass filter to the signal.\n\n        Args:\n            cutoff: Filter cutoff frequency (Hz)\n            order: Filter order. Default is 4.\n\n        Returns:\n            New ChannelFrame after filter application\n        \"\"\"\n        logger.debug(\n            f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        result = self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n        return cast(T_Processing, result)\n\n    def band_pass_filter(\n        self: T_Processing, low_cutoff: float, high_cutoff: float, order: int = 4\n    ) -&gt; T_Processing:\n        \"\"\"Apply a band-pass filter to the signal.\n\n        Args:\n            low_cutoff: Lower cutoff frequency (Hz)\n            high_cutoff: Higher cutoff frequency (Hz)\n            order: Filter order. Default is 4.\n\n        Returns:\n            New ChannelFrame after filter application\n        \"\"\"\n        logger.debug(\n            f\"Setting up bandpass filter: low_cutoff={low_cutoff}, \"\n            f\"high_cutoff={high_cutoff}, order={order} (lazy)\"\n        )\n        result = self.apply_operation(\n            \"bandpass_filter\",\n            low_cutoff=low_cutoff,\n            high_cutoff=high_cutoff,\n            order=order,\n        )\n        return cast(T_Processing, result)\n\n    def normalize(\n        self: T_Processing, target_level: float = -20, channel_wise: bool = True\n    ) -&gt; T_Processing:\n        \"\"\"Normalize signal levels.\n\n        This method adjusts the signal amplitude to reach the target RMS level.\n\n        Args:\n            target_level: Target RMS level (dB). Default is -20.\n            channel_wise: If True, normalize each channel individually.\n                If False, apply the same scaling to all channels.\n\n        Returns:\n            New ChannelFrame containing the normalized signal\n        \"\"\"\n        logger.debug(\n            f\"Setting up normalize: target_level={target_level}, \"\n            f\"channel_wise={channel_wise} (lazy)\"\n        )\n        result = self.apply_operation(\n            \"normalize\", target_level=target_level, channel_wise=channel_wise\n        )\n        return cast(T_Processing, result)\n\n    def a_weighting(self: T_Processing) -&gt; T_Processing:\n        \"\"\"Apply A-weighting filter to the signal.\n\n        A-weighting adjusts the frequency response to approximate human\n        auditory perception, according to the IEC 61672-1:2013 standard.\n\n        Returns:\n            New ChannelFrame containing the A-weighted signal\n        \"\"\"\n        result = self.apply_operation(\"a_weighting\")\n        return cast(T_Processing, result)\n\n    def abs(self: T_Processing) -&gt; T_Processing:\n        \"\"\"Compute the absolute value of the signal.\n\n        Returns:\n            New ChannelFrame containing the absolute values\n        \"\"\"\n        result = self.apply_operation(\"abs\")\n        return cast(T_Processing, result)\n\n    def power(self: T_Processing, exponent: float = 2.0) -&gt; T_Processing:\n        \"\"\"Compute the power of the signal.\n\n        Args:\n            exponent: Exponent to raise the signal to. Default is 2.0.\n\n        Returns:\n            New ChannelFrame containing the powered signal\n        \"\"\"\n        result = self.apply_operation(\"power\", exponent=exponent)\n        return cast(T_Processing, result)\n\n    def _reduce_channels(self: T_Processing, op: str) -&gt; T_Processing:\n        \"\"\"Helper to reduce all channels with the given operation ('sum' or 'mean').\"\"\"\n        if op == \"sum\":\n            reduced_data = self._data.sum(axis=0, keepdims=True)\n            label = \"sum\"\n        elif op == \"mean\":\n            reduced_data = self._data.mean(axis=0, keepdims=True)\n            label = \"mean\"\n        else:\n            raise ValueError(f\"Unsupported reduction operation: {op}\")\n\n        units = [ch.unit for ch in self._channel_metadata]\n        if all(u == units[0] for u in units):\n            reduced_unit = units[0]\n        else:\n            reduced_unit = \"\"\n\n        reduced_extra = {\"source_extras\": [ch.extra for ch in self._channel_metadata]}\n        new_channel_metadata = [\n            ChannelMetadata(\n                label=label,\n                unit=reduced_unit,\n                extra=reduced_extra,\n            )\n        ]\n        new_history = (\n            self.operation_history.copy() if hasattr(self, \"operation_history\") else []\n        )\n        new_history.append({\"operation\": op})\n        new_metadata = self.metadata.copy() if hasattr(self, \"metadata\") else {}\n        result = self._create_new_instance(\n            data=reduced_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n            channel_metadata=new_channel_metadata,\n        )\n        return result\n\n    def sum(self: T_Processing) -&gt; T_Processing:\n        \"\"\"Sum all channels.\n\n        Returns:\n            A new ChannelFrame with summed signal.\n        \"\"\"\n        return cast(T_Processing, cast(Any, self)._reduce_channels(\"sum\"))\n\n    def mean(self: T_Processing) -&gt; T_Processing:\n        \"\"\"Average all channels.\n\n        Returns:\n            A new ChannelFrame with averaged signal.\n        \"\"\"\n        return cast(T_Processing, cast(Any, self)._reduce_channels(\"mean\"))\n\n    def trim(\n        self: T_Processing,\n        start: float = 0,\n        end: Optional[float] = None,\n    ) -&gt; T_Processing:\n        \"\"\"Trim the signal to the specified time range.\n\n        Args:\n            start: Start time (seconds)\n            end: End time (seconds)\n\n        Returns:\n            New ChannelFrame containing the trimmed signal\n\n        Raises:\n            ValueError: If end time is earlier than start time\n        \"\"\"\n        if end is None:\n            end = self.duration\n        if start &gt; end:\n            raise ValueError(\"start must be less than end\")\n        result = self.apply_operation(\"trim\", start=start, end=end)\n        return cast(T_Processing, result)\n\n    def fix_length(\n        self: T_Processing,\n        length: Optional[int] = None,\n        duration: Optional[float] = None,\n    ) -&gt; T_Processing:\n        \"\"\"Adjust the signal to the specified length.\n\n        Args:\n            duration: Signal length in seconds\n            length: Signal length in samples\n\n        Returns:\n            New ChannelFrame containing the adjusted signal\n        \"\"\"\n\n        result = self.apply_operation(\"fix_length\", length=length, duration=duration)\n        return cast(T_Processing, result)\n\n    def rms_trend(\n        self: T_Processing,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; T_Processing:\n        \"\"\"Compute the RMS trend of the signal.\n\n        This method calculates the root mean square value over a sliding window.\n\n        Args:\n            frame_length: Size of the sliding window in samples. Default is 2048.\n            hop_length: Hop length between windows in samples. Default is 512.\n            dB: Whether to return RMS values in decibels. Default is False.\n            Aw: Whether to apply A-weighting. Default is False.\n\n        Returns:\n            New ChannelFrame containing the RMS trend\n        \"\"\"\n        # Access _channel_metadata to retrieve reference values\n        frame = cast(ProcessingFrameProtocol, self)\n\n        # Ensure _channel_metadata exists before referencing\n        ref_values = []\n        if hasattr(frame, \"_channel_metadata\") and frame._channel_metadata:\n            ref_values = [ch.ref for ch in frame._channel_metadata]\n\n        result = self.apply_operation(\n            \"rms_trend\",\n            frame_length=frame_length,\n            hop_length=hop_length,\n            ref=ref_values,\n            dB=dB,\n            Aw=Aw,\n        )\n\n        # Update sampling rate\n        result_obj = cast(T_Processing, result)\n        if hasattr(result_obj, \"sampling_rate\"):\n            result_obj.sampling_rate = frame.sampling_rate / hop_length\n\n        return result_obj\n\n    def channel_difference(\n        self: T_Processing, other_channel: Union[int, str] = 0\n    ) -&gt; T_Processing:\n        \"\"\"Compute the difference between channels.\n\n        Args:\n            other_channel: Index or label of the reference channel. Default is 0.\n\n        Returns:\n            New ChannelFrame containing the channel difference\n        \"\"\"\n        # label2index is a method of BaseFrame\n        if isinstance(other_channel, str):\n            if hasattr(self, \"label2index\"):\n                other_channel = self.label2index(other_channel)\n\n        result = self.apply_operation(\"channel_difference\", other_channel=other_channel)\n        return cast(T_Processing, result)\n\n    def resampling(\n        self: T_Processing,\n        target_sr: float,\n        **kwargs: Any,\n    ) -&gt; T_Processing:\n        \"\"\"Resample audio data.\n\n        Args:\n            target_sr: Target sampling rate (Hz)\n            **kwargs: Additional resampling parameters\n\n        Returns:\n            Resampled ChannelFrame\n        \"\"\"\n        return cast(\n            T_Processing,\n            self.apply_operation(\n                \"resampling\",\n                target_sr=target_sr,\n                **kwargs,\n            ),\n        )\n\n    def hpss_harmonic(\n        self: T_Processing,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; T_Processing:\n        \"\"\"\n        Extract harmonic components using HPSS\n         (Harmonic-Percussive Source Separation).\n\n        This method separates the harmonic (tonal) components from the signal.\n\n        Args:\n            kernel_size: Median filter size for HPSS.\n            power: Exponent for the Weiner filter used in HPSS.\n            margin: Margin size for the separation.\n            n_fft: Size of FFT window.\n            hop_length: Hop length for STFT.\n            win_length: Window length for STFT.\n            window: Window type for STFT.\n            center: If True, center the frames.\n            pad_mode: Padding mode for STFT.\n\n        Returns:\n            A new ChannelFrame containing the harmonic components.\n        \"\"\"\n        result = self.apply_operation(\n            \"hpss_harmonic\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n        return cast(T_Processing, result)\n\n    def hpss_percussive(\n        self: T_Processing,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; T_Processing:\n        \"\"\"\n        Extract percussive components using HPSS\n        (Harmonic-Percussive Source Separation).\n\n        This method separates the percussive (tonal) components from the signal.\n\n        Args:\n            kernel_size: Median filter size for HPSS.\n            power: Exponent for the Weiner filter used in HPSS.\n            margin: Margin size for the separation.\n\n        Returns:\n            A new ChannelFrame containing the harmonic components.\n        \"\"\"\n        result = self.apply_operation(\n            \"hpss_percussive\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n        return cast(T_Processing, result)\n</code></pre> Functions\u00b6 <code></code> <code>high_pass_filter(cutoff, order=4)</code> \u00b6 <p>Apply a high-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>Filter cutoff frequency (Hz)</p> required <code>order</code> <code>int</code> <p>Filter order. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame after filter application</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def high_pass_filter(\n    self: T_Processing, cutoff: float, order: int = 4\n) -&gt; T_Processing:\n    \"\"\"Apply a high-pass filter to the signal.\n\n    Args:\n        cutoff: Filter cutoff frequency (Hz)\n        order: Filter order. Default is 4.\n\n    Returns:\n        New ChannelFrame after filter application\n    \"\"\"\n    logger.debug(\n        f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    result = self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>low_pass_filter(cutoff, order=4)</code> \u00b6 <p>Apply a low-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>Filter cutoff frequency (Hz)</p> required <code>order</code> <code>int</code> <p>Filter order. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame after filter application</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def low_pass_filter(\n    self: T_Processing, cutoff: float, order: int = 4\n) -&gt; T_Processing:\n    \"\"\"Apply a low-pass filter to the signal.\n\n    Args:\n        cutoff: Filter cutoff frequency (Hz)\n        order: Filter order. Default is 4.\n\n    Returns:\n        New ChannelFrame after filter application\n    \"\"\"\n    logger.debug(\n        f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    result = self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>band_pass_filter(low_cutoff, high_cutoff, order=4)</code> \u00b6 <p>Apply a band-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>low_cutoff</code> <code>float</code> <p>Lower cutoff frequency (Hz)</p> required <code>high_cutoff</code> <code>float</code> <p>Higher cutoff frequency (Hz)</p> required <code>order</code> <code>int</code> <p>Filter order. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame after filter application</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def band_pass_filter(\n    self: T_Processing, low_cutoff: float, high_cutoff: float, order: int = 4\n) -&gt; T_Processing:\n    \"\"\"Apply a band-pass filter to the signal.\n\n    Args:\n        low_cutoff: Lower cutoff frequency (Hz)\n        high_cutoff: Higher cutoff frequency (Hz)\n        order: Filter order. Default is 4.\n\n    Returns:\n        New ChannelFrame after filter application\n    \"\"\"\n    logger.debug(\n        f\"Setting up bandpass filter: low_cutoff={low_cutoff}, \"\n        f\"high_cutoff={high_cutoff}, order={order} (lazy)\"\n    )\n    result = self.apply_operation(\n        \"bandpass_filter\",\n        low_cutoff=low_cutoff,\n        high_cutoff=high_cutoff,\n        order=order,\n    )\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>normalize(target_level=-20, channel_wise=True)</code> \u00b6 <p>Normalize signal levels.</p> <p>This method adjusts the signal amplitude to reach the target RMS level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target RMS level (dB). Default is -20.</p> <code>-20</code> <code>channel_wise</code> <code>bool</code> <p>If True, normalize each channel individually. If False, apply the same scaling to all channels.</p> <code>True</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the normalized signal</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def normalize(\n    self: T_Processing, target_level: float = -20, channel_wise: bool = True\n) -&gt; T_Processing:\n    \"\"\"Normalize signal levels.\n\n    This method adjusts the signal amplitude to reach the target RMS level.\n\n    Args:\n        target_level: Target RMS level (dB). Default is -20.\n        channel_wise: If True, normalize each channel individually.\n            If False, apply the same scaling to all channels.\n\n    Returns:\n        New ChannelFrame containing the normalized signal\n    \"\"\"\n    logger.debug(\n        f\"Setting up normalize: target_level={target_level}, \"\n        f\"channel_wise={channel_wise} (lazy)\"\n    )\n    result = self.apply_operation(\n        \"normalize\", target_level=target_level, channel_wise=channel_wise\n    )\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>a_weighting()</code> \u00b6 <p>Apply A-weighting filter to the signal.</p> <p>A-weighting adjusts the frequency response to approximate human auditory perception, according to the IEC 61672-1:2013 standard.</p> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the A-weighted signal</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def a_weighting(self: T_Processing) -&gt; T_Processing:\n    \"\"\"Apply A-weighting filter to the signal.\n\n    A-weighting adjusts the frequency response to approximate human\n    auditory perception, according to the IEC 61672-1:2013 standard.\n\n    Returns:\n        New ChannelFrame containing the A-weighted signal\n    \"\"\"\n    result = self.apply_operation(\"a_weighting\")\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>abs()</code> \u00b6 <p>Compute the absolute value of the signal.</p> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the absolute values</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def abs(self: T_Processing) -&gt; T_Processing:\n    \"\"\"Compute the absolute value of the signal.\n\n    Returns:\n        New ChannelFrame containing the absolute values\n    \"\"\"\n    result = self.apply_operation(\"abs\")\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>power(exponent=2.0)</code> \u00b6 <p>Compute the power of the signal.</p> <p>Parameters:</p> Name Type Description Default <code>exponent</code> <code>float</code> <p>Exponent to raise the signal to. Default is 2.0.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the powered signal</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def power(self: T_Processing, exponent: float = 2.0) -&gt; T_Processing:\n    \"\"\"Compute the power of the signal.\n\n    Args:\n        exponent: Exponent to raise the signal to. Default is 2.0.\n\n    Returns:\n        New ChannelFrame containing the powered signal\n    \"\"\"\n    result = self.apply_operation(\"power\", exponent=exponent)\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>sum()</code> \u00b6 <p>Sum all channels.</p> <p>Returns:</p> Type Description <code>T_Processing</code> <p>A new ChannelFrame with summed signal.</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def sum(self: T_Processing) -&gt; T_Processing:\n    \"\"\"Sum all channels.\n\n    Returns:\n        A new ChannelFrame with summed signal.\n    \"\"\"\n    return cast(T_Processing, cast(Any, self)._reduce_channels(\"sum\"))\n</code></pre> <code></code> <code>mean()</code> \u00b6 <p>Average all channels.</p> <p>Returns:</p> Type Description <code>T_Processing</code> <p>A new ChannelFrame with averaged signal.</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def mean(self: T_Processing) -&gt; T_Processing:\n    \"\"\"Average all channels.\n\n    Returns:\n        A new ChannelFrame with averaged signal.\n    \"\"\"\n    return cast(T_Processing, cast(Any, self)._reduce_channels(\"mean\"))\n</code></pre> <code></code> <code>trim(start=0, end=None)</code> \u00b6 <p>Trim the signal to the specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>Start time (seconds)</p> <code>0</code> <code>end</code> <code>Optional[float]</code> <p>End time (seconds)</p> <code>None</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the trimmed signal</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If end time is earlier than start time</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def trim(\n    self: T_Processing,\n    start: float = 0,\n    end: Optional[float] = None,\n) -&gt; T_Processing:\n    \"\"\"Trim the signal to the specified time range.\n\n    Args:\n        start: Start time (seconds)\n        end: End time (seconds)\n\n    Returns:\n        New ChannelFrame containing the trimmed signal\n\n    Raises:\n        ValueError: If end time is earlier than start time\n    \"\"\"\n    if end is None:\n        end = self.duration\n    if start &gt; end:\n        raise ValueError(\"start must be less than end\")\n    result = self.apply_operation(\"trim\", start=start, end=end)\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>fix_length(length=None, duration=None)</code> \u00b6 <p>Adjust the signal to the specified length.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>Optional[float]</code> <p>Signal length in seconds</p> <code>None</code> <code>length</code> <code>Optional[int]</code> <p>Signal length in samples</p> <code>None</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the adjusted signal</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def fix_length(\n    self: T_Processing,\n    length: Optional[int] = None,\n    duration: Optional[float] = None,\n) -&gt; T_Processing:\n    \"\"\"Adjust the signal to the specified length.\n\n    Args:\n        duration: Signal length in seconds\n        length: Signal length in samples\n\n    Returns:\n        New ChannelFrame containing the adjusted signal\n    \"\"\"\n\n    result = self.apply_operation(\"fix_length\", length=length, duration=duration)\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>rms_trend(frame_length=2048, hop_length=512, dB=False, Aw=False)</code> \u00b6 <p>Compute the RMS trend of the signal.</p> <p>This method calculates the root mean square value over a sliding window.</p> <p>Parameters:</p> Name Type Description Default <code>frame_length</code> <code>int</code> <p>Size of the sliding window in samples. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>int</code> <p>Hop length between windows in samples. Default is 512.</p> <code>512</code> <code>dB</code> <code>bool</code> <p>Whether to return RMS values in decibels. Default is False.</p> <code>False</code> <code>Aw</code> <code>bool</code> <p>Whether to apply A-weighting. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the RMS trend</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def rms_trend(\n    self: T_Processing,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; T_Processing:\n    \"\"\"Compute the RMS trend of the signal.\n\n    This method calculates the root mean square value over a sliding window.\n\n    Args:\n        frame_length: Size of the sliding window in samples. Default is 2048.\n        hop_length: Hop length between windows in samples. Default is 512.\n        dB: Whether to return RMS values in decibels. Default is False.\n        Aw: Whether to apply A-weighting. Default is False.\n\n    Returns:\n        New ChannelFrame containing the RMS trend\n    \"\"\"\n    # Access _channel_metadata to retrieve reference values\n    frame = cast(ProcessingFrameProtocol, self)\n\n    # Ensure _channel_metadata exists before referencing\n    ref_values = []\n    if hasattr(frame, \"_channel_metadata\") and frame._channel_metadata:\n        ref_values = [ch.ref for ch in frame._channel_metadata]\n\n    result = self.apply_operation(\n        \"rms_trend\",\n        frame_length=frame_length,\n        hop_length=hop_length,\n        ref=ref_values,\n        dB=dB,\n        Aw=Aw,\n    )\n\n    # Update sampling rate\n    result_obj = cast(T_Processing, result)\n    if hasattr(result_obj, \"sampling_rate\"):\n        result_obj.sampling_rate = frame.sampling_rate / hop_length\n\n    return result_obj\n</code></pre> <code></code> <code>channel_difference(other_channel=0)</code> \u00b6 <p>Compute the difference between channels.</p> <p>Parameters:</p> Name Type Description Default <code>other_channel</code> <code>Union[int, str]</code> <p>Index or label of the reference channel. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the channel difference</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def channel_difference(\n    self: T_Processing, other_channel: Union[int, str] = 0\n) -&gt; T_Processing:\n    \"\"\"Compute the difference between channels.\n\n    Args:\n        other_channel: Index or label of the reference channel. Default is 0.\n\n    Returns:\n        New ChannelFrame containing the channel difference\n    \"\"\"\n    # label2index is a method of BaseFrame\n    if isinstance(other_channel, str):\n        if hasattr(self, \"label2index\"):\n            other_channel = self.label2index(other_channel)\n\n    result = self.apply_operation(\"channel_difference\", other_channel=other_channel)\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>resampling(target_sr, **kwargs)</code> \u00b6 <p>Resample audio data.</p> <p>Parameters:</p> Name Type Description Default <code>target_sr</code> <code>float</code> <p>Target sampling rate (Hz)</p> required <code>**kwargs</code> <code>Any</code> <p>Additional resampling parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>Resampled ChannelFrame</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def resampling(\n    self: T_Processing,\n    target_sr: float,\n    **kwargs: Any,\n) -&gt; T_Processing:\n    \"\"\"Resample audio data.\n\n    Args:\n        target_sr: Target sampling rate (Hz)\n        **kwargs: Additional resampling parameters\n\n    Returns:\n        Resampled ChannelFrame\n    \"\"\"\n    return cast(\n        T_Processing,\n        self.apply_operation(\n            \"resampling\",\n            target_sr=target_sr,\n            **kwargs,\n        ),\n    )\n</code></pre> <code></code> <code>hpss_harmonic(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code> \u00b6 <p>Extract harmonic components using HPSS  (Harmonic-Percussive Source Separation).</p> <p>This method separates the harmonic (tonal) components from the signal.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Union[_IntLike_co, tuple[_IntLike_co, _IntLike_co], list[_IntLike_co]]</code> <p>Median filter size for HPSS.</p> <code>31</code> <code>power</code> <code>float</code> <p>Exponent for the Weiner filter used in HPSS.</p> <code>2</code> <code>margin</code> <code>Union[_FloatLike_co, tuple[_FloatLike_co, _FloatLike_co], list[_FloatLike_co]]</code> <p>Margin size for the separation.</p> <code>1</code> <code>n_fft</code> <code>int</code> <p>Size of FFT window.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Hop length for STFT.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Window length for STFT.</p> <code>None</code> <code>window</code> <code>_WindowSpec</code> <p>Window type for STFT.</p> <code>'hann'</code> <code>center</code> <code>bool</code> <p>If True, center the frames.</p> <code>True</code> <code>pad_mode</code> <code>_PadModeSTFT</code> <p>Padding mode for STFT.</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>A new ChannelFrame containing the harmonic components.</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def hpss_harmonic(\n    self: T_Processing,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; T_Processing:\n    \"\"\"\n    Extract harmonic components using HPSS\n     (Harmonic-Percussive Source Separation).\n\n    This method separates the harmonic (tonal) components from the signal.\n\n    Args:\n        kernel_size: Median filter size for HPSS.\n        power: Exponent for the Weiner filter used in HPSS.\n        margin: Margin size for the separation.\n        n_fft: Size of FFT window.\n        hop_length: Hop length for STFT.\n        win_length: Window length for STFT.\n        window: Window type for STFT.\n        center: If True, center the frames.\n        pad_mode: Padding mode for STFT.\n\n    Returns:\n        A new ChannelFrame containing the harmonic components.\n    \"\"\"\n    result = self.apply_operation(\n        \"hpss_harmonic\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n    return cast(T_Processing, result)\n</code></pre> <code></code> <code>hpss_percussive(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code> \u00b6 <p>Extract percussive components using HPSS (Harmonic-Percussive Source Separation).</p> <p>This method separates the percussive (tonal) components from the signal.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Union[_IntLike_co, tuple[_IntLike_co, _IntLike_co], list[_IntLike_co]]</code> <p>Median filter size for HPSS.</p> <code>31</code> <code>power</code> <code>float</code> <p>Exponent for the Weiner filter used in HPSS.</p> <code>2</code> <code>margin</code> <code>Union[_FloatLike_co, tuple[_FloatLike_co, _FloatLike_co], list[_FloatLike_co]]</code> <p>Margin size for the separation.</p> <code>1</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>A new ChannelFrame containing the harmonic components.</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def hpss_percussive(\n    self: T_Processing,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; T_Processing:\n    \"\"\"\n    Extract percussive components using HPSS\n    (Harmonic-Percussive Source Separation).\n\n    This method separates the percussive (tonal) components from the signal.\n\n    Args:\n        kernel_size: Median filter size for HPSS.\n        power: Exponent for the Weiner filter used in HPSS.\n        margin: Margin size for the separation.\n\n    Returns:\n        A new ChannelFrame containing the harmonic components.\n    \"\"\"\n    result = self.apply_operation(\n        \"hpss_percussive\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n    return cast(T_Processing, result)\n</code></pre>"},{"location":"api/#wandas.frames.mixins.channel_transform_mixin","title":"<code>channel_transform_mixin</code>","text":"<p>Module providing mixins related to frequency transformations and transform operations.</p> Attributes\u00b6 <code>logger = logging.getLogger(__name__)</code> <code>module-attribute</code> \u00b6 Classes\u00b6 <code></code> <code>ChannelTransformMixin</code> \u00b6 <p>Mixin providing methods related to frequency transformations.</p> <p>This mixin provides operations related to frequency analysis and transformations such as FFT, STFT, and Welch method.</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>class ChannelTransformMixin:\n    \"\"\"Mixin providing methods related to frequency transformations.\n\n    This mixin provides operations related to frequency analysis and\n    transformations such as FFT, STFT, and Welch method.\n    \"\"\"\n\n    def fft(\n        self: T_Transform, n_fft: Optional[int] = None, window: str = \"hann\"\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Calculate Fast Fourier Transform (FFT).\n\n        Args:\n            n_fft: Number of FFT points. Default is the next power of 2 of the data\n                length.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            SpectralFrame containing FFT results\n        \"\"\"\n        from wandas.frames.spectral import SpectralFrame\n        from wandas.processing import FFT, create_operation\n\n        params = {\"n_fft\": n_fft, \"window\": window}\n        operation_name = \"fft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"FFT\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        if n_fft is None:\n            is_even = spectrum_data.shape[-1] % 2 == 0\n            _n_fft = (\n                spectrum_data.shape[-1] * 2 - 2\n                if is_even\n                else spectrum_data.shape[-1] * 2 - 1\n            )\n        else:\n            _n_fft = n_fft\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=_n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=base_self,\n        )\n\n    def welch(\n        self: T_Transform,\n        n_fft: Optional[int] = None,\n        hop_length: Optional[int] = None,\n        win_length: int = 2048,\n        window: str = \"hann\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Calculate power spectral density using Welch's method.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between frames.\n                Default is n_fft//4.\n            win_length: Window length. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            SpectralFrame containing power spectral density\n        \"\"\"\n        from wandas.frames.spectral import SpectralFrame\n        from wandas.processing import Welch, create_operation\n\n        params = dict(\n            n_fft=n_fft or win_length,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            average=average,\n        )\n        operation_name = \"welch\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Welch\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"welch\", \"params\": params},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=base_self,\n        )\n\n    def noct_spectrum(\n        self: T_Transform,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"Calculate N-octave band spectrum.\n\n        Args:\n            fmin: Minimum center frequency (Hz). Default is 20 Hz.\n            fmax: Maximum center frequency (Hz). Default is 20000 Hz.\n            n: Band division (1: octave, 3: 1/3 octave). Default is 3.\n            G: Reference gain (dB). Default is 10 dB.\n            fr: Reference frequency (Hz). Default is 1000 Hz.\n\n        Returns:\n            NOctFrame containing N-octave band spectrum\n        \"\"\"\n        from wandas.processing import NOctSpectrum, create_operation\n\n        from ..noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_spectrum\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSpectrum\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_spectrum\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=base_self,\n        )\n\n    def stft(\n        self: T_Transform,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"Calculate Short-Time Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between frames.\n                Default is n_fft//4.\n            win_length: Window length. Default is n_fft.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            SpectrogramFrame containing STFT results\n        \"\"\"\n        from wandas.processing import STFT, create_operation\n\n        from ..spectrogram import SpectrogramFrame\n\n        # Set hop length and window length\n        _hop_length = hop_length if hop_length is not None else n_fft // 4\n        _win_length = win_length if win_length is not None else n_fft\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": _hop_length,\n            \"win_length\": _win_length,\n            \"window\": window,\n        }\n        operation_name = \"stft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"STFT\", operation)\n\n        # Apply processing to data\n        spectrogram_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        # Create new instance\n        return SpectrogramFrame(\n            data=spectrogram_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=n_fft,\n            hop_length=_hop_length,\n            win_length=_win_length,\n            window=window,\n            label=f\"stft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n            previous=base_self,\n        )\n\n    def coherence(\n        self: T_Transform,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Calculate magnitude squared coherence.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between frames.\n                Default is n_fft//4.\n            win_length: Window length. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrend method. Options: \"constant\", \"linear\", None.\n\n        Returns:\n            SpectralFrame containing magnitude squared coherence\n        \"\"\"\n        from wandas.core.metadata import ChannelMetadata\n        from wandas.processing import Coherence, create_operation\n\n        from ..spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n        }\n        operation_name = \"coherence\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Coherence\", operation)\n\n        # Apply processing to data\n        coherence_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=coherence_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Coherence of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=base_self,\n        )\n\n    def csd(\n        self: T_Transform,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Calculate cross-spectral density matrix.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between frames.\n                Default is n_fft//4.\n            win_length: Window length. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrend method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            SpectralFrame containing cross-spectral density matrix\n        \"\"\"\n        from wandas.core.metadata import ChannelMetadata\n        from wandas.frames.spectral import SpectralFrame\n        from wandas.processing import CSD, create_operation\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"csd\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"CSD\", operation)\n\n        # Apply processing to data\n        csd_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=csd_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=base_self,\n        )\n\n    def transfer_function(\n        self: T_Transform,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Calculate transfer function matrix.\n\n        The transfer function represents the signal transfer characteristics between\n        channels in the frequency domain and represents the input-output relationship\n        of the system.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between frames.\n                Default is n_fft//4.\n            win_length: Window length. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrend method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            SpectralFrame containing transfer function matrix\n        \"\"\"\n        from wandas.core.metadata import ChannelMetadata\n        from wandas.frames.spectral import SpectralFrame\n        from wandas.processing import TransferFunction, create_operation\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"transfer_function\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"TransferFunction\", operation)\n\n        # Apply processing to data\n        tf_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=tf_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Transfer function of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=base_self,\n        )\n</code></pre> Functions\u00b6 <code></code> <code>fft(n_fft=None, window='hann')</code> \u00b6 <p>Calculate Fast Fourier Transform (FFT).</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is the next power of 2 of the data length.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>SpectralFrame containing FFT results</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def fft(\n    self: T_Transform, n_fft: Optional[int] = None, window: str = \"hann\"\n) -&gt; \"SpectralFrame\":\n    \"\"\"Calculate Fast Fourier Transform (FFT).\n\n    Args:\n        n_fft: Number of FFT points. Default is the next power of 2 of the data\n            length.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        SpectralFrame containing FFT results\n    \"\"\"\n    from wandas.frames.spectral import SpectralFrame\n    from wandas.processing import FFT, create_operation\n\n    params = {\"n_fft\": n_fft, \"window\": window}\n    operation_name = \"fft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"FFT\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    if n_fft is None:\n        is_even = spectrum_data.shape[-1] % 2 == 0\n        _n_fft = (\n            spectrum_data.shape[-1] * 2 - 2\n            if is_even\n            else spectrum_data.shape[-1] * 2 - 1\n        )\n    else:\n        _n_fft = n_fft\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=_n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=base_self,\n    )\n</code></pre> <code></code> <code>welch(n_fft=None, hop_length=None, win_length=2048, window='hann', average='mean')</code> \u00b6 <p>Calculate power spectral density using Welch's method.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is 2048.</p> <code>None</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between frames. Default is n_fft//4.</p> <code>None</code> <code>win_length</code> <code>int</code> <p>Window length. Default is n_fft.</p> <code>2048</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>SpectralFrame containing power spectral density</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def welch(\n    self: T_Transform,\n    n_fft: Optional[int] = None,\n    hop_length: Optional[int] = None,\n    win_length: int = 2048,\n    window: str = \"hann\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Calculate power spectral density using Welch's method.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between frames.\n            Default is n_fft//4.\n        win_length: Window length. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        SpectralFrame containing power spectral density\n    \"\"\"\n    from wandas.frames.spectral import SpectralFrame\n    from wandas.processing import Welch, create_operation\n\n    params = dict(\n        n_fft=n_fft or win_length,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        average=average,\n    )\n    operation_name = \"welch\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Welch\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"welch\", \"params\": params},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=base_self,\n    )\n</code></pre> <code></code> <code>noct_spectrum(fmin, fmax, n=3, G=10, fr=1000)</code> \u00b6 <p>Calculate N-octave band spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>fmin</code> <code>float</code> <p>Minimum center frequency (Hz). Default is 20 Hz.</p> required <code>fmax</code> <code>float</code> <p>Maximum center frequency (Hz). Default is 20000 Hz.</p> required <code>n</code> <code>int</code> <p>Band division (1: octave, 3: 1/3 octave). Default is 3.</p> <code>3</code> <code>G</code> <code>int</code> <p>Reference gain (dB). Default is 10 dB.</p> <code>10</code> <code>fr</code> <code>int</code> <p>Reference frequency (Hz). Default is 1000 Hz.</p> <code>1000</code> <p>Returns:</p> Type Description <code>NOctFrame</code> <p>NOctFrame containing N-octave band spectrum</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def noct_spectrum(\n    self: T_Transform,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"Calculate N-octave band spectrum.\n\n    Args:\n        fmin: Minimum center frequency (Hz). Default is 20 Hz.\n        fmax: Maximum center frequency (Hz). Default is 20000 Hz.\n        n: Band division (1: octave, 3: 1/3 octave). Default is 3.\n        G: Reference gain (dB). Default is 10 dB.\n        fr: Reference frequency (Hz). Default is 1000 Hz.\n\n    Returns:\n        NOctFrame containing N-octave band spectrum\n    \"\"\"\n    from wandas.processing import NOctSpectrum, create_operation\n\n    from ..noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_spectrum\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSpectrum\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_spectrum\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=base_self,\n    )\n</code></pre> <code></code> <code>stft(n_fft=2048, hop_length=None, win_length=None, window='hann')</code> \u00b6 <p>Calculate Short-Time Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between frames. Default is n_fft//4.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Window length. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectrogramFrame</code> <p>SpectrogramFrame containing STFT results</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def stft(\n    self: T_Transform,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n) -&gt; \"SpectrogramFrame\":\n    \"\"\"Calculate Short-Time Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between frames.\n            Default is n_fft//4.\n        win_length: Window length. Default is n_fft.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        SpectrogramFrame containing STFT results\n    \"\"\"\n    from wandas.processing import STFT, create_operation\n\n    from ..spectrogram import SpectrogramFrame\n\n    # Set hop length and window length\n    _hop_length = hop_length if hop_length is not None else n_fft // 4\n    _win_length = win_length if win_length is not None else n_fft\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": _hop_length,\n        \"win_length\": _win_length,\n        \"window\": window,\n    }\n    operation_name = \"stft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"STFT\", operation)\n\n    # Apply processing to data\n    spectrogram_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    # Create new instance\n    return SpectrogramFrame(\n        data=spectrogram_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=n_fft,\n        hop_length=_hop_length,\n        win_length=_win_length,\n        window=window,\n        label=f\"stft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n        previous=base_self,\n    )\n</code></pre> <code></code> <code>coherence(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant')</code> \u00b6 <p>Calculate magnitude squared coherence.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between frames. Default is n_fft//4.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Window length. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrend method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>SpectralFrame containing magnitude squared coherence</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def coherence(\n    self: T_Transform,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Calculate magnitude squared coherence.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between frames.\n            Default is n_fft//4.\n        win_length: Window length. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrend method. Options: \"constant\", \"linear\", None.\n\n    Returns:\n        SpectralFrame containing magnitude squared coherence\n    \"\"\"\n    from wandas.core.metadata import ChannelMetadata\n    from wandas.processing import Coherence, create_operation\n\n    from ..spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n    }\n    operation_name = \"coherence\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Coherence\", operation)\n\n    # Apply processing to data\n    coherence_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=coherence_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Coherence of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=base_self,\n    )\n</code></pre> <code></code> <code>csd(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code> \u00b6 <p>Calculate cross-spectral density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between frames. Default is n_fft//4.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Window length. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrend method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>SpectralFrame containing cross-spectral density matrix</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def csd(\n    self: T_Transform,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Calculate cross-spectral density matrix.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between frames.\n            Default is n_fft//4.\n        win_length: Window length. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrend method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        SpectralFrame containing cross-spectral density matrix\n    \"\"\"\n    from wandas.core.metadata import ChannelMetadata\n    from wandas.frames.spectral import SpectralFrame\n    from wandas.processing import CSD, create_operation\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"csd\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"CSD\", operation)\n\n    # Apply processing to data\n    csd_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=csd_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=base_self,\n    )\n</code></pre> <code></code> <code>transfer_function(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code> \u00b6 <p>Calculate transfer function matrix.</p> <p>The transfer function represents the signal transfer characteristics between channels in the frequency domain and represents the input-output relationship of the system.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between frames. Default is n_fft//4.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Window length. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrend method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>SpectralFrame containing transfer function matrix</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def transfer_function(\n    self: T_Transform,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Calculate transfer function matrix.\n\n    The transfer function represents the signal transfer characteristics between\n    channels in the frequency domain and represents the input-output relationship\n    of the system.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between frames.\n            Default is n_fft//4.\n        win_length: Window length. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrend method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        SpectralFrame containing transfer function matrix\n    \"\"\"\n    from wandas.core.metadata import ChannelMetadata\n    from wandas.frames.spectral import SpectralFrame\n    from wandas.processing import TransferFunction, create_operation\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"transfer_function\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"TransferFunction\", operation)\n\n    # Apply processing to data\n    tf_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=tf_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Transfer function of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=base_self,\n    )\n</code></pre>"},{"location":"api/#wandas.frames.mixins.protocols","title":"<code>protocols</code>","text":"<p>Common protocol definition module.</p> <p>This module contains common protocols used by mixin classes.</p> Attributes\u00b6 <code>logger = logging.getLogger(__name__)</code> <code>module-attribute</code> \u00b6 <code></code> <code>T_Base = TypeVar('T_Base', bound='BaseFrameProtocol')</code> <code>module-attribute</code> \u00b6 <code></code> <code>T_Processing = TypeVar('T_Processing', bound=ProcessingFrameProtocol)</code> <code>module-attribute</code> \u00b6 <code></code> <code>T_Transform = TypeVar('T_Transform', bound=TransformFrameProtocol)</code> <code>module-attribute</code> \u00b6 <code></code> <code>__all__ = ['BaseFrameProtocol', 'ProcessingFrameProtocol', 'TransformFrameProtocol', 'T_Processing']</code> <code>module-attribute</code> \u00b6 Classes\u00b6 <code></code> <code>BaseFrameProtocol</code> \u00b6 <p>               Bases: <code>Protocol</code></p> <p>Protocol that defines basic frame operations.</p> <p>Defines the basic methods and properties provided by all frame classes.</p> Source code in <code>wandas/frames/mixins/protocols.py</code> <pre><code>@runtime_checkable\nclass BaseFrameProtocol(Protocol):\n    \"\"\"Protocol that defines basic frame operations.\n\n    Defines the basic methods and properties provided by all frame classes.\n    \"\"\"\n\n    _data: DaArray\n    sampling_rate: float\n    _channel_metadata: list[ChannelMetadata]\n    metadata: dict[str, Any]\n    operation_history: list[dict[str, Any]]\n    label: str\n\n    @property\n    def duration(self) -&gt; float:\n        \"\"\"Returns the duration in seconds.\"\"\"\n        ...\n\n    def label2index(self, label: str) -&gt; int:\n        \"\"\"\n        Get the index from a channel label.\n        \"\"\"\n        ...\n\n    def apply_operation(\n        self, operation_name: str, **params: Any\n    ) -&gt; \"BaseFrameProtocol\":\n        \"\"\"Apply a named operation.\n\n        Args:\n            operation_name: Name of the operation to apply\n            **params: Parameters to pass to the operation\n\n        Returns:\n            A new frame instance with the operation applied\n        \"\"\"\n        ...\n\n    def _create_new_instance(self: T_Base, data: DaArray, **kwargs: Any) -&gt; T_Base:\n        \"\"\"Create a new instance of the frame with updated data and metadata.\n        Args:\n            data: The new data for the frame\n            metadata: The new metadata for the frame\n            operation_history: The new operation history for the frame\n            channel_metadata: The new channel metadata for the frame\n        Returns:\n            A new instance of the frame with the updated data and metadata\n        \"\"\"\n        ...\n</code></pre> Attributes\u00b6 <code></code> <code>sampling_rate</code> <code>instance-attribute</code> \u00b6 <code></code> <code>metadata</code> <code>instance-attribute</code> \u00b6 <code></code> <code>operation_history</code> <code>instance-attribute</code> \u00b6 <code></code> <code>label</code> <code>instance-attribute</code> \u00b6 <code></code> <code>duration</code> <code>property</code> \u00b6 <p>Returns the duration in seconds.</p> Functions\u00b6 <code></code> <code>label2index(label)</code> \u00b6 <p>Get the index from a channel label.</p> Source code in <code>wandas/frames/mixins/protocols.py</code> <pre><code>def label2index(self, label: str) -&gt; int:\n    \"\"\"\n    Get the index from a channel label.\n    \"\"\"\n    ...\n</code></pre> <code></code> <code>apply_operation(operation_name, **params)</code> \u00b6 <p>Apply a named operation.</p> <p>Parameters:</p> Name Type Description Default <code>operation_name</code> <code>str</code> <p>Name of the operation to apply</p> required <code>**params</code> <code>Any</code> <p>Parameters to pass to the operation</p> <code>{}</code> <p>Returns:</p> Type Description <code>BaseFrameProtocol</code> <p>A new frame instance with the operation applied</p> Source code in <code>wandas/frames/mixins/protocols.py</code> <pre><code>def apply_operation(\n    self, operation_name: str, **params: Any\n) -&gt; \"BaseFrameProtocol\":\n    \"\"\"Apply a named operation.\n\n    Args:\n        operation_name: Name of the operation to apply\n        **params: Parameters to pass to the operation\n\n    Returns:\n        A new frame instance with the operation applied\n    \"\"\"\n    ...\n</code></pre> <code></code> <code>ProcessingFrameProtocol</code> \u00b6 <p>               Bases: <code>BaseFrameProtocol</code>, <code>Protocol</code></p> <p>Protocol that defines operations related to signal processing.</p> <p>Defines methods that provide frame operations related to signal processing.</p> Source code in <code>wandas/frames/mixins/protocols.py</code> <pre><code>@runtime_checkable\nclass ProcessingFrameProtocol(BaseFrameProtocol, Protocol):\n    \"\"\"Protocol that defines operations related to signal processing.\n\n    Defines methods that provide frame operations related to signal processing.\n    \"\"\"\n\n    pass\n</code></pre> <code></code> <code>TransformFrameProtocol</code> \u00b6 <p>               Bases: <code>BaseFrameProtocol</code>, <code>Protocol</code></p> <p>Protocol related to transform operations.</p> <p>Defines methods that provide operations such as frequency analysis and spectral transformation.</p> Source code in <code>wandas/frames/mixins/protocols.py</code> <pre><code>@runtime_checkable\nclass TransformFrameProtocol(BaseFrameProtocol, Protocol):\n    \"\"\"Protocol related to transform operations.\n\n    Defines methods that provide operations such as frequency analysis and\n    spectral transformation.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/#wandas.frames.noct","title":"<code>noct</code>","text":""},{"location":"api/#wandas.frames.noct-attributes","title":"Attributes","text":""},{"location":"api/#wandas.frames.noct.dask_delayed","title":"<code>dask_delayed = dask.delayed</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.frames.noct.da_from_delayed","title":"<code>da_from_delayed = da.from_delayed</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.frames.noct.da_from_array","title":"<code>da_from_array = da.from_array</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.frames.noct.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.frames.noct.S","title":"<code>S = TypeVar('S', bound='BaseFrame[Any]')</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.frames.noct-classes","title":"Classes","text":""},{"location":"api/#wandas.frames.noct.NOctFrame","title":"<code>NOctFrame</code>","text":"<p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Class for handling N-octave band analysis data.</p> <p>This class represents frequency data analyzed in fractional octave bands, typically used in acoustic and vibration analysis. It handles real-valued data representing energy or power in each frequency band, following standard acoustical band definitions.</p>"},{"location":"api/#wandas.frames.noct.NOctFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The N-octave band data. Must be a dask array with shape:     - (channels, frequency_bins) for multi-channel data     - (frequency_bins,) for single-channel data, which will be       reshaped to (1, frequency_bins) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. fmin : float, default=0     Lower frequency bound in Hz. fmax : float, default=0     Upper frequency bound in Hz. n : int, default=3     Number of bands per octave (e.g., 3 for third-octave bands). G : int, default=10     Reference band number according to IEC 61260-1:2014. fr : int, default=1000     Reference frequency in Hz, typically 1000 Hz for acoustic analysis. label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"api/#wandas.frames.noct.NOctFrame--attributes","title":"Attributes","text":"<p>freqs : NDArrayReal     The center frequencies of each band in Hz, calculated according to     the standard fractional octave band definitions. dB : NDArrayReal     The spectrum in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrum in decibels, applying frequency weighting     for better correlation with perceived loudness. fmin : float     Lower frequency bound in Hz. fmax : float     Upper frequency bound in Hz. n : int     Number of bands per octave. G : int     Reference band number. fr : int     Reference frequency in Hz.</p>"},{"location":"api/#wandas.frames.noct.NOctFrame--examples","title":"Examples","text":"<p>Create an N-octave band spectrum from a time-domain signal:</p> <p>signal = ChannelFrame.from_wav(\"audio.wav\") spectrum = signal.noct_spectrum(fmin=20, fmax=20000, n=3)</p> <p>Plot the N-octave band spectrum:</p> <p>spectrum.plot()</p> <p>Plot with A-weighting applied:</p> <p>spectrum.plot(Aw=True)</p>"},{"location":"api/#wandas.frames.noct.NOctFrame--notes","title":"Notes","text":"<ul> <li>Binary operations (addition, multiplication, etc.) are not currently   supported for N-octave band data.</li> <li>The actual frequency bands are determined by the parameters n, G, and fr   according to IEC 61260-1:2014 standard for fractional octave band filters.</li> <li>The class follows acoustic standards for band definitions and analysis,   making it suitable for noise measurements and sound level analysis.</li> <li>A-weighting is available for better correlation with human hearing   perception, following IEC 61672-1:2013.</li> </ul> Source code in <code>wandas/frames/noct.py</code> <pre><code>class NOctFrame(BaseFrame[NDArrayReal]):\n    \"\"\"\n    Class for handling N-octave band analysis data.\n\n    This class represents frequency data analyzed in fractional octave bands,\n    typically used in acoustic and vibration analysis. It handles real-valued\n    data representing energy or power in each frequency band, following standard\n    acoustical band definitions.\n\n    Parameters\n    ----------\n    data : DaArray\n        The N-octave band data. Must be a dask array with shape:\n        - (channels, frequency_bins) for multi-channel data\n        - (frequency_bins,) for single-channel data, which will be\n          reshaped to (1, frequency_bins)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    fmin : float, default=0\n        Lower frequency bound in Hz.\n    fmax : float, default=0\n        Upper frequency bound in Hz.\n    n : int, default=3\n        Number of bands per octave (e.g., 3 for third-octave bands).\n    G : int, default=10\n        Reference band number according to IEC 61260-1:2014.\n    fr : int, default=1000\n        Reference frequency in Hz, typically 1000 Hz for acoustic analysis.\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    freqs : NDArrayReal\n        The center frequencies of each band in Hz, calculated according to\n        the standard fractional octave band definitions.\n    dB : NDArrayReal\n        The spectrum in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrum in decibels, applying frequency weighting\n        for better correlation with perceived loudness.\n    fmin : float\n        Lower frequency bound in Hz.\n    fmax : float\n        Upper frequency bound in Hz.\n    n : int\n        Number of bands per octave.\n    G : int\n        Reference band number.\n    fr : int\n        Reference frequency in Hz.\n\n    Examples\n    --------\n    Create an N-octave band spectrum from a time-domain signal:\n    &gt;&gt;&gt; signal = ChannelFrame.from_wav(\"audio.wav\")\n    &gt;&gt;&gt; spectrum = signal.noct_spectrum(fmin=20, fmax=20000, n=3)\n\n    Plot the N-octave band spectrum:\n    &gt;&gt;&gt; spectrum.plot()\n\n    Plot with A-weighting applied:\n    &gt;&gt;&gt; spectrum.plot(Aw=True)\n\n    Notes\n    -----\n    - Binary operations (addition, multiplication, etc.) are not currently\n      supported for N-octave band data.\n    - The actual frequency bands are determined by the parameters n, G, and fr\n      according to IEC 61260-1:2014 standard for fractional octave band filters.\n    - The class follows acoustic standards for band definitions and analysis,\n      making it suitable for noise measurements and sound level analysis.\n    - A-weighting is available for better correlation with human hearing\n      perception, following IEC 61672-1:2013.\n    \"\"\"\n\n    fmin: float\n    fmax: float\n    n: int\n    G: int\n    fr: int\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        fmin: float = 0,\n        fmax: float = 0,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a NOctFrame instance.\n\n        Sets up N-octave band analysis parameters and prepares the frame for\n        storing band-filtered data. Data shape is validated to ensure compatibility\n        with N-octave band analysis.\n\n        See class docstring for parameter descriptions.\n        \"\"\"\n        self.n = n\n        self.G = G\n        self.fr = fr\n        self.fmin = fmin\n        self.fmax = fmax\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrum in decibels relative to each channel's reference value.\n\n        The reference value for each channel is specified in its metadata.\n        A minimum value of -120 dB is enforced to avoid numerical issues.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrum in decibels. Shape matches the input data shape:\n            (channels, frequency_bins).\n        \"\"\"\n        # Collect dB reference values from _channel_metadata\n        ref = np.array([ch.ref for ch in self._channel_metadata])\n        # Convert to dB\n        # Use either the maximum value or 1e-12 to avoid division by zero\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(self.data / ref[..., np.newaxis], 1e-12)\n        )\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrum in decibels.\n\n        A-weighting applies a frequency-dependent weighting filter that approximates\n        the human ear's response to different frequencies. This is particularly useful\n        for analyzing noise and acoustic measurements as it provides a better\n        correlation with perceived loudness.\n\n        The weighting is applied according to IEC 61672-1:2013 standard.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrum in decibels. Shape matches the input data shape:\n            (channels, frequency_bins).\n        \"\"\"\n        # Collect dB reference values from _channel_metadata\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels in the N-octave band data.\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the center frequencies of each band in Hz.\n\n        These frequencies are calculated based on the N-octave band parameters\n        (n, G, fr) and the frequency bounds (fmin, fmax) according to\n        IEC 61260-1:2014 standard for fractional octave band filters.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of center frequencies for each frequency band.\n\n        Raises\n        ------\n        ValueError\n            If the center frequencies cannot be calculated or the result\n            is not a numpy array.\n        \"\"\"\n        _, freqs = _center_freq(\n            fmax=self.fmax,\n            fmin=self.fmin,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        if isinstance(freqs, np.ndarray):\n            return freqs\n        else:\n            raise ValueError(\"freqs is not numpy array.\")\n\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"\n        Binary operations are not currently supported for N-octave band data.\n\n        Parameters\n        ----------\n        other : Union[S, int, float, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation.\n        symbol : str\n            String representation of the operation (e.g., '+', '-', '*', '/').\n\n        Raises\n        ------\n        NotImplementedError\n            Always raises this error as operations are not implemented\n            for N-octave band data.\n        \"\"\"\n        raise NotImplementedError(\n            f\"Operation {symbol} is not implemented for NOctFrame.\"\n        )\n        return self\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Apply operations using lazy evaluation.\n        \"\"\"\n        # Apply operations using lazy evaluation\n        raise NotImplementedError(\n            f\"Operation {operation_name} is not implemented for NOctFrame.\"\n        )\n        return self\n\n    def plot(\n        self, plot_type: str = \"noct\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the N-octave band data using various visualization strategies.\n\n        Supports standard plotting configurations for acoustic analysis,\n        including decibel scales and A-weighting.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"noct\"\n            Type of plot to create. The default \"noct\" type creates a bar plot\n            suitable for displaying N-octave band data.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n            - title: Plot title\n            - xlabel, ylabel: Axis labels\n            - xscale: Set to \"log\" for logarithmic frequency axis\n            - grid: Whether to show grid lines\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        plot_strategy: PlotStrategy[NOctFrame] = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get additional initialization arguments for NOctFrame.\n\n        This internal method provides the additional initialization arguments\n        required by NOctFrame beyond those required by BaseFrame. These include\n        the N-octave band analysis parameters that define the frequency bands.\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments specific to NOctFrame:\n            - n: Number of bands per octave\n            - G: Reference band number\n            - fr: Reference frequency\n            - fmin: Lower frequency bound\n            - fmax: Upper frequency bound\n        \"\"\"\n        return {\n            \"n\": self.n,\n            \"G\": self.G,\n            \"fr\": self.fr,\n            \"fmin\": self.fmin,\n            \"fmax\": self.fmax,\n        }\n</code></pre> Attributes\u00b6 <code></code> <code>n = n</code> <code>instance-attribute</code> \u00b6 <code></code> <code>G = G</code> <code>instance-attribute</code> \u00b6 <code></code> <code>fr = fr</code> <code>instance-attribute</code> \u00b6 <code></code> <code>fmin = fmin</code> <code>instance-attribute</code> \u00b6 <code></code> <code>fmax = fmax</code> <code>instance-attribute</code> \u00b6 <code></code> <code>dB</code> <code>property</code> \u00b6 <p>Get the spectrum in decibels relative to each channel's reference value.</p> <p>The reference value for each channel is specified in its metadata. A minimum value of -120 dB is enforced to avoid numerical issues.</p> <code></code> <code>dBA</code> <code>property</code> \u00b6 <p>Get the A-weighted spectrum in decibels.</p> <p>A-weighting applies a frequency-dependent weighting filter that approximates the human ear's response to different frequencies. This is particularly useful for analyzing noise and acoustic measurements as it provides a better correlation with perceived loudness.</p> <p>The weighting is applied according to IEC 61672-1:2013 standard.</p> <code></code> <code>freqs</code> <code>property</code> \u00b6 <p>Get the center frequencies of each band in Hz.</p> <p>These frequencies are calculated based on the N-octave band parameters (n, G, fr) and the frequency bounds (fmin, fmax) according to IEC 61260-1:2014 standard for fractional octave band filters.</p> Functions\u00b6 <code></code> <code>__init__(data, sampling_rate, fmin=0, fmax=0, n=3, G=10, fr=1000, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code> \u00b6 <p>Initialize a NOctFrame instance.</p> <p>Sets up N-octave band analysis parameters and prepares the frame for storing band-filtered data. Data shape is validated to ensure compatibility with N-octave band analysis.</p> <p>See class docstring for parameter descriptions.</p> Source code in <code>wandas/frames/noct.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    fmin: float = 0,\n    fmax: float = 0,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a NOctFrame instance.\n\n    Sets up N-octave band analysis parameters and prepares the frame for\n    storing band-filtered data. Data shape is validated to ensure compatibility\n    with N-octave band analysis.\n\n    See class docstring for parameter descriptions.\n    \"\"\"\n    self.n = n\n    self.G = G\n    self.fr = fr\n    self.fmin = fmin\n    self.fmax = fmax\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre> <code></code> <code>plot(plot_type='noct', ax=None, **kwargs)</code> \u00b6 <p>Plot the N-octave band data using various visualization strategies.</p> <p>Supports standard plotting configurations for acoustic analysis, including decibel scales and A-weighting.</p>"},{"location":"api/#wandas.frames.noct.NOctFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrum in decibels. Shape matches the input data shape:     (channels, frequency_bins).</p>"},{"location":"api/#wandas.frames.noct.NOctFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrum in decibels. Shape matches the input data shape:     (channels, frequency_bins).</p>"},{"location":"api/#wandas.frames.noct.NOctFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of center frequencies for each frequency band.</p>"},{"location":"api/#wandas.frames.noct.NOctFrame.freqs--raises","title":"Raises","text":"<p>ValueError     If the center frequencies cannot be calculated or the result     is not a numpy array.</p>"},{"location":"api/#wandas.frames.noct.NOctFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"noct\"     Type of plot to create. The default \"noct\" type creates a bar plot     suitable for displaying N-octave band data. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting     - title: Plot title     - xlabel, ylabel: Axis labels     - xscale: Set to \"log\" for logarithmic frequency axis     - grid: Whether to show grid lines</p>"},{"location":"api/#wandas.frames.noct.NOctFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/noct.py</code> <pre><code>def plot(\n    self, plot_type: str = \"noct\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the N-octave band data using various visualization strategies.\n\n    Supports standard plotting configurations for acoustic analysis,\n    including decibel scales and A-weighting.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"noct\"\n        Type of plot to create. The default \"noct\" type creates a bar plot\n        suitable for displaying N-octave band data.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n        - title: Plot title\n        - xlabel, ylabel: Axis labels\n        - xscale: Set to \"log\" for logarithmic frequency axis\n        - grid: Whether to show grid lines\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    plot_strategy: PlotStrategy[NOctFrame] = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"api/#wandas.frames.spectral","title":"<code>spectral</code>","text":""},{"location":"api/#wandas.frames.spectral-attributes","title":"Attributes","text":""},{"location":"api/#wandas.frames.spectral.dask_delayed","title":"<code>dask_delayed = dask.delayed</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.frames.spectral.da_from_delayed","title":"<code>da_from_delayed = da.from_delayed</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.frames.spectral.da_from_array","title":"<code>da_from_array = da.from_array</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.frames.spectral.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.frames.spectral.S","title":"<code>S = TypeVar('S', bound='BaseFrame[Any]')</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.frames.spectral-classes","title":"Classes","text":""},{"location":"api/#wandas.frames.spectral.SpectralFrame","title":"<code>SpectralFrame</code>","text":"<p>               Bases: <code>BaseFrame[NDArrayComplex]</code></p> <p>Class for handling frequency-domain signal data.</p> <p>This class represents spectral data, providing methods for spectral analysis, manipulation, and visualization. It handles complex-valued frequency domain data obtained through operations like FFT.</p>"},{"location":"api/#wandas.frames.spectral.SpectralFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The spectral data. Must be a dask array with shape:     - (channels, frequency_bins) for multi-channel data     - (frequency_bins,) for single-channel data, which will be       reshaped to (1, frequency_bins) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. n_fft : int     The FFT size used to generate this spectral data. window : str, default=\"hann\"     The window function used in the FFT. label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"api/#wandas.frames.spectral.SpectralFrame--attributes","title":"Attributes","text":"<p>magnitude : NDArrayReal     The magnitude spectrum of the data. phase : NDArrayReal     The phase spectrum in radians. power : NDArrayReal     The power spectrum (magnitude squared). dB : NDArrayReal     The spectrum in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrum in decibels. freqs : NDArrayReal     The frequency axis values in Hz.</p>"},{"location":"api/#wandas.frames.spectral.SpectralFrame--examples","title":"Examples","text":"<p>Create a SpectralFrame from FFT:</p> <p>signal = ChannelFrame.from_numpy(data, sampling_rate=44100) spectrum = signal.fft(n_fft=2048)</p> <p>Plot the magnitude spectrum:</p> <p>spectrum.plot()</p> <p>Perform binary operations:</p> <p>scaled = spectrum * 2.0 summed = spectrum1 + spectrum2  # Must have matching sampling rates</p> <p>Convert back to time domain:</p> <p>time_signal = spectrum.ifft()</p>"},{"location":"api/#wandas.frames.spectral.SpectralFrame--notes","title":"Notes","text":"<ul> <li>All operations are performed lazily using dask arrays for efficient memory usage.</li> <li>Binary operations (+, -, *, /) can be performed between SpectralFrames or with   scalar values.</li> <li>The class maintains the processing history and metadata through all operations.</li> </ul> Source code in <code>wandas/frames/spectral.py</code> <pre><code>class SpectralFrame(BaseFrame[NDArrayComplex]):\n    \"\"\"\n    Class for handling frequency-domain signal data.\n\n    This class represents spectral data, providing methods for spectral analysis,\n    manipulation, and visualization. It handles complex-valued frequency domain data\n    obtained through operations like FFT.\n\n    Parameters\n    ----------\n    data : DaArray\n        The spectral data. Must be a dask array with shape:\n        - (channels, frequency_bins) for multi-channel data\n        - (frequency_bins,) for single-channel data, which will be\n          reshaped to (1, frequency_bins)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    n_fft : int\n        The FFT size used to generate this spectral data.\n    window : str, default=\"hann\"\n        The window function used in the FFT.\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    magnitude : NDArrayReal\n        The magnitude spectrum of the data.\n    phase : NDArrayReal\n        The phase spectrum in radians.\n    power : NDArrayReal\n        The power spectrum (magnitude squared).\n    dB : NDArrayReal\n        The spectrum in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrum in decibels.\n    freqs : NDArrayReal\n        The frequency axis values in Hz.\n\n    Examples\n    --------\n    Create a SpectralFrame from FFT:\n    &gt;&gt;&gt; signal = ChannelFrame.from_numpy(data, sampling_rate=44100)\n    &gt;&gt;&gt; spectrum = signal.fft(n_fft=2048)\n\n    Plot the magnitude spectrum:\n    &gt;&gt;&gt; spectrum.plot()\n\n    Perform binary operations:\n    &gt;&gt;&gt; scaled = spectrum * 2.0\n    &gt;&gt;&gt; summed = spectrum1 + spectrum2  # Must have matching sampling rates\n\n    Convert back to time domain:\n    &gt;&gt;&gt; time_signal = spectrum.ifft()\n\n    Notes\n    -----\n    - All operations are performed lazily using dask arrays for efficient memory usage.\n    - Binary operations (+, -, *, /) can be performed between SpectralFrames or with\n      scalar values.\n    - The class maintains the processing history and metadata through all operations.\n    \"\"\"\n\n    n_fft: int\n    window: str\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        n_fft: int,\n        window: str = \"hann\",\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def magnitude(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the magnitude spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The absolute values of the complex spectrum.\n        \"\"\"\n        return np.abs(self.data)\n\n    @property\n    def phase(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the phase spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The phase angles of the complex spectrum in radians.\n        \"\"\"\n        return np.angle(self.data)\n\n    @property\n    def power(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the power spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The squared magnitude spectrum.\n        \"\"\"\n        return self.magnitude**2\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrum in decibels.\n\n        The reference values are taken from channel metadata. If no reference\n        is specified, uses 1.0.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrum in dB relative to channel references.\n        \"\"\"\n        mag: NDArrayReal = self.magnitude\n        ref_values: NDArrayReal = np.array([ch.ref for ch in self._channel_metadata])\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(mag / ref_values[:, np.newaxis], 1e-12)\n        )\n\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrum in decibels.\n\n        Applies A-weighting filter to the spectrum for better correlation with\n        perceived loudness.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrum in dB.\n        \"\"\"\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels.\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the frequency axis values in Hz.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of frequency values corresponding to each frequency bin.\n        \"\"\"\n        return np.fft.rfftfreq(self.n_fft, 1.0 / self.sampling_rate)\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Implementation of operation application for spectral data.\n\n        This internal method handles the application of various operations to\n        spectral data, maintaining lazy evaluation through dask.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters for the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # Apply processing to data\n        processed_data = operation.process(self._data)\n\n        # Update metadata\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\n            \"SpectralFrame\", int, float, complex, NDArrayComplex, NDArrayReal, \"DaArray\"\n        ],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"\n        Common implementation for binary operations.\n\n        This method handles binary operations between SpectralFrames and various types\n        of operands, maintaining lazy evaluation through dask arrays.\n\n        Parameters\n        ----------\n        other : Union[SpectralFrame, int, float, complex,\n                        NDArrayComplex, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation (e.g., lambda a, b: a + b)\n        symbol : str\n            String representation of the operation (e.g., '+')\n\n        Returns\n        -------\n        SpectralFrame\n            A new SpectralFrame containing the result of the operation.\n\n        Raises\n        ------\n        ValueError\n            If attempting to operate with a SpectralFrame\n            with a different sampling rate.\n        \"\"\"\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, SpectralFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Directly operate on dask arrays (maintaining lazy execution)\n            result_data = op(self._data, other._data)\n\n            # Combine channel metadata\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return SpectralFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # Operation with scalar, NumPy array, or other types\n        else:\n            # Apply operation directly to dask array (maintaining lazy execution)\n            result_data = op(self._data, other)\n\n            # String representation of operand for display\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, complex):\n                other_str = f\"complex({other.real}, {other.imag})\"\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # Check for dask.array.Array\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # Update channel metadata\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return SpectralFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n            )\n\n    def plot(\n        self,\n        plot_type: str = \"frequency\",\n        ax: Optional[\"Axes\"] = None,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the spectral data using various visualization strategies.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"frequency\"\n            Type of plot to create. Options include:\n            - \"frequency\": Standard frequency plot\n            - \"matrix\": Matrix plot for comparing channels\n            - Other types as defined by available plot strategies\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - title: Plot title\n            - xlabel, ylabel: Axis labels\n            - vmin, vmax: Value limits for plots\n            - cmap: Colormap name\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def ifft(self) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.\n\n        This method transforms the frequency-domain data back to the time domain using\n        the inverse FFT operation. The window function used in the forward FFT is\n        taken into account to ensure proper reconstruction.\n\n        Returns\n        -------\n        ChannelFrame\n            A new ChannelFrame containing the time-domain signal.\n        \"\"\"\n        from ..processing import IFFT, create_operation\n        from .channel import ChannelFrame\n\n        params = {\"n_fft\": self.n_fft, \"window\": self.window}\n        operation_name = \"ifft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"IFFT\", operation)\n        # Apply processing to data\n        time_series = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # Create new instance\n        return ChannelFrame(\n            data=time_series,\n            sampling_rate=self.sampling_rate,\n            label=f\"ifft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Provide additional initialization arguments required for SpectralFrame.\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments for SpectralFrame.\n        \"\"\"\n        return {\n            \"n_fft\": self.n_fft,\n            \"window\": self.window,\n        }\n\n    def noct_synthesis(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"\n        Synthesize N-octave band spectrum.\n\n        This method combines frequency components into N-octave bands according to\n        standard acoustical band definitions. This is commonly used in noise and\n        vibration analysis.\n\n        Parameters\n        ----------\n        fmin : float\n            Lower frequency bound in Hz.\n        fmax : float\n            Upper frequency bound in Hz.\n        n : int, default=3\n            Number of bands per octave (e.g., 3 for third-octave bands).\n        G : int, default=10\n            Reference band number.\n        fr : int, default=1000\n            Reference frequency in Hz.\n\n        Returns\n        -------\n        NOctFrame\n            A new NOctFrame containing the N-octave band spectrum.\n\n        Raises\n        ------\n        ValueError\n            If the sampling rate is not 48000 Hz, which is required for this operation.\n        \"\"\"\n        if self.sampling_rate != 48000:\n            raise ValueError(\n                \"noct_synthesis can only be used with a sampling rate of 48000 Hz.\"\n            )\n        from ..processing import NOctSynthesis\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_synthesis\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSynthesis\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_synthesis\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def plot_matrix(\n        self,\n        plot_type: str = \"matrix\",\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot channel relationships in matrix format.\n\n        This method creates a matrix plot showing relationships between channels,\n        such as coherence, transfer functions, or cross-spectral density.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"matrix\"\n            Type of matrix plot to create.\n        **kwargs : dict\n            Additional plot parameters:\n            - vmin, vmax: Color scale limits\n            - cmap: Colormap name\n            - title: Plot title\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n</code></pre> Attributes\u00b6 <code></code> <code>n_fft = n_fft</code> <code>instance-attribute</code> \u00b6 <code></code> <code>window = window</code> <code>instance-attribute</code> \u00b6 <code></code> <code>magnitude</code> <code>property</code> \u00b6 <p>Get the magnitude spectrum.</p> <code></code> <code>phase</code> <code>property</code> \u00b6 <p>Get the phase spectrum.</p> <code></code> <code>power</code> <code>property</code> \u00b6 <p>Get the power spectrum.</p> <code></code> <code>dB</code> <code>property</code> \u00b6 <p>Get the spectrum in decibels.</p> <p>The reference values are taken from channel metadata. If no reference is specified, uses 1.0.</p> <code></code> <code>dBA</code> <code>property</code> \u00b6 <p>Get the A-weighted spectrum in decibels.</p> <p>Applies A-weighting filter to the spectrum for better correlation with perceived loudness.</p> <code></code> <code>freqs</code> <code>property</code> \u00b6 <p>Get the frequency axis values in Hz.</p> Functions\u00b6 <code></code> <code>__init__(data, sampling_rate, n_fft, window='hann', label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code> \u00b6 Source code in <code>wandas/frames/spectral.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    n_fft: int,\n    window: str = \"hann\",\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre> <code></code> <code>plot(plot_type='frequency', ax=None, **kwargs)</code> \u00b6 <p>Plot the spectral data using various visualization strategies.</p> <code></code> <code>ifft()</code> \u00b6 <p>Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.</p> <p>This method transforms the frequency-domain data back to the time domain using the inverse FFT operation. The window function used in the forward FFT is taken into account to ensure proper reconstruction.</p> <code></code> <code>noct_synthesis(fmin, fmax, n=3, G=10, fr=1000)</code> \u00b6 <p>Synthesize N-octave band spectrum.</p> <p>This method combines frequency components into N-octave bands according to standard acoustical band definitions. This is commonly used in noise and vibration analysis.</p> <code></code> <code>plot_matrix(plot_type='matrix', **kwargs)</code> \u00b6 <p>Plot channel relationships in matrix format.</p> <p>This method creates a matrix plot showing relationships between channels, such as coherence, transfer functions, or cross-spectral density.</p>"},{"location":"api/#wandas.frames.spectral.SpectralFrame.magnitude--returns","title":"Returns","text":"<p>NDArrayReal     The absolute values of the complex spectrum.</p>"},{"location":"api/#wandas.frames.spectral.SpectralFrame.phase--returns","title":"Returns","text":"<p>NDArrayReal     The phase angles of the complex spectrum in radians.</p>"},{"location":"api/#wandas.frames.spectral.SpectralFrame.power--returns","title":"Returns","text":"<p>NDArrayReal     The squared magnitude spectrum.</p>"},{"location":"api/#wandas.frames.spectral.SpectralFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrum in dB relative to channel references.</p>"},{"location":"api/#wandas.frames.spectral.SpectralFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrum in dB.</p>"},{"location":"api/#wandas.frames.spectral.SpectralFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of frequency values corresponding to each frequency bin.</p>"},{"location":"api/#wandas.frames.spectral.SpectralFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"frequency\"     Type of plot to create. Options include:     - \"frequency\": Standard frequency plot     - \"matrix\": Matrix plot for comparing channels     - Other types as defined by available plot strategies ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - title: Plot title     - xlabel, ylabel: Axis labels     - vmin, vmax: Value limits for plots     - cmap: Colormap name     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting</p>"},{"location":"api/#wandas.frames.spectral.SpectralFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def plot(\n    self,\n    plot_type: str = \"frequency\",\n    ax: Optional[\"Axes\"] = None,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the spectral data using various visualization strategies.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"frequency\"\n        Type of plot to create. Options include:\n        - \"frequency\": Standard frequency plot\n        - \"matrix\": Matrix plot for comparing channels\n        - Other types as defined by available plot strategies\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - title: Plot title\n        - xlabel, ylabel: Axis labels\n        - vmin, vmax: Value limits for plots\n        - cmap: Colormap name\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"api/#wandas.frames.spectral.SpectralFrame.ifft--returns","title":"Returns","text":"<p>ChannelFrame     A new ChannelFrame containing the time-domain signal.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def ifft(self) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.\n\n    This method transforms the frequency-domain data back to the time domain using\n    the inverse FFT operation. The window function used in the forward FFT is\n    taken into account to ensure proper reconstruction.\n\n    Returns\n    -------\n    ChannelFrame\n        A new ChannelFrame containing the time-domain signal.\n    \"\"\"\n    from ..processing import IFFT, create_operation\n    from .channel import ChannelFrame\n\n    params = {\"n_fft\": self.n_fft, \"window\": self.window}\n    operation_name = \"ifft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"IFFT\", operation)\n    # Apply processing to data\n    time_series = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # Create new instance\n    return ChannelFrame(\n        data=time_series,\n        sampling_rate=self.sampling_rate,\n        label=f\"ifft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"api/#wandas.frames.spectral.SpectralFrame.noct_synthesis--parameters","title":"Parameters","text":"<p>fmin : float     Lower frequency bound in Hz. fmax : float     Upper frequency bound in Hz. n : int, default=3     Number of bands per octave (e.g., 3 for third-octave bands). G : int, default=10     Reference band number. fr : int, default=1000     Reference frequency in Hz.</p>"},{"location":"api/#wandas.frames.spectral.SpectralFrame.noct_synthesis--returns","title":"Returns","text":"<p>NOctFrame     A new NOctFrame containing the N-octave band spectrum.</p>"},{"location":"api/#wandas.frames.spectral.SpectralFrame.noct_synthesis--raises","title":"Raises","text":"<p>ValueError     If the sampling rate is not 48000 Hz, which is required for this operation.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def noct_synthesis(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"\n    Synthesize N-octave band spectrum.\n\n    This method combines frequency components into N-octave bands according to\n    standard acoustical band definitions. This is commonly used in noise and\n    vibration analysis.\n\n    Parameters\n    ----------\n    fmin : float\n        Lower frequency bound in Hz.\n    fmax : float\n        Upper frequency bound in Hz.\n    n : int, default=3\n        Number of bands per octave (e.g., 3 for third-octave bands).\n    G : int, default=10\n        Reference band number.\n    fr : int, default=1000\n        Reference frequency in Hz.\n\n    Returns\n    -------\n    NOctFrame\n        A new NOctFrame containing the N-octave band spectrum.\n\n    Raises\n    ------\n    ValueError\n        If the sampling rate is not 48000 Hz, which is required for this operation.\n    \"\"\"\n    if self.sampling_rate != 48000:\n        raise ValueError(\n            \"noct_synthesis can only be used with a sampling rate of 48000 Hz.\"\n        )\n    from ..processing import NOctSynthesis\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_synthesis\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSynthesis\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_synthesis\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"api/#wandas.frames.spectral.SpectralFrame.plot_matrix--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"matrix\"     Type of matrix plot to create. **kwargs : dict     Additional plot parameters:     - vmin, vmax: Color scale limits     - cmap: Colormap name     - title: Plot title</p>"},{"location":"api/#wandas.frames.spectral.SpectralFrame.plot_matrix--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def plot_matrix(\n    self,\n    plot_type: str = \"matrix\",\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot channel relationships in matrix format.\n\n    This method creates a matrix plot showing relationships between channels,\n    such as coherence, transfer functions, or cross-spectral density.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"matrix\"\n        Type of matrix plot to create.\n    **kwargs : dict\n        Additional plot parameters:\n        - vmin, vmax: Color scale limits\n        - cmap: Colormap name\n        - title: Plot title\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"api/#wandas.frames.spectrogram","title":"<code>spectrogram</code>","text":""},{"location":"api/#wandas.frames.spectrogram-attributes","title":"Attributes","text":""},{"location":"api/#wandas.frames.spectrogram.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.frames.spectrogram.S","title":"<code>S = TypeVar('S', bound='BaseFrame[Any]')</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.frames.spectrogram-classes","title":"Classes","text":""},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame","title":"<code>SpectrogramFrame</code>","text":"<p>               Bases: <code>BaseFrame[NDArrayComplex]</code></p> <p>Class for handling time-frequency domain data (spectrograms).</p> <p>This class represents spectrogram data obtained through Short-Time Fourier Transform (STFT) or similar time-frequency analysis methods. It provides methods for visualization, manipulation, and conversion back to time domain.</p>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The spectrogram data. Must be a dask array with shape:     - (channels, frequency_bins, time_frames) for multi-channel data     - (frequency_bins, time_frames) for single-channel data, which will be       reshaped to (1, frequency_bins, time_frames) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. n_fft : int     The FFT size used to generate this spectrogram. hop_length : int     Number of samples between successive frames. win_length : int, optional     The window length in samples. If None, defaults to n_fft. window : str, default=\"hann\"     The window function to use (e.g., \"hann\", \"hamming\", \"blackman\"). label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame--attributes","title":"Attributes","text":"<p>magnitude : NDArrayReal     The magnitude spectrogram. phase : NDArrayReal     The phase spectrogram in radians. power : NDArrayReal     The power spectrogram. dB : NDArrayReal     The spectrogram in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrogram in decibels. n_frames : int     Number of time frames. n_freq_bins : int     Number of frequency bins. freqs : NDArrayReal     The frequency axis values in Hz. times : NDArrayReal     The time axis values in seconds.</p>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame--examples","title":"Examples","text":"<p>Create a spectrogram from a time-domain signal:</p> <p>signal = ChannelFrame.from_wav(\"audio.wav\") spectrogram = signal.stft(n_fft=2048, hop_length=512)</p> <p>Extract a specific time frame:</p> <p>frame_at_1s = spectrogram.get_frame_at(int(1.0 * sampling_rate / hop_length))</p> <p>Convert back to time domain:</p> <p>reconstructed = spectrogram.to_channel_frame()</p> <p>Plot the spectrogram:</p> <p>spectrogram.plot()</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>class SpectrogramFrame(BaseFrame[NDArrayComplex]):\n    \"\"\"\n    Class for handling time-frequency domain data (spectrograms).\n\n    This class represents spectrogram data obtained through\n    Short-Time Fourier Transform (STFT)\n    or similar time-frequency analysis methods. It provides methods for visualization,\n    manipulation, and conversion back to time domain.\n\n    Parameters\n    ----------\n    data : DaArray\n        The spectrogram data. Must be a dask array with shape:\n        - (channels, frequency_bins, time_frames) for multi-channel data\n        - (frequency_bins, time_frames) for single-channel data, which will be\n          reshaped to (1, frequency_bins, time_frames)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    n_fft : int\n        The FFT size used to generate this spectrogram.\n    hop_length : int\n        Number of samples between successive frames.\n    win_length : int, optional\n        The window length in samples. If None, defaults to n_fft.\n    window : str, default=\"hann\"\n        The window function to use (e.g., \"hann\", \"hamming\", \"blackman\").\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    magnitude : NDArrayReal\n        The magnitude spectrogram.\n    phase : NDArrayReal\n        The phase spectrogram in radians.\n    power : NDArrayReal\n        The power spectrogram.\n    dB : NDArrayReal\n        The spectrogram in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrogram in decibels.\n    n_frames : int\n        Number of time frames.\n    n_freq_bins : int\n        Number of frequency bins.\n    freqs : NDArrayReal\n        The frequency axis values in Hz.\n    times : NDArrayReal\n        The time axis values in seconds.\n\n    Examples\n    --------\n    Create a spectrogram from a time-domain signal:\n    &gt;&gt;&gt; signal = ChannelFrame.from_wav(\"audio.wav\")\n    &gt;&gt;&gt; spectrogram = signal.stft(n_fft=2048, hop_length=512)\n\n    Extract a specific time frame:\n    &gt;&gt;&gt; frame_at_1s = spectrogram.get_frame_at(int(1.0 * sampling_rate / hop_length))\n\n    Convert back to time domain:\n    &gt;&gt;&gt; reconstructed = spectrogram.to_channel_frame()\n\n    Plot the spectrogram:\n    &gt;&gt;&gt; spectrogram.plot()\n    \"\"\"\n\n    n_fft: int\n    hop_length: int\n    win_length: int\n    window: str\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        if data.ndim == 2:\n            data = da.expand_dims(data, axis=0)  # type: ignore [unused-ignore]\n        elif data.ndim != 3:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306f2\u6b21\u5143\u307e\u305f\u306f3\u6b21\u5143\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u5f62\u72b6: {data.shape}\"\n            )\n        if not data.shape[-2] == n_fft // 2 + 1:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u304c\u7121\u52b9\u3067\u3059\u3002\u5468\u6ce2\u6570\u30d3\u30f3\u6570\u306f {n_fft // 2 + 1} \u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\"  # noqa: E501\n            )\n\n        self.n_fft = n_fft\n        self.hop_length = hop_length\n        self.win_length = win_length if win_length is not None else n_fft\n        self.window = window\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def magnitude(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the magnitude spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The absolute values of the complex spectrogram.\n        \"\"\"\n        return np.abs(self.data)\n\n    @property\n    def phase(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the phase spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The phase angles of the complex spectrogram in radians.\n        \"\"\"\n        return np.angle(self.data)\n\n    @property\n    def power(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the power spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The squared magnitude of the complex spectrogram.\n        \"\"\"\n        return np.abs(self.data) ** 2\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrogram in decibels relative to each channel's reference value.\n\n        The reference value for each channel is specified in its metadata.\n        A minimum value of -120 dB is enforced to avoid numerical issues.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrogram in decibels.\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        ref = np.array([ch.ref for ch in self._channel_metadata])\n        # dB\u5909\u63db\n        # 0\u9664\u7b97\u3092\u907f\u3051\u308b\u305f\u3081\u306b\u3001\u6700\u5927\u5024\u30681e-12\u306e\u3044\u305a\u308c\u304b\u3092\u4f7f\u7528\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(self.magnitude / ref[..., np.newaxis, np.newaxis], 1e-12)\n        )\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrogram in decibels.\n\n        A-weighting applies a frequency-dependent weighting filter that approximates\n        the human ear's response. This is particularly useful for analyzing noise\n        and acoustic measurements.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrogram in decibels.\n        \"\"\"\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted[:, np.newaxis]  # \u5468\u6ce2\u6570\u8ef8\u306b\u6cbf\u3063\u3066\u30d6\u30ed\u30fc\u30c9\u30ad\u30e3\u30b9\u30c8\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels.\n        \"\"\"\n        return self.shape[0]\n\n    @property\n    def n_frames(self) -&gt; int:\n        \"\"\"\n        Get the number of time frames.\n\n        Returns\n        -------\n        int\n            The number of time frames in the spectrogram.\n        \"\"\"\n        return self.shape[-1]\n\n    @property\n    def n_freq_bins(self) -&gt; int:\n        \"\"\"\n        Get the number of frequency bins.\n\n        Returns\n        -------\n        int\n            The number of frequency bins (n_fft // 2 + 1).\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the frequency axis values in Hz.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of frequency values corresponding to each frequency bin.\n        \"\"\"\n        return np.fft.rfftfreq(self.n_fft, 1.0 / self.sampling_rate)\n\n    @property\n    def times(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the time axis values in seconds.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of time values corresponding to each time frame.\n        \"\"\"\n        return np.arange(self.n_frames) * self.hop_length / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Implementation of operation application for spectrogram data.\n\n        This internal method handles the application of various operations to\n        spectrogram data, maintaining lazy evaluation through dask.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters for the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from wandas.processing import create_operation\n\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        processed_data = operation.process(self._data)\n\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\n            \"SpectrogramFrame\",\n            int,\n            float,\n            complex,\n            NDArrayComplex,\n            NDArrayReal,\n            \"DaArray\",\n        ],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"\n        Common implementation for binary operations.\n\n        This method handles binary operations between\n        SpectrogramFrames and various types\n        of operands, maintaining lazy evaluation through dask arrays.\n\n        Parameters\n        ----------\n        other : Union[SpectrogramFrame, int, float, complex,\n            NDArrayComplex, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation (e.g., lambda a, b: a + b)\n        symbol : str\n            String representation of the operation (e.g., '+')\n\n        Returns\n        -------\n        SpectrogramFrame\n            A new SpectrogramFrame containing the result of the operation.\n\n        Raises\n        ------\n        ValueError\n            If attempting to operate with a SpectrogramFrame\n            with a different sampling rate.\n        \"\"\"\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        if isinstance(other, SpectrogramFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u304c\u4e00\u81f4\u3057\u3066\u3044\u307e\u305b\u3093\u3002\u6f14\u7b97\u3067\u304d\u307e\u305b\u3093\u3002\"\n                )\n\n            result_data = op(self._data, other._data)\n\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return SpectrogramFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                hop_length=self.hop_length,\n                win_length=self.win_length,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n        else:\n            result_data = op(self._data, other)\n\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, complex):\n                other_str = f\"complex({other.real}, {other.imag})\"\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return SpectrogramFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                hop_length=self.hop_length,\n                win_length=self.win_length,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n            )\n\n    def plot(\n        self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the spectrogram using various visualization strategies.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"spectrogram\"\n            Type of plot to create.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - vmin, vmax: Colormap scaling\n            - cmap: Colormap name\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectrogramFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def plot_Aw(  # noqa: N802\n        self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the A-weighted spectrogram.\n\n        A convenience method that calls plot() with Aw=True, applying A-weighting\n        to the spectrogram before plotting.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"spectrogram\"\n            Type of plot to create.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to plot().\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot.\n        \"\"\"\n        return self.plot(plot_type=plot_type, ax=ax, Aw=True, **kwargs)\n\n    def get_frame_at(self, time_idx: int) -&gt; \"SpectralFrame\":\n        \"\"\"\n        Extract spectral data at a specific time frame.\n\n        Parameters\n        ----------\n        time_idx : int\n            Index of the time frame to extract.\n\n        Returns\n        -------\n        SpectralFrame\n            A new SpectralFrame containing the spectral data at the specified time.\n\n        Raises\n        ------\n        IndexError\n            If time_idx is out of range.\n        \"\"\"\n        from wandas.frames.spectral import SpectralFrame\n\n        if time_idx &lt; 0 or time_idx &gt;= self.n_frames:\n            raise IndexError(\n                f\"\u6642\u9593\u30a4\u30f3\u30c7\u30c3\u30af\u30b9 {time_idx} \u304c\u7bc4\u56f2\u5916\u3067\u3059\u3002\u6709\u52b9\u7bc4\u56f2: 0-{self.n_frames - 1}\"  # noqa: E501\n            )\n\n        frame_data = self._data[..., time_idx]\n\n        return SpectralFrame(\n            data=frame_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=self.n_fft,\n            window=self.window,\n            label=f\"{self.label} (Frame {time_idx}, Time {self.times[time_idx]:.3f}s)\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def to_channel_frame(self) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Convert the spectrogram back to time domain using inverse STFT.\n\n        This method performs an inverse Short-Time Fourier Transform (ISTFT) to\n        reconstruct the time-domain signal from the spectrogram.\n\n        Returns\n        -------\n        ChannelFrame\n            A new ChannelFrame containing the reconstructed time-domain signal.\n        \"\"\"\n        from wandas.frames.channel import ChannelFrame\n        from wandas.processing import ISTFT, create_operation\n\n        params = {\n            \"n_fft\": self.n_fft,\n            \"hop_length\": self.hop_length,\n            \"win_length\": self.win_length,\n            \"window\": self.window,\n        }\n        operation_name = \"istft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"ISTFT\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        time_series = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n\n        # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        return ChannelFrame(\n            data=time_series,\n            sampling_rate=self.sampling_rate,\n            label=f\"istft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get additional initialization arguments for SpectrogramFrame.\n\n        This internal method provides the additional initialization arguments\n        required by SpectrogramFrame beyond those required by BaseFrame.\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments.\n        \"\"\"\n        return {\n            \"n_fft\": self.n_fft,\n            \"hop_length\": self.hop_length,\n            \"win_length\": self.win_length,\n            \"window\": self.window,\n        }\n</code></pre> Attributes\u00b6 <code></code> <code>n_fft = n_fft</code> <code>instance-attribute</code> \u00b6 <code></code> <code>hop_length = hop_length</code> <code>instance-attribute</code> \u00b6 <code></code> <code>win_length = win_length if win_length is not None else n_fft</code> <code>instance-attribute</code> \u00b6 <code></code> <code>window = window</code> <code>instance-attribute</code> \u00b6 <code></code> <code>magnitude</code> <code>property</code> \u00b6 <p>Get the magnitude spectrogram.</p> <code></code> <code>phase</code> <code>property</code> \u00b6 <p>Get the phase spectrogram.</p> <code></code> <code>power</code> <code>property</code> \u00b6 <p>Get the power spectrogram.</p> <code></code> <code>dB</code> <code>property</code> \u00b6 <p>Get the spectrogram in decibels relative to each channel's reference value.</p> <p>The reference value for each channel is specified in its metadata. A minimum value of -120 dB is enforced to avoid numerical issues.</p> <code></code> <code>dBA</code> <code>property</code> \u00b6 <p>Get the A-weighted spectrogram in decibels.</p> <p>A-weighting applies a frequency-dependent weighting filter that approximates the human ear's response. This is particularly useful for analyzing noise and acoustic measurements.</p> <code></code> <code>n_frames</code> <code>property</code> \u00b6 <p>Get the number of time frames.</p> <code></code> <code>n_freq_bins</code> <code>property</code> \u00b6 <p>Get the number of frequency bins.</p> <code></code> <code>freqs</code> <code>property</code> \u00b6 <p>Get the frequency axis values in Hz.</p> <code></code> <code>times</code> <code>property</code> \u00b6 <p>Get the time axis values in seconds.</p> Functions\u00b6 <code></code> <code>__init__(data, sampling_rate, n_fft, hop_length, win_length=None, window='hann', label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code> \u00b6 Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    if data.ndim == 2:\n        data = da.expand_dims(data, axis=0)  # type: ignore [unused-ignore]\n    elif data.ndim != 3:\n        raise ValueError(\n            f\"\u30c7\u30fc\u30bf\u306f2\u6b21\u5143\u307e\u305f\u306f3\u6b21\u5143\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u5f62\u72b6: {data.shape}\"\n        )\n    if not data.shape[-2] == n_fft // 2 + 1:\n        raise ValueError(\n            f\"\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u304c\u7121\u52b9\u3067\u3059\u3002\u5468\u6ce2\u6570\u30d3\u30f3\u6570\u306f {n_fft // 2 + 1} \u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\"  # noqa: E501\n        )\n\n    self.n_fft = n_fft\n    self.hop_length = hop_length\n    self.win_length = win_length if win_length is not None else n_fft\n    self.window = window\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre> <code></code> <code>plot(plot_type='spectrogram', ax=None, **kwargs)</code> \u00b6 <p>Plot the spectrogram using various visualization strategies.</p> <code></code> <code>plot_Aw(plot_type='spectrogram', ax=None, **kwargs)</code> \u00b6 <p>Plot the A-weighted spectrogram.</p> <p>A convenience method that calls plot() with Aw=True, applying A-weighting to the spectrogram before plotting.</p> <code></code> <code>get_frame_at(time_idx)</code> \u00b6 <p>Extract spectral data at a specific time frame.</p> <code></code> <code>to_channel_frame()</code> \u00b6 <p>Convert the spectrogram back to time domain using inverse STFT.</p> <p>This method performs an inverse Short-Time Fourier Transform (ISTFT) to reconstruct the time-domain signal from the spectrogram.</p>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame.magnitude--returns","title":"Returns","text":"<p>NDArrayReal     The absolute values of the complex spectrogram.</p>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame.phase--returns","title":"Returns","text":"<p>NDArrayReal     The phase angles of the complex spectrogram in radians.</p>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame.power--returns","title":"Returns","text":"<p>NDArrayReal     The squared magnitude of the complex spectrogram.</p>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrogram in decibels.</p>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrogram in decibels.</p>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame.n_frames--returns","title":"Returns","text":"<p>int     The number of time frames in the spectrogram.</p>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame.n_freq_bins--returns","title":"Returns","text":"<p>int     The number of frequency bins (n_fft // 2 + 1).</p>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of frequency values corresponding to each frequency bin.</p>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame.times--returns","title":"Returns","text":"<p>NDArrayReal     Array of time values corresponding to each time frame.</p>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"spectrogram\"     Type of plot to create. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - vmin, vmax: Colormap scaling     - cmap: Colormap name     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting</p>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def plot(\n    self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the spectrogram using various visualization strategies.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"spectrogram\"\n        Type of plot to create.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - vmin, vmax: Colormap scaling\n        - cmap: Colormap name\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectrogramFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"spectrogram\"     Type of plot to create. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to plot().</p>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def plot_Aw(  # noqa: N802\n    self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the A-weighted spectrogram.\n\n    A convenience method that calls plot() with Aw=True, applying A-weighting\n    to the spectrogram before plotting.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"spectrogram\"\n        Type of plot to create.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to plot().\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot.\n    \"\"\"\n    return self.plot(plot_type=plot_type, ax=ax, Aw=True, **kwargs)\n</code></pre>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--parameters","title":"Parameters","text":"<p>time_idx : int     Index of the time frame to extract.</p>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--returns","title":"Returns","text":"<p>SpectralFrame     A new SpectralFrame containing the spectral data at the specified time.</p>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--raises","title":"Raises","text":"<p>IndexError     If time_idx is out of range.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def get_frame_at(self, time_idx: int) -&gt; \"SpectralFrame\":\n    \"\"\"\n    Extract spectral data at a specific time frame.\n\n    Parameters\n    ----------\n    time_idx : int\n        Index of the time frame to extract.\n\n    Returns\n    -------\n    SpectralFrame\n        A new SpectralFrame containing the spectral data at the specified time.\n\n    Raises\n    ------\n    IndexError\n        If time_idx is out of range.\n    \"\"\"\n    from wandas.frames.spectral import SpectralFrame\n\n    if time_idx &lt; 0 or time_idx &gt;= self.n_frames:\n        raise IndexError(\n            f\"\u6642\u9593\u30a4\u30f3\u30c7\u30c3\u30af\u30b9 {time_idx} \u304c\u7bc4\u56f2\u5916\u3067\u3059\u3002\u6709\u52b9\u7bc4\u56f2: 0-{self.n_frames - 1}\"  # noqa: E501\n        )\n\n    frame_data = self._data[..., time_idx]\n\n    return SpectralFrame(\n        data=frame_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=self.n_fft,\n        window=self.window,\n        label=f\"{self.label} (Frame {time_idx}, Time {self.times[time_idx]:.3f}s)\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"api/#wandas.frames.spectrogram.SpectrogramFrame.to_channel_frame--returns","title":"Returns","text":"<p>ChannelFrame     A new ChannelFrame containing the reconstructed time-domain signal.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def to_channel_frame(self) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Convert the spectrogram back to time domain using inverse STFT.\n\n    This method performs an inverse Short-Time Fourier Transform (ISTFT) to\n    reconstruct the time-domain signal from the spectrogram.\n\n    Returns\n    -------\n    ChannelFrame\n        A new ChannelFrame containing the reconstructed time-domain signal.\n    \"\"\"\n    from wandas.frames.channel import ChannelFrame\n    from wandas.processing import ISTFT, create_operation\n\n    params = {\n        \"n_fft\": self.n_fft,\n        \"hop_length\": self.hop_length,\n        \"win_length\": self.win_length,\n        \"window\": self.window,\n    }\n    operation_name = \"istft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"ISTFT\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    time_series = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n    )\n\n    # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    return ChannelFrame(\n        data=time_series,\n        sampling_rate=self.sampling_rate,\n        label=f\"istft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"api/#_3","title":"\u51e6\u7406\u30e2\u30b8\u30e5\u30fc\u30eb","text":"<p>\u51e6\u7406\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u30aa\u30fc\u30c7\u30a3\u30aa\u30c7\u30fc\u30bf\u306b\u5bfe\u3059\u308b\u69d8\u3005\u306a\u51e6\u7406\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/#wandas.processing","title":"<code>wandas.processing</code>","text":"<p>Audio time series processing operations.</p> <p>This module provides audio processing operations for time series data.</p>"},{"location":"api/#wandas.processing-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.__all__","title":"<code>__all__ = ['AudioOperation', '_OPERATION_REGISTRY', 'create_operation', 'get_operation', 'register_operation', 'AWeighting', 'HighPassFilter', 'LowPassFilter', 'CSD', 'Coherence', 'FFT', 'IFFT', 'ISTFT', 'NOctSpectrum', 'NOctSynthesis', 'STFT', 'TransferFunction', 'Welch', 'ReSampling', 'RmsTrend', 'Trim', 'AddWithSNR', 'HpssHarmonic', 'HpssPercussive', 'ABS', 'ChannelDifference', 'Mean', 'Power', 'Sum']</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.processing-classes","title":"Classes","text":""},{"location":"api/#wandas.processing.AudioOperation","title":"<code>AudioOperation</code>","text":"<p>               Bases: <code>Generic[InputArrayType, OutputArrayType]</code></p> <p>Abstract base class for audio processing operations.</p> Source code in <code>wandas/processing/base.py</code> <pre><code>class AudioOperation(Generic[InputArrayType, OutputArrayType]):\n    \"\"\"Abstract base class for audio processing operations.\"\"\"\n\n    # Class variable: operation name\n    name: ClassVar[str]\n\n    def __init__(self, sampling_rate: float, **params: Any):\n        \"\"\"\n        Initialize AudioOperation.\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        **params : Any\n            Operation-specific parameters\n        \"\"\"\n        self.sampling_rate = sampling_rate\n        self.params = params\n\n        # Validate parameters during initialization\n        self.validate_params()\n\n        # Create processor function (lazy initialization possible)\n        self._setup_processor()\n\n        logger.debug(\n            f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n        )\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n        pass\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up processor function (implemented by subclasses)\"\"\"\n        pass\n\n    def _process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function (implemented by subclasses)\"\"\"\n        # Default is no-op function\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    @dask.delayed  # type: ignore [misc, unused-ignore]\n    def process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n        # Default is no-op function\n        logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n        return self._process_array(x)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation (implemented by subclasses)\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        \"\"\"\n        Execute operation and return result\n        data shape is (channels, samples)\n        \"\"\"\n        # Add task as delayed processing\n        logger.debug(\"Adding delayed operation to computation graph\")\n        delayed_result = self.process_array(data)\n        # Convert delayed result to dask array and return\n        output_shape = self.calculate_output_shape(data.shape)\n        return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"api/#wandas.processing.AudioOperation-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.AudioOperation.name","title":"<code>name</code>  <code>class-attribute</code>","text":""},{"location":"api/#wandas.processing.AudioOperation.sampling_rate","title":"<code>sampling_rate = sampling_rate</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.AudioOperation.params","title":"<code>params = params</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.AudioOperation-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.AudioOperation.__init__","title":"<code>__init__(sampling_rate, **params)</code>","text":"<p>Initialize AudioOperation.</p>"},{"location":"api/#wandas.processing.AudioOperation.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) **params : Any     Operation-specific parameters</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def __init__(self, sampling_rate: float, **params: Any):\n    \"\"\"\n    Initialize AudioOperation.\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    **params : Any\n        Operation-specific parameters\n    \"\"\"\n    self.sampling_rate = sampling_rate\n    self.params = params\n\n    # Validate parameters during initialization\n    self.validate_params()\n\n    # Create processor function (lazy initialization possible)\n    self._setup_processor()\n\n    logger.debug(\n        f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n    )\n</code></pre>"},{"location":"api/#wandas.processing.AudioOperation.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters (raises exception if invalid)</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n    pass\n</code></pre>"},{"location":"api/#wandas.processing.AudioOperation.process_array","title":"<code>process_array(x)</code>","text":"<p>Processing function wrapped with @dask.delayed</p> Source code in <code>wandas/processing/base.py</code> <pre><code>@dask.delayed  # type: ignore [misc, unused-ignore]\ndef process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n    \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n    # Default is no-op function\n    logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n    return self._process_array(x)\n</code></pre>"},{"location":"api/#wandas.processing.AudioOperation.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation (implemented by subclasses)</p>"},{"location":"api/#wandas.processing.AudioOperation.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/#wandas.processing.AudioOperation.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation (implemented by subclasses)\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"api/#wandas.processing.AudioOperation.process","title":"<code>process(data)</code>","text":"<p>Execute operation and return result data shape is (channels, samples)</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    \"\"\"\n    Execute operation and return result\n    data shape is (channels, samples)\n    \"\"\"\n    # Add task as delayed processing\n    logger.debug(\"Adding delayed operation to computation graph\")\n    delayed_result = self.process_array(data)\n    # Convert delayed result to dask array and return\n    output_shape = self.calculate_output_shape(data.shape)\n    return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"api/#wandas.processing.AddWithSNR","title":"<code>AddWithSNR</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Addition operation considering SNR</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>class AddWithSNR(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Addition operation considering SNR\"\"\"\n\n    name = \"add_with_snr\"\n\n    def __init__(self, sampling_rate: float, other: DaArray, snr: float = 1.0):\n        \"\"\"\n        Initialize addition operation considering SNR\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        other : DaArray\n            Noise signal to add (channel-frame format)\n        snr : float\n            Signal-to-noise ratio (dB)\n        \"\"\"\n        super().__init__(sampling_rate, other=other, snr=snr)\n\n        self.other = other\n        self.snr = snr\n        logger.debug(f\"Initialized AddWithSNR operation with SNR: {snr} dB\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape (same as input)\n        \"\"\"\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Perform addition processing considering SNR\"\"\"\n        logger.debug(f\"Applying SNR-based addition with shape: {x.shape}\")\n        other: NDArrayReal = self.other.compute()\n\n        # Use multi-channel versions of calculate_rms and calculate_desired_noise_rms\n        clean_rms = util.calculate_rms(x)\n        other_rms = util.calculate_rms(other)\n\n        # Adjust noise gain based on specified SNR (apply per channel)\n        desired_noise_rms = util.calculate_desired_noise_rms(clean_rms, self.snr)\n\n        # Apply gain per channel using broadcasting\n        gain = desired_noise_rms / other_rms\n        # Add adjusted noise to signal\n        result: NDArrayReal = x + other * gain\n        return result\n</code></pre>"},{"location":"api/#wandas.processing.AddWithSNR-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.AddWithSNR.name","title":"<code>name = 'add_with_snr'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.AddWithSNR.other","title":"<code>other = other</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.AddWithSNR.snr","title":"<code>snr = snr</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.AddWithSNR-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.AddWithSNR.__init__","title":"<code>__init__(sampling_rate, other, snr=1.0)</code>","text":"<p>Initialize addition operation considering SNR</p>"},{"location":"api/#wandas.processing.AddWithSNR.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) other : DaArray     Noise signal to add (channel-frame format) snr : float     Signal-to-noise ratio (dB)</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>def __init__(self, sampling_rate: float, other: DaArray, snr: float = 1.0):\n    \"\"\"\n    Initialize addition operation considering SNR\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    other : DaArray\n        Noise signal to add (channel-frame format)\n    snr : float\n        Signal-to-noise ratio (dB)\n    \"\"\"\n    super().__init__(sampling_rate, other=other, snr=snr)\n\n    self.other = other\n    self.snr = snr\n    logger.debug(f\"Initialized AddWithSNR operation with SNR: {snr} dB\")\n</code></pre>"},{"location":"api/#wandas.processing.AddWithSNR.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.AddWithSNR.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/#wandas.processing.AddWithSNR.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (same as input)</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape (same as input)\n    \"\"\"\n    return input_shape\n</code></pre>"},{"location":"api/#wandas.processing.HpssHarmonic","title":"<code>HpssHarmonic</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>HPSS Harmonic operation</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>class HpssHarmonic(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"HPSS Harmonic operation\"\"\"\n\n    name = \"hpss_harmonic\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize HPSS Harmonic\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        self.kwargs = kwargs\n        super().__init__(sampling_rate, **kwargs)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for HPSS Harmonic\"\"\"\n        logger.debug(f\"Applying HPSS Harmonic to array with shape: {x.shape}\")\n        result: NDArrayReal = effects.harmonic(x, **self.kwargs)\n        logger.debug(\n            f\"HPSS Harmonic applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"api/#wandas.processing.HpssHarmonic-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.HpssHarmonic.name","title":"<code>name = 'hpss_harmonic'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.HpssHarmonic.kwargs","title":"<code>kwargs = kwargs</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.HpssHarmonic-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.HpssHarmonic.__init__","title":"<code>__init__(sampling_rate, **kwargs)</code>","text":"<p>Initialize HPSS Harmonic</p>"},{"location":"api/#wandas.processing.HpssHarmonic.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize HPSS Harmonic\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    self.kwargs = kwargs\n    super().__init__(sampling_rate, **kwargs)\n</code></pre>"},{"location":"api/#wandas.processing.HpssHarmonic.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"Source code in <code>wandas/processing/effects.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    return input_shape\n</code></pre>"},{"location":"api/#wandas.processing.HpssPercussive","title":"<code>HpssPercussive</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>HPSS Percussive operation</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>class HpssPercussive(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"HPSS Percussive operation\"\"\"\n\n    name = \"hpss_percussive\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize HPSS Percussive\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        self.kwargs = kwargs\n        super().__init__(sampling_rate, **kwargs)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for HPSS Percussive\"\"\"\n        logger.debug(f\"Applying HPSS Percussive to array with shape: {x.shape}\")\n        result: NDArrayReal = effects.percussive(x, **self.kwargs)\n        logger.debug(\n            f\"HPSS Percussive applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"api/#wandas.processing.HpssPercussive-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.HpssPercussive.name","title":"<code>name = 'hpss_percussive'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.HpssPercussive.kwargs","title":"<code>kwargs = kwargs</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.HpssPercussive-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.HpssPercussive.__init__","title":"<code>__init__(sampling_rate, **kwargs)</code>","text":"<p>Initialize HPSS Percussive</p>"},{"location":"api/#wandas.processing.HpssPercussive.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize HPSS Percussive\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    self.kwargs = kwargs\n    super().__init__(sampling_rate, **kwargs)\n</code></pre>"},{"location":"api/#wandas.processing.HpssPercussive.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"Source code in <code>wandas/processing/effects.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    return input_shape\n</code></pre>"},{"location":"api/#wandas.processing.AWeighting","title":"<code>AWeighting</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>A-weighting filter operation</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>class AWeighting(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"A-weighting filter operation\"\"\"\n\n    name = \"a_weighting\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize A-weighting filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for A-weighting filter\"\"\"\n        logger.debug(f\"Applying A-weighting to array with shape: {x.shape}\")\n        result = A_weight(x, self.sampling_rate)\n\n        # Handle case where A_weight returns a tuple\n        if isinstance(result, tuple):\n            # Use the first element of the tuple\n            result = result[0]\n\n        logger.debug(\n            f\"A-weighting applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"api/#wandas.processing.AWeighting-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.AWeighting.name","title":"<code>name = 'a_weighting'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.AWeighting-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.AWeighting.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize A-weighting filter</p>"},{"location":"api/#wandas.processing.AWeighting.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize A-weighting filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"api/#wandas.processing.AWeighting.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"Source code in <code>wandas/processing/filters.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    return input_shape\n</code></pre>"},{"location":"api/#wandas.processing.HighPassFilter","title":"<code>HighPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>High-pass filter operation</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>class HighPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"High-pass filter operation\"\"\"\n\n    name = \"highpass_filter\"\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize high-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            limit = self.sampling_rate / 2\n            raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up high-pass filter processor\"\"\"\n        # Calculate filter coefficients (once) - safely retrieve from instance variables\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # Precompute and save filter coefficients\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"high\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Highpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying highpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/#wandas.processing.HighPassFilter-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.HighPassFilter.name","title":"<code>name = 'highpass_filter'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.HighPassFilter.cutoff","title":"<code>cutoff = cutoff</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.HighPassFilter.order","title":"<code>order = order</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.HighPassFilter-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.HighPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize high-pass filter</p>"},{"location":"api/#wandas.processing.HighPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize high-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"api/#wandas.processing.HighPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        limit = self.sampling_rate / 2\n        raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n</code></pre>"},{"location":"api/#wandas.processing.HighPassFilter.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"Source code in <code>wandas/processing/filters.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    return input_shape\n</code></pre>"},{"location":"api/#wandas.processing.LowPassFilter","title":"<code>LowPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Low-pass filter operation</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>class LowPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Low-pass filter operation\"\"\"\n\n    name = \"lowpass_filter\"\n    a: NDArrayReal\n    b: NDArrayReal\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize low-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            raise ValueError(\n                f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n            )\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up low-pass filter processor\"\"\"\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # Precompute and save filter coefficients\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"low\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Lowpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying lowpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/#wandas.processing.LowPassFilter-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.LowPassFilter.name","title":"<code>name = 'lowpass_filter'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.LowPassFilter.a","title":"<code>a</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.LowPassFilter.b","title":"<code>b</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.LowPassFilter.cutoff","title":"<code>cutoff = cutoff</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.LowPassFilter.order","title":"<code>order = order</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.LowPassFilter-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.LowPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize low-pass filter</p>"},{"location":"api/#wandas.processing.LowPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize low-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"api/#wandas.processing.LowPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        raise ValueError(\n            f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n        )\n</code></pre>"},{"location":"api/#wandas.processing.LowPassFilter.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"Source code in <code>wandas/processing/filters.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    return input_shape\n</code></pre>"},{"location":"api/#wandas.processing.CSD","title":"<code>CSD</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Cross-spectral density estimation operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class CSD(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Cross-spectral density estimation operation\"\"\"\n\n    name = \"csd\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n        scaling: str,\n        average: str,\n    ):\n        \"\"\"\n        Initialize cross-spectral density estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        scaling : str\n            Type of scaling\n        average : str\n            Method of averaging\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        self.scaling = scaling\n        self.average = average\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n            scaling=scaling,\n            average=average,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Processor function for cross-spectral density estimation operation\"\"\"\n        logger.debug(f\"Applying CSD estimation to array with shape: {x.shape}\")\n        from scipy import signal as ss\n\n        # Calculate all combinations using scipy's csd function\n        _, csd_result = ss.csd(\n            x=x[:, np.newaxis],\n            y=x[np.newaxis, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n        )\n\n        # Reshape result to (n_channels * n_channels, n_freqs)\n        result: NDArrayComplex = csd_result.transpose(1, 0, 2).reshape(\n            -1, csd_result.shape[-1]\n        )\n\n        logger.debug(f\"CSD estimation applied, result shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/#wandas.processing.CSD-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.CSD.name","title":"<code>name = 'csd'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.CSD.n_fft","title":"<code>n_fft = n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.CSD.win_length","title":"<code>win_length = win_length if win_length is not None else n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.CSD.hop_length","title":"<code>hop_length = hop_length if hop_length is not None else self.win_length // 4</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.CSD.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.CSD.detrend","title":"<code>detrend = detrend</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.CSD.scaling","title":"<code>scaling = scaling</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.CSD.average","title":"<code>average = average</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.CSD-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.CSD.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend, scaling, average)</code>","text":"<p>Initialize cross-spectral density estimation operation</p>"},{"location":"api/#wandas.processing.CSD.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend scaling : str     Type of scaling average : str     Method of averaging</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n    scaling: str,\n    average: str,\n):\n    \"\"\"\n    Initialize cross-spectral density estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    scaling : str\n        Type of scaling\n    average : str\n        Method of averaging\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    self.scaling = scaling\n    self.average = average\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n        scaling=scaling,\n        average=average,\n    )\n</code></pre>"},{"location":"api/#wandas.processing.CSD.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.CSD.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"api/#wandas.processing.CSD.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"api/#wandas.processing.FFT","title":"<code>FFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>FFT (Fast Fourier Transform) operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class FFT(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"FFT (Fast Fourier Transform) operation\"\"\"\n\n    name = \"fft\"\n    n_fft: Optional[int]\n    window: str\n\n    def __init__(\n        self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n    ):\n        \"\"\"\n        Initialize FFT operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int, optional\n            FFT size, default is None (determined by input size)\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(sampling_rate, n_fft=n_fft, window=window)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        \u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059\n\n        Parameters\n        ----------\n        input_shape : tuple\n            \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)\n\n        Returns\n        -------\n        tuple\n            \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)\n        \"\"\"\n        n_freqs = self.n_fft // 2 + 1 if self.n_fft else input_shape[-1] // 2 + 1\n        return (*input_shape[:-1], n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"FFT\u64cd\u4f5c\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u95a2\u6570\u3092\u4f5c\u6210\"\"\"\n        from scipy.signal import get_window\n\n        win = get_window(self.window, x.shape[-1])\n        x = x * win\n        result: NDArrayComplex = np.fft.rfft(x, n=self.n_fft, axis=-1)\n        result[..., 1:-1] *= 2.0\n        # \u7a93\u95a2\u6570\u88dc\u6b63\n        scaling_factor = np.sum(win)\n        result = result / scaling_factor\n        return result\n</code></pre>"},{"location":"api/#wandas.processing.FFT-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.FFT.name","title":"<code>name = 'fft'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.FFT.n_fft","title":"<code>n_fft = n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.FFT.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.FFT-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.FFT.__init__","title":"<code>__init__(sampling_rate, n_fft=None, window='hann')</code>","text":"<p>Initialize FFT operation</p>"},{"location":"api/#wandas.processing.FFT.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int, optional     FFT size, default is None (determined by input size) window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n):\n    \"\"\"\n    Initialize FFT operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int, optional\n        FFT size, default is None (determined by input size)\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(sampling_rate, n_fft=n_fft, window=window)\n</code></pre>"},{"location":"api/#wandas.processing.FFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>\u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059</p>"},{"location":"api/#wandas.processing.FFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)</p>"},{"location":"api/#wandas.processing.FFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    \u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059\n\n    Parameters\n    ----------\n    input_shape : tuple\n        \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)\n\n    Returns\n    -------\n    tuple\n        \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)\n    \"\"\"\n    n_freqs = self.n_fft // 2 + 1 if self.n_fft else input_shape[-1] // 2 + 1\n    return (*input_shape[:-1], n_freqs)\n</code></pre>"},{"location":"api/#wandas.processing.IFFT","title":"<code>IFFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayComplex, NDArrayReal]</code></p> <p>IFFT (Inverse Fast Fourier Transform) operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class IFFT(AudioOperation[NDArrayComplex, NDArrayReal]):\n    \"\"\"IFFT (Inverse Fast Fourier Transform) operation\"\"\"\n\n    name = \"ifft\"\n    n_fft: Optional[int]\n    window: str\n\n    def __init__(\n        self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n    ):\n        \"\"\"\n        Initialize IFFT operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : Optional[int], optional\n            IFFT size, default is None (determined based on input size)\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(sampling_rate, n_fft=n_fft, window=window)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, freqs)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, samples)\n        \"\"\"\n        n_samples = 2 * (input_shape[-1] - 1) if self.n_fft is None else self.n_fft\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayComplex) -&gt; NDArrayReal:\n        \"\"\"Create processor function for IFFT operation\"\"\"\n        logger.debug(f\"Applying IFFT to array with shape: {x.shape}\")\n\n        # Restore frequency component scaling (remove the 2.0 multiplier applied in FFT)\n        _x = x.copy()\n        _x[..., 1:-1] /= 2.0\n\n        # Execute IFFT\n        result: NDArrayReal = np.fft.irfft(_x, n=self.n_fft, axis=-1)\n\n        # Window function correction (inverse of FFT operation)\n        from scipy.signal import get_window\n\n        win = get_window(self.window, result.shape[-1])\n\n        # Correct the FFT window function scaling\n        scaling_factor = np.sum(win) / result.shape[-1]\n        result = result / scaling_factor\n\n        logger.debug(f\"IFFT applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/#wandas.processing.IFFT-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.IFFT.name","title":"<code>name = 'ifft'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.IFFT.n_fft","title":"<code>n_fft = n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.IFFT.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.IFFT-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.IFFT.__init__","title":"<code>__init__(sampling_rate, n_fft=None, window='hann')</code>","text":"<p>Initialize IFFT operation</p>"},{"location":"api/#wandas.processing.IFFT.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : Optional[int], optional     IFFT size, default is None (determined based on input size) window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n):\n    \"\"\"\n    Initialize IFFT operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : Optional[int], optional\n        IFFT size, default is None (determined based on input size)\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(sampling_rate, n_fft=n_fft, window=window)\n</code></pre>"},{"location":"api/#wandas.processing.IFFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.IFFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, freqs)</p>"},{"location":"api/#wandas.processing.IFFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, samples)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, freqs)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, samples)\n    \"\"\"\n    n_samples = 2 * (input_shape[-1] - 1) if self.n_fft is None else self.n_fft\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"api/#wandas.processing.ISTFT","title":"<code>ISTFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayComplex, NDArrayReal]</code></p> <p>Inverse Short-Time Fourier Transform operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class ISTFT(AudioOperation[NDArrayComplex, NDArrayReal]):\n    \"\"\"Inverse Short-Time Fourier Transform operation\"\"\"\n\n    name = \"istft\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        length: Optional[int] = None,\n    ):\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.length = length\n\n        # Instantiate ShortTimeFFT for ISTFT calculation\n        self.SFT = ShortTimeFFT(\n            win=get_window(window, self.win_length),\n            hop=self.hop_length,\n            fs=sampling_rate,\n            mfft=self.n_fft,\n            scale_to=\"magnitude\",  # Consistent scaling with STFT\n        )\n\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n            length=length,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, freqs, time_frames)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, samples)\n        \"\"\"\n        k0: int = 0\n        q_max = input_shape[-1] + self.SFT.p_min\n        k_max = (q_max - 1) * self.SFT.hop + self.SFT.m_num - self.SFT.m_num_mid\n        k_q0, k_q1 = self.SFT.nearest_k_p(k0), self.SFT.nearest_k_p(k_max, left=False)\n        n_pts = k_q1 - k_q0 + self.SFT.m_num - self.SFT.m_num_mid\n\n        return input_shape[:-2] + (n_pts,)\n\n    def _process_array(self, x: NDArrayComplex) -&gt; NDArrayReal:\n        \"\"\"\n        Apply SciPy ISTFT processing to multiple channels at once using ShortTimeFFT\"\"\"\n        logger.debug(\n            f\"Applying SciPy ISTFT (ShortTimeFFT) to array with shape: {x.shape}\"\n        )\n\n        # Convert 2D input to 3D (assume single channel)\n        if x.ndim == 2:\n            x = x.reshape(1, *x.shape)\n\n        # Adjust scaling back if STFT applied factor of 2\n        _x = np.copy(x)\n        _x[..., 1:-1, :] /= 2.0\n\n        # Apply ISTFT using the ShortTimeFFT instance\n        result: NDArrayReal = self.SFT.istft(_x)\n\n        # Trim to desired length if specified\n        if self.length is not None:\n            result = result[..., : self.length]\n\n        logger.debug(\n            f\"ShortTimeFFT applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"api/#wandas.processing.ISTFT-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.ISTFT.name","title":"<code>name = 'istft'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.ISTFT.n_fft","title":"<code>n_fft = n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.ISTFT.win_length","title":"<code>win_length = win_length if win_length is not None else n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.ISTFT.hop_length","title":"<code>hop_length = hop_length if hop_length is not None else self.win_length // 4</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.ISTFT.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.ISTFT.length","title":"<code>length = length</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.ISTFT.SFT","title":"<code>SFT = ShortTimeFFT(win=get_window(window, self.win_length), hop=self.hop_length, fs=sampling_rate, mfft=self.n_fft, scale_to='magnitude')</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.ISTFT-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.ISTFT.__init__","title":"<code>__init__(sampling_rate, n_fft=2048, hop_length=None, win_length=None, window='hann', length=None)</code>","text":"Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    length: Optional[int] = None,\n):\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.length = length\n\n    # Instantiate ShortTimeFFT for ISTFT calculation\n    self.SFT = ShortTimeFFT(\n        win=get_window(window, self.win_length),\n        hop=self.hop_length,\n        fs=sampling_rate,\n        mfft=self.n_fft,\n        scale_to=\"magnitude\",  # Consistent scaling with STFT\n    )\n\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        win_length=self.win_length,\n        hop_length=self.hop_length,\n        window=window,\n        length=length,\n    )\n</code></pre>"},{"location":"api/#wandas.processing.ISTFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.ISTFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, freqs, time_frames)</p>"},{"location":"api/#wandas.processing.ISTFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, samples)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, freqs, time_frames)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, samples)\n    \"\"\"\n    k0: int = 0\n    q_max = input_shape[-1] + self.SFT.p_min\n    k_max = (q_max - 1) * self.SFT.hop + self.SFT.m_num - self.SFT.m_num_mid\n    k_q0, k_q1 = self.SFT.nearest_k_p(k0), self.SFT.nearest_k_p(k_max, left=False)\n    n_pts = k_q1 - k_q0 + self.SFT.m_num - self.SFT.m_num_mid\n\n    return input_shape[:-2] + (n_pts,)\n</code></pre>"},{"location":"api/#wandas.processing.STFT","title":"<code>STFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Short-Time Fourier Transform operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class STFT(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Short-Time Fourier Transform operation\"\"\"\n\n    name = \"stft\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ):\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.noverlap = (\n            self.win_length - self.hop_length if hop_length is not None else None\n        )\n        self.window = window\n\n        self.SFT = ShortTimeFFT(\n            win=get_window(window, self.win_length),\n            hop=self.hop_length,\n            fs=sampling_rate,\n            mfft=self.n_fft,\n            scale_to=\"magnitude\",\n        )\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        n_samples = input_shape[-1]\n        n_f = len(self.SFT.f)\n        n_t = len(self.SFT.t(n_samples))\n        return (input_shape[0], n_f, n_t)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Apply SciPy STFT processing to multiple channels at once\"\"\"\n        logger.debug(f\"Applying SciPy STFT to array with shape: {x.shape}\")\n\n        # Convert 1D input to 2D\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n\n        # Apply STFT to all channels at once\n        result: NDArrayComplex = self.SFT.stft(x)\n        result[..., 1:-1, :] *= 2.0\n        logger.debug(f\"SciPy STFT applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/#wandas.processing.STFT-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.STFT.name","title":"<code>name = 'stft'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.STFT.n_fft","title":"<code>n_fft = n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.STFT.win_length","title":"<code>win_length = win_length if win_length is not None else n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.STFT.hop_length","title":"<code>hop_length = hop_length if hop_length is not None else self.win_length // 4</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.STFT.noverlap","title":"<code>noverlap = self.win_length - self.hop_length if hop_length is not None else None</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.STFT.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.STFT.SFT","title":"<code>SFT = ShortTimeFFT(win=get_window(window, self.win_length), hop=self.hop_length, fs=sampling_rate, mfft=self.n_fft, scale_to='magnitude')</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.STFT-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.STFT.__init__","title":"<code>__init__(sampling_rate, n_fft=2048, hop_length=None, win_length=None, window='hann')</code>","text":"Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n):\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.noverlap = (\n        self.win_length - self.hop_length if hop_length is not None else None\n    )\n    self.window = window\n\n    self.SFT = ShortTimeFFT(\n        win=get_window(window, self.win_length),\n        hop=self.hop_length,\n        fs=sampling_rate,\n        mfft=self.n_fft,\n        scale_to=\"magnitude\",\n    )\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        win_length=self.win_length,\n        hop_length=self.hop_length,\n        window=window,\n    )\n</code></pre>"},{"location":"api/#wandas.processing.STFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.STFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/#wandas.processing.STFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    n_samples = input_shape[-1]\n    n_f = len(self.SFT.f)\n    n_t = len(self.SFT.t(n_samples))\n    return (input_shape[0], n_f, n_t)\n</code></pre>"},{"location":"api/#wandas.processing.Coherence","title":"<code>Coherence</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Coherence estimation operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class Coherence(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Coherence estimation operation\"\"\"\n\n    name = \"coherence\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n    ):\n        \"\"\"\n        Initialize coherence estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Processor function for coherence estimation operation\"\"\"\n        logger.debug(f\"Applying coherence estimation to array with shape: {x.shape}\")\n        from scipy import signal as ss\n\n        _, coh = ss.coherence(\n            x=x[:, np.newaxis],\n            y=x[np.newaxis, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n        )\n\n        # Reshape result to (n_channels * n_channels, n_freqs)\n        result: NDArrayReal = coh.transpose(1, 0, 2).reshape(-1, coh.shape[-1])\n\n        logger.debug(f\"Coherence estimation applied, result shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/#wandas.processing.Coherence-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.Coherence.name","title":"<code>name = 'coherence'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Coherence.n_fft","title":"<code>n_fft = n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Coherence.win_length","title":"<code>win_length = win_length if win_length is not None else n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Coherence.hop_length","title":"<code>hop_length = hop_length if hop_length is not None else self.win_length // 4</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Coherence.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Coherence.detrend","title":"<code>detrend = detrend</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Coherence-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.Coherence.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend)</code>","text":"<p>Initialize coherence estimation operation</p>"},{"location":"api/#wandas.processing.Coherence.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n):\n    \"\"\"\n    Initialize coherence estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n    )\n</code></pre>"},{"location":"api/#wandas.processing.Coherence.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.Coherence.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"api/#wandas.processing.Coherence.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"api/#wandas.processing.NOctSpectrum","title":"<code>NOctSpectrum</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>N-octave spectrum operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class NOctSpectrum(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"N-octave spectrum operation\"\"\"\n\n    name = \"noct_spectrum\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ):\n        \"\"\"\n        Initialize N-octave spectrum\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        fmin : float\n            Minimum frequency (Hz)\n        fmax : float\n            Maximum frequency (Hz)\n        n : int, optional\n            Number of octave divisions, default is 3\n        G : int, optional\n            Reference level, default is 10\n        fr : int, optional\n            Reference frequency, default is 1000\n        \"\"\"\n        super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n        self.fmin = fmin\n        self.fmax = fmax\n        self.n = n\n        self.G = G\n        self.fr = fr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate output shape for octave spectrum\n        _, fpref = _center_freq(\n            fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n        )\n        return (input_shape[0], fpref.shape[0])\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for octave spectrum\"\"\"\n        logger.debug(f\"Applying NoctSpectrum to array with shape: {x.shape}\")\n        spec, _ = noct_spectrum(\n            sig=x.T,\n            fs=self.sampling_rate,\n            fmin=self.fmin,\n            fmax=self.fmax,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        if spec.ndim == 1:\n            # Add channel dimension for 1D\n            spec = np.expand_dims(spec, axis=0)\n        else:\n            spec = spec.T\n        logger.debug(f\"NoctSpectrum applied, returning result with shape: {spec.shape}\")\n        return np.array(spec)\n</code></pre>"},{"location":"api/#wandas.processing.NOctSpectrum-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.NOctSpectrum.name","title":"<code>name = 'noct_spectrum'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.NOctSpectrum.fmin","title":"<code>fmin = fmin</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.NOctSpectrum.fmax","title":"<code>fmax = fmax</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.NOctSpectrum.n","title":"<code>n = n</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.NOctSpectrum.G","title":"<code>G = G</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.NOctSpectrum.fr","title":"<code>fr = fr</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.NOctSpectrum-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.NOctSpectrum.__init__","title":"<code>__init__(sampling_rate, fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Initialize N-octave spectrum</p>"},{"location":"api/#wandas.processing.NOctSpectrum.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) fmin : float     Minimum frequency (Hz) fmax : float     Maximum frequency (Hz) n : int, optional     Number of octave divisions, default is 3 G : int, optional     Reference level, default is 10 fr : int, optional     Reference frequency, default is 1000</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n):\n    \"\"\"\n    Initialize N-octave spectrum\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    fmin : float\n        Minimum frequency (Hz)\n    fmax : float\n        Maximum frequency (Hz)\n    n : int, optional\n        Number of octave divisions, default is 3\n    G : int, optional\n        Reference level, default is 10\n    fr : int, optional\n        Reference frequency, default is 1000\n    \"\"\"\n    super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n    self.fmin = fmin\n    self.fmax = fmax\n    self.n = n\n    self.G = G\n    self.fr = fr\n</code></pre>"},{"location":"api/#wandas.processing.NOctSpectrum.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.NOctSpectrum.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/#wandas.processing.NOctSpectrum.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate output shape for octave spectrum\n    _, fpref = _center_freq(\n        fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n    )\n    return (input_shape[0], fpref.shape[0])\n</code></pre>"},{"location":"api/#wandas.processing.NOctSynthesis","title":"<code>NOctSynthesis</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Octave synthesis operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class NOctSynthesis(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Octave synthesis operation\"\"\"\n\n    name = \"noct_synthesis\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ):\n        \"\"\"\n        Initialize octave synthesis\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        fmin : float\n            Minimum frequency (Hz)\n        fmax : float\n            Maximum frequency (Hz)\n        n : int, optional\n            Number of octave divisions, default is 3\n        G : int, optional\n            Reference level, default is 10\n        fr : int, optional\n            Reference frequency, default is 1000\n        \"\"\"\n        super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n\n        self.fmin = fmin\n        self.fmax = fmax\n        self.n = n\n        self.G = G\n        self.fr = fr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate output shape for octave spectrum\n        _, fpref = _center_freq(\n            fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n        )\n        return (input_shape[0], fpref.shape[0])\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for octave synthesis\"\"\"\n        logger.debug(f\"Applying NoctSynthesis to array with shape: {x.shape}\")\n        # Calculate n from shape[-1]\n        n = x.shape[-1]  # Calculate n from shape[-1]\n        if n % 2 == 0:\n            n = n * 2 - 1\n        else:\n            n = (n - 1) * 2\n        freqs = np.fft.rfftfreq(n, d=1 / self.sampling_rate)\n        result, _ = noct_synthesis(\n            spectrum=np.abs(x).T,\n            freqs=freqs,\n            fmin=self.fmin,\n            fmax=self.fmax,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        result = result.T\n        logger.debug(\n            f\"NoctSynthesis applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"api/#wandas.processing.NOctSynthesis-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.NOctSynthesis.name","title":"<code>name = 'noct_synthesis'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.NOctSynthesis.fmin","title":"<code>fmin = fmin</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.NOctSynthesis.fmax","title":"<code>fmax = fmax</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.NOctSynthesis.n","title":"<code>n = n</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.NOctSynthesis.G","title":"<code>G = G</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.NOctSynthesis.fr","title":"<code>fr = fr</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.NOctSynthesis-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.NOctSynthesis.__init__","title":"<code>__init__(sampling_rate, fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Initialize octave synthesis</p>"},{"location":"api/#wandas.processing.NOctSynthesis.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) fmin : float     Minimum frequency (Hz) fmax : float     Maximum frequency (Hz) n : int, optional     Number of octave divisions, default is 3 G : int, optional     Reference level, default is 10 fr : int, optional     Reference frequency, default is 1000</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n):\n    \"\"\"\n    Initialize octave synthesis\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    fmin : float\n        Minimum frequency (Hz)\n    fmax : float\n        Maximum frequency (Hz)\n    n : int, optional\n        Number of octave divisions, default is 3\n    G : int, optional\n        Reference level, default is 10\n    fr : int, optional\n        Reference frequency, default is 1000\n    \"\"\"\n    super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n\n    self.fmin = fmin\n    self.fmax = fmax\n    self.n = n\n    self.G = G\n    self.fr = fr\n</code></pre>"},{"location":"api/#wandas.processing.NOctSynthesis.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.NOctSynthesis.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/#wandas.processing.NOctSynthesis.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate output shape for octave spectrum\n    _, fpref = _center_freq(\n        fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n    )\n    return (input_shape[0], fpref.shape[0])\n</code></pre>"},{"location":"api/#wandas.processing.TransferFunction","title":"<code>TransferFunction</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Transfer function estimation operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class TransferFunction(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Transfer function estimation operation\"\"\"\n\n    name = \"transfer_function\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ):\n        \"\"\"\n        Initialize transfer function estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        scaling : str\n            Type of scaling\n        average : str\n            Method of averaging\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        self.scaling = scaling\n        self.average = average\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n            scaling=scaling,\n            average=average,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Processor function for transfer function estimation operation\"\"\"\n        logger.debug(\n            f\"Applying transfer function estimation to array with shape: {x.shape}\"\n        )\n        from scipy import signal as ss\n\n        # Calculate cross-spectral density between all channels\n        f, p_yx = ss.csd(\n            x=x[:, np.newaxis, :],\n            y=x[np.newaxis, :, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n            axis=-1,\n        )\n        # p_yx shape: (num_channels, num_channels, num_frequencies)\n\n        # Calculate power spectral density for each channel\n        f, p_xx = ss.welch(\n            x=x,\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n            axis=-1,\n        )\n        # p_xx shape: (num_channels, num_frequencies)\n\n        # Calculate transfer function H(f) = P_yx / P_xx\n        h_f = p_yx / p_xx[np.newaxis, :, :]\n        result: NDArrayComplex = h_f.transpose(1, 0, 2).reshape(-1, h_f.shape[-1])\n\n        logger.debug(\n            f\"Transfer function estimation applied, result shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"api/#wandas.processing.TransferFunction-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.TransferFunction.name","title":"<code>name = 'transfer_function'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.TransferFunction.n_fft","title":"<code>n_fft = n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.TransferFunction.win_length","title":"<code>win_length = win_length if win_length is not None else n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.TransferFunction.hop_length","title":"<code>hop_length = hop_length if hop_length is not None else self.win_length // 4</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.TransferFunction.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.TransferFunction.detrend","title":"<code>detrend = detrend</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.TransferFunction.scaling","title":"<code>scaling = scaling</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.TransferFunction.average","title":"<code>average = average</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.TransferFunction-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.TransferFunction.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend, scaling='spectrum', average='mean')</code>","text":"<p>Initialize transfer function estimation operation</p>"},{"location":"api/#wandas.processing.TransferFunction.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend scaling : str     Type of scaling average : str     Method of averaging</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n):\n    \"\"\"\n    Initialize transfer function estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    scaling : str\n        Type of scaling\n    average : str\n        Method of averaging\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    self.scaling = scaling\n    self.average = average\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n        scaling=scaling,\n        average=average,\n    )\n</code></pre>"},{"location":"api/#wandas.processing.TransferFunction.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.TransferFunction.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"api/#wandas.processing.TransferFunction.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"api/#wandas.processing.Welch","title":"<code>Welch</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Welch</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class Welch(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Welch\"\"\"\n\n    name = \"welch\"\n    n_fft: int\n    window: str\n    hop_length: Optional[int]\n    win_length: Optional[int]\n    average: str\n    detrend: str\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        average: str = \"mean\",\n        detrend: str = \"constant\",\n    ):\n        \"\"\"\n        Initialize Welch operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int, optional\n            FFT size, default is 2048\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.noverlap = (\n            self.win_length - self.hop_length if hop_length is not None else None\n        )\n        self.window = window\n        self.average = average\n        self.detrend = detrend\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n            average=average,\n            detrend=detrend,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, freqs)\n        \"\"\"\n        n_freqs = self.n_fft // 2 + 1\n        return (*input_shape[:-1], n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for Welch operation\"\"\"\n        from scipy import signal as ss\n\n        _, result = ss.welch(\n            x,\n            nperseg=self.win_length,\n            noverlap=self.noverlap,\n            nfft=self.n_fft,\n            window=self.window,\n            average=self.average,\n            detrend=self.detrend,\n            scaling=\"spectrum\",\n        )\n\n        if not isinstance(x, np.ndarray):\n            # Trigger computation for Dask array\n            raise ValueError(\n                \"Welch operation requires a Dask array, but received a non-ndarray.\"\n            )\n        return np.array(result)\n</code></pre>"},{"location":"api/#wandas.processing.Welch-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.Welch.name","title":"<code>name = 'welch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Welch.n_fft","title":"<code>n_fft = n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Welch.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Welch.hop_length","title":"<code>hop_length = hop_length if hop_length is not None else self.win_length // 4</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Welch.win_length","title":"<code>win_length = win_length if win_length is not None else n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Welch.average","title":"<code>average = average</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Welch.detrend","title":"<code>detrend = detrend</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Welch.noverlap","title":"<code>noverlap = self.win_length - self.hop_length if hop_length is not None else None</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Welch-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.Welch.__init__","title":"<code>__init__(sampling_rate, n_fft=2048, hop_length=None, win_length=None, window='hann', average='mean', detrend='constant')</code>","text":"<p>Initialize Welch operation</p>"},{"location":"api/#wandas.processing.Welch.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int, optional     FFT size, default is 2048 window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    average: str = \"mean\",\n    detrend: str = \"constant\",\n):\n    \"\"\"\n    Initialize Welch operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int, optional\n        FFT size, default is 2048\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.noverlap = (\n        self.win_length - self.hop_length if hop_length is not None else None\n    )\n    self.window = window\n    self.average = average\n    self.detrend = detrend\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        win_length=self.win_length,\n        hop_length=self.hop_length,\n        window=window,\n        average=average,\n        detrend=detrend,\n    )\n</code></pre>"},{"location":"api/#wandas.processing.Welch.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.Welch.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"api/#wandas.processing.Welch.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, freqs)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, freqs)\n    \"\"\"\n    n_freqs = self.n_fft // 2 + 1\n    return (*input_shape[:-1], n_freqs)\n</code></pre>"},{"location":"api/#wandas.processing.ABS","title":"<code>ABS</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Absolute value operation</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>class ABS(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Absolute value operation\"\"\"\n\n    name = \"abs\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize absolute value operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        return da.abs(data)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"api/#wandas.processing.ABS-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.ABS.name","title":"<code>name = 'abs'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.ABS-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.ABS.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize absolute value operation</p>"},{"location":"api/#wandas.processing.ABS.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize absolute value operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"api/#wandas.processing.ABS.process","title":"<code>process(data)</code>","text":"Source code in <code>wandas/processing/stats.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n    return da.abs(data)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"api/#wandas.processing.ChannelDifference","title":"<code>ChannelDifference</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Channel difference calculation operation</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>class ChannelDifference(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Channel difference calculation operation\"\"\"\n\n    name = \"channel_difference\"\n    other_channel: int\n\n    def __init__(self, sampling_rate: float, other_channel: int = 0):\n        \"\"\"\n        Initialize channel difference calculation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        other_channel : int\n            Channel to calculate difference with, default is 0\n        \"\"\"\n        self.other_channel = other_channel\n        super().__init__(sampling_rate, other_channel=other_channel)\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        result = data - data[self.other_channel]\n        return result\n</code></pre>"},{"location":"api/#wandas.processing.ChannelDifference-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.ChannelDifference.name","title":"<code>name = 'channel_difference'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.ChannelDifference.other_channel","title":"<code>other_channel = other_channel</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.ChannelDifference-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.ChannelDifference.__init__","title":"<code>__init__(sampling_rate, other_channel=0)</code>","text":"<p>Initialize channel difference calculation</p>"},{"location":"api/#wandas.processing.ChannelDifference.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) other_channel : int     Channel to calculate difference with, default is 0</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>def __init__(self, sampling_rate: float, other_channel: int = 0):\n    \"\"\"\n    Initialize channel difference calculation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    other_channel : int\n        Channel to calculate difference with, default is 0\n    \"\"\"\n    self.other_channel = other_channel\n    super().__init__(sampling_rate, other_channel=other_channel)\n</code></pre>"},{"location":"api/#wandas.processing.ChannelDifference.process","title":"<code>process(data)</code>","text":"Source code in <code>wandas/processing/stats.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n    result = data - data[self.other_channel]\n    return result\n</code></pre>"},{"location":"api/#wandas.processing.Mean","title":"<code>Mean</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Mean calculation</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>class Mean(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Mean calculation\"\"\"\n\n    name = \"mean\"\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # Use Dask's aggregate function directly without map_blocks\n        return data.mean(axis=0, keepdims=True)\n</code></pre>"},{"location":"api/#wandas.processing.Mean-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.Mean.name","title":"<code>name = 'mean'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Mean-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.Mean.process","title":"<code>process(data)</code>","text":"Source code in <code>wandas/processing/stats.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    # Use Dask's aggregate function directly without map_blocks\n    return data.mean(axis=0, keepdims=True)\n</code></pre>"},{"location":"api/#wandas.processing.Power","title":"<code>Power</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Power operation</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>class Power(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Power operation\"\"\"\n\n    name = \"power\"\n\n    def __init__(self, sampling_rate: float, exponent: float):\n        \"\"\"\n        Initialize power operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        exponent : float\n            Power exponent\n        \"\"\"\n        super().__init__(sampling_rate)\n        self.exp = exponent\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        return da.power(data, self.exp)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"api/#wandas.processing.Power-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.Power.name","title":"<code>name = 'power'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Power.exp","title":"<code>exp = exponent</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Power-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.Power.__init__","title":"<code>__init__(sampling_rate, exponent)</code>","text":"<p>Initialize power operation</p>"},{"location":"api/#wandas.processing.Power.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) exponent : float     Power exponent</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>def __init__(self, sampling_rate: float, exponent: float):\n    \"\"\"\n    Initialize power operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    exponent : float\n        Power exponent\n    \"\"\"\n    super().__init__(sampling_rate)\n    self.exp = exponent\n</code></pre>"},{"location":"api/#wandas.processing.Power.process","title":"<code>process(data)</code>","text":"Source code in <code>wandas/processing/stats.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n    return da.power(data, self.exp)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"api/#wandas.processing.Sum","title":"<code>Sum</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Sum calculation</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>class Sum(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Sum calculation\"\"\"\n\n    name = \"sum\"\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # Use Dask's aggregate function directly without map_blocks\n        return data.sum(axis=0, keepdims=True)\n</code></pre>"},{"location":"api/#wandas.processing.Sum-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.Sum.name","title":"<code>name = 'sum'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Sum-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.Sum.process","title":"<code>process(data)</code>","text":"Source code in <code>wandas/processing/stats.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    # Use Dask's aggregate function directly without map_blocks\n    return data.sum(axis=0, keepdims=True)\n</code></pre>"},{"location":"api/#wandas.processing.ReSampling","title":"<code>ReSampling</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Resampling operation</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>class ReSampling(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Resampling operation\"\"\"\n\n    name = \"resampling\"\n\n    def __init__(self, sampling_rate: float, target_sr: float):\n        \"\"\"\n        Initialize resampling operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        target_sampling_rate : float\n            Target sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate, target_sr=target_sr)\n        self.target_sr = target_sr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after resampling\n        ratio = float(self.target_sr) / float(self.sampling_rate)\n        n_samples = int(np.ceil(input_shape[-1] * ratio))\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for resampling operation\"\"\"\n        logger.debug(f\"Applying resampling to array with shape: {x.shape}\")\n        result: NDArrayReal = librosa.resample(\n            x, orig_sr=self.sampling_rate, target_sr=self.target_sr\n        )\n        logger.debug(f\"Resampling applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/#wandas.processing.ReSampling-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.ReSampling.name","title":"<code>name = 'resampling'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.ReSampling.target_sr","title":"<code>target_sr = target_sr</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.ReSampling-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.ReSampling.__init__","title":"<code>__init__(sampling_rate, target_sr)</code>","text":"<p>Initialize resampling operation</p>"},{"location":"api/#wandas.processing.ReSampling.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) target_sampling_rate : float     Target sampling rate (Hz)</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def __init__(self, sampling_rate: float, target_sr: float):\n    \"\"\"\n    Initialize resampling operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    target_sampling_rate : float\n        Target sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate, target_sr=target_sr)\n    self.target_sr = target_sr\n</code></pre>"},{"location":"api/#wandas.processing.ReSampling.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.ReSampling.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/#wandas.processing.ReSampling.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after resampling\n    ratio = float(self.target_sr) / float(self.sampling_rate)\n    n_samples = int(np.ceil(input_shape[-1] * ratio))\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"api/#wandas.processing.RmsTrend","title":"<code>RmsTrend</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>RMS calculation</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>class RmsTrend(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"RMS calculation\"\"\"\n\n    name = \"rms_trend\"\n    frame_length: int\n    hop_length: int\n    Aw: bool\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        ref: Union[list[float], float] = 1.0,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; None:\n        \"\"\"\n        Initialize RMS calculation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        frame_length : int\n            Frame length, default is 2048\n        hop_length : int\n            Hop length, default is 512\n        ref : Union[list[float], float]\n            Reference value(s) for dB calculation\n        dB : bool\n            Whether to convert to decibels\n        Aw : bool\n            Whether to apply A-weighting before RMS calculation\n        \"\"\"\n        self.frame_length = frame_length\n        self.hop_length = hop_length\n        self.dB = dB\n        self.Aw = Aw\n        self.ref = np.array(ref if isinstance(ref, list) else [ref])\n        super().__init__(\n            sampling_rate,\n            frame_length=frame_length,\n            hop_length=hop_length,\n            dB=dB,\n            Aw=Aw,\n            ref=self.ref,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, frames)\n        \"\"\"\n        n_frames = librosa.feature.rms(\n            y=np.ones((1, input_shape[-1])),\n            frame_length=self.frame_length,\n            hop_length=self.hop_length,\n        ).shape[-1]\n        return (*input_shape[:-1], n_frames)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for RMS calculation\"\"\"\n        logger.debug(f\"Applying RMS to array with shape: {x.shape}\")\n\n        if self.Aw:\n            # Apply A-weighting\n            _x = A_weight(x, self.sampling_rate)\n            if isinstance(_x, np.ndarray):\n                # A_weight\u304c\u30bf\u30d7\u30eb\u3092\u8fd4\u3059\u5834\u5408\u3001\u6700\u521d\u306e\u8981\u7d20\u3092\u4f7f\u7528\n                x = _x\n            elif isinstance(_x, tuple):\n                # Use the first element if A_weight returns a tuple\n                x = _x[0]\n            else:\n                raise ValueError(\"A_weighting returned an unexpected type.\")\n\n        # Calculate RMS\n        result: NDArrayReal = librosa.feature.rms(\n            y=x, frame_length=self.frame_length, hop_length=self.hop_length\n        )[..., 0, :]\n\n        if self.dB:\n            # Convert to dB\n            result = 20 * np.log10(\n                np.maximum(result / self.ref[..., np.newaxis], 1e-12)\n            )\n        #\n        logger.debug(f\"RMS applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/#wandas.processing.RmsTrend-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.RmsTrend.name","title":"<code>name = 'rms_trend'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.RmsTrend.frame_length","title":"<code>frame_length = frame_length</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.RmsTrend.hop_length","title":"<code>hop_length = hop_length</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.RmsTrend.Aw","title":"<code>Aw = Aw</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.RmsTrend.dB","title":"<code>dB = dB</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.RmsTrend.ref","title":"<code>ref = np.array(ref if isinstance(ref, list) else [ref])</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.RmsTrend-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.RmsTrend.__init__","title":"<code>__init__(sampling_rate, frame_length=2048, hop_length=512, ref=1.0, dB=False, Aw=False)</code>","text":"<p>Initialize RMS calculation</p>"},{"location":"api/#wandas.processing.RmsTrend.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) frame_length : int     Frame length, default is 2048 hop_length : int     Hop length, default is 512 ref : Union[list[float], float]     Reference value(s) for dB calculation dB : bool     Whether to convert to decibels Aw : bool     Whether to apply A-weighting before RMS calculation</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    ref: Union[list[float], float] = 1.0,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; None:\n    \"\"\"\n    Initialize RMS calculation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    frame_length : int\n        Frame length, default is 2048\n    hop_length : int\n        Hop length, default is 512\n    ref : Union[list[float], float]\n        Reference value(s) for dB calculation\n    dB : bool\n        Whether to convert to decibels\n    Aw : bool\n        Whether to apply A-weighting before RMS calculation\n    \"\"\"\n    self.frame_length = frame_length\n    self.hop_length = hop_length\n    self.dB = dB\n    self.Aw = Aw\n    self.ref = np.array(ref if isinstance(ref, list) else [ref])\n    super().__init__(\n        sampling_rate,\n        frame_length=frame_length,\n        hop_length=hop_length,\n        dB=dB,\n        Aw=Aw,\n        ref=self.ref,\n    )\n</code></pre>"},{"location":"api/#wandas.processing.RmsTrend.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.RmsTrend.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"api/#wandas.processing.RmsTrend.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, frames)</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, frames)\n    \"\"\"\n    n_frames = librosa.feature.rms(\n        y=np.ones((1, input_shape[-1])),\n        frame_length=self.frame_length,\n        hop_length=self.hop_length,\n    ).shape[-1]\n    return (*input_shape[:-1], n_frames)\n</code></pre>"},{"location":"api/#wandas.processing.Trim","title":"<code>Trim</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Trimming operation</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>class Trim(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Trimming operation\"\"\"\n\n    name = \"trim\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        start: float,\n        end: float,\n    ):\n        \"\"\"\n        Initialize trimming operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        start : float\n            Start time for trimming (seconds)\n        end : float\n            End time for trimming (seconds)\n        \"\"\"\n        super().__init__(sampling_rate, start=start, end=end)\n        self.start = start\n        self.end = end\n        self.start_sample = int(start * sampling_rate)\n        self.end_sample = int(end * sampling_rate)\n        logger.debug(\n            f\"Initialized Trim operation with start: {self.start}, end: {self.end}\"\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after trimming\n        # Exclude parts where there is no signal\n        end_sample = min(self.end_sample, input_shape[-1])\n        n_samples = end_sample - self.start_sample\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for trimming operation\"\"\"\n        logger.debug(f\"Applying trim to array with shape: {x.shape}\")\n        # Apply trimming\n        result = x[..., self.start_sample : self.end_sample]\n        logger.debug(f\"Trim applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/#wandas.processing.Trim-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.Trim.name","title":"<code>name = 'trim'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Trim.start","title":"<code>start = start</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Trim.end","title":"<code>end = end</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Trim.start_sample","title":"<code>start_sample = int(start * sampling_rate)</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Trim.end_sample","title":"<code>end_sample = int(end * sampling_rate)</code>  <code>instance-attribute</code>","text":""},{"location":"api/#wandas.processing.Trim-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.Trim.__init__","title":"<code>__init__(sampling_rate, start, end)</code>","text":"<p>Initialize trimming operation</p>"},{"location":"api/#wandas.processing.Trim.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) start : float     Start time for trimming (seconds) end : float     End time for trimming (seconds)</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    start: float,\n    end: float,\n):\n    \"\"\"\n    Initialize trimming operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    start : float\n        Start time for trimming (seconds)\n    end : float\n        End time for trimming (seconds)\n    \"\"\"\n    super().__init__(sampling_rate, start=start, end=end)\n    self.start = start\n    self.end = end\n    self.start_sample = int(start * sampling_rate)\n    self.end_sample = int(end * sampling_rate)\n    logger.debug(\n        f\"Initialized Trim operation with start: {self.start}, end: {self.end}\"\n    )\n</code></pre>"},{"location":"api/#wandas.processing.Trim.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.Trim.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/#wandas.processing.Trim.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after trimming\n    # Exclude parts where there is no signal\n    end_sample = min(self.end_sample, input_shape[-1])\n    n_samples = end_sample - self.start_sample\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"api/#wandas.processing-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.create_operation","title":"<code>create_operation(name, sampling_rate, **params)</code>","text":"<p>Create operation instance from name and parameters</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def create_operation(\n    name: str, sampling_rate: float, **params: Any\n) -&gt; AudioOperation[Any, Any]:\n    \"\"\"Create operation instance from name and parameters\"\"\"\n    operation_class = get_operation(name)\n    return operation_class(sampling_rate, **params)\n</code></pre>"},{"location":"api/#wandas.processing.get_operation","title":"<code>get_operation(name)</code>","text":"<p>Get operation class by name</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def get_operation(name: str) -&gt; type[AudioOperation[Any, Any]]:\n    \"\"\"Get operation class by name\"\"\"\n    if name not in _OPERATION_REGISTRY:\n        raise ValueError(f\"Unknown operation type: {name}\")\n    return _OPERATION_REGISTRY[name]\n</code></pre>"},{"location":"api/#wandas.processing.register_operation","title":"<code>register_operation(operation_class)</code>","text":"<p>Register a new operation type</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def register_operation(operation_class: type) -&gt; None:\n    \"\"\"Register a new operation type\"\"\"\n\n    if not issubclass(operation_class, AudioOperation):\n        raise TypeError(\"Strategy class must inherit from AudioOperation.\")\n    if inspect.isabstract(operation_class):\n        raise TypeError(\"Cannot register abstract AudioOperation class.\")\n\n    _OPERATION_REGISTRY[operation_class.name] = operation_class\n</code></pre>"},{"location":"api/#wandas.processing-modules","title":"Modules","text":""},{"location":"api/#wandas.processing.base","title":"<code>base</code>","text":""},{"location":"api/#wandas.processing.base-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.base.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.processing.base.InputArrayType","title":"<code>InputArrayType = TypeVar('InputArrayType', NDArrayReal, NDArrayComplex)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.processing.base.OutputArrayType","title":"<code>OutputArrayType = TypeVar('OutputArrayType', NDArrayReal, NDArrayComplex)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.processing.base-classes","title":"Classes","text":""},{"location":"api/#wandas.processing.base.AudioOperation","title":"<code>AudioOperation</code>","text":"<p>               Bases: <code>Generic[InputArrayType, OutputArrayType]</code></p> <p>Abstract base class for audio processing operations.</p> Source code in <code>wandas/processing/base.py</code> <pre><code>class AudioOperation(Generic[InputArrayType, OutputArrayType]):\n    \"\"\"Abstract base class for audio processing operations.\"\"\"\n\n    # Class variable: operation name\n    name: ClassVar[str]\n\n    def __init__(self, sampling_rate: float, **params: Any):\n        \"\"\"\n        Initialize AudioOperation.\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        **params : Any\n            Operation-specific parameters\n        \"\"\"\n        self.sampling_rate = sampling_rate\n        self.params = params\n\n        # Validate parameters during initialization\n        self.validate_params()\n\n        # Create processor function (lazy initialization possible)\n        self._setup_processor()\n\n        logger.debug(\n            f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n        )\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n        pass\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up processor function (implemented by subclasses)\"\"\"\n        pass\n\n    def _process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function (implemented by subclasses)\"\"\"\n        # Default is no-op function\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    @dask.delayed  # type: ignore [misc, unused-ignore]\n    def process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n        # Default is no-op function\n        logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n        return self._process_array(x)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation (implemented by subclasses)\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        \"\"\"\n        Execute operation and return result\n        data shape is (channels, samples)\n        \"\"\"\n        # Add task as delayed processing\n        logger.debug(\"Adding delayed operation to computation graph\")\n        delayed_result = self.process_array(data)\n        # Convert delayed result to dask array and return\n        output_shape = self.calculate_output_shape(data.shape)\n        return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre> Attributes\u00b6 <code></code> <code>name</code> <code>class-attribute</code> \u00b6 <code></code> <code>sampling_rate = sampling_rate</code> <code>instance-attribute</code> \u00b6 <code></code> <code>params = params</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, **params)</code> \u00b6 <p>Initialize AudioOperation.</p> <code></code> <code>validate_params()</code> \u00b6 <p>Validate parameters (raises exception if invalid)</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n    pass\n</code></pre> <code></code> <code>process_array(x)</code> \u00b6 <p>Processing function wrapped with @dask.delayed</p> Source code in <code>wandas/processing/base.py</code> <pre><code>@dask.delayed  # type: ignore [misc, unused-ignore]\ndef process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n    \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n    # Default is no-op function\n    logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n    return self._process_array(x)\n</code></pre> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 <p>Calculate output data shape after operation (implemented by subclasses)</p> <code></code> <code>process(data)</code> \u00b6 <p>Execute operation and return result data shape is (channels, samples)</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    \"\"\"\n    Execute operation and return result\n    data shape is (channels, samples)\n    \"\"\"\n    # Add task as delayed processing\n    logger.debug(\"Adding delayed operation to computation graph\")\n    delayed_result = self.process_array(data)\n    # Convert delayed result to dask array and return\n    output_shape = self.calculate_output_shape(data.shape)\n    return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"api/#wandas.processing.base.AudioOperation.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) **params : Any     Operation-specific parameters</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def __init__(self, sampling_rate: float, **params: Any):\n    \"\"\"\n    Initialize AudioOperation.\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    **params : Any\n        Operation-specific parameters\n    \"\"\"\n    self.sampling_rate = sampling_rate\n    self.params = params\n\n    # Validate parameters during initialization\n    self.validate_params()\n\n    # Create processor function (lazy initialization possible)\n    self._setup_processor()\n\n    logger.debug(\n        f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n    )\n</code></pre>"},{"location":"api/#wandas.processing.base.AudioOperation.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/#wandas.processing.base.AudioOperation.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation (implemented by subclasses)\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"api/#wandas.processing.base-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.base.register_operation","title":"<code>register_operation(operation_class)</code>","text":"<p>Register a new operation type</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def register_operation(operation_class: type) -&gt; None:\n    \"\"\"Register a new operation type\"\"\"\n\n    if not issubclass(operation_class, AudioOperation):\n        raise TypeError(\"Strategy class must inherit from AudioOperation.\")\n    if inspect.isabstract(operation_class):\n        raise TypeError(\"Cannot register abstract AudioOperation class.\")\n\n    _OPERATION_REGISTRY[operation_class.name] = operation_class\n</code></pre>"},{"location":"api/#wandas.processing.base.get_operation","title":"<code>get_operation(name)</code>","text":"<p>Get operation class by name</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def get_operation(name: str) -&gt; type[AudioOperation[Any, Any]]:\n    \"\"\"Get operation class by name\"\"\"\n    if name not in _OPERATION_REGISTRY:\n        raise ValueError(f\"Unknown operation type: {name}\")\n    return _OPERATION_REGISTRY[name]\n</code></pre>"},{"location":"api/#wandas.processing.base.create_operation","title":"<code>create_operation(name, sampling_rate, **params)</code>","text":"<p>Create operation instance from name and parameters</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def create_operation(\n    name: str, sampling_rate: float, **params: Any\n) -&gt; AudioOperation[Any, Any]:\n    \"\"\"Create operation instance from name and parameters\"\"\"\n    operation_class = get_operation(name)\n    return operation_class(sampling_rate, **params)\n</code></pre>"},{"location":"api/#wandas.processing.effects","title":"<code>effects</code>","text":""},{"location":"api/#wandas.processing.effects-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.effects.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.processing.effects-classes","title":"Classes","text":""},{"location":"api/#wandas.processing.effects.HpssHarmonic","title":"<code>HpssHarmonic</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>HPSS Harmonic operation</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>class HpssHarmonic(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"HPSS Harmonic operation\"\"\"\n\n    name = \"hpss_harmonic\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize HPSS Harmonic\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        self.kwargs = kwargs\n        super().__init__(sampling_rate, **kwargs)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for HPSS Harmonic\"\"\"\n        logger.debug(f\"Applying HPSS Harmonic to array with shape: {x.shape}\")\n        result: NDArrayReal = effects.harmonic(x, **self.kwargs)\n        logger.debug(\n            f\"HPSS Harmonic applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'hpss_harmonic'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>kwargs = kwargs</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, **kwargs)</code> \u00b6 <p>Initialize HPSS Harmonic</p> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 Source code in <code>wandas/processing/effects.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    return input_shape\n</code></pre>"},{"location":"api/#wandas.processing.effects.HpssHarmonic.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize HPSS Harmonic\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    self.kwargs = kwargs\n    super().__init__(sampling_rate, **kwargs)\n</code></pre>"},{"location":"api/#wandas.processing.effects.HpssPercussive","title":"<code>HpssPercussive</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>HPSS Percussive operation</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>class HpssPercussive(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"HPSS Percussive operation\"\"\"\n\n    name = \"hpss_percussive\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize HPSS Percussive\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        self.kwargs = kwargs\n        super().__init__(sampling_rate, **kwargs)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for HPSS Percussive\"\"\"\n        logger.debug(f\"Applying HPSS Percussive to array with shape: {x.shape}\")\n        result: NDArrayReal = effects.percussive(x, **self.kwargs)\n        logger.debug(\n            f\"HPSS Percussive applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'hpss_percussive'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>kwargs = kwargs</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, **kwargs)</code> \u00b6 <p>Initialize HPSS Percussive</p> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 Source code in <code>wandas/processing/effects.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    return input_shape\n</code></pre>"},{"location":"api/#wandas.processing.effects.HpssPercussive.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize HPSS Percussive\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    self.kwargs = kwargs\n    super().__init__(sampling_rate, **kwargs)\n</code></pre>"},{"location":"api/#wandas.processing.effects.AddWithSNR","title":"<code>AddWithSNR</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Addition operation considering SNR</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>class AddWithSNR(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Addition operation considering SNR\"\"\"\n\n    name = \"add_with_snr\"\n\n    def __init__(self, sampling_rate: float, other: DaArray, snr: float = 1.0):\n        \"\"\"\n        Initialize addition operation considering SNR\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        other : DaArray\n            Noise signal to add (channel-frame format)\n        snr : float\n            Signal-to-noise ratio (dB)\n        \"\"\"\n        super().__init__(sampling_rate, other=other, snr=snr)\n\n        self.other = other\n        self.snr = snr\n        logger.debug(f\"Initialized AddWithSNR operation with SNR: {snr} dB\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape (same as input)\n        \"\"\"\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Perform addition processing considering SNR\"\"\"\n        logger.debug(f\"Applying SNR-based addition with shape: {x.shape}\")\n        other: NDArrayReal = self.other.compute()\n\n        # Use multi-channel versions of calculate_rms and calculate_desired_noise_rms\n        clean_rms = util.calculate_rms(x)\n        other_rms = util.calculate_rms(other)\n\n        # Adjust noise gain based on specified SNR (apply per channel)\n        desired_noise_rms = util.calculate_desired_noise_rms(clean_rms, self.snr)\n\n        # Apply gain per channel using broadcasting\n        gain = desired_noise_rms / other_rms\n        # Add adjusted noise to signal\n        result: NDArrayReal = x + other * gain\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'add_with_snr'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>other = other</code> <code>instance-attribute</code> \u00b6 <code></code> <code>snr = snr</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, other, snr=1.0)</code> \u00b6 <p>Initialize addition operation considering SNR</p> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 <p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.effects.AddWithSNR.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) other : DaArray     Noise signal to add (channel-frame format) snr : float     Signal-to-noise ratio (dB)</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>def __init__(self, sampling_rate: float, other: DaArray, snr: float = 1.0):\n    \"\"\"\n    Initialize addition operation considering SNR\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    other : DaArray\n        Noise signal to add (channel-frame format)\n    snr : float\n        Signal-to-noise ratio (dB)\n    \"\"\"\n    super().__init__(sampling_rate, other=other, snr=snr)\n\n    self.other = other\n    self.snr = snr\n    logger.debug(f\"Initialized AddWithSNR operation with SNR: {snr} dB\")\n</code></pre>"},{"location":"api/#wandas.processing.effects.AddWithSNR.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/#wandas.processing.effects.AddWithSNR.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (same as input)</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape (same as input)\n    \"\"\"\n    return input_shape\n</code></pre>"},{"location":"api/#wandas.processing.effects-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.effects-modules","title":"Modules","text":""},{"location":"api/#wandas.processing.filters","title":"<code>filters</code>","text":""},{"location":"api/#wandas.processing.filters-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.filters.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.processing.filters-classes","title":"Classes","text":""},{"location":"api/#wandas.processing.filters.HighPassFilter","title":"<code>HighPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>High-pass filter operation</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>class HighPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"High-pass filter operation\"\"\"\n\n    name = \"highpass_filter\"\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize high-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            limit = self.sampling_rate / 2\n            raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up high-pass filter processor\"\"\"\n        # Calculate filter coefficients (once) - safely retrieve from instance variables\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # Precompute and save filter coefficients\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"high\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Highpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying highpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'highpass_filter'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>cutoff = cutoff</code> <code>instance-attribute</code> \u00b6 <code></code> <code>order = order</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, cutoff, order=4)</code> \u00b6 <p>Initialize high-pass filter</p> <code></code> <code>validate_params()</code> \u00b6 <p>Validate parameters</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        limit = self.sampling_rate / 2\n        raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n</code></pre> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 Source code in <code>wandas/processing/filters.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    return input_shape\n</code></pre>"},{"location":"api/#wandas.processing.filters.HighPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize high-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"api/#wandas.processing.filters.LowPassFilter","title":"<code>LowPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Low-pass filter operation</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>class LowPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Low-pass filter operation\"\"\"\n\n    name = \"lowpass_filter\"\n    a: NDArrayReal\n    b: NDArrayReal\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize low-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            raise ValueError(\n                f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n            )\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up low-pass filter processor\"\"\"\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # Precompute and save filter coefficients\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"low\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Lowpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying lowpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'lowpass_filter'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>a</code> <code>instance-attribute</code> \u00b6 <code></code> <code>b</code> <code>instance-attribute</code> \u00b6 <code></code> <code>cutoff = cutoff</code> <code>instance-attribute</code> \u00b6 <code></code> <code>order = order</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, cutoff, order=4)</code> \u00b6 <p>Initialize low-pass filter</p> <code></code> <code>validate_params()</code> \u00b6 <p>Validate parameters</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        raise ValueError(\n            f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n        )\n</code></pre> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 Source code in <code>wandas/processing/filters.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    return input_shape\n</code></pre>"},{"location":"api/#wandas.processing.filters.LowPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize low-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"api/#wandas.processing.filters.BandPassFilter","title":"<code>BandPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Band-pass filter operation</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>class BandPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Band-pass filter operation\"\"\"\n\n    name = \"bandpass_filter\"\n    a: NDArrayReal\n    b: NDArrayReal\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        low_cutoff: float,\n        high_cutoff: float,\n        order: int = 4,\n    ):\n        \"\"\"\n        Initialize band-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        low_cutoff : float\n            Lower cutoff frequency (Hz)\n        high_cutoff : float\n            Higher cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.low_cutoff = low_cutoff\n        self.high_cutoff = high_cutoff\n        self.order = order\n        super().__init__(\n            sampling_rate, low_cutoff=low_cutoff, high_cutoff=high_cutoff, order=order\n        )\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        nyquist = self.sampling_rate / 2\n        if self.low_cutoff &lt;= 0 or self.low_cutoff &gt;= nyquist:\n            raise ValueError(\n                f\"Lower cutoff frequency must be between 0 Hz and {nyquist} Hz\"\n            )\n        if self.high_cutoff &lt;= 0 or self.high_cutoff &gt;= nyquist:\n            raise ValueError(\n                f\"Higher cutoff frequency must be between 0 Hz and {nyquist} Hz\"\n            )\n        if self.low_cutoff &gt;= self.high_cutoff:\n            raise ValueError(\n                f\"Lower cutoff frequency ({self.low_cutoff} Hz) must be less than \"\n                f\"higher cutoff frequency ({self.high_cutoff} Hz)\"\n            )\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up band-pass filter processor\"\"\"\n        nyquist = 0.5 * self.sampling_rate\n        low_normal_cutoff = self.low_cutoff / nyquist\n        high_normal_cutoff = self.high_cutoff / nyquist\n\n        # Precompute and save filter coefficients\n        self.b, self.a = signal.butter(\n            self.order, [low_normal_cutoff, high_normal_cutoff], btype=\"band\"\n        )  # type: ignore [unused-ignore]\n        logger.debug(f\"Bandpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying bandpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'bandpass_filter'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>a</code> <code>instance-attribute</code> \u00b6 <code></code> <code>b</code> <code>instance-attribute</code> \u00b6 <code></code> <code>low_cutoff = low_cutoff</code> <code>instance-attribute</code> \u00b6 <code></code> <code>high_cutoff = high_cutoff</code> <code>instance-attribute</code> \u00b6 <code></code> <code>order = order</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, low_cutoff, high_cutoff, order=4)</code> \u00b6 <p>Initialize band-pass filter</p> <code></code> <code>validate_params()</code> \u00b6 <p>Validate parameters</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    nyquist = self.sampling_rate / 2\n    if self.low_cutoff &lt;= 0 or self.low_cutoff &gt;= nyquist:\n        raise ValueError(\n            f\"Lower cutoff frequency must be between 0 Hz and {nyquist} Hz\"\n        )\n    if self.high_cutoff &lt;= 0 or self.high_cutoff &gt;= nyquist:\n        raise ValueError(\n            f\"Higher cutoff frequency must be between 0 Hz and {nyquist} Hz\"\n        )\n    if self.low_cutoff &gt;= self.high_cutoff:\n        raise ValueError(\n            f\"Lower cutoff frequency ({self.low_cutoff} Hz) must be less than \"\n            f\"higher cutoff frequency ({self.high_cutoff} Hz)\"\n        )\n</code></pre> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 Source code in <code>wandas/processing/filters.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    return input_shape\n</code></pre>"},{"location":"api/#wandas.processing.filters.BandPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) low_cutoff : float     Lower cutoff frequency (Hz) high_cutoff : float     Higher cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    low_cutoff: float,\n    high_cutoff: float,\n    order: int = 4,\n):\n    \"\"\"\n    Initialize band-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    low_cutoff : float\n        Lower cutoff frequency (Hz)\n    high_cutoff : float\n        Higher cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.low_cutoff = low_cutoff\n    self.high_cutoff = high_cutoff\n    self.order = order\n    super().__init__(\n        sampling_rate, low_cutoff=low_cutoff, high_cutoff=high_cutoff, order=order\n    )\n</code></pre>"},{"location":"api/#wandas.processing.filters.AWeighting","title":"<code>AWeighting</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>A-weighting filter operation</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>class AWeighting(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"A-weighting filter operation\"\"\"\n\n    name = \"a_weighting\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize A-weighting filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for A-weighting filter\"\"\"\n        logger.debug(f\"Applying A-weighting to array with shape: {x.shape}\")\n        result = A_weight(x, self.sampling_rate)\n\n        # Handle case where A_weight returns a tuple\n        if isinstance(result, tuple):\n            # Use the first element of the tuple\n            result = result[0]\n\n        logger.debug(\n            f\"A-weighting applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'a_weighting'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate)</code> \u00b6 <p>Initialize A-weighting filter</p> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 Source code in <code>wandas/processing/filters.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    return input_shape\n</code></pre>"},{"location":"api/#wandas.processing.filters.AWeighting.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize A-weighting filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"api/#wandas.processing.filters-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.spectral","title":"<code>spectral</code>","text":""},{"location":"api/#wandas.processing.spectral-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.spectral.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.processing.spectral-classes","title":"Classes","text":""},{"location":"api/#wandas.processing.spectral.FFT","title":"<code>FFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>FFT (Fast Fourier Transform) operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class FFT(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"FFT (Fast Fourier Transform) operation\"\"\"\n\n    name = \"fft\"\n    n_fft: Optional[int]\n    window: str\n\n    def __init__(\n        self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n    ):\n        \"\"\"\n        Initialize FFT operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int, optional\n            FFT size, default is None (determined by input size)\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(sampling_rate, n_fft=n_fft, window=window)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        \u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059\n\n        Parameters\n        ----------\n        input_shape : tuple\n            \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)\n\n        Returns\n        -------\n        tuple\n            \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)\n        \"\"\"\n        n_freqs = self.n_fft // 2 + 1 if self.n_fft else input_shape[-1] // 2 + 1\n        return (*input_shape[:-1], n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"FFT\u64cd\u4f5c\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u95a2\u6570\u3092\u4f5c\u6210\"\"\"\n        from scipy.signal import get_window\n\n        win = get_window(self.window, x.shape[-1])\n        x = x * win\n        result: NDArrayComplex = np.fft.rfft(x, n=self.n_fft, axis=-1)\n        result[..., 1:-1] *= 2.0\n        # \u7a93\u95a2\u6570\u88dc\u6b63\n        scaling_factor = np.sum(win)\n        result = result / scaling_factor\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'fft'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>n_fft = n_fft</code> <code>instance-attribute</code> \u00b6 <code></code> <code>window = window</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, n_fft=None, window='hann')</code> \u00b6 <p>Initialize FFT operation</p> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 <p>\u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059</p>"},{"location":"api/#wandas.processing.spectral.FFT.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int, optional     FFT size, default is None (determined by input size) window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n):\n    \"\"\"\n    Initialize FFT operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int, optional\n        FFT size, default is None (determined by input size)\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(sampling_rate, n_fft=n_fft, window=window)\n</code></pre>"},{"location":"api/#wandas.processing.spectral.FFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)</p>"},{"location":"api/#wandas.processing.spectral.FFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    \u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059\n\n    Parameters\n    ----------\n    input_shape : tuple\n        \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)\n\n    Returns\n    -------\n    tuple\n        \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)\n    \"\"\"\n    n_freqs = self.n_fft // 2 + 1 if self.n_fft else input_shape[-1] // 2 + 1\n    return (*input_shape[:-1], n_freqs)\n</code></pre>"},{"location":"api/#wandas.processing.spectral.IFFT","title":"<code>IFFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayComplex, NDArrayReal]</code></p> <p>IFFT (Inverse Fast Fourier Transform) operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class IFFT(AudioOperation[NDArrayComplex, NDArrayReal]):\n    \"\"\"IFFT (Inverse Fast Fourier Transform) operation\"\"\"\n\n    name = \"ifft\"\n    n_fft: Optional[int]\n    window: str\n\n    def __init__(\n        self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n    ):\n        \"\"\"\n        Initialize IFFT operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : Optional[int], optional\n            IFFT size, default is None (determined based on input size)\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(sampling_rate, n_fft=n_fft, window=window)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, freqs)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, samples)\n        \"\"\"\n        n_samples = 2 * (input_shape[-1] - 1) if self.n_fft is None else self.n_fft\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayComplex) -&gt; NDArrayReal:\n        \"\"\"Create processor function for IFFT operation\"\"\"\n        logger.debug(f\"Applying IFFT to array with shape: {x.shape}\")\n\n        # Restore frequency component scaling (remove the 2.0 multiplier applied in FFT)\n        _x = x.copy()\n        _x[..., 1:-1] /= 2.0\n\n        # Execute IFFT\n        result: NDArrayReal = np.fft.irfft(_x, n=self.n_fft, axis=-1)\n\n        # Window function correction (inverse of FFT operation)\n        from scipy.signal import get_window\n\n        win = get_window(self.window, result.shape[-1])\n\n        # Correct the FFT window function scaling\n        scaling_factor = np.sum(win) / result.shape[-1]\n        result = result / scaling_factor\n\n        logger.debug(f\"IFFT applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'ifft'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>n_fft = n_fft</code> <code>instance-attribute</code> \u00b6 <code></code> <code>window = window</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, n_fft=None, window='hann')</code> \u00b6 <p>Initialize IFFT operation</p> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 <p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.spectral.IFFT.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : Optional[int], optional     IFFT size, default is None (determined based on input size) window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n):\n    \"\"\"\n    Initialize IFFT operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : Optional[int], optional\n        IFFT size, default is None (determined based on input size)\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(sampling_rate, n_fft=n_fft, window=window)\n</code></pre>"},{"location":"api/#wandas.processing.spectral.IFFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, freqs)</p>"},{"location":"api/#wandas.processing.spectral.IFFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, samples)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, freqs)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, samples)\n    \"\"\"\n    n_samples = 2 * (input_shape[-1] - 1) if self.n_fft is None else self.n_fft\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"api/#wandas.processing.spectral.STFT","title":"<code>STFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Short-Time Fourier Transform operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class STFT(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Short-Time Fourier Transform operation\"\"\"\n\n    name = \"stft\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ):\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.noverlap = (\n            self.win_length - self.hop_length if hop_length is not None else None\n        )\n        self.window = window\n\n        self.SFT = ShortTimeFFT(\n            win=get_window(window, self.win_length),\n            hop=self.hop_length,\n            fs=sampling_rate,\n            mfft=self.n_fft,\n            scale_to=\"magnitude\",\n        )\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        n_samples = input_shape[-1]\n        n_f = len(self.SFT.f)\n        n_t = len(self.SFT.t(n_samples))\n        return (input_shape[0], n_f, n_t)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Apply SciPy STFT processing to multiple channels at once\"\"\"\n        logger.debug(f\"Applying SciPy STFT to array with shape: {x.shape}\")\n\n        # Convert 1D input to 2D\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n\n        # Apply STFT to all channels at once\n        result: NDArrayComplex = self.SFT.stft(x)\n        result[..., 1:-1, :] *= 2.0\n        logger.debug(f\"SciPy STFT applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'stft'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>n_fft = n_fft</code> <code>instance-attribute</code> \u00b6 <code></code> <code>win_length = win_length if win_length is not None else n_fft</code> <code>instance-attribute</code> \u00b6 <code></code> <code>hop_length = hop_length if hop_length is not None else self.win_length // 4</code> <code>instance-attribute</code> \u00b6 <code></code> <code>noverlap = self.win_length - self.hop_length if hop_length is not None else None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>window = window</code> <code>instance-attribute</code> \u00b6 <code></code> <code>SFT = ShortTimeFFT(win=get_window(window, self.win_length), hop=self.hop_length, fs=sampling_rate, mfft=self.n_fft, scale_to='magnitude')</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, n_fft=2048, hop_length=None, win_length=None, window='hann')</code> \u00b6 Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n):\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.noverlap = (\n        self.win_length - self.hop_length if hop_length is not None else None\n    )\n    self.window = window\n\n    self.SFT = ShortTimeFFT(\n        win=get_window(window, self.win_length),\n        hop=self.hop_length,\n        fs=sampling_rate,\n        mfft=self.n_fft,\n        scale_to=\"magnitude\",\n    )\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        win_length=self.win_length,\n        hop_length=self.hop_length,\n        window=window,\n    )\n</code></pre> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 <p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.spectral.STFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/#wandas.processing.spectral.STFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    n_samples = input_shape[-1]\n    n_f = len(self.SFT.f)\n    n_t = len(self.SFT.t(n_samples))\n    return (input_shape[0], n_f, n_t)\n</code></pre>"},{"location":"api/#wandas.processing.spectral.ISTFT","title":"<code>ISTFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayComplex, NDArrayReal]</code></p> <p>Inverse Short-Time Fourier Transform operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class ISTFT(AudioOperation[NDArrayComplex, NDArrayReal]):\n    \"\"\"Inverse Short-Time Fourier Transform operation\"\"\"\n\n    name = \"istft\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        length: Optional[int] = None,\n    ):\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.length = length\n\n        # Instantiate ShortTimeFFT for ISTFT calculation\n        self.SFT = ShortTimeFFT(\n            win=get_window(window, self.win_length),\n            hop=self.hop_length,\n            fs=sampling_rate,\n            mfft=self.n_fft,\n            scale_to=\"magnitude\",  # Consistent scaling with STFT\n        )\n\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n            length=length,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, freqs, time_frames)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, samples)\n        \"\"\"\n        k0: int = 0\n        q_max = input_shape[-1] + self.SFT.p_min\n        k_max = (q_max - 1) * self.SFT.hop + self.SFT.m_num - self.SFT.m_num_mid\n        k_q0, k_q1 = self.SFT.nearest_k_p(k0), self.SFT.nearest_k_p(k_max, left=False)\n        n_pts = k_q1 - k_q0 + self.SFT.m_num - self.SFT.m_num_mid\n\n        return input_shape[:-2] + (n_pts,)\n\n    def _process_array(self, x: NDArrayComplex) -&gt; NDArrayReal:\n        \"\"\"\n        Apply SciPy ISTFT processing to multiple channels at once using ShortTimeFFT\"\"\"\n        logger.debug(\n            f\"Applying SciPy ISTFT (ShortTimeFFT) to array with shape: {x.shape}\"\n        )\n\n        # Convert 2D input to 3D (assume single channel)\n        if x.ndim == 2:\n            x = x.reshape(1, *x.shape)\n\n        # Adjust scaling back if STFT applied factor of 2\n        _x = np.copy(x)\n        _x[..., 1:-1, :] /= 2.0\n\n        # Apply ISTFT using the ShortTimeFFT instance\n        result: NDArrayReal = self.SFT.istft(_x)\n\n        # Trim to desired length if specified\n        if self.length is not None:\n            result = result[..., : self.length]\n\n        logger.debug(\n            f\"ShortTimeFFT applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'istft'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>n_fft = n_fft</code> <code>instance-attribute</code> \u00b6 <code></code> <code>win_length = win_length if win_length is not None else n_fft</code> <code>instance-attribute</code> \u00b6 <code></code> <code>hop_length = hop_length if hop_length is not None else self.win_length // 4</code> <code>instance-attribute</code> \u00b6 <code></code> <code>window = window</code> <code>instance-attribute</code> \u00b6 <code></code> <code>length = length</code> <code>instance-attribute</code> \u00b6 <code></code> <code>SFT = ShortTimeFFT(win=get_window(window, self.win_length), hop=self.hop_length, fs=sampling_rate, mfft=self.n_fft, scale_to='magnitude')</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, n_fft=2048, hop_length=None, win_length=None, window='hann', length=None)</code> \u00b6 Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    length: Optional[int] = None,\n):\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.length = length\n\n    # Instantiate ShortTimeFFT for ISTFT calculation\n    self.SFT = ShortTimeFFT(\n        win=get_window(window, self.win_length),\n        hop=self.hop_length,\n        fs=sampling_rate,\n        mfft=self.n_fft,\n        scale_to=\"magnitude\",  # Consistent scaling with STFT\n    )\n\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        win_length=self.win_length,\n        hop_length=self.hop_length,\n        window=window,\n        length=length,\n    )\n</code></pre> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 <p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.spectral.ISTFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, freqs, time_frames)</p>"},{"location":"api/#wandas.processing.spectral.ISTFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, samples)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, freqs, time_frames)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, samples)\n    \"\"\"\n    k0: int = 0\n    q_max = input_shape[-1] + self.SFT.p_min\n    k_max = (q_max - 1) * self.SFT.hop + self.SFT.m_num - self.SFT.m_num_mid\n    k_q0, k_q1 = self.SFT.nearest_k_p(k0), self.SFT.nearest_k_p(k_max, left=False)\n    n_pts = k_q1 - k_q0 + self.SFT.m_num - self.SFT.m_num_mid\n\n    return input_shape[:-2] + (n_pts,)\n</code></pre>"},{"location":"api/#wandas.processing.spectral.Welch","title":"<code>Welch</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Welch</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class Welch(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Welch\"\"\"\n\n    name = \"welch\"\n    n_fft: int\n    window: str\n    hop_length: Optional[int]\n    win_length: Optional[int]\n    average: str\n    detrend: str\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        average: str = \"mean\",\n        detrend: str = \"constant\",\n    ):\n        \"\"\"\n        Initialize Welch operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int, optional\n            FFT size, default is 2048\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.noverlap = (\n            self.win_length - self.hop_length if hop_length is not None else None\n        )\n        self.window = window\n        self.average = average\n        self.detrend = detrend\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n            average=average,\n            detrend=detrend,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, freqs)\n        \"\"\"\n        n_freqs = self.n_fft // 2 + 1\n        return (*input_shape[:-1], n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for Welch operation\"\"\"\n        from scipy import signal as ss\n\n        _, result = ss.welch(\n            x,\n            nperseg=self.win_length,\n            noverlap=self.noverlap,\n            nfft=self.n_fft,\n            window=self.window,\n            average=self.average,\n            detrend=self.detrend,\n            scaling=\"spectrum\",\n        )\n\n        if not isinstance(x, np.ndarray):\n            # Trigger computation for Dask array\n            raise ValueError(\n                \"Welch operation requires a Dask array, but received a non-ndarray.\"\n            )\n        return np.array(result)\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'welch'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>n_fft = n_fft</code> <code>instance-attribute</code> \u00b6 <code></code> <code>win_length = win_length if win_length is not None else n_fft</code> <code>instance-attribute</code> \u00b6 <code></code> <code>hop_length = hop_length if hop_length is not None else self.win_length // 4</code> <code>instance-attribute</code> \u00b6 <code></code> <code>noverlap = self.win_length - self.hop_length if hop_length is not None else None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>window = window</code> <code>instance-attribute</code> \u00b6 <code></code> <code>average = average</code> <code>instance-attribute</code> \u00b6 <code></code> <code>detrend = detrend</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, n_fft=2048, hop_length=None, win_length=None, window='hann', average='mean', detrend='constant')</code> \u00b6 <p>Initialize Welch operation</p> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 <p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.spectral.Welch.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int, optional     FFT size, default is 2048 window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    average: str = \"mean\",\n    detrend: str = \"constant\",\n):\n    \"\"\"\n    Initialize Welch operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int, optional\n        FFT size, default is 2048\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.noverlap = (\n        self.win_length - self.hop_length if hop_length is not None else None\n    )\n    self.window = window\n    self.average = average\n    self.detrend = detrend\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        win_length=self.win_length,\n        hop_length=self.hop_length,\n        window=window,\n        average=average,\n        detrend=detrend,\n    )\n</code></pre>"},{"location":"api/#wandas.processing.spectral.Welch.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"api/#wandas.processing.spectral.Welch.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, freqs)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, freqs)\n    \"\"\"\n    n_freqs = self.n_fft // 2 + 1\n    return (*input_shape[:-1], n_freqs)\n</code></pre>"},{"location":"api/#wandas.processing.spectral.NOctSpectrum","title":"<code>NOctSpectrum</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>N-octave spectrum operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class NOctSpectrum(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"N-octave spectrum operation\"\"\"\n\n    name = \"noct_spectrum\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ):\n        \"\"\"\n        Initialize N-octave spectrum\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        fmin : float\n            Minimum frequency (Hz)\n        fmax : float\n            Maximum frequency (Hz)\n        n : int, optional\n            Number of octave divisions, default is 3\n        G : int, optional\n            Reference level, default is 10\n        fr : int, optional\n            Reference frequency, default is 1000\n        \"\"\"\n        super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n        self.fmin = fmin\n        self.fmax = fmax\n        self.n = n\n        self.G = G\n        self.fr = fr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate output shape for octave spectrum\n        _, fpref = _center_freq(\n            fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n        )\n        return (input_shape[0], fpref.shape[0])\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for octave spectrum\"\"\"\n        logger.debug(f\"Applying NoctSpectrum to array with shape: {x.shape}\")\n        spec, _ = noct_spectrum(\n            sig=x.T,\n            fs=self.sampling_rate,\n            fmin=self.fmin,\n            fmax=self.fmax,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        if spec.ndim == 1:\n            # Add channel dimension for 1D\n            spec = np.expand_dims(spec, axis=0)\n        else:\n            spec = spec.T\n        logger.debug(f\"NoctSpectrum applied, returning result with shape: {spec.shape}\")\n        return np.array(spec)\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'noct_spectrum'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>fmin = fmin</code> <code>instance-attribute</code> \u00b6 <code></code> <code>fmax = fmax</code> <code>instance-attribute</code> \u00b6 <code></code> <code>n = n</code> <code>instance-attribute</code> \u00b6 <code></code> <code>G = G</code> <code>instance-attribute</code> \u00b6 <code></code> <code>fr = fr</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, fmin, fmax, n=3, G=10, fr=1000)</code> \u00b6 <p>Initialize N-octave spectrum</p> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 <p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.spectral.NOctSpectrum.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) fmin : float     Minimum frequency (Hz) fmax : float     Maximum frequency (Hz) n : int, optional     Number of octave divisions, default is 3 G : int, optional     Reference level, default is 10 fr : int, optional     Reference frequency, default is 1000</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n):\n    \"\"\"\n    Initialize N-octave spectrum\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    fmin : float\n        Minimum frequency (Hz)\n    fmax : float\n        Maximum frequency (Hz)\n    n : int, optional\n        Number of octave divisions, default is 3\n    G : int, optional\n        Reference level, default is 10\n    fr : int, optional\n        Reference frequency, default is 1000\n    \"\"\"\n    super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n    self.fmin = fmin\n    self.fmax = fmax\n    self.n = n\n    self.G = G\n    self.fr = fr\n</code></pre>"},{"location":"api/#wandas.processing.spectral.NOctSpectrum.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/#wandas.processing.spectral.NOctSpectrum.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate output shape for octave spectrum\n    _, fpref = _center_freq(\n        fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n    )\n    return (input_shape[0], fpref.shape[0])\n</code></pre>"},{"location":"api/#wandas.processing.spectral.NOctSynthesis","title":"<code>NOctSynthesis</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Octave synthesis operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class NOctSynthesis(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Octave synthesis operation\"\"\"\n\n    name = \"noct_synthesis\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ):\n        \"\"\"\n        Initialize octave synthesis\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        fmin : float\n            Minimum frequency (Hz)\n        fmax : float\n            Maximum frequency (Hz)\n        n : int, optional\n            Number of octave divisions, default is 3\n        G : int, optional\n            Reference level, default is 10\n        fr : int, optional\n            Reference frequency, default is 1000\n        \"\"\"\n        super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n\n        self.fmin = fmin\n        self.fmax = fmax\n        self.n = n\n        self.G = G\n        self.fr = fr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate output shape for octave spectrum\n        _, fpref = _center_freq(\n            fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n        )\n        return (input_shape[0], fpref.shape[0])\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for octave synthesis\"\"\"\n        logger.debug(f\"Applying NoctSynthesis to array with shape: {x.shape}\")\n        # Calculate n from shape[-1]\n        n = x.shape[-1]  # Calculate n from shape[-1]\n        if n % 2 == 0:\n            n = n * 2 - 1\n        else:\n            n = (n - 1) * 2\n        freqs = np.fft.rfftfreq(n, d=1 / self.sampling_rate)\n        result, _ = noct_synthesis(\n            spectrum=np.abs(x).T,\n            freqs=freqs,\n            fmin=self.fmin,\n            fmax=self.fmax,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        result = result.T\n        logger.debug(\n            f\"NoctSynthesis applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'noct_synthesis'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>fmin = fmin</code> <code>instance-attribute</code> \u00b6 <code></code> <code>fmax = fmax</code> <code>instance-attribute</code> \u00b6 <code></code> <code>n = n</code> <code>instance-attribute</code> \u00b6 <code></code> <code>G = G</code> <code>instance-attribute</code> \u00b6 <code></code> <code>fr = fr</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, fmin, fmax, n=3, G=10, fr=1000)</code> \u00b6 <p>Initialize octave synthesis</p> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 <p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.spectral.NOctSynthesis.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) fmin : float     Minimum frequency (Hz) fmax : float     Maximum frequency (Hz) n : int, optional     Number of octave divisions, default is 3 G : int, optional     Reference level, default is 10 fr : int, optional     Reference frequency, default is 1000</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n):\n    \"\"\"\n    Initialize octave synthesis\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    fmin : float\n        Minimum frequency (Hz)\n    fmax : float\n        Maximum frequency (Hz)\n    n : int, optional\n        Number of octave divisions, default is 3\n    G : int, optional\n        Reference level, default is 10\n    fr : int, optional\n        Reference frequency, default is 1000\n    \"\"\"\n    super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n\n    self.fmin = fmin\n    self.fmax = fmax\n    self.n = n\n    self.G = G\n    self.fr = fr\n</code></pre>"},{"location":"api/#wandas.processing.spectral.NOctSynthesis.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/#wandas.processing.spectral.NOctSynthesis.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate output shape for octave spectrum\n    _, fpref = _center_freq(\n        fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n    )\n    return (input_shape[0], fpref.shape[0])\n</code></pre>"},{"location":"api/#wandas.processing.spectral.Coherence","title":"<code>Coherence</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Coherence estimation operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class Coherence(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Coherence estimation operation\"\"\"\n\n    name = \"coherence\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n    ):\n        \"\"\"\n        Initialize coherence estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Processor function for coherence estimation operation\"\"\"\n        logger.debug(f\"Applying coherence estimation to array with shape: {x.shape}\")\n        from scipy import signal as ss\n\n        _, coh = ss.coherence(\n            x=x[:, np.newaxis],\n            y=x[np.newaxis, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n        )\n\n        # Reshape result to (n_channels * n_channels, n_freqs)\n        result: NDArrayReal = coh.transpose(1, 0, 2).reshape(-1, coh.shape[-1])\n\n        logger.debug(f\"Coherence estimation applied, result shape: {result.shape}\")\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'coherence'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>n_fft = n_fft</code> <code>instance-attribute</code> \u00b6 <code></code> <code>win_length = win_length if win_length is not None else n_fft</code> <code>instance-attribute</code> \u00b6 <code></code> <code>hop_length = hop_length if hop_length is not None else self.win_length // 4</code> <code>instance-attribute</code> \u00b6 <code></code> <code>window = window</code> <code>instance-attribute</code> \u00b6 <code></code> <code>detrend = detrend</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend)</code> \u00b6 <p>Initialize coherence estimation operation</p> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 <p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.spectral.Coherence.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n):\n    \"\"\"\n    Initialize coherence estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n    )\n</code></pre>"},{"location":"api/#wandas.processing.spectral.Coherence.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"api/#wandas.processing.spectral.Coherence.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"api/#wandas.processing.spectral.CSD","title":"<code>CSD</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Cross-spectral density estimation operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class CSD(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Cross-spectral density estimation operation\"\"\"\n\n    name = \"csd\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n        scaling: str,\n        average: str,\n    ):\n        \"\"\"\n        Initialize cross-spectral density estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        scaling : str\n            Type of scaling\n        average : str\n            Method of averaging\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        self.scaling = scaling\n        self.average = average\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n            scaling=scaling,\n            average=average,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Processor function for cross-spectral density estimation operation\"\"\"\n        logger.debug(f\"Applying CSD estimation to array with shape: {x.shape}\")\n        from scipy import signal as ss\n\n        # Calculate all combinations using scipy's csd function\n        _, csd_result = ss.csd(\n            x=x[:, np.newaxis],\n            y=x[np.newaxis, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n        )\n\n        # Reshape result to (n_channels * n_channels, n_freqs)\n        result: NDArrayComplex = csd_result.transpose(1, 0, 2).reshape(\n            -1, csd_result.shape[-1]\n        )\n\n        logger.debug(f\"CSD estimation applied, result shape: {result.shape}\")\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'csd'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>n_fft = n_fft</code> <code>instance-attribute</code> \u00b6 <code></code> <code>win_length = win_length if win_length is not None else n_fft</code> <code>instance-attribute</code> \u00b6 <code></code> <code>hop_length = hop_length if hop_length is not None else self.win_length // 4</code> <code>instance-attribute</code> \u00b6 <code></code> <code>window = window</code> <code>instance-attribute</code> \u00b6 <code></code> <code>detrend = detrend</code> <code>instance-attribute</code> \u00b6 <code></code> <code>scaling = scaling</code> <code>instance-attribute</code> \u00b6 <code></code> <code>average = average</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend, scaling, average)</code> \u00b6 <p>Initialize cross-spectral density estimation operation</p> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 <p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.spectral.CSD.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend scaling : str     Type of scaling average : str     Method of averaging</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n    scaling: str,\n    average: str,\n):\n    \"\"\"\n    Initialize cross-spectral density estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    scaling : str\n        Type of scaling\n    average : str\n        Method of averaging\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    self.scaling = scaling\n    self.average = average\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n        scaling=scaling,\n        average=average,\n    )\n</code></pre>"},{"location":"api/#wandas.processing.spectral.CSD.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"api/#wandas.processing.spectral.CSD.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"api/#wandas.processing.spectral.TransferFunction","title":"<code>TransferFunction</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Transfer function estimation operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class TransferFunction(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Transfer function estimation operation\"\"\"\n\n    name = \"transfer_function\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ):\n        \"\"\"\n        Initialize transfer function estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        scaling : str\n            Type of scaling\n        average : str\n            Method of averaging\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        self.scaling = scaling\n        self.average = average\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n            scaling=scaling,\n            average=average,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Processor function for transfer function estimation operation\"\"\"\n        logger.debug(\n            f\"Applying transfer function estimation to array with shape: {x.shape}\"\n        )\n        from scipy import signal as ss\n\n        # Calculate cross-spectral density between all channels\n        f, p_yx = ss.csd(\n            x=x[:, np.newaxis, :],\n            y=x[np.newaxis, :, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n            axis=-1,\n        )\n        # p_yx shape: (num_channels, num_channels, num_frequencies)\n\n        # Calculate power spectral density for each channel\n        f, p_xx = ss.welch(\n            x=x,\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n            axis=-1,\n        )\n        # p_xx shape: (num_channels, num_frequencies)\n\n        # Calculate transfer function H(f) = P_yx / P_xx\n        h_f = p_yx / p_xx[np.newaxis, :, :]\n        result: NDArrayComplex = h_f.transpose(1, 0, 2).reshape(-1, h_f.shape[-1])\n\n        logger.debug(\n            f\"Transfer function estimation applied, result shape: {result.shape}\"\n        )\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'transfer_function'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>n_fft = n_fft</code> <code>instance-attribute</code> \u00b6 <code></code> <code>win_length = win_length if win_length is not None else n_fft</code> <code>instance-attribute</code> \u00b6 <code></code> <code>hop_length = hop_length if hop_length is not None else self.win_length // 4</code> <code>instance-attribute</code> \u00b6 <code></code> <code>window = window</code> <code>instance-attribute</code> \u00b6 <code></code> <code>detrend = detrend</code> <code>instance-attribute</code> \u00b6 <code></code> <code>scaling = scaling</code> <code>instance-attribute</code> \u00b6 <code></code> <code>average = average</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend, scaling='spectrum', average='mean')</code> \u00b6 <p>Initialize transfer function estimation operation</p> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 <p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.spectral.TransferFunction.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend scaling : str     Type of scaling average : str     Method of averaging</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n):\n    \"\"\"\n    Initialize transfer function estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    scaling : str\n        Type of scaling\n    average : str\n        Method of averaging\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    self.scaling = scaling\n    self.average = average\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n        scaling=scaling,\n        average=average,\n    )\n</code></pre>"},{"location":"api/#wandas.processing.spectral.TransferFunction.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"api/#wandas.processing.spectral.TransferFunction.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"api/#wandas.processing.spectral-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.stats","title":"<code>stats</code>","text":""},{"location":"api/#wandas.processing.stats-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.stats.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.processing.stats-classes","title":"Classes","text":""},{"location":"api/#wandas.processing.stats.ABS","title":"<code>ABS</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Absolute value operation</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>class ABS(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Absolute value operation\"\"\"\n\n    name = \"abs\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize absolute value operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        return da.abs(data)  # type: ignore [unused-ignore]\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'abs'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate)</code> \u00b6 <p>Initialize absolute value operation</p> <code></code> <code>process(data)</code> \u00b6 Source code in <code>wandas/processing/stats.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n    return da.abs(data)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"api/#wandas.processing.stats.ABS.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize absolute value operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"api/#wandas.processing.stats.Power","title":"<code>Power</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Power operation</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>class Power(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Power operation\"\"\"\n\n    name = \"power\"\n\n    def __init__(self, sampling_rate: float, exponent: float):\n        \"\"\"\n        Initialize power operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        exponent : float\n            Power exponent\n        \"\"\"\n        super().__init__(sampling_rate)\n        self.exp = exponent\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        return da.power(data, self.exp)  # type: ignore [unused-ignore]\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'power'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>exp = exponent</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, exponent)</code> \u00b6 <p>Initialize power operation</p> <code></code> <code>process(data)</code> \u00b6 Source code in <code>wandas/processing/stats.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n    return da.power(data, self.exp)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"api/#wandas.processing.stats.Power.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) exponent : float     Power exponent</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>def __init__(self, sampling_rate: float, exponent: float):\n    \"\"\"\n    Initialize power operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    exponent : float\n        Power exponent\n    \"\"\"\n    super().__init__(sampling_rate)\n    self.exp = exponent\n</code></pre>"},{"location":"api/#wandas.processing.stats.Sum","title":"<code>Sum</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Sum calculation</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>class Sum(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Sum calculation\"\"\"\n\n    name = \"sum\"\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # Use Dask's aggregate function directly without map_blocks\n        return data.sum(axis=0, keepdims=True)\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'sum'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>process(data)</code> \u00b6 Source code in <code>wandas/processing/stats.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    # Use Dask's aggregate function directly without map_blocks\n    return data.sum(axis=0, keepdims=True)\n</code></pre>"},{"location":"api/#wandas.processing.stats.Mean","title":"<code>Mean</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Mean calculation</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>class Mean(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Mean calculation\"\"\"\n\n    name = \"mean\"\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # Use Dask's aggregate function directly without map_blocks\n        return data.mean(axis=0, keepdims=True)\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'mean'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>process(data)</code> \u00b6 Source code in <code>wandas/processing/stats.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    # Use Dask's aggregate function directly without map_blocks\n    return data.mean(axis=0, keepdims=True)\n</code></pre>"},{"location":"api/#wandas.processing.stats.ChannelDifference","title":"<code>ChannelDifference</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Channel difference calculation operation</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>class ChannelDifference(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Channel difference calculation operation\"\"\"\n\n    name = \"channel_difference\"\n    other_channel: int\n\n    def __init__(self, sampling_rate: float, other_channel: int = 0):\n        \"\"\"\n        Initialize channel difference calculation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        other_channel : int\n            Channel to calculate difference with, default is 0\n        \"\"\"\n        self.other_channel = other_channel\n        super().__init__(sampling_rate, other_channel=other_channel)\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        result = data - data[self.other_channel]\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'channel_difference'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>other_channel = other_channel</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, other_channel=0)</code> \u00b6 <p>Initialize channel difference calculation</p> <code></code> <code>process(data)</code> \u00b6 Source code in <code>wandas/processing/stats.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n    result = data - data[self.other_channel]\n    return result\n</code></pre>"},{"location":"api/#wandas.processing.stats.ChannelDifference.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) other_channel : int     Channel to calculate difference with, default is 0</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>def __init__(self, sampling_rate: float, other_channel: int = 0):\n    \"\"\"\n    Initialize channel difference calculation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    other_channel : int\n        Channel to calculate difference with, default is 0\n    \"\"\"\n    self.other_channel = other_channel\n    super().__init__(sampling_rate, other_channel=other_channel)\n</code></pre>"},{"location":"api/#wandas.processing.stats-functions","title":"Functions","text":""},{"location":"api/#wandas.processing.temporal","title":"<code>temporal</code>","text":""},{"location":"api/#wandas.processing.temporal-attributes","title":"Attributes","text":""},{"location":"api/#wandas.processing.temporal.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.processing.temporal-classes","title":"Classes","text":""},{"location":"api/#wandas.processing.temporal.ReSampling","title":"<code>ReSampling</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Resampling operation</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>class ReSampling(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Resampling operation\"\"\"\n\n    name = \"resampling\"\n\n    def __init__(self, sampling_rate: float, target_sr: float):\n        \"\"\"\n        Initialize resampling operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        target_sampling_rate : float\n            Target sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate, target_sr=target_sr)\n        self.target_sr = target_sr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after resampling\n        ratio = float(self.target_sr) / float(self.sampling_rate)\n        n_samples = int(np.ceil(input_shape[-1] * ratio))\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for resampling operation\"\"\"\n        logger.debug(f\"Applying resampling to array with shape: {x.shape}\")\n        result: NDArrayReal = librosa.resample(\n            x, orig_sr=self.sampling_rate, target_sr=self.target_sr\n        )\n        logger.debug(f\"Resampling applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'resampling'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>target_sr = target_sr</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, target_sr)</code> \u00b6 <p>Initialize resampling operation</p> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 <p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.temporal.ReSampling.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) target_sampling_rate : float     Target sampling rate (Hz)</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def __init__(self, sampling_rate: float, target_sr: float):\n    \"\"\"\n    Initialize resampling operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    target_sampling_rate : float\n        Target sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate, target_sr=target_sr)\n    self.target_sr = target_sr\n</code></pre>"},{"location":"api/#wandas.processing.temporal.ReSampling.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/#wandas.processing.temporal.ReSampling.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after resampling\n    ratio = float(self.target_sr) / float(self.sampling_rate)\n    n_samples = int(np.ceil(input_shape[-1] * ratio))\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"api/#wandas.processing.temporal.Trim","title":"<code>Trim</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Trimming operation</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>class Trim(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Trimming operation\"\"\"\n\n    name = \"trim\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        start: float,\n        end: float,\n    ):\n        \"\"\"\n        Initialize trimming operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        start : float\n            Start time for trimming (seconds)\n        end : float\n            End time for trimming (seconds)\n        \"\"\"\n        super().__init__(sampling_rate, start=start, end=end)\n        self.start = start\n        self.end = end\n        self.start_sample = int(start * sampling_rate)\n        self.end_sample = int(end * sampling_rate)\n        logger.debug(\n            f\"Initialized Trim operation with start: {self.start}, end: {self.end}\"\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after trimming\n        # Exclude parts where there is no signal\n        end_sample = min(self.end_sample, input_shape[-1])\n        n_samples = end_sample - self.start_sample\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for trimming operation\"\"\"\n        logger.debug(f\"Applying trim to array with shape: {x.shape}\")\n        # Apply trimming\n        result = x[..., self.start_sample : self.end_sample]\n        logger.debug(f\"Trim applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'trim'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>start = start</code> <code>instance-attribute</code> \u00b6 <code></code> <code>end = end</code> <code>instance-attribute</code> \u00b6 <code></code> <code>start_sample = int(start * sampling_rate)</code> <code>instance-attribute</code> \u00b6 <code></code> <code>end_sample = int(end * sampling_rate)</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, start, end)</code> \u00b6 <p>Initialize trimming operation</p> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 <p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.temporal.Trim.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) start : float     Start time for trimming (seconds) end : float     End time for trimming (seconds)</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    start: float,\n    end: float,\n):\n    \"\"\"\n    Initialize trimming operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    start : float\n        Start time for trimming (seconds)\n    end : float\n        End time for trimming (seconds)\n    \"\"\"\n    super().__init__(sampling_rate, start=start, end=end)\n    self.start = start\n    self.end = end\n    self.start_sample = int(start * sampling_rate)\n    self.end_sample = int(end * sampling_rate)\n    logger.debug(\n        f\"Initialized Trim operation with start: {self.start}, end: {self.end}\"\n    )\n</code></pre>"},{"location":"api/#wandas.processing.temporal.Trim.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/#wandas.processing.temporal.Trim.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after trimming\n    # Exclude parts where there is no signal\n    end_sample = min(self.end_sample, input_shape[-1])\n    n_samples = end_sample - self.start_sample\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"api/#wandas.processing.temporal.FixLength","title":"<code>FixLength</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>\u4fe1\u53f7\u306e\u9577\u3055\u3092\u6307\u5b9a\u3055\u308c\u305f\u9577\u3055\u306b\u8abf\u6574\u3059\u308b\u64cd\u4f5c</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>class FixLength(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"\u4fe1\u53f7\u306e\u9577\u3055\u3092\u6307\u5b9a\u3055\u308c\u305f\u9577\u3055\u306b\u8abf\u6574\u3059\u308b\u64cd\u4f5c\"\"\"\n\n    name = \"fix_length\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        length: Optional[int] = None,\n        duration: Optional[float] = None,\n    ):\n        \"\"\"\n        Initialize fix length operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        length : Optional[int]\n            Target length for fixing\n        duration : Optional[float]\n            Target length for fixing\n        \"\"\"\n        if length is None:\n            if duration is None:\n                raise ValueError(\"Either length or duration must be provided.\")\n            else:\n                length = int(duration * sampling_rate)\n        self.target_length = length\n\n        super().__init__(sampling_rate, target_length=self.target_length)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        return (*input_shape[:-1], self.target_length)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for padding operation\"\"\"\n        logger.debug(f\"Applying padding to array with shape: {x.shape}\")\n        # Apply padding\n        pad_width = self.target_length - x.shape[-1]\n        if pad_width &gt; 0:\n            result = np.pad(x, ((0, 0), (0, pad_width)), mode=\"constant\")\n        else:\n            result = x[..., : self.target_length]\n        logger.debug(f\"Padding applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'fix_length'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>target_length = length</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, length=None, duration=None)</code> \u00b6 <p>Initialize fix length operation</p> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 <p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.temporal.FixLength.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) length : Optional[int]     Target length for fixing duration : Optional[float]     Target length for fixing</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    length: Optional[int] = None,\n    duration: Optional[float] = None,\n):\n    \"\"\"\n    Initialize fix length operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    length : Optional[int]\n        Target length for fixing\n    duration : Optional[float]\n        Target length for fixing\n    \"\"\"\n    if length is None:\n        if duration is None:\n            raise ValueError(\"Either length or duration must be provided.\")\n        else:\n            length = int(duration * sampling_rate)\n    self.target_length = length\n\n    super().__init__(sampling_rate, target_length=self.target_length)\n</code></pre>"},{"location":"api/#wandas.processing.temporal.FixLength.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/#wandas.processing.temporal.FixLength.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    return (*input_shape[:-1], self.target_length)\n</code></pre>"},{"location":"api/#wandas.processing.temporal.RmsTrend","title":"<code>RmsTrend</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>RMS calculation</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>class RmsTrend(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"RMS calculation\"\"\"\n\n    name = \"rms_trend\"\n    frame_length: int\n    hop_length: int\n    Aw: bool\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        ref: Union[list[float], float] = 1.0,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; None:\n        \"\"\"\n        Initialize RMS calculation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        frame_length : int\n            Frame length, default is 2048\n        hop_length : int\n            Hop length, default is 512\n        ref : Union[list[float], float]\n            Reference value(s) for dB calculation\n        dB : bool\n            Whether to convert to decibels\n        Aw : bool\n            Whether to apply A-weighting before RMS calculation\n        \"\"\"\n        self.frame_length = frame_length\n        self.hop_length = hop_length\n        self.dB = dB\n        self.Aw = Aw\n        self.ref = np.array(ref if isinstance(ref, list) else [ref])\n        super().__init__(\n            sampling_rate,\n            frame_length=frame_length,\n            hop_length=hop_length,\n            dB=dB,\n            Aw=Aw,\n            ref=self.ref,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, frames)\n        \"\"\"\n        n_frames = librosa.feature.rms(\n            y=np.ones((1, input_shape[-1])),\n            frame_length=self.frame_length,\n            hop_length=self.hop_length,\n        ).shape[-1]\n        return (*input_shape[:-1], n_frames)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for RMS calculation\"\"\"\n        logger.debug(f\"Applying RMS to array with shape: {x.shape}\")\n\n        if self.Aw:\n            # Apply A-weighting\n            _x = A_weight(x, self.sampling_rate)\n            if isinstance(_x, np.ndarray):\n                # A_weight\u304c\u30bf\u30d7\u30eb\u3092\u8fd4\u3059\u5834\u5408\u3001\u6700\u521d\u306e\u8981\u7d20\u3092\u4f7f\u7528\n                x = _x\n            elif isinstance(_x, tuple):\n                # Use the first element if A_weight returns a tuple\n                x = _x[0]\n            else:\n                raise ValueError(\"A_weighting returned an unexpected type.\")\n\n        # Calculate RMS\n        result: NDArrayReal = librosa.feature.rms(\n            y=x, frame_length=self.frame_length, hop_length=self.hop_length\n        )[..., 0, :]\n\n        if self.dB:\n            # Convert to dB\n            result = 20 * np.log10(\n                np.maximum(result / self.ref[..., np.newaxis], 1e-12)\n            )\n        #\n        logger.debug(f\"RMS applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'rms_trend'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>frame_length = frame_length</code> <code>instance-attribute</code> \u00b6 <code></code> <code>hop_length = hop_length</code> <code>instance-attribute</code> \u00b6 <code></code> <code>dB = dB</code> <code>instance-attribute</code> \u00b6 <code></code> <code>Aw = Aw</code> <code>instance-attribute</code> \u00b6 <code></code> <code>ref = np.array(ref if isinstance(ref, list) else [ref])</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(sampling_rate, frame_length=2048, hop_length=512, ref=1.0, dB=False, Aw=False)</code> \u00b6 <p>Initialize RMS calculation</p> <code></code> <code>calculate_output_shape(input_shape)</code> \u00b6 <p>Calculate output data shape after operation</p>"},{"location":"api/#wandas.processing.temporal.RmsTrend.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) frame_length : int     Frame length, default is 2048 hop_length : int     Hop length, default is 512 ref : Union[list[float], float]     Reference value(s) for dB calculation dB : bool     Whether to convert to decibels Aw : bool     Whether to apply A-weighting before RMS calculation</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    ref: Union[list[float], float] = 1.0,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; None:\n    \"\"\"\n    Initialize RMS calculation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    frame_length : int\n        Frame length, default is 2048\n    hop_length : int\n        Hop length, default is 512\n    ref : Union[list[float], float]\n        Reference value(s) for dB calculation\n    dB : bool\n        Whether to convert to decibels\n    Aw : bool\n        Whether to apply A-weighting before RMS calculation\n    \"\"\"\n    self.frame_length = frame_length\n    self.hop_length = hop_length\n    self.dB = dB\n    self.Aw = Aw\n    self.ref = np.array(ref if isinstance(ref, list) else [ref])\n    super().__init__(\n        sampling_rate,\n        frame_length=frame_length,\n        hop_length=hop_length,\n        dB=dB,\n        Aw=Aw,\n        ref=self.ref,\n    )\n</code></pre>"},{"location":"api/#wandas.processing.temporal.RmsTrend.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"api/#wandas.processing.temporal.RmsTrend.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, frames)</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, frames)\n    \"\"\"\n    n_frames = librosa.feature.rms(\n        y=np.ones((1, input_shape[-1])),\n        frame_length=self.frame_length,\n        hop_length=self.hop_length,\n    ).shape[-1]\n    return (*input_shape[:-1], n_frames)\n</code></pre>"},{"location":"api/#wandas.processing.temporal-functions","title":"Functions","text":""},{"location":"api/#_4","title":"\u5165\u51fa\u529b\u30e2\u30b8\u30e5\u30fc\u30eb","text":"<p>\u5165\u51fa\u529b\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u66f8\u304d\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/#wandas.io","title":"<code>wandas.io</code>","text":""},{"location":"api/#wandas.io-attributes","title":"Attributes","text":""},{"location":"api/#wandas.io.__all__","title":"<code>__all__ = ['read_wav', 'write_wav', 'load', 'save']</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.io-functions","title":"Functions","text":""},{"location":"api/#wandas.io.read_wav","title":"<code>read_wav(filename, labels=None)</code>","text":"<p>Read a WAV file and create a ChannelFrame object.</p>"},{"location":"api/#wandas.io.read_wav--parameters","title":"Parameters","text":"<p>filename : str     Path to the WAV file or URL to the WAV file. labels : list of str, optional     Labels for each channel.</p>"},{"location":"api/#wandas.io.read_wav--returns","title":"Returns","text":"<p>ChannelFrame     ChannelFrame object containing the audio data.</p> Source code in <code>wandas/io/wav_io.py</code> <pre><code>def read_wav(filename: str, labels: Optional[list[str]] = None) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Read a WAV file and create a ChannelFrame object.\n\n    Parameters\n    ----------\n    filename : str\n        Path to the WAV file or URL to the WAV file.\n    labels : list of str, optional\n        Labels for each channel.\n\n    Returns\n    -------\n    ChannelFrame\n        ChannelFrame object containing the audio data.\n    \"\"\"\n    from wandas.frames.channel import ChannelFrame\n\n    # \u30d5\u30a1\u30a4\u30eb\u540d\u304cURL\u304b\u3069\u3046\u304b\u3092\u5224\u65ad\n    if filename.startswith(\"http://\") or filename.startswith(\"https://\"):\n        # URL\u306e\u5834\u5408\u3001requests\u3092\u4f7f\u7528\u3057\u3066\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\n\n        response = requests.get(filename)\n        file_obj = io.BytesIO(response.content)\n        file_label = os.path.basename(filename)\n        # \u30e1\u30e2\u30ea\u30de\u30c3\u30d4\u30f3\u30b0\u306f\u4f7f\u7528\u305b\u305a\u306b\u8aad\u307f\u8fbc\u3080\n        sampling_rate, data = wavfile.read(file_obj)\n    else:\n        # \u30ed\u30fc\u30ab\u30eb\u30d5\u30a1\u30a4\u30eb\u30d1\u30b9\u306e\u5834\u5408\n        file_label = os.path.basename(filename)\n        # \u30c7\u30fc\u30bf\u306e\u8aad\u307f\u8fbc\u307f\uff08\u30e1\u30e2\u30ea\u30de\u30c3\u30d4\u30f3\u30b0\u3092\u4f7f\u7528\uff09\n        sampling_rate, data = wavfile.read(filename, mmap=True)\n\n    # \u30c7\u30fc\u30bf\u3092(num_channels, num_samples)\u5f62\u72b6\u306eNumPy\u914d\u5217\u306b\u5909\u63db\n    if data.ndim == 1:\n        # \u30e2\u30ce\u30e9\u30eb\uff1a(samples,) -&gt; (1, samples)\n        data = np.expand_dims(data, axis=0)\n    else:\n        # \u30b9\u30c6\u30ec\u30aa\uff1a(samples, channels) -&gt; (channels, samples)\n        data = data.T\n\n    # NumPy\u914d\u5217\u304b\u3089ChannelFrame\u3092\u4f5c\u6210\n    channel_frame = ChannelFrame.from_numpy(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=file_label,\n        ch_labels=labels,\n    )\n\n    return channel_frame\n</code></pre>"},{"location":"api/#wandas.io.write_wav","title":"<code>write_wav(filename, target, format=None)</code>","text":"<p>Write a ChannelFrame object to a WAV file.</p>"},{"location":"api/#wandas.io.write_wav--parameters","title":"Parameters","text":"<p>filename : str     Path to the WAV file. target : ChannelFrame     ChannelFrame object containing the data to write. format : str, optional     File format. If None, determined from file extension.</p>"},{"location":"api/#wandas.io.write_wav--raises","title":"Raises","text":"<p>ValueError     If target is not a ChannelFrame object.</p> Source code in <code>wandas/io/wav_io.py</code> <pre><code>def write_wav(\n    filename: str, target: \"ChannelFrame\", format: Optional[str] = None\n) -&gt; None:\n    \"\"\"\n    Write a ChannelFrame object to a WAV file.\n\n    Parameters\n    ----------\n    filename : str\n        Path to the WAV file.\n    target : ChannelFrame\n        ChannelFrame object containing the data to write.\n    format : str, optional\n        File format. If None, determined from file extension.\n\n    Raises\n    ------\n    ValueError\n        If target is not a ChannelFrame object.\n    \"\"\"\n    from wandas.frames.channel import ChannelFrame\n\n    if not isinstance(target, ChannelFrame):\n        raise ValueError(\"target must be a ChannelFrame object.\")\n\n    logger.debug(f\"Saving audio data to file: {filename} (will compute now)\")\n    data = target.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    if data.dtype == float and max([np.abs(data.max()), np.abs(data.min())]) &lt; 1:\n        sf.write(\n            str(filename),\n            data,\n            int(target.sampling_rate),\n            subtype=\"FLOAT\",\n            format=format,\n        )\n    else:\n        sf.write(str(filename), data, int(target.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {filename}\")\n</code></pre>"},{"location":"api/#wandas.io.load","title":"<code>load(path, *, format='hdf5')</code>","text":"<p>Load a ChannelFrame object from a WDF (Wandas Data File) file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the WDF file to load.</p> required <code>format</code> <code>str</code> <p>Format of the file. Currently only \"hdf5\" is supported.</p> <code>'hdf5'</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame object with data and metadata loaded from the file.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> <code>NotImplementedError</code> <p>If format is not \"hdf5\".</p> <code>ValueError</code> <p>If the file format is invalid or incompatible.</p> Example <p>cf = ChannelFrame.load(\"audio_data.wdf\")</p> Source code in <code>wandas/io/wdf_io.py</code> <pre><code>def load(path: Union[str, Path], *, format: str = \"hdf5\") -&gt; \"ChannelFrame\":\n    \"\"\"Load a ChannelFrame object from a WDF (Wandas Data File) file.\n\n    Args:\n        path: Path to the WDF file to load.\n        format: Format of the file. Currently only \"hdf5\" is supported.\n\n    Returns:\n        A new ChannelFrame object with data and metadata loaded from the file.\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist.\n        NotImplementedError: If format is not \"hdf5\".\n        ValueError: If the file format is invalid or incompatible.\n\n    Example:\n        &gt;&gt;&gt; cf = ChannelFrame.load(\"audio_data.wdf\")\n    \"\"\"\n    # Ensure ChannelFrame is imported here to avoid circular imports\n    from ..core.metadata import ChannelMetadata\n    from ..frames.channel import ChannelFrame\n\n    if format != \"hdf5\":\n        raise NotImplementedError(f\"Format '{format}' is not supported\")\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    logger.debug(f\"Loading ChannelFrame from {path}\")\n\n    with h5py.File(path, \"r\") as f:\n        # Check format version for compatibility\n        version = f.attrs.get(\"version\", \"unknown\")\n        if version != WDF_FORMAT_VERSION:\n            logger.warning(\n                f\"File format version mismatch: file={version}, current={WDF_FORMAT_VERSION}\"  # noqa: E501\n            )\n\n        # Get global attributes\n        sampling_rate = float(f.attrs[\"sampling_rate\"])\n        frame_label = f.attrs.get(\"label\", \"\")\n\n        # Get frame metadata\n        frame_metadata = {}\n        if \"meta\" in f:\n            meta_json = f[\"meta\"].attrs.get(\"json\", \"{}\")\n            frame_metadata = json.loads(meta_json)\n\n        # Load channel data and metadata\n        all_channel_data = []\n        channel_metadata_list = []\n\n        if \"channels\" in f:\n            channels_group = f[\"channels\"]\n            # Sort channel indices numerically\n            channel_indices = sorted([int(key) for key in channels_group.keys()])\n\n            for idx in channel_indices:\n                ch_group = channels_group[f\"{idx}\"]\n\n                # Load channel data\n                channel_data = ch_group[\"data\"][()]\n\n                # Append to combined array\n                all_channel_data.append(channel_data)\n\n                # Load channel metadata\n                label = ch_group.attrs.get(\"label\", f\"Ch{idx}\")\n                unit = ch_group.attrs.get(\"unit\", \"\")\n\n                # Load additional metadata if present\n                ch_extra = {}\n                if \"metadata_json\" in ch_group.attrs:\n                    ch_extra = json.loads(ch_group.attrs[\"metadata_json\"])\n\n                # Create ChannelMetadata object\n                channel_metadata = ChannelMetadata(\n                    label=label, unit=unit, extra=ch_extra\n                )\n                channel_metadata_list.append(channel_metadata)\n\n        # Stack channel data into a single array\n        if all_channel_data:\n            combined_data = np.stack(all_channel_data, axis=0)\n        else:\n            raise ValueError(\"No channel data found in the file\")\n\n        # Create a new ChannelFrame\n        dask_data = da_from_array(combined_data)\n\n        cf = ChannelFrame(\n            data=dask_data,\n            sampling_rate=sampling_rate,\n            label=frame_label if frame_label else None,\n            metadata=frame_metadata,\n            channel_metadata=channel_metadata_list,\n        )\n\n        logger.debug(\n            f\"ChannelFrame loaded from {path}: {len(cf)} channels, {cf.n_samples} samples\"  # noqa: E501\n        )\n        return cf\n</code></pre>"},{"location":"api/#wandas.io.save","title":"<code>save(frame, path, *, format='hdf5', compress='gzip', overwrite=False, dtype=None)</code>","text":"<p>Save a frame to a file.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>BaseFrame[Any]</code> <p>The frame to save.</p> required <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file. '.wdf' extension will be added if not present.</p> required <code>format</code> <code>str</code> <p>Format to use (currently only 'hdf5' is supported)</p> <code>'hdf5'</code> <code>compress</code> <code>Optional[str]</code> <p>Compression method ('gzip' by default, None for no compression)</p> <code>'gzip'</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing file</p> <code>False</code> <code>dtype</code> <code>Optional[Union[str, dtype[Any]]]</code> <p>Optional data type conversion before saving (e.g. 'float32')</p> <code>None</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If the file exists and overwrite=False.</p> <code>NotImplementedError</code> <p>For unsupported formats.</p> Source code in <code>wandas/io/wdf_io.py</code> <pre><code>def save(\n    frame: BaseFrame[Any],\n    path: Union[str, Path],\n    *,\n    format: str = \"hdf5\",\n    compress: Optional[str] = \"gzip\",\n    overwrite: bool = False,\n    dtype: Optional[Union[str, np.dtype[Any]]] = None,\n) -&gt; None:\n    \"\"\"Save a frame to a file.\n\n    Args:\n        frame: The frame to save.\n        path: Path to save the file. '.wdf' extension will be added if not present.\n        format: Format to use (currently only 'hdf5' is supported)\n        compress: Compression method ('gzip' by default, None for no compression)\n        overwrite: Whether to overwrite existing file\n        dtype: Optional data type conversion before saving (e.g. 'float32')\n\n    Raises:\n        FileExistsError: If the file exists and overwrite=False.\n        NotImplementedError: For unsupported formats.\n    \"\"\"\n    # Handle path\n    path = Path(path)\n    if path.suffix != \".wdf\":\n        path = path.with_suffix(\".wdf\")\n\n    # Check if file exists\n    if path.exists() and not overwrite:\n        raise FileExistsError(\n            f\"File {path} already exists. Set overwrite=True to overwrite.\"\n        )\n\n    # Currently only HDF5 is supported\n    if format.lower() != \"hdf5\":\n        raise NotImplementedError(\n            f\"Format {format} not supported. Only 'hdf5' is currently implemented.\"\n        )\n\n    # Compute data arrays (this triggers actual computation)\n    logger.info(\"Computing data arrays for saving...\")\n    computed_data = frame.compute()\n    if dtype is not None:\n        computed_data = computed_data.astype(dtype)\n\n    # Create file\n    logger.info(f\"Creating HDF5 file at {path}...\")\n    with h5py.File(path, \"w\") as f:\n        # Set file version\n        f.attrs[\"version\"] = WDF_FORMAT_VERSION\n\n        # Store frame metadata\n        f.attrs[\"sampling_rate\"] = frame.sampling_rate\n        f.attrs[\"label\"] = frame.label or \"\"\n        f.attrs[\"frame_type\"] = type(frame).__name__\n\n        # Create channels group\n        channels_grp = f.create_group(\"channels\")\n\n        # Store each channel\n        for i, (channel_data, ch_meta) in enumerate(\n            zip(computed_data, frame._channel_metadata)\n        ):\n            ch_grp = channels_grp.create_group(f\"{i}\")\n\n            # Store channel data\n            if compress:\n                ch_grp.create_dataset(\"data\", data=channel_data, compression=compress)\n            else:\n                ch_grp.create_dataset(\"data\", data=channel_data)\n\n            # Store metadata\n            ch_grp.attrs[\"label\"] = ch_meta.label\n            ch_grp.attrs[\"unit\"] = ch_meta.unit\n\n            # Store extra metadata as JSON\n            if ch_meta.extra:\n                ch_grp.attrs[\"metadata_json\"] = json.dumps(ch_meta.extra)\n\n        # Store operation history\n        if frame.operation_history:\n            op_grp = f.create_group(\"operation_history\")\n            for i, op in enumerate(frame.operation_history):\n                op_sub_grp = op_grp.create_group(f\"operation_{i}\")\n                for k, v in op.items():\n                    # Store simple attributes directly\n                    if isinstance(v, (str, int, float, bool, np.number)):\n                        op_sub_grp.attrs[k] = v\n                    else:\n                        # For complex types, serialize to JSON\n                        try:\n                            op_sub_grp.attrs[k] = json.dumps(v)\n                        except (TypeError, OverflowError) as e:\n                            logger.warning(\n                                f\"Could not serialize operation key '{k}': {e}\"\n                            )\n                            op_sub_grp.attrs[k] = str(v)\n\n        # Store frame metadata\n        if frame.metadata:\n            meta_grp = f.create_group(\"meta\")\n            # Store metadata as JSON\n            meta_grp.attrs[\"json\"] = json.dumps(frame.metadata)\n\n            # Also store individual metadata items as attributes for compatibility\n            for k, v in frame.metadata.items():\n                if isinstance(v, (str, int, float, bool, np.number)):\n                    meta_grp.attrs[k] = v\n\n    logger.info(f\"Frame saved to {path}\")\n</code></pre>"},{"location":"api/#wandas.io-modules","title":"Modules","text":""},{"location":"api/#wandas.io.readers","title":"<code>readers</code>","text":""},{"location":"api/#wandas.io.readers-attributes","title":"Attributes","text":""},{"location":"api/#wandas.io.readers.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.io.readers-classes","title":"Classes","text":""},{"location":"api/#wandas.io.readers.FileReader","title":"<code>FileReader</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for audio file readers.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>class FileReader(ABC):\n    \"\"\"Base class for audio file readers.\"\"\"\n\n    # Class attribute for supported file extensions\n    supported_extensions: list[str] = []\n\n    @classmethod\n    @abstractmethod\n    def get_file_info(cls, path: Union[str, Path], **kwargs: Any) -&gt; dict[str, Any]:\n        \"\"\"Get basic information about the audio file.\"\"\"\n        pass\n\n    @classmethod\n    @abstractmethod\n    def get_data(\n        cls,\n        path: Union[str, Path],\n        channels: list[int],\n        start_idx: int,\n        frames: int,\n        **kwargs: Any,\n    ) -&gt; ArrayLike:\n        \"\"\"Read audio data from the file.\"\"\"\n        pass\n\n    @classmethod\n    def can_read(cls, path: Union[str, Path]) -&gt; bool:\n        \"\"\"Check if this reader can handle the file based on extension.\"\"\"\n        ext = Path(path).suffix.lower()\n        return ext in cls.supported_extensions\n</code></pre> Attributes\u00b6 <code></code> <code>supported_extensions = []</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>get_file_info(path, **kwargs)</code> <code>abstractmethod</code> <code>classmethod</code> \u00b6 <p>Get basic information about the audio file.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get_file_info(cls, path: Union[str, Path], **kwargs: Any) -&gt; dict[str, Any]:\n    \"\"\"Get basic information about the audio file.\"\"\"\n    pass\n</code></pre> <code></code> <code>get_data(path, channels, start_idx, frames, **kwargs)</code> <code>abstractmethod</code> <code>classmethod</code> \u00b6 <p>Read audio data from the file.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get_data(\n    cls,\n    path: Union[str, Path],\n    channels: list[int],\n    start_idx: int,\n    frames: int,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Read audio data from the file.\"\"\"\n    pass\n</code></pre> <code></code> <code>can_read(path)</code> <code>classmethod</code> \u00b6 <p>Check if this reader can handle the file based on extension.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>@classmethod\ndef can_read(cls, path: Union[str, Path]) -&gt; bool:\n    \"\"\"Check if this reader can handle the file based on extension.\"\"\"\n    ext = Path(path).suffix.lower()\n    return ext in cls.supported_extensions\n</code></pre>"},{"location":"api/#wandas.io.readers.SoundFileReader","title":"<code>SoundFileReader</code>","text":"<p>               Bases: <code>FileReader</code></p> <p>Audio file reader using SoundFile library.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>class SoundFileReader(FileReader):\n    \"\"\"Audio file reader using SoundFile library.\"\"\"\n\n    # SoundFile supported formats\n    supported_extensions = [\".wav\", \".flac\", \".ogg\", \".aiff\", \".aif\", \".snd\"]\n\n    @classmethod\n    def get_file_info(cls, path: Union[str, Path], **kwargs: Any) -&gt; dict[str, Any]:\n        \"\"\"Get basic information about the audio file.\"\"\"\n        info = sf.info(str(path))\n        return {\n            \"samplerate\": info.samplerate,\n            \"channels\": info.channels,\n            \"frames\": info.frames,\n            \"format\": info.format,\n            \"subtype\": info.subtype,\n            \"duration\": info.frames / info.samplerate,\n        }\n\n    @classmethod\n    def get_data(\n        cls,\n        path: Union[str, Path],\n        channels: list[int],\n        start_idx: int,\n        frames: int,\n        **kwargs: Any,\n    ) -&gt; ArrayLike:\n        \"\"\"Read audio data from the file.\"\"\"\n        logger.debug(f\"Reading {frames} frames from {path} starting at {start_idx}\")\n\n        with sf.SoundFile(str(path)) as f:\n            if start_idx &gt; 0:\n                f.seek(start_idx)\n            data = f.read(frames=frames, dtype=\"float32\", always_2d=True)\n\n            # Select requested channels\n            if len(channels) &lt; f.channels:\n                data = data[:, channels]\n\n            # Transpose to get (channels, samples) format\n            result: ArrayLike = data.T\n            if not isinstance(result, np.ndarray):\n                raise ValueError(\"Unexpected data type after reading file\")\n\n        _shape = result.shape\n        logger.debug(f\"File read complete, returning data with shape {_shape}\")\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>supported_extensions = ['.wav', '.flac', '.ogg', '.aiff', '.aif', '.snd']</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>get_file_info(path, **kwargs)</code> <code>classmethod</code> \u00b6 <p>Get basic information about the audio file.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>@classmethod\ndef get_file_info(cls, path: Union[str, Path], **kwargs: Any) -&gt; dict[str, Any]:\n    \"\"\"Get basic information about the audio file.\"\"\"\n    info = sf.info(str(path))\n    return {\n        \"samplerate\": info.samplerate,\n        \"channels\": info.channels,\n        \"frames\": info.frames,\n        \"format\": info.format,\n        \"subtype\": info.subtype,\n        \"duration\": info.frames / info.samplerate,\n    }\n</code></pre> <code></code> <code>get_data(path, channels, start_idx, frames, **kwargs)</code> <code>classmethod</code> \u00b6 <p>Read audio data from the file.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>@classmethod\ndef get_data(\n    cls,\n    path: Union[str, Path],\n    channels: list[int],\n    start_idx: int,\n    frames: int,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Read audio data from the file.\"\"\"\n    logger.debug(f\"Reading {frames} frames from {path} starting at {start_idx}\")\n\n    with sf.SoundFile(str(path)) as f:\n        if start_idx &gt; 0:\n            f.seek(start_idx)\n        data = f.read(frames=frames, dtype=\"float32\", always_2d=True)\n\n        # Select requested channels\n        if len(channels) &lt; f.channels:\n            data = data[:, channels]\n\n        # Transpose to get (channels, samples) format\n        result: ArrayLike = data.T\n        if not isinstance(result, np.ndarray):\n            raise ValueError(\"Unexpected data type after reading file\")\n\n    _shape = result.shape\n    logger.debug(f\"File read complete, returning data with shape {_shape}\")\n    return result\n</code></pre>"},{"location":"api/#wandas.io.readers.CSVFileReader","title":"<code>CSVFileReader</code>","text":"<p>               Bases: <code>FileReader</code></p> <p>CSV file reader for time series data.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>class CSVFileReader(FileReader):\n    \"\"\"CSV file reader for time series data.\"\"\"\n\n    # CSV supported formats\n    supported_extensions = [\".csv\"]\n\n    @classmethod\n    def get_file_info(cls, path: Union[str, Path], **kwargs: Any) -&gt; dict[str, Any]:\n        delimiter = kwargs.get(\"delimiter\", \",\")\n        header = kwargs.get(\"header\", 0)\n        \"\"\"Get basic information about the CSV file.\"\"\"\n        # Read first few lines to determine structure\n        df = pd.read_csv(path, delimiter=delimiter, header=header)\n\n        # Estimate sampling rate from first column (assuming it's time)\n        time_column = 0\n        try:\n            time_values = np.array(df.iloc[:, time_column].values)\n            if len(time_values) &gt; 1:\n                estimated_sr = int(1 / np.mean(np.diff(time_values)))\n            else:\n                estimated_sr = 0  # Cannot determine from single row\n        except Exception:\n            estimated_sr = 0  # Default if can't calculate\n\n        frames = df.shape[0]\n        duration = frames / estimated_sr if estimated_sr &gt; 0 else None\n\n        # Return file info\n        return {\n            \"samplerate\": estimated_sr,\n            \"channels\": df.shape[1] - 1,  # Assuming first column is time\n            \"frames\": frames,\n            \"format\": \"CSV\",\n            \"duration\": duration,\n            \"ch_labels\": df.columns[1:].tolist(),  # Assuming first column is time\n        }\n\n    @classmethod\n    def get_data(\n        cls,\n        path: Union[str, Path],\n        channels: list[int],\n        start_idx: int,\n        frames: int,\n        **kwargs: Any,\n    ) -&gt; ArrayLike:\n        \"\"\"Read data from the CSV file.\"\"\"\n        logger.debug(f\"Reading CSV data from {path} starting at {start_idx}\")\n\n        # Read the CSV file\n        time_column = kwargs.get(\"time_column\", 0)\n        delimiter = kwargs.get(\"delimiter\", \",\")\n        header = kwargs.get(\"header\", 0)\n        # Read first few lines to determine structure\n        df = pd.read_csv(path, delimiter=delimiter, header=header)\n\n        # Remove time column\n        df = df.drop(\n            columns=[time_column]\n            if isinstance(time_column, str)\n            else df.columns[time_column]\n        )\n\n        # Select requested channels - adjust indices to account for time column removal\n        if channels:\n            try:\n                data_df = df.iloc[:, channels]\n            except IndexError:\n                raise ValueError(f\"Requested channels {channels} out of range\")\n        else:\n            data_df = df\n\n        # Handle start_idx and frames for partial reading\n        end_idx = start_idx + frames if frames &gt; 0 else None\n        data_df = data_df.iloc[start_idx:end_idx]\n\n        # Convert to numpy array and transpose to (channels, samples) format\n        result = data_df.values.T\n\n        if not isinstance(result, np.ndarray):\n            raise ValueError(\"Unexpected data type after reading file\")\n\n        _shape = result.shape\n        logger.debug(f\"CSV read complete, returning data with shape {_shape}\")\n        return result\n</code></pre> Attributes\u00b6 <code></code> <code>supported_extensions = ['.csv']</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>get_file_info(path, **kwargs)</code> <code>classmethod</code> \u00b6 Source code in <code>wandas/io/readers.py</code> <pre><code>@classmethod\ndef get_file_info(cls, path: Union[str, Path], **kwargs: Any) -&gt; dict[str, Any]:\n    delimiter = kwargs.get(\"delimiter\", \",\")\n    header = kwargs.get(\"header\", 0)\n    \"\"\"Get basic information about the CSV file.\"\"\"\n    # Read first few lines to determine structure\n    df = pd.read_csv(path, delimiter=delimiter, header=header)\n\n    # Estimate sampling rate from first column (assuming it's time)\n    time_column = 0\n    try:\n        time_values = np.array(df.iloc[:, time_column].values)\n        if len(time_values) &gt; 1:\n            estimated_sr = int(1 / np.mean(np.diff(time_values)))\n        else:\n            estimated_sr = 0  # Cannot determine from single row\n    except Exception:\n        estimated_sr = 0  # Default if can't calculate\n\n    frames = df.shape[0]\n    duration = frames / estimated_sr if estimated_sr &gt; 0 else None\n\n    # Return file info\n    return {\n        \"samplerate\": estimated_sr,\n        \"channels\": df.shape[1] - 1,  # Assuming first column is time\n        \"frames\": frames,\n        \"format\": \"CSV\",\n        \"duration\": duration,\n        \"ch_labels\": df.columns[1:].tolist(),  # Assuming first column is time\n    }\n</code></pre> <code></code> <code>get_data(path, channels, start_idx, frames, **kwargs)</code> <code>classmethod</code> \u00b6 <p>Read data from the CSV file.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>@classmethod\ndef get_data(\n    cls,\n    path: Union[str, Path],\n    channels: list[int],\n    start_idx: int,\n    frames: int,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Read data from the CSV file.\"\"\"\n    logger.debug(f\"Reading CSV data from {path} starting at {start_idx}\")\n\n    # Read the CSV file\n    time_column = kwargs.get(\"time_column\", 0)\n    delimiter = kwargs.get(\"delimiter\", \",\")\n    header = kwargs.get(\"header\", 0)\n    # Read first few lines to determine structure\n    df = pd.read_csv(path, delimiter=delimiter, header=header)\n\n    # Remove time column\n    df = df.drop(\n        columns=[time_column]\n        if isinstance(time_column, str)\n        else df.columns[time_column]\n    )\n\n    # Select requested channels - adjust indices to account for time column removal\n    if channels:\n        try:\n            data_df = df.iloc[:, channels]\n        except IndexError:\n            raise ValueError(f\"Requested channels {channels} out of range\")\n    else:\n        data_df = df\n\n    # Handle start_idx and frames for partial reading\n    end_idx = start_idx + frames if frames &gt; 0 else None\n    data_df = data_df.iloc[start_idx:end_idx]\n\n    # Convert to numpy array and transpose to (channels, samples) format\n    result = data_df.values.T\n\n    if not isinstance(result, np.ndarray):\n        raise ValueError(\"Unexpected data type after reading file\")\n\n    _shape = result.shape\n    logger.debug(f\"CSV read complete, returning data with shape {_shape}\")\n    return result\n</code></pre>"},{"location":"api/#wandas.io.readers-functions","title":"Functions","text":""},{"location":"api/#wandas.io.readers.get_file_reader","title":"<code>get_file_reader(path)</code>","text":"<p>Get an appropriate file reader for the given path.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>def get_file_reader(path: Union[str, Path]) -&gt; FileReader:\n    \"\"\"Get an appropriate file reader for the given path.\"\"\"\n    path_str = str(path)\n    ext = Path(path).suffix.lower()\n\n    # Try each reader in order\n    for reader in _file_readers:\n        if ext in reader.__class__.supported_extensions:\n            logger.debug(f\"Using {reader.__class__.__name__} for {path_str}\")\n            return reader\n\n    # If no reader found, raise error\n    raise ValueError(f\"No suitable file reader found for {path_str}\")\n</code></pre>"},{"location":"api/#wandas.io.readers.register_file_reader","title":"<code>register_file_reader(reader_class)</code>","text":"<p>Register a new file reader.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>def register_file_reader(reader_class: type) -&gt; None:\n    \"\"\"Register a new file reader.\"\"\"\n    reader = reader_class()\n    _file_readers.append(reader)\n    logger.debug(f\"Registered new file reader: {reader_class.__name__}\")\n</code></pre>"},{"location":"api/#wandas.io.wav_io","title":"<code>wav_io</code>","text":""},{"location":"api/#wandas.io.wav_io-attributes","title":"Attributes","text":""},{"location":"api/#wandas.io.wav_io.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.io.wav_io-classes","title":"Classes","text":""},{"location":"api/#wandas.io.wav_io-functions","title":"Functions","text":""},{"location":"api/#wandas.io.wav_io.read_wav","title":"<code>read_wav(filename, labels=None)</code>","text":"<p>Read a WAV file and create a ChannelFrame object.</p>"},{"location":"api/#wandas.io.wav_io.read_wav--parameters","title":"Parameters","text":"<p>filename : str     Path to the WAV file or URL to the WAV file. labels : list of str, optional     Labels for each channel.</p>"},{"location":"api/#wandas.io.wav_io.read_wav--returns","title":"Returns","text":"<p>ChannelFrame     ChannelFrame object containing the audio data.</p> Source code in <code>wandas/io/wav_io.py</code> <pre><code>def read_wav(filename: str, labels: Optional[list[str]] = None) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Read a WAV file and create a ChannelFrame object.\n\n    Parameters\n    ----------\n    filename : str\n        Path to the WAV file or URL to the WAV file.\n    labels : list of str, optional\n        Labels for each channel.\n\n    Returns\n    -------\n    ChannelFrame\n        ChannelFrame object containing the audio data.\n    \"\"\"\n    from wandas.frames.channel import ChannelFrame\n\n    # \u30d5\u30a1\u30a4\u30eb\u540d\u304cURL\u304b\u3069\u3046\u304b\u3092\u5224\u65ad\n    if filename.startswith(\"http://\") or filename.startswith(\"https://\"):\n        # URL\u306e\u5834\u5408\u3001requests\u3092\u4f7f\u7528\u3057\u3066\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\n\n        response = requests.get(filename)\n        file_obj = io.BytesIO(response.content)\n        file_label = os.path.basename(filename)\n        # \u30e1\u30e2\u30ea\u30de\u30c3\u30d4\u30f3\u30b0\u306f\u4f7f\u7528\u305b\u305a\u306b\u8aad\u307f\u8fbc\u3080\n        sampling_rate, data = wavfile.read(file_obj)\n    else:\n        # \u30ed\u30fc\u30ab\u30eb\u30d5\u30a1\u30a4\u30eb\u30d1\u30b9\u306e\u5834\u5408\n        file_label = os.path.basename(filename)\n        # \u30c7\u30fc\u30bf\u306e\u8aad\u307f\u8fbc\u307f\uff08\u30e1\u30e2\u30ea\u30de\u30c3\u30d4\u30f3\u30b0\u3092\u4f7f\u7528\uff09\n        sampling_rate, data = wavfile.read(filename, mmap=True)\n\n    # \u30c7\u30fc\u30bf\u3092(num_channels, num_samples)\u5f62\u72b6\u306eNumPy\u914d\u5217\u306b\u5909\u63db\n    if data.ndim == 1:\n        # \u30e2\u30ce\u30e9\u30eb\uff1a(samples,) -&gt; (1, samples)\n        data = np.expand_dims(data, axis=0)\n    else:\n        # \u30b9\u30c6\u30ec\u30aa\uff1a(samples, channels) -&gt; (channels, samples)\n        data = data.T\n\n    # NumPy\u914d\u5217\u304b\u3089ChannelFrame\u3092\u4f5c\u6210\n    channel_frame = ChannelFrame.from_numpy(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=file_label,\n        ch_labels=labels,\n    )\n\n    return channel_frame\n</code></pre>"},{"location":"api/#wandas.io.wav_io.write_wav","title":"<code>write_wav(filename, target, format=None)</code>","text":"<p>Write a ChannelFrame object to a WAV file.</p>"},{"location":"api/#wandas.io.wav_io.write_wav--parameters","title":"Parameters","text":"<p>filename : str     Path to the WAV file. target : ChannelFrame     ChannelFrame object containing the data to write. format : str, optional     File format. If None, determined from file extension.</p>"},{"location":"api/#wandas.io.wav_io.write_wav--raises","title":"Raises","text":"<p>ValueError     If target is not a ChannelFrame object.</p> Source code in <code>wandas/io/wav_io.py</code> <pre><code>def write_wav(\n    filename: str, target: \"ChannelFrame\", format: Optional[str] = None\n) -&gt; None:\n    \"\"\"\n    Write a ChannelFrame object to a WAV file.\n\n    Parameters\n    ----------\n    filename : str\n        Path to the WAV file.\n    target : ChannelFrame\n        ChannelFrame object containing the data to write.\n    format : str, optional\n        File format. If None, determined from file extension.\n\n    Raises\n    ------\n    ValueError\n        If target is not a ChannelFrame object.\n    \"\"\"\n    from wandas.frames.channel import ChannelFrame\n\n    if not isinstance(target, ChannelFrame):\n        raise ValueError(\"target must be a ChannelFrame object.\")\n\n    logger.debug(f\"Saving audio data to file: {filename} (will compute now)\")\n    data = target.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    if data.dtype == float and max([np.abs(data.max()), np.abs(data.min())]) &lt; 1:\n        sf.write(\n            str(filename),\n            data,\n            int(target.sampling_rate),\n            subtype=\"FLOAT\",\n            format=format,\n        )\n    else:\n        sf.write(str(filename), data, int(target.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {filename}\")\n</code></pre>"},{"location":"api/#wandas.io.wdf_io","title":"<code>wdf_io</code>","text":"<p>WDF (Wandas Data File) I/O module for saving and loading ChannelFrame objects.</p> <p>This module provides functionality to save and load ChannelFrame objects in the WDF (Wandas Data File) format, which is based on HDF5. The format preserves all metadata including sampling rate, channel labels, units, and frame metadata.</p>"},{"location":"api/#wandas.io.wdf_io-attributes","title":"Attributes","text":""},{"location":"api/#wandas.io.wdf_io.da_from_array","title":"<code>da_from_array = da.from_array</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.io.wdf_io.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.io.wdf_io.WDF_FORMAT_VERSION","title":"<code>WDF_FORMAT_VERSION = '0.1'</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.io.wdf_io-classes","title":"Classes","text":""},{"location":"api/#wandas.io.wdf_io-functions","title":"Functions","text":""},{"location":"api/#wandas.io.wdf_io.save","title":"<code>save(frame, path, *, format='hdf5', compress='gzip', overwrite=False, dtype=None)</code>","text":"<p>Save a frame to a file.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>BaseFrame[Any]</code> <p>The frame to save.</p> required <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file. '.wdf' extension will be added if not present.</p> required <code>format</code> <code>str</code> <p>Format to use (currently only 'hdf5' is supported)</p> <code>'hdf5'</code> <code>compress</code> <code>Optional[str]</code> <p>Compression method ('gzip' by default, None for no compression)</p> <code>'gzip'</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing file</p> <code>False</code> <code>dtype</code> <code>Optional[Union[str, dtype[Any]]]</code> <p>Optional data type conversion before saving (e.g. 'float32')</p> <code>None</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If the file exists and overwrite=False.</p> <code>NotImplementedError</code> <p>For unsupported formats.</p> Source code in <code>wandas/io/wdf_io.py</code> <pre><code>def save(\n    frame: BaseFrame[Any],\n    path: Union[str, Path],\n    *,\n    format: str = \"hdf5\",\n    compress: Optional[str] = \"gzip\",\n    overwrite: bool = False,\n    dtype: Optional[Union[str, np.dtype[Any]]] = None,\n) -&gt; None:\n    \"\"\"Save a frame to a file.\n\n    Args:\n        frame: The frame to save.\n        path: Path to save the file. '.wdf' extension will be added if not present.\n        format: Format to use (currently only 'hdf5' is supported)\n        compress: Compression method ('gzip' by default, None for no compression)\n        overwrite: Whether to overwrite existing file\n        dtype: Optional data type conversion before saving (e.g. 'float32')\n\n    Raises:\n        FileExistsError: If the file exists and overwrite=False.\n        NotImplementedError: For unsupported formats.\n    \"\"\"\n    # Handle path\n    path = Path(path)\n    if path.suffix != \".wdf\":\n        path = path.with_suffix(\".wdf\")\n\n    # Check if file exists\n    if path.exists() and not overwrite:\n        raise FileExistsError(\n            f\"File {path} already exists. Set overwrite=True to overwrite.\"\n        )\n\n    # Currently only HDF5 is supported\n    if format.lower() != \"hdf5\":\n        raise NotImplementedError(\n            f\"Format {format} not supported. Only 'hdf5' is currently implemented.\"\n        )\n\n    # Compute data arrays (this triggers actual computation)\n    logger.info(\"Computing data arrays for saving...\")\n    computed_data = frame.compute()\n    if dtype is not None:\n        computed_data = computed_data.astype(dtype)\n\n    # Create file\n    logger.info(f\"Creating HDF5 file at {path}...\")\n    with h5py.File(path, \"w\") as f:\n        # Set file version\n        f.attrs[\"version\"] = WDF_FORMAT_VERSION\n\n        # Store frame metadata\n        f.attrs[\"sampling_rate\"] = frame.sampling_rate\n        f.attrs[\"label\"] = frame.label or \"\"\n        f.attrs[\"frame_type\"] = type(frame).__name__\n\n        # Create channels group\n        channels_grp = f.create_group(\"channels\")\n\n        # Store each channel\n        for i, (channel_data, ch_meta) in enumerate(\n            zip(computed_data, frame._channel_metadata)\n        ):\n            ch_grp = channels_grp.create_group(f\"{i}\")\n\n            # Store channel data\n            if compress:\n                ch_grp.create_dataset(\"data\", data=channel_data, compression=compress)\n            else:\n                ch_grp.create_dataset(\"data\", data=channel_data)\n\n            # Store metadata\n            ch_grp.attrs[\"label\"] = ch_meta.label\n            ch_grp.attrs[\"unit\"] = ch_meta.unit\n\n            # Store extra metadata as JSON\n            if ch_meta.extra:\n                ch_grp.attrs[\"metadata_json\"] = json.dumps(ch_meta.extra)\n\n        # Store operation history\n        if frame.operation_history:\n            op_grp = f.create_group(\"operation_history\")\n            for i, op in enumerate(frame.operation_history):\n                op_sub_grp = op_grp.create_group(f\"operation_{i}\")\n                for k, v in op.items():\n                    # Store simple attributes directly\n                    if isinstance(v, (str, int, float, bool, np.number)):\n                        op_sub_grp.attrs[k] = v\n                    else:\n                        # For complex types, serialize to JSON\n                        try:\n                            op_sub_grp.attrs[k] = json.dumps(v)\n                        except (TypeError, OverflowError) as e:\n                            logger.warning(\n                                f\"Could not serialize operation key '{k}': {e}\"\n                            )\n                            op_sub_grp.attrs[k] = str(v)\n\n        # Store frame metadata\n        if frame.metadata:\n            meta_grp = f.create_group(\"meta\")\n            # Store metadata as JSON\n            meta_grp.attrs[\"json\"] = json.dumps(frame.metadata)\n\n            # Also store individual metadata items as attributes for compatibility\n            for k, v in frame.metadata.items():\n                if isinstance(v, (str, int, float, bool, np.number)):\n                    meta_grp.attrs[k] = v\n\n    logger.info(f\"Frame saved to {path}\")\n</code></pre>"},{"location":"api/#wandas.io.wdf_io.load","title":"<code>load(path, *, format='hdf5')</code>","text":"<p>Load a ChannelFrame object from a WDF (Wandas Data File) file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the WDF file to load.</p> required <code>format</code> <code>str</code> <p>Format of the file. Currently only \"hdf5\" is supported.</p> <code>'hdf5'</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame object with data and metadata loaded from the file.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> <code>NotImplementedError</code> <p>If format is not \"hdf5\".</p> <code>ValueError</code> <p>If the file format is invalid or incompatible.</p> Example <p>cf = ChannelFrame.load(\"audio_data.wdf\")</p> Source code in <code>wandas/io/wdf_io.py</code> <pre><code>def load(path: Union[str, Path], *, format: str = \"hdf5\") -&gt; \"ChannelFrame\":\n    \"\"\"Load a ChannelFrame object from a WDF (Wandas Data File) file.\n\n    Args:\n        path: Path to the WDF file to load.\n        format: Format of the file. Currently only \"hdf5\" is supported.\n\n    Returns:\n        A new ChannelFrame object with data and metadata loaded from the file.\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist.\n        NotImplementedError: If format is not \"hdf5\".\n        ValueError: If the file format is invalid or incompatible.\n\n    Example:\n        &gt;&gt;&gt; cf = ChannelFrame.load(\"audio_data.wdf\")\n    \"\"\"\n    # Ensure ChannelFrame is imported here to avoid circular imports\n    from ..core.metadata import ChannelMetadata\n    from ..frames.channel import ChannelFrame\n\n    if format != \"hdf5\":\n        raise NotImplementedError(f\"Format '{format}' is not supported\")\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    logger.debug(f\"Loading ChannelFrame from {path}\")\n\n    with h5py.File(path, \"r\") as f:\n        # Check format version for compatibility\n        version = f.attrs.get(\"version\", \"unknown\")\n        if version != WDF_FORMAT_VERSION:\n            logger.warning(\n                f\"File format version mismatch: file={version}, current={WDF_FORMAT_VERSION}\"  # noqa: E501\n            )\n\n        # Get global attributes\n        sampling_rate = float(f.attrs[\"sampling_rate\"])\n        frame_label = f.attrs.get(\"label\", \"\")\n\n        # Get frame metadata\n        frame_metadata = {}\n        if \"meta\" in f:\n            meta_json = f[\"meta\"].attrs.get(\"json\", \"{}\")\n            frame_metadata = json.loads(meta_json)\n\n        # Load channel data and metadata\n        all_channel_data = []\n        channel_metadata_list = []\n\n        if \"channels\" in f:\n            channels_group = f[\"channels\"]\n            # Sort channel indices numerically\n            channel_indices = sorted([int(key) for key in channels_group.keys()])\n\n            for idx in channel_indices:\n                ch_group = channels_group[f\"{idx}\"]\n\n                # Load channel data\n                channel_data = ch_group[\"data\"][()]\n\n                # Append to combined array\n                all_channel_data.append(channel_data)\n\n                # Load channel metadata\n                label = ch_group.attrs.get(\"label\", f\"Ch{idx}\")\n                unit = ch_group.attrs.get(\"unit\", \"\")\n\n                # Load additional metadata if present\n                ch_extra = {}\n                if \"metadata_json\" in ch_group.attrs:\n                    ch_extra = json.loads(ch_group.attrs[\"metadata_json\"])\n\n                # Create ChannelMetadata object\n                channel_metadata = ChannelMetadata(\n                    label=label, unit=unit, extra=ch_extra\n                )\n                channel_metadata_list.append(channel_metadata)\n\n        # Stack channel data into a single array\n        if all_channel_data:\n            combined_data = np.stack(all_channel_data, axis=0)\n        else:\n            raise ValueError(\"No channel data found in the file\")\n\n        # Create a new ChannelFrame\n        dask_data = da_from_array(combined_data)\n\n        cf = ChannelFrame(\n            data=dask_data,\n            sampling_rate=sampling_rate,\n            label=frame_label if frame_label else None,\n            metadata=frame_metadata,\n            channel_metadata=channel_metadata_list,\n        )\n\n        logger.debug(\n            f\"ChannelFrame loaded from {path}: {len(cf)} channels, {cf.n_samples} samples\"  # noqa: E501\n        )\n        return cf\n</code></pre>"},{"location":"api/#_5","title":"\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u30e2\u30b8\u30e5\u30fc\u30eb","text":"<p>\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u88dc\u52a9\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/#wandas.utils","title":"<code>wandas.utils</code>","text":""},{"location":"api/#wandas.utils-attributes","title":"Attributes","text":""},{"location":"api/#wandas.utils.__all__","title":"<code>__all__ = ['filter_kwargs', 'accepted_kwargs']</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.utils-functions","title":"Functions","text":""},{"location":"api/#wandas.utils.accepted_kwargs","title":"<code>accepted_kwargs(func)</code>","text":"<p>Get the set of explicit keyword arguments accepted by a function and whether it accepts **kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any]</code> <p>The function to inspect.</p> required <p>Returns:</p> Type Description <code>set[str]</code> <p>A tuple containing:</p> <code>bool</code> <ul> <li>set[str]: Set of explicit keyword argument names accepted by func.</li> </ul> <code>tuple[set[str], bool]</code> <ul> <li>bool: Whether the function accepts variable keyword arguments (**kwargs).</li> </ul> Source code in <code>wandas/utils/introspection.py</code> <pre><code>def accepted_kwargs(func: Callable[..., Any]) -&gt; tuple[set[str], bool]:\n    \"\"\"\n    Get the set of explicit keyword arguments accepted by\n    a function and whether it accepts **kwargs.\n\n    Args:\n        func: The function to inspect.\n\n    Returns:\n        A tuple containing:\n        - set[str]: Set of explicit keyword argument names accepted by func.\n        - bool: Whether the function accepts variable keyword arguments (**kwargs).\n    \"\"\"\n    # \u30e2\u30c3\u30af\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u5834\u5408\u306f\u7a7a\u30bb\u30c3\u30c8\u3068\u7121\u5236\u9650\u30d5\u30e9\u30b0\u3092\u8fd4\u3059\n    if hasattr(func, \"__module__\") and func.__module__ == \"unittest.mock\":\n        return set(), True\n    try:\n        params = signature(func).parameters.values()\n\n        # \u660e\u793a\u7684\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u5f15\u6570\u3092\u53ce\u96c6\n        explicit_kwargs = {\n            p.name\n            for p in params\n            if p.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY)\n        }\n\n        # **kwargs\u3092\u53d7\u3051\u4ed8\u3051\u308b\u304b\u3069\u3046\u304b\u306e\u30d5\u30e9\u30b0\n        has_var_kwargs = any(p.kind is Parameter.VAR_KEYWORD for p in params)\n\n        return explicit_kwargs, has_var_kwargs\n    except (ValueError, TypeError):\n        # \u30b7\u30b0\u30cd\u30c1\u30e3\u3092\u53d6\u5f97\u3067\u304d\u306a\u3044\u5834\u5408\u306f\u7a7a\u30bb\u30c3\u30c8\u3068\u7121\u5236\u9650\u30d5\u30e9\u30b0\u3092\u8fd4\u3059\n        return set(), True\n</code></pre>"},{"location":"api/#wandas.utils.filter_kwargs","title":"<code>filter_kwargs(func, kwargs, *, strict_mode=False)</code>","text":"<p>Filter keyword arguments to only those accepted by the function.</p> <p>This function examines the signature of <code>func</code> and returns a dictionary containing only the key-value pairs from <code>kwargs</code> that are valid keyword arguments for <code>func</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any]</code> <p>The function to filter keyword arguments for.</p> required <code>kwargs</code> <code>Mapping[str, Any]</code> <p>The keyword arguments to filter.</p> required <code>strict_mode</code> <code>bool</code> <p>If True, only explicitly defined parameters are passed even when the function accepts kwargs. If False (default), all parameters are passed to functions that accept kwargs, but a warning is issued for parameters not explicitly defined.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing only the key-value pairs that are valid for <code>func</code>.</p> Source code in <code>wandas/utils/introspection.py</code> <pre><code>def filter_kwargs(\n    func: Callable[..., Any],\n    kwargs: Mapping[str, Any],\n    *,\n    strict_mode: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Filter keyword arguments to only those accepted by the function.\n\n    This function examines the signature of `func` and returns a dictionary\n    containing only the key-value pairs from `kwargs` that are valid keyword\n    arguments for `func`.\n\n    Args:\n        func: The function to filter keyword arguments for.\n        kwargs: The keyword arguments to filter.\n        strict_mode: If True, only explicitly defined parameters are passed even when\n            the function accepts **kwargs. If False (default), all parameters are\n            passed to functions that accept **kwargs, but a warning is issued for\n            parameters not explicitly defined.\n\n    Returns:\n        A dictionary containing only the key-value pairs that are valid for `func`.\n    \"\"\"\n    explicit_params, accepts_var_kwargs = accepted_kwargs(func)\n\n    # **kwargs\u3092\u53d7\u3051\u4ed8\u3051\u306a\u3044\u5834\u5408\u3001\u307e\u305f\u306f strict_mode \u304c True \u306e\u5834\u5408\u306f\u3001\n    # \u660e\u793a\u7684\u306a\u30d1\u30e9\u30e1\u30fc\u30bf\u306e\u307f\u3092\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\n    if not accepts_var_kwargs or strict_mode:\n        filtered = {k: v for k, v in kwargs.items() if k in explicit_params}\n        return filtered\n\n    # **kwargs\u3092\u53d7\u3051\u4ed8\u3051\u308b\u5834\u5408\uff08strict_mode\u304cFalse\u306e\u5834\u5408\uff09\u306f\u5168\u30ad\u30fc\u3092\u8a31\u53ef\n    # \u305f\u3060\u3057\u3001\u660e\u793a\u7684\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u306a\u3044\u30ad\u30fc\u306b\u306f\u8b66\u544a\u3092\u51fa\u3059\n    unknown = set(kwargs) - explicit_params\n    if unknown:\n        warnings.warn(\n            f\"Implicit kwargs for {func.__name__}: {unknown}\",\n            UserWarning,\n            stacklevel=2,\n        )\n    return dict(kwargs)\n</code></pre>"},{"location":"api/#wandas.utils-modules","title":"Modules","text":""},{"location":"api/#wandas.utils.frame_dataset","title":"<code>frame_dataset</code>","text":""},{"location":"api/#wandas.utils.frame_dataset-attributes","title":"Attributes","text":""},{"location":"api/#wandas.utils.frame_dataset.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.utils.frame_dataset.FrameType","title":"<code>FrameType = Union[ChannelFrame, SpectrogramFrame]</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.utils.frame_dataset.F","title":"<code>F = TypeVar('F', bound=FrameType)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.utils.frame_dataset.F_out","title":"<code>F_out = TypeVar('F_out', bound=FrameType)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.utils.frame_dataset-classes","title":"Classes","text":""},{"location":"api/#wandas.utils.frame_dataset.LazyFrame","title":"<code>LazyFrame</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[F]</code></p> <p>A class that encapsulates a frame and its loading state.</p> <p>Attributes:</p> Name Type Description <code>file_path</code> <code>Path</code> <p>File path associated with the frame</p> <code>frame</code> <code>Optional[F]</code> <p>Loaded frame object (None if not loaded)</p> <code>is_loaded</code> <code>bool</code> <p>Flag indicating if the frame is loaded</p> <code>load_attempted</code> <code>bool</code> <p>Flag indicating if loading was attempted (for error detection)</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>@dataclass\nclass LazyFrame(Generic[F]):\n    \"\"\"\n    A class that encapsulates a frame and its loading state.\n\n    Attributes:\n        file_path: File path associated with the frame\n        frame: Loaded frame object (None if not loaded)\n        is_loaded: Flag indicating if the frame is loaded\n        load_attempted: Flag indicating if loading was attempted (for error detection)\n    \"\"\"\n\n    file_path: Path\n    frame: Optional[F] = None\n    is_loaded: bool = False\n    load_attempted: bool = False\n\n    def ensure_loaded(self, loader: Callable[[Path], Optional[F]]) -&gt; Optional[F]:\n        \"\"\"\n        Ensures the frame is loaded, loading it if necessary.\n\n        Args:\n            loader: Function to load a frame from a file path\n\n        Returns:\n            The loaded frame, or None if loading failed\n        \"\"\"\n        # Return the current frame if already loaded\n        if self.is_loaded:\n            return self.frame\n\n        # Attempt to load if not loaded yet\n        try:\n            self.load_attempted = True\n            self.frame = loader(self.file_path)\n            self.is_loaded = True\n            return self.frame\n        except Exception as e:\n            logger.error(f\"Failed to load file {self.file_path}: {str(e)}\")\n            self.is_loaded = True  # Loading was attempted\n            self.frame = None\n            return None\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Reset the frame state.\n        \"\"\"\n        self.frame = None\n        self.is_loaded = False\n        self.load_attempted = False\n</code></pre> Attributes\u00b6 <code></code> <code>file_path</code> <code>instance-attribute</code> \u00b6 <code></code> <code>frame = None</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>is_loaded = False</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code></code> <code>load_attempted = False</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(file_path, frame=None, is_loaded=False, load_attempted=False)</code> \u00b6 <code></code> <code>ensure_loaded(loader)</code> \u00b6 <p>Ensures the frame is loaded, loading it if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>Callable[[Path], Optional[F]]</code> <p>Function to load a frame from a file path</p> required <p>Returns:</p> Type Description <code>Optional[F]</code> <p>The loaded frame, or None if loading failed</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def ensure_loaded(self, loader: Callable[[Path], Optional[F]]) -&gt; Optional[F]:\n    \"\"\"\n    Ensures the frame is loaded, loading it if necessary.\n\n    Args:\n        loader: Function to load a frame from a file path\n\n    Returns:\n        The loaded frame, or None if loading failed\n    \"\"\"\n    # Return the current frame if already loaded\n    if self.is_loaded:\n        return self.frame\n\n    # Attempt to load if not loaded yet\n    try:\n        self.load_attempted = True\n        self.frame = loader(self.file_path)\n        self.is_loaded = True\n        return self.frame\n    except Exception as e:\n        logger.error(f\"Failed to load file {self.file_path}: {str(e)}\")\n        self.is_loaded = True  # Loading was attempted\n        self.frame = None\n        return None\n</code></pre> <code></code> <code>reset()</code> \u00b6 <p>Reset the frame state.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Reset the frame state.\n    \"\"\"\n    self.frame = None\n    self.is_loaded = False\n    self.load_attempted = False\n</code></pre>"},{"location":"api/#wandas.utils.frame_dataset.FrameDataset","title":"<code>FrameDataset</code>","text":"<p>               Bases: <code>Generic[F]</code>, <code>ABC</code></p> <p>Abstract base dataset class for processing files in a folder. Includes lazy loading capability to efficiently handle large datasets. Subclasses handle specific frame types (ChannelFrame, SpectrogramFrame, etc.).</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>class FrameDataset(Generic[F], ABC):\n    \"\"\"\n    Abstract base dataset class for processing files in a folder.\n    Includes lazy loading capability to efficiently handle large datasets.\n    Subclasses handle specific frame types (ChannelFrame, SpectrogramFrame, etc.).\n    \"\"\"\n\n    def __init__(\n        self,\n        folder_path: str,\n        sampling_rate: Optional[int] = None,\n        signal_length: Optional[int] = None,\n        file_extensions: Optional[list[str]] = None,\n        lazy_loading: bool = True,\n        recursive: bool = False,\n        source_dataset: Optional[\"FrameDataset[Any]\"] = None,\n        transform: Optional[Callable[[Any], Optional[F]]] = None,\n    ):\n        self.folder_path = Path(folder_path)\n        if source_dataset is None and not self.folder_path.exists():\n            raise FileNotFoundError(f\"Folder does not exist: {self.folder_path}\")\n\n        self.sampling_rate = sampling_rate\n        self.signal_length = signal_length\n        self.file_extensions = file_extensions or [\".wav\"]\n        self._recursive = recursive\n        self._lazy_loading = lazy_loading\n\n        # Changed to a list of LazyFrame\n        self._lazy_frames: list[LazyFrame[F]] = []\n\n        self._source_dataset = source_dataset\n        self._transform = transform\n\n        if self._source_dataset:\n            self._initialize_from_source()\n        else:\n            self._initialize_from_folder()\n\n    def _initialize_from_source(self) -&gt; None:\n        \"\"\"Initialize from a source dataset.\"\"\"\n        if self._source_dataset is None:\n            return\n\n        # Copy file paths from source\n        file_paths = self._source_dataset._get_file_paths()\n        self._lazy_frames = [LazyFrame(file_path) for file_path in file_paths]\n\n        # Inherit other properties\n        self.sampling_rate = self.sampling_rate or self._source_dataset.sampling_rate\n        self.signal_length = self.signal_length or self._source_dataset.signal_length\n        self.file_extensions = (\n            self.file_extensions or self._source_dataset.file_extensions\n        )\n        self._recursive = self._source_dataset._recursive\n        self.folder_path = self._source_dataset.folder_path\n\n    def _initialize_from_folder(self) -&gt; None:\n        \"\"\"Initialize from a folder.\"\"\"\n        self._discover_files()\n        if not self._lazy_loading:\n            self._load_all_files()\n\n    def _discover_files(self) -&gt; None:\n        \"\"\"Discover files in the folder and store them in a list of LazyFrame.\"\"\"\n        file_paths = []\n        for ext in self.file_extensions:\n            pattern = f\"**/*{ext}\" if self._recursive else f\"*{ext}\"\n            file_paths.extend(\n                sorted(p for p in self.folder_path.glob(pattern) if p.is_file())\n            )\n\n        # Remove duplicates and sort\n        file_paths = sorted(list(set(file_paths)))\n\n        # Create a list of LazyFrame\n        self._lazy_frames = [LazyFrame(file_path) for file_path in file_paths]\n\n    def _load_all_files(self) -&gt; None:\n        \"\"\"Load all files.\"\"\"\n        for i in tqdm(range(len(self._lazy_frames)), desc=\"Loading/transforming\"):\n            try:\n                self._ensure_loaded(i)\n            except Exception as e:\n                filepath = self._lazy_frames[i].file_path\n                logger.warning(\n                    f\"Failed to load/transform index {i} ({filepath}): {str(e)}\"\n                )\n        self._lazy_loading = False\n\n    @abstractmethod\n    def _load_file(self, file_path: Path) -&gt; Optional[F]:\n        \"\"\"Abstract method to load a frame from a file.\"\"\"\n        pass\n\n    def _load_from_source(self, index: int) -&gt; Optional[F]:\n        \"\"\"Load a frame from the source dataset and transform it if necessary.\"\"\"\n        if self._source_dataset is None or self._transform is None:\n            return None\n\n        source_frame = self._source_dataset._ensure_loaded(index)\n        if source_frame is None:\n            return None\n\n        try:\n            return self._transform(source_frame)\n        except Exception as e:\n            logger.warning(f\"Failed to transform index {index}: {str(e)}\")\n            return None\n\n    def _ensure_loaded(self, index: int) -&gt; Optional[F]:\n        \"\"\"Ensure the frame at the given index is loaded.\"\"\"\n        if not (0 &lt;= index &lt; len(self._lazy_frames)):\n            raise IndexError(\n                f\"Index {index} is out of range (0-{len(self._lazy_frames) - 1})\"\n            )\n\n        lazy_frame = self._lazy_frames[index]\n\n        # Return if already loaded\n        if lazy_frame.is_loaded:\n            return lazy_frame.frame\n\n        try:\n            # Convert from source dataset\n            if self._transform and self._source_dataset:\n                lazy_frame.load_attempted = True\n                frame = self._load_from_source(index)\n                lazy_frame.frame = frame\n                lazy_frame.is_loaded = True\n                return frame\n            # Load directly from file\n            else:\n                return lazy_frame.ensure_loaded(self._load_file)\n        except Exception as e:\n            f_path = lazy_frame.file_path\n            logger.error(\n                f\"Failed to load or initialize index {index} ({f_path}): {str(e)}\"\n            )\n            lazy_frame.frame = None\n            lazy_frame.is_loaded = True\n            lazy_frame.load_attempted = True\n            return None\n\n    def _get_file_paths(self) -&gt; list[Path]:\n        \"\"\"Get a list of file paths.\"\"\"\n        return [lazy_frame.file_path for lazy_frame in self._lazy_frames]\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of files in the dataset.\"\"\"\n        return len(self._lazy_frames)\n\n    def __getitem__(self, index: int) -&gt; Optional[F]:\n        \"\"\"Get the frame at the specified index.\"\"\"\n        return self._ensure_loaded(index)\n\n    @overload\n    def apply(self, func: Callable[[F], Optional[F_out]]) -&gt; \"FrameDataset[F_out]\": ...\n\n    @overload\n    def apply(self, func: Callable[[F], Optional[Any]]) -&gt; \"FrameDataset[Any]\": ...\n\n    def apply(self, func: Callable[[F], Optional[Any]]) -&gt; \"FrameDataset[Any]\":\n        \"\"\"Apply a function to the entire dataset to create a new dataset.\"\"\"\n        new_dataset = type(self)(\n            folder_path=str(self.folder_path),\n            lazy_loading=True,\n            source_dataset=self,\n            transform=func,\n            sampling_rate=self.sampling_rate,\n            signal_length=self.signal_length,\n            file_extensions=self.file_extensions,\n            recursive=self._recursive,\n        )\n        return cast(\"FrameDataset[Any]\", new_dataset)\n\n    def save(self, output_folder: str, filename_prefix: str = \"\") -&gt; None:\n        \"\"\"Save processed frames to files.\"\"\"\n        raise NotImplementedError(\"The save method is not currently implemented.\")\n\n    def sample(\n        self,\n        n: Optional[int] = None,\n        ratio: Optional[float] = None,\n        seed: Optional[int] = None,\n    ) -&gt; \"FrameDataset[F]\":\n        \"\"\"Get a sample from the dataset.\"\"\"\n        if seed is not None:\n            random.seed(seed)\n\n        total = len(self._lazy_frames)\n        if total == 0:\n            return type(self)(\n                str(self.folder_path),\n                sampling_rate=self.sampling_rate,\n                signal_length=self.signal_length,\n                file_extensions=self.file_extensions,\n                lazy_loading=self._lazy_loading,\n                recursive=self._recursive,\n            )\n\n        # Determine sample size\n        if n is None and ratio is None:\n            n = max(1, min(10, int(total * 0.1)))\n        elif n is None and ratio is not None:\n            n = max(1, int(total * ratio))\n        elif n is not None:\n            n = max(1, n)\n        else:\n            n = 1\n\n        n = min(n, total)\n\n        # Randomly select indices\n        sampled_indices = sorted(random.sample(range(total), n))\n\n        return _SampledFrameDataset(self, sampled_indices)\n\n    def get_metadata(self) -&gt; dict[str, Any]:\n        \"\"\"Get metadata for the dataset.\"\"\"\n        actual_sr: Optional[Union[int, float]] = self.sampling_rate\n        frame_type_name = \"Unknown\"\n\n        # Count loaded frames\n        loaded_count = sum(\n            1 for lazy_frame in self._lazy_frames if lazy_frame.is_loaded\n        )\n\n        # Get metadata from the first frame (if possible)\n        first_frame: Optional[F] = None\n        if len(self._lazy_frames) &gt; 0:\n            try:\n                if self._lazy_frames[0].is_loaded:\n                    first_frame = self._lazy_frames[0].frame\n\n                if first_frame:\n                    actual_sr = getattr(\n                        first_frame, \"sampling_rate\", self.sampling_rate\n                    )\n                    frame_type_name = type(first_frame).__name__\n            except Exception as e:\n                logger.warning(\n                    f\"Error accessing the first frame during metadata retrieval: {e}\"\n                )\n\n        return {\n            \"folder_path\": str(self.folder_path),\n            \"file_count\": len(self._lazy_frames),\n            \"loaded_count\": loaded_count,\n            \"target_sampling_rate\": self.sampling_rate,\n            \"actual_sampling_rate\": actual_sr,\n            \"signal_length\": self.signal_length,\n            \"file_extensions\": self.file_extensions,\n            \"lazy_loading\": self._lazy_loading,\n            \"recursive\": self._recursive,\n            \"frame_type\": frame_type_name,\n            \"has_transform\": self._transform is not None,\n            \"is_sampled\": isinstance(self, _SampledFrameDataset),\n        }\n</code></pre> Attributes\u00b6 <code></code> <code>folder_path = Path(folder_path)</code> <code>instance-attribute</code> \u00b6 <code></code> <code>sampling_rate = sampling_rate</code> <code>instance-attribute</code> \u00b6 <code></code> <code>signal_length = signal_length</code> <code>instance-attribute</code> \u00b6 <code></code> <code>file_extensions = file_extensions or ['.wav']</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>__init__(folder_path, sampling_rate=None, signal_length=None, file_extensions=None, lazy_loading=True, recursive=False, source_dataset=None, transform=None)</code> \u00b6 Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def __init__(\n    self,\n    folder_path: str,\n    sampling_rate: Optional[int] = None,\n    signal_length: Optional[int] = None,\n    file_extensions: Optional[list[str]] = None,\n    lazy_loading: bool = True,\n    recursive: bool = False,\n    source_dataset: Optional[\"FrameDataset[Any]\"] = None,\n    transform: Optional[Callable[[Any], Optional[F]]] = None,\n):\n    self.folder_path = Path(folder_path)\n    if source_dataset is None and not self.folder_path.exists():\n        raise FileNotFoundError(f\"Folder does not exist: {self.folder_path}\")\n\n    self.sampling_rate = sampling_rate\n    self.signal_length = signal_length\n    self.file_extensions = file_extensions or [\".wav\"]\n    self._recursive = recursive\n    self._lazy_loading = lazy_loading\n\n    # Changed to a list of LazyFrame\n    self._lazy_frames: list[LazyFrame[F]] = []\n\n    self._source_dataset = source_dataset\n    self._transform = transform\n\n    if self._source_dataset:\n        self._initialize_from_source()\n    else:\n        self._initialize_from_folder()\n</code></pre> <code></code> <code>__len__()</code> \u00b6 <p>Return the number of files in the dataset.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of files in the dataset.\"\"\"\n    return len(self._lazy_frames)\n</code></pre> <code></code> <code>__getitem__(index)</code> \u00b6 <p>Get the frame at the specified index.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def __getitem__(self, index: int) -&gt; Optional[F]:\n    \"\"\"Get the frame at the specified index.\"\"\"\n    return self._ensure_loaded(index)\n</code></pre> <code></code> <code>apply(func)</code> \u00b6 <pre><code>apply(\n    func: Callable[[F], Optional[F_out]],\n) -&gt; FrameDataset[F_out]\n</code></pre><pre><code>apply(\n    func: Callable[[F], Optional[Any]],\n) -&gt; FrameDataset[Any]\n</code></pre> <p>Apply a function to the entire dataset to create a new dataset.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def apply(self, func: Callable[[F], Optional[Any]]) -&gt; \"FrameDataset[Any]\":\n    \"\"\"Apply a function to the entire dataset to create a new dataset.\"\"\"\n    new_dataset = type(self)(\n        folder_path=str(self.folder_path),\n        lazy_loading=True,\n        source_dataset=self,\n        transform=func,\n        sampling_rate=self.sampling_rate,\n        signal_length=self.signal_length,\n        file_extensions=self.file_extensions,\n        recursive=self._recursive,\n    )\n    return cast(\"FrameDataset[Any]\", new_dataset)\n</code></pre> <code></code> <code>save(output_folder, filename_prefix='')</code> \u00b6 <p>Save processed frames to files.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def save(self, output_folder: str, filename_prefix: str = \"\") -&gt; None:\n    \"\"\"Save processed frames to files.\"\"\"\n    raise NotImplementedError(\"The save method is not currently implemented.\")\n</code></pre> <code></code> <code>sample(n=None, ratio=None, seed=None)</code> \u00b6 <p>Get a sample from the dataset.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def sample(\n    self,\n    n: Optional[int] = None,\n    ratio: Optional[float] = None,\n    seed: Optional[int] = None,\n) -&gt; \"FrameDataset[F]\":\n    \"\"\"Get a sample from the dataset.\"\"\"\n    if seed is not None:\n        random.seed(seed)\n\n    total = len(self._lazy_frames)\n    if total == 0:\n        return type(self)(\n            str(self.folder_path),\n            sampling_rate=self.sampling_rate,\n            signal_length=self.signal_length,\n            file_extensions=self.file_extensions,\n            lazy_loading=self._lazy_loading,\n            recursive=self._recursive,\n        )\n\n    # Determine sample size\n    if n is None and ratio is None:\n        n = max(1, min(10, int(total * 0.1)))\n    elif n is None and ratio is not None:\n        n = max(1, int(total * ratio))\n    elif n is not None:\n        n = max(1, n)\n    else:\n        n = 1\n\n    n = min(n, total)\n\n    # Randomly select indices\n    sampled_indices = sorted(random.sample(range(total), n))\n\n    return _SampledFrameDataset(self, sampled_indices)\n</code></pre> <code></code> <code>get_metadata()</code> \u00b6 <p>Get metadata for the dataset.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def get_metadata(self) -&gt; dict[str, Any]:\n    \"\"\"Get metadata for the dataset.\"\"\"\n    actual_sr: Optional[Union[int, float]] = self.sampling_rate\n    frame_type_name = \"Unknown\"\n\n    # Count loaded frames\n    loaded_count = sum(\n        1 for lazy_frame in self._lazy_frames if lazy_frame.is_loaded\n    )\n\n    # Get metadata from the first frame (if possible)\n    first_frame: Optional[F] = None\n    if len(self._lazy_frames) &gt; 0:\n        try:\n            if self._lazy_frames[0].is_loaded:\n                first_frame = self._lazy_frames[0].frame\n\n            if first_frame:\n                actual_sr = getattr(\n                    first_frame, \"sampling_rate\", self.sampling_rate\n                )\n                frame_type_name = type(first_frame).__name__\n        except Exception as e:\n            logger.warning(\n                f\"Error accessing the first frame during metadata retrieval: {e}\"\n            )\n\n    return {\n        \"folder_path\": str(self.folder_path),\n        \"file_count\": len(self._lazy_frames),\n        \"loaded_count\": loaded_count,\n        \"target_sampling_rate\": self.sampling_rate,\n        \"actual_sampling_rate\": actual_sr,\n        \"signal_length\": self.signal_length,\n        \"file_extensions\": self.file_extensions,\n        \"lazy_loading\": self._lazy_loading,\n        \"recursive\": self._recursive,\n        \"frame_type\": frame_type_name,\n        \"has_transform\": self._transform is not None,\n        \"is_sampled\": isinstance(self, _SampledFrameDataset),\n    }\n</code></pre>"},{"location":"api/#wandas.utils.frame_dataset.ChannelFrameDataset","title":"<code>ChannelFrameDataset</code>","text":"<p>               Bases: <code>FrameDataset[ChannelFrame]</code></p> <p>Dataset class for handling audio files as ChannelFrames in a folder.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>class ChannelFrameDataset(FrameDataset[ChannelFrame]):\n    \"\"\"\n    Dataset class for handling audio files as ChannelFrames in a folder.\n    \"\"\"\n\n    def __init__(\n        self,\n        folder_path: str,\n        sampling_rate: Optional[int] = None,\n        signal_length: Optional[int] = None,\n        file_extensions: Optional[list[str]] = None,\n        lazy_loading: bool = True,\n        recursive: bool = False,\n        source_dataset: Optional[\"FrameDataset[Any]\"] = None,\n        transform: Optional[Callable[[Any], Optional[ChannelFrame]]] = None,\n    ):\n        _file_extensions = file_extensions or [\n            \".wav\",\n            \".mp3\",\n            \".flac\",\n            \".csv\",\n        ]\n\n        super().__init__(\n            folder_path=folder_path,\n            sampling_rate=sampling_rate,\n            signal_length=signal_length,\n            file_extensions=_file_extensions,\n            lazy_loading=lazy_loading,\n            recursive=recursive,\n            source_dataset=source_dataset,\n            transform=transform,\n        )\n\n    def _load_file(self, file_path: Path) -&gt; Optional[ChannelFrame]:\n        \"\"\"Load an audio file and return a ChannelFrame.\"\"\"\n        try:\n            frame = ChannelFrame.from_file(file_path)\n            if self.sampling_rate and frame.sampling_rate != self.sampling_rate:\n                logger.info(\n                    f\"Resampling file {file_path.name} ({frame.sampling_rate} Hz) to \"\n                    f\"dataset rate ({self.sampling_rate} Hz).\"\n                )\n                frame = frame.resampling(target_sr=self.sampling_rate)\n            return frame\n        except Exception as e:\n            logger.error(f\"Failed to load or initialize file {file_path}: {str(e)}\")\n            return None\n\n    def resample(self, target_sr: int) -&gt; \"ChannelFrameDataset\":\n        \"\"\"Resample all frames in the dataset.\"\"\"\n\n        def _resample_func(frame: ChannelFrame) -&gt; Optional[ChannelFrame]:\n            if frame is None:\n                return None\n            try:\n                return frame.resampling(target_sr=target_sr)\n            except Exception as e:\n                logger.warning(f\"Resampling error (target_sr={target_sr}): {e}\")\n                return None\n\n        new_dataset = self.apply(_resample_func)\n        return cast(ChannelFrameDataset, new_dataset)\n\n    def trim(self, start: float, end: float) -&gt; \"ChannelFrameDataset\":\n        \"\"\"Trim all frames in the dataset.\"\"\"\n\n        def _trim_func(frame: ChannelFrame) -&gt; Optional[ChannelFrame]:\n            if frame is None:\n                return None\n            try:\n                return frame.trim(start=start, end=end)\n            except Exception as e:\n                logger.warning(f\"Trimming error (start={start}, end={end}): {e}\")\n                return None\n\n        new_dataset = self.apply(_trim_func)\n        return cast(ChannelFrameDataset, new_dataset)\n\n    def normalize(self, **kwargs: Any) -&gt; \"ChannelFrameDataset\":\n        \"\"\"Normalize all frames in the dataset.\"\"\"\n\n        def _normalize_func(frame: ChannelFrame) -&gt; Optional[ChannelFrame]:\n            if frame is None:\n                return None\n            try:\n                return frame.normalize(**kwargs)\n            except Exception as e:\n                logger.warning(f\"Normalization error ({kwargs}): {e}\")\n                return None\n\n        new_dataset = self.apply(_normalize_func)\n        return cast(ChannelFrameDataset, new_dataset)\n\n    def stft(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ) -&gt; \"SpectrogramFrameDataset\":\n        \"\"\"Apply STFT to all frames in the dataset.\"\"\"\n        _hop = hop_length or n_fft // 4\n\n        def _stft_func(frame: ChannelFrame) -&gt; Optional[SpectrogramFrame]:\n            if frame is None:\n                return None\n            try:\n                return frame.stft(\n                    n_fft=n_fft,\n                    hop_length=_hop,\n                    win_length=win_length,\n                    window=window,\n                )\n            except Exception as e:\n                logger.warning(f\"STFT error (n_fft={n_fft}, hop={_hop}): {e}\")\n                return None\n\n        new_dataset = SpectrogramFrameDataset(\n            folder_path=str(self.folder_path),\n            lazy_loading=True,\n            source_dataset=self,\n            transform=_stft_func,\n            sampling_rate=self.sampling_rate,\n        )\n        return new_dataset\n\n    @classmethod\n    def from_folder(\n        cls,\n        folder_path: str,\n        sampling_rate: Optional[int] = None,\n        file_extensions: Optional[list[str]] = None,\n        recursive: bool = False,\n        lazy_loading: bool = True,\n    ) -&gt; \"ChannelFrameDataset\":\n        \"\"\"Class method to create a ChannelFrameDataset from a folder.\"\"\"\n        extensions = (\n            file_extensions\n            if file_extensions is not None\n            else [\".wav\", \".mp3\", \".flac\", \".csv\"]\n        )\n\n        return cls(\n            folder_path,\n            sampling_rate=sampling_rate,\n            file_extensions=extensions,\n            lazy_loading=lazy_loading,\n            recursive=recursive,\n        )\n</code></pre> Functions\u00b6 <code></code> <code>__init__(folder_path, sampling_rate=None, signal_length=None, file_extensions=None, lazy_loading=True, recursive=False, source_dataset=None, transform=None)</code> \u00b6 Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def __init__(\n    self,\n    folder_path: str,\n    sampling_rate: Optional[int] = None,\n    signal_length: Optional[int] = None,\n    file_extensions: Optional[list[str]] = None,\n    lazy_loading: bool = True,\n    recursive: bool = False,\n    source_dataset: Optional[\"FrameDataset[Any]\"] = None,\n    transform: Optional[Callable[[Any], Optional[ChannelFrame]]] = None,\n):\n    _file_extensions = file_extensions or [\n        \".wav\",\n        \".mp3\",\n        \".flac\",\n        \".csv\",\n    ]\n\n    super().__init__(\n        folder_path=folder_path,\n        sampling_rate=sampling_rate,\n        signal_length=signal_length,\n        file_extensions=_file_extensions,\n        lazy_loading=lazy_loading,\n        recursive=recursive,\n        source_dataset=source_dataset,\n        transform=transform,\n    )\n</code></pre> <code></code> <code>resample(target_sr)</code> \u00b6 <p>Resample all frames in the dataset.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def resample(self, target_sr: int) -&gt; \"ChannelFrameDataset\":\n    \"\"\"Resample all frames in the dataset.\"\"\"\n\n    def _resample_func(frame: ChannelFrame) -&gt; Optional[ChannelFrame]:\n        if frame is None:\n            return None\n        try:\n            return frame.resampling(target_sr=target_sr)\n        except Exception as e:\n            logger.warning(f\"Resampling error (target_sr={target_sr}): {e}\")\n            return None\n\n    new_dataset = self.apply(_resample_func)\n    return cast(ChannelFrameDataset, new_dataset)\n</code></pre> <code></code> <code>trim(start, end)</code> \u00b6 <p>Trim all frames in the dataset.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def trim(self, start: float, end: float) -&gt; \"ChannelFrameDataset\":\n    \"\"\"Trim all frames in the dataset.\"\"\"\n\n    def _trim_func(frame: ChannelFrame) -&gt; Optional[ChannelFrame]:\n        if frame is None:\n            return None\n        try:\n            return frame.trim(start=start, end=end)\n        except Exception as e:\n            logger.warning(f\"Trimming error (start={start}, end={end}): {e}\")\n            return None\n\n    new_dataset = self.apply(_trim_func)\n    return cast(ChannelFrameDataset, new_dataset)\n</code></pre> <code></code> <code>normalize(**kwargs)</code> \u00b6 <p>Normalize all frames in the dataset.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def normalize(self, **kwargs: Any) -&gt; \"ChannelFrameDataset\":\n    \"\"\"Normalize all frames in the dataset.\"\"\"\n\n    def _normalize_func(frame: ChannelFrame) -&gt; Optional[ChannelFrame]:\n        if frame is None:\n            return None\n        try:\n            return frame.normalize(**kwargs)\n        except Exception as e:\n            logger.warning(f\"Normalization error ({kwargs}): {e}\")\n            return None\n\n    new_dataset = self.apply(_normalize_func)\n    return cast(ChannelFrameDataset, new_dataset)\n</code></pre> <code></code> <code>stft(n_fft=2048, hop_length=None, win_length=None, window='hann')</code> \u00b6 <p>Apply STFT to all frames in the dataset.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def stft(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n) -&gt; \"SpectrogramFrameDataset\":\n    \"\"\"Apply STFT to all frames in the dataset.\"\"\"\n    _hop = hop_length or n_fft // 4\n\n    def _stft_func(frame: ChannelFrame) -&gt; Optional[SpectrogramFrame]:\n        if frame is None:\n            return None\n        try:\n            return frame.stft(\n                n_fft=n_fft,\n                hop_length=_hop,\n                win_length=win_length,\n                window=window,\n            )\n        except Exception as e:\n            logger.warning(f\"STFT error (n_fft={n_fft}, hop={_hop}): {e}\")\n            return None\n\n    new_dataset = SpectrogramFrameDataset(\n        folder_path=str(self.folder_path),\n        lazy_loading=True,\n        source_dataset=self,\n        transform=_stft_func,\n        sampling_rate=self.sampling_rate,\n    )\n    return new_dataset\n</code></pre> <code></code> <code>from_folder(folder_path, sampling_rate=None, file_extensions=None, recursive=False, lazy_loading=True)</code> <code>classmethod</code> \u00b6 <p>Class method to create a ChannelFrameDataset from a folder.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>@classmethod\ndef from_folder(\n    cls,\n    folder_path: str,\n    sampling_rate: Optional[int] = None,\n    file_extensions: Optional[list[str]] = None,\n    recursive: bool = False,\n    lazy_loading: bool = True,\n) -&gt; \"ChannelFrameDataset\":\n    \"\"\"Class method to create a ChannelFrameDataset from a folder.\"\"\"\n    extensions = (\n        file_extensions\n        if file_extensions is not None\n        else [\".wav\", \".mp3\", \".flac\", \".csv\"]\n    )\n\n    return cls(\n        folder_path,\n        sampling_rate=sampling_rate,\n        file_extensions=extensions,\n        lazy_loading=lazy_loading,\n        recursive=recursive,\n    )\n</code></pre>"},{"location":"api/#wandas.utils.frame_dataset.SpectrogramFrameDataset","title":"<code>SpectrogramFrameDataset</code>","text":"<p>               Bases: <code>FrameDataset[SpectrogramFrame]</code></p> <p>Dataset class for handling spectrogram data as SpectrogramFrames. Expected to be generated mainly as a result of ChannelFrameDataset.stft().</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>class SpectrogramFrameDataset(FrameDataset[SpectrogramFrame]):\n    \"\"\"\n    Dataset class for handling spectrogram data as SpectrogramFrames.\n    Expected to be generated mainly as a result of ChannelFrameDataset.stft().\n    \"\"\"\n\n    def __init__(\n        self,\n        folder_path: str,\n        sampling_rate: Optional[int] = None,\n        signal_length: Optional[int] = None,\n        file_extensions: Optional[list[str]] = None,\n        lazy_loading: bool = True,\n        recursive: bool = False,\n        source_dataset: Optional[\"FrameDataset[Any]\"] = None,\n        transform: Optional[Callable[[Any], Optional[SpectrogramFrame]]] = None,\n    ):\n        super().__init__(\n            folder_path=folder_path,\n            sampling_rate=sampling_rate,\n            signal_length=signal_length,\n            file_extensions=file_extensions,\n            lazy_loading=lazy_loading,\n            recursive=recursive,\n            source_dataset=source_dataset,\n            transform=transform,\n        )\n\n    def _load_file(self, file_path: Path) -&gt; Optional[SpectrogramFrame]:\n        \"\"\"Direct loading from files is not currently supported.\"\"\"\n        logger.warning(\n            \"No method defined for directly loading SpectrogramFrames. Normally \"\n            \"created from ChannelFrameDataset.stft().\"\n        )\n        raise NotImplementedError(\n            \"No method defined for directly loading SpectrogramFrames\"\n        )\n\n    def plot(self, index: int, **kwargs: Any) -&gt; None:\n        \"\"\"Plot the spectrogram at the specified index.\"\"\"\n        try:\n            frame = self._ensure_loaded(index)\n\n            if frame is None:\n                logger.warning(\n                    f\"Cannot plot index {index} as it failed to load/transform.\"\n                )\n                return\n\n            plot_method = getattr(frame, \"plot\", None)\n            if callable(plot_method):\n                plot_method(**kwargs)\n            else:\n                logger.warning(\n                    f\"Frame (index {index}, type {type(frame).__name__}) does not \"\n                    f\"have a plot method implemented.\"\n                )\n        except Exception as e:\n            logger.error(f\"An error occurred while plotting index {index}: {e}\")\n</code></pre> Functions\u00b6 <code></code> <code>__init__(folder_path, sampling_rate=None, signal_length=None, file_extensions=None, lazy_loading=True, recursive=False, source_dataset=None, transform=None)</code> \u00b6 Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def __init__(\n    self,\n    folder_path: str,\n    sampling_rate: Optional[int] = None,\n    signal_length: Optional[int] = None,\n    file_extensions: Optional[list[str]] = None,\n    lazy_loading: bool = True,\n    recursive: bool = False,\n    source_dataset: Optional[\"FrameDataset[Any]\"] = None,\n    transform: Optional[Callable[[Any], Optional[SpectrogramFrame]]] = None,\n):\n    super().__init__(\n        folder_path=folder_path,\n        sampling_rate=sampling_rate,\n        signal_length=signal_length,\n        file_extensions=file_extensions,\n        lazy_loading=lazy_loading,\n        recursive=recursive,\n        source_dataset=source_dataset,\n        transform=transform,\n    )\n</code></pre> <code></code> <code>plot(index, **kwargs)</code> \u00b6 <p>Plot the spectrogram at the specified index.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def plot(self, index: int, **kwargs: Any) -&gt; None:\n    \"\"\"Plot the spectrogram at the specified index.\"\"\"\n    try:\n        frame = self._ensure_loaded(index)\n\n        if frame is None:\n            logger.warning(\n                f\"Cannot plot index {index} as it failed to load/transform.\"\n            )\n            return\n\n        plot_method = getattr(frame, \"plot\", None)\n        if callable(plot_method):\n            plot_method(**kwargs)\n        else:\n            logger.warning(\n                f\"Frame (index {index}, type {type(frame).__name__}) does not \"\n                f\"have a plot method implemented.\"\n            )\n    except Exception as e:\n        logger.error(f\"An error occurred while plotting index {index}: {e}\")\n</code></pre>"},{"location":"api/#wandas.utils.generate_sample","title":"<code>generate_sample</code>","text":""},{"location":"api/#wandas.utils.generate_sample-classes","title":"Classes","text":""},{"location":"api/#wandas.utils.generate_sample-functions","title":"Functions","text":""},{"location":"api/#wandas.utils.generate_sample.generate_sin","title":"<code>generate_sin(freqs=1000, sampling_rate=16000, duration=1.0, label=None)</code>","text":"<p>Generate sample sine wave signals.</p>"},{"location":"api/#wandas.utils.generate_sample.generate_sin--parameters","title":"Parameters","text":"<p>freqs : float or list of float, default=1000     Frequency of the sine wave(s) in Hz.     If multiple frequencies are specified, multiple channels will be created. sampling_rate : int, default=16000     Sampling rate in Hz. duration : float, default=1.0     Duration of the signal in seconds. label : str, optional     Label for the entire signal.</p>"},{"location":"api/#wandas.utils.generate_sample.generate_sin--returns","title":"Returns","text":"<p>ChannelFrame     ChannelFrame object containing the sine wave(s).</p> Source code in <code>wandas/utils/generate_sample.py</code> <pre><code>def generate_sin(\n    freqs: Union[float, list[float]] = 1000,\n    sampling_rate: int = 16000,\n    duration: float = 1.0,\n    label: Optional[str] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Generate sample sine wave signals.\n\n    Parameters\n    ----------\n    freqs : float or list of float, default=1000\n        Frequency of the sine wave(s) in Hz.\n        If multiple frequencies are specified, multiple channels will be created.\n    sampling_rate : int, default=16000\n        Sampling rate in Hz.\n    duration : float, default=1.0\n        Duration of the signal in seconds.\n    label : str, optional\n        Label for the entire signal.\n\n    Returns\n    -------\n    ChannelFrame\n        ChannelFrame object containing the sine wave(s).\n    \"\"\"\n    # \u76f4\u63a5\u3001generate_sin_lazy\u95a2\u6570\u3092\u547c\u3073\u51fa\u3059\n    return generate_sin_lazy(\n        freqs=freqs, sampling_rate=sampling_rate, duration=duration, label=label\n    )\n</code></pre>"},{"location":"api/#wandas.utils.generate_sample.generate_sin_lazy","title":"<code>generate_sin_lazy(freqs=1000, sampling_rate=16000, duration=1.0, label=None)</code>","text":"<p>Generate sample sine wave signals using lazy computation.</p>"},{"location":"api/#wandas.utils.generate_sample.generate_sin_lazy--parameters","title":"Parameters","text":"<p>freqs : float or list of float, default=1000     Frequency of the sine wave(s) in Hz.     If multiple frequencies are specified, multiple channels will be created. sampling_rate : int, default=16000     Sampling rate in Hz. duration : float, default=1.0     Duration of the signal in seconds. label : str, optional     Label for the entire signal.</p>"},{"location":"api/#wandas.utils.generate_sample.generate_sin_lazy--returns","title":"Returns","text":"<p>ChannelFrame     Lazy ChannelFrame object containing the sine wave(s).</p> Source code in <code>wandas/utils/generate_sample.py</code> <pre><code>def generate_sin_lazy(\n    freqs: Union[float, list[float]] = 1000,\n    sampling_rate: int = 16000,\n    duration: float = 1.0,\n    label: Optional[str] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Generate sample sine wave signals using lazy computation.\n\n    Parameters\n    ----------\n    freqs : float or list of float, default=1000\n        Frequency of the sine wave(s) in Hz.\n        If multiple frequencies are specified, multiple channels will be created.\n    sampling_rate : int, default=16000\n        Sampling rate in Hz.\n    duration : float, default=1.0\n        Duration of the signal in seconds.\n    label : str, optional\n        Label for the entire signal.\n\n    Returns\n    -------\n    ChannelFrame\n        Lazy ChannelFrame object containing the sine wave(s).\n    \"\"\"\n    from wandas.frames.channel import ChannelFrame\n\n    label = label or \"Generated Sin\"\n    t = np.linspace(0, duration, int(sampling_rate * duration), endpoint=False)\n\n    _freqs: list[float]\n    if isinstance(freqs, float):\n        _freqs = [freqs]\n    elif isinstance(freqs, list):\n        _freqs = freqs\n    else:\n        raise ValueError(\"freqs must be a float or a list of floats.\")\n\n    channels = []\n    labels = []\n    for idx, freq in enumerate(_freqs):\n        data = np.sin(2 * np.pi * freq * t) * 2 * np.sqrt(2)\n        labels.append(f\"Channel {idx + 1}\")\n        channels.append(data)\n    return ChannelFrame.from_numpy(\n        data=np.array(channels),\n        label=label,\n        sampling_rate=sampling_rate,\n        ch_labels=labels,\n    )\n</code></pre>"},{"location":"api/#wandas.utils.introspection","title":"<code>introspection</code>","text":"<p>Utilities for runtime signature introspection.</p>"},{"location":"api/#wandas.utils.introspection-attributes","title":"Attributes","text":""},{"location":"api/#wandas.utils.introspection.__all__","title":"<code>__all__ = ['accepted_kwargs', 'filter_kwargs']</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.utils.introspection-functions","title":"Functions","text":""},{"location":"api/#wandas.utils.introspection.accepted_kwargs","title":"<code>accepted_kwargs(func)</code>","text":"<p>Get the set of explicit keyword arguments accepted by a function and whether it accepts **kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any]</code> <p>The function to inspect.</p> required <p>Returns:</p> Type Description <code>set[str]</code> <p>A tuple containing:</p> <code>bool</code> <ul> <li>set[str]: Set of explicit keyword argument names accepted by func.</li> </ul> <code>tuple[set[str], bool]</code> <ul> <li>bool: Whether the function accepts variable keyword arguments (**kwargs).</li> </ul> Source code in <code>wandas/utils/introspection.py</code> <pre><code>def accepted_kwargs(func: Callable[..., Any]) -&gt; tuple[set[str], bool]:\n    \"\"\"\n    Get the set of explicit keyword arguments accepted by\n    a function and whether it accepts **kwargs.\n\n    Args:\n        func: The function to inspect.\n\n    Returns:\n        A tuple containing:\n        - set[str]: Set of explicit keyword argument names accepted by func.\n        - bool: Whether the function accepts variable keyword arguments (**kwargs).\n    \"\"\"\n    # \u30e2\u30c3\u30af\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u5834\u5408\u306f\u7a7a\u30bb\u30c3\u30c8\u3068\u7121\u5236\u9650\u30d5\u30e9\u30b0\u3092\u8fd4\u3059\n    if hasattr(func, \"__module__\") and func.__module__ == \"unittest.mock\":\n        return set(), True\n    try:\n        params = signature(func).parameters.values()\n\n        # \u660e\u793a\u7684\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u5f15\u6570\u3092\u53ce\u96c6\n        explicit_kwargs = {\n            p.name\n            for p in params\n            if p.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY)\n        }\n\n        # **kwargs\u3092\u53d7\u3051\u4ed8\u3051\u308b\u304b\u3069\u3046\u304b\u306e\u30d5\u30e9\u30b0\n        has_var_kwargs = any(p.kind is Parameter.VAR_KEYWORD for p in params)\n\n        return explicit_kwargs, has_var_kwargs\n    except (ValueError, TypeError):\n        # \u30b7\u30b0\u30cd\u30c1\u30e3\u3092\u53d6\u5f97\u3067\u304d\u306a\u3044\u5834\u5408\u306f\u7a7a\u30bb\u30c3\u30c8\u3068\u7121\u5236\u9650\u30d5\u30e9\u30b0\u3092\u8fd4\u3059\n        return set(), True\n</code></pre>"},{"location":"api/#wandas.utils.introspection.filter_kwargs","title":"<code>filter_kwargs(func, kwargs, *, strict_mode=False)</code>","text":"<p>Filter keyword arguments to only those accepted by the function.</p> <p>This function examines the signature of <code>func</code> and returns a dictionary containing only the key-value pairs from <code>kwargs</code> that are valid keyword arguments for <code>func</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any]</code> <p>The function to filter keyword arguments for.</p> required <code>kwargs</code> <code>Mapping[str, Any]</code> <p>The keyword arguments to filter.</p> required <code>strict_mode</code> <code>bool</code> <p>If True, only explicitly defined parameters are passed even when the function accepts kwargs. If False (default), all parameters are passed to functions that accept kwargs, but a warning is issued for parameters not explicitly defined.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing only the key-value pairs that are valid for <code>func</code>.</p> Source code in <code>wandas/utils/introspection.py</code> <pre><code>def filter_kwargs(\n    func: Callable[..., Any],\n    kwargs: Mapping[str, Any],\n    *,\n    strict_mode: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Filter keyword arguments to only those accepted by the function.\n\n    This function examines the signature of `func` and returns a dictionary\n    containing only the key-value pairs from `kwargs` that are valid keyword\n    arguments for `func`.\n\n    Args:\n        func: The function to filter keyword arguments for.\n        kwargs: The keyword arguments to filter.\n        strict_mode: If True, only explicitly defined parameters are passed even when\n            the function accepts **kwargs. If False (default), all parameters are\n            passed to functions that accept **kwargs, but a warning is issued for\n            parameters not explicitly defined.\n\n    Returns:\n        A dictionary containing only the key-value pairs that are valid for `func`.\n    \"\"\"\n    explicit_params, accepts_var_kwargs = accepted_kwargs(func)\n\n    # **kwargs\u3092\u53d7\u3051\u4ed8\u3051\u306a\u3044\u5834\u5408\u3001\u307e\u305f\u306f strict_mode \u304c True \u306e\u5834\u5408\u306f\u3001\n    # \u660e\u793a\u7684\u306a\u30d1\u30e9\u30e1\u30fc\u30bf\u306e\u307f\u3092\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\n    if not accepts_var_kwargs or strict_mode:\n        filtered = {k: v for k, v in kwargs.items() if k in explicit_params}\n        return filtered\n\n    # **kwargs\u3092\u53d7\u3051\u4ed8\u3051\u308b\u5834\u5408\uff08strict_mode\u304cFalse\u306e\u5834\u5408\uff09\u306f\u5168\u30ad\u30fc\u3092\u8a31\u53ef\n    # \u305f\u3060\u3057\u3001\u660e\u793a\u7684\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u306a\u3044\u30ad\u30fc\u306b\u306f\u8b66\u544a\u3092\u51fa\u3059\n    unknown = set(kwargs) - explicit_params\n    if unknown:\n        warnings.warn(\n            f\"Implicit kwargs for {func.__name__}: {unknown}\",\n            UserWarning,\n            stacklevel=2,\n        )\n    return dict(kwargs)\n</code></pre>"},{"location":"api/#wandas.utils.types","title":"<code>types</code>","text":""},{"location":"api/#wandas.utils.types-attributes","title":"Attributes","text":""},{"location":"api/#wandas.utils.types.Real","title":"<code>Real = np.number[Any]</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.utils.types.Complex","title":"<code>Complex = np.complexfloating[Any, Any]</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.utils.types.NDArrayReal","title":"<code>NDArrayReal = npt.NDArray[Real]</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.utils.types.NDArrayComplex","title":"<code>NDArrayComplex = npt.NDArray[Complex]</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.utils.util","title":"<code>util</code>","text":""},{"location":"api/#wandas.utils.util-attributes","title":"Attributes","text":""},{"location":"api/#wandas.utils.util-functions","title":"Functions","text":""},{"location":"api/#wandas.utils.util.unit_to_ref","title":"<code>unit_to_ref(unit)</code>","text":"<p>Convert unit to reference value.</p>"},{"location":"api/#wandas.utils.util.unit_to_ref--parameters","title":"Parameters","text":"<p>unit : str     Unit string.</p>"},{"location":"api/#wandas.utils.util.unit_to_ref--returns","title":"Returns","text":"<p>float     Reference value for the unit. For 'Pa', returns 2e-5 (20 \u03bcPa).     For other units, returns 1.0.</p> Source code in <code>wandas/utils/util.py</code> <pre><code>def unit_to_ref(unit: str) -&gt; float:\n    \"\"\"\n    Convert unit to reference value.\n\n    Parameters\n    ----------\n    unit : str\n        Unit string.\n\n    Returns\n    -------\n    float\n        Reference value for the unit. For 'Pa', returns 2e-5 (20 \u03bcPa).\n        For other units, returns 1.0.\n    \"\"\"\n    if unit == \"Pa\":\n        return 2e-5\n\n    else:\n        return 1.0\n</code></pre>"},{"location":"api/#wandas.utils.util.calculate_rms","title":"<code>calculate_rms(wave)</code>","text":"<p>Calculate the root mean square of the wave.</p>"},{"location":"api/#wandas.utils.util.calculate_rms--parameters","title":"Parameters","text":"<p>wave : NDArrayReal     Input waveform data. Can be multi-channel (shape: [channels, samples])     or single channel (shape: [samples]).</p>"},{"location":"api/#wandas.utils.util.calculate_rms--returns","title":"Returns","text":"<p>Union[float, NDArray[np.float64]]     RMS value(s). For multi-channel input, returns an array of RMS values,     one per channel. For single-channel input, returns a single RMS value.</p> Source code in <code>wandas/utils/util.py</code> <pre><code>def calculate_rms(wave: \"NDArrayReal\") -&gt; \"NDArrayReal\":\n    \"\"\"\n    Calculate the root mean square of the wave.\n\n    Parameters\n    ----------\n    wave : NDArrayReal\n        Input waveform data. Can be multi-channel (shape: [channels, samples])\n        or single channel (shape: [samples]).\n\n    Returns\n    -------\n    Union[float, NDArray[np.float64]]\n        RMS value(s). For multi-channel input, returns an array of RMS values,\n        one per channel. For single-channel input, returns a single RMS value.\n    \"\"\"\n    # Calculate RMS considering axis (over the last dimension)\n    axis_to_use = -1 if wave.ndim &gt; 1 else None\n    rms_values: NDArrayReal = np.sqrt(\n        np.mean(np.square(wave), axis=axis_to_use, keepdims=True)\n    )\n    return rms_values\n</code></pre>"},{"location":"api/#wandas.utils.util.calculate_desired_noise_rms","title":"<code>calculate_desired_noise_rms(clean_rms, snr)</code>","text":"<p>Calculate the desired noise RMS based on clean signal RMS and target SNR.</p>"},{"location":"api/#wandas.utils.util.calculate_desired_noise_rms--parameters","title":"Parameters","text":"<p>clean_rms : \"NDArrayReal\"     RMS value(s) of the clean signal.     Can be a single value or an array for multi-channel. snr : float     Target Signal-to-Noise Ratio in dB.</p>"},{"location":"api/#wandas.utils.util.calculate_desired_noise_rms--returns","title":"Returns","text":"<p>\"NDArrayReal\"     Desired noise RMS value(s) to achieve the target SNR.</p> Source code in <code>wandas/utils/util.py</code> <pre><code>def calculate_desired_noise_rms(clean_rms: \"NDArrayReal\", snr: float) -&gt; \"NDArrayReal\":\n    \"\"\"\n    Calculate the desired noise RMS based on clean signal RMS and target SNR.\n\n    Parameters\n    ----------\n    clean_rms : \"NDArrayReal\"\n        RMS value(s) of the clean signal.\n        Can be a single value or an array for multi-channel.\n    snr : float\n        Target Signal-to-Noise Ratio in dB.\n\n    Returns\n    -------\n    \"NDArrayReal\"\n        Desired noise RMS value(s) to achieve the target SNR.\n    \"\"\"\n    a = snr / 20\n    noise_rms = clean_rms / (10**a)\n    return noise_rms\n</code></pre>"},{"location":"api/#wandas.utils.util.amplitude_to_db","title":"<code>amplitude_to_db(amplitude, ref)</code>","text":"<p>Convert amplitude to decibel.</p>"},{"location":"api/#wandas.utils.util.amplitude_to_db--parameters","title":"Parameters","text":"<p>amplitude : NDArrayReal     Input amplitude data. ref : float     Reference value for conversion.</p>"},{"location":"api/#wandas.utils.util.amplitude_to_db--returns","title":"Returns","text":"<p>NDArrayReal     Amplitude data converted to decibels.</p> Source code in <code>wandas/utils/util.py</code> <pre><code>def amplitude_to_db(amplitude: \"NDArrayReal\", ref: float) -&gt; \"NDArrayReal\":\n    \"\"\"\n    Convert amplitude to decibel.\n\n    Parameters\n    ----------\n    amplitude : NDArrayReal\n        Input amplitude data.\n    ref : float\n        Reference value for conversion.\n\n    Returns\n    -------\n    NDArrayReal\n        Amplitude data converted to decibels.\n    \"\"\"\n    db: NDArrayReal = librosa.amplitude_to_db(\n        np.abs(amplitude), ref=ref, amin=1e-15, top_db=None\n    )\n    return db\n</code></pre>"},{"location":"api/#wandas.utils.util.level_trigger","title":"<code>level_trigger(data, level, offset=0, hold=1)</code>","text":"<p>Find points where the signal crosses the specified level from below.</p>"},{"location":"api/#wandas.utils.util.level_trigger--parameters","title":"Parameters","text":"<p>data : NDArrayReal     Input signal data. level : float     Threshold level for triggering. offset : int, default=0     Offset to add to trigger points. hold : int, default=1     Minimum number of samples between successive trigger points.</p>"},{"location":"api/#wandas.utils.util.level_trigger--returns","title":"Returns","text":"<p>list of int     List of sample indices where the signal crosses the level.</p> Source code in <code>wandas/utils/util.py</code> <pre><code>def level_trigger(\n    data: \"NDArrayReal\", level: float, offset: int = 0, hold: int = 1\n) -&gt; list[int]:\n    \"\"\"\n    Find points where the signal crosses the specified level from below.\n\n    Parameters\n    ----------\n    data : NDArrayReal\n        Input signal data.\n    level : float\n        Threshold level for triggering.\n    offset : int, default=0\n        Offset to add to trigger points.\n    hold : int, default=1\n        Minimum number of samples between successive trigger points.\n\n    Returns\n    -------\n    list of int\n        List of sample indices where the signal crosses the level.\n    \"\"\"\n    trig_point: list[int] = []\n\n    sig_len = len(data)\n    diff = np.diff(np.sign(data - level))\n    level_point = np.where(diff &gt; 0)[0]\n    level_point = level_point[(level_point + hold) &lt; sig_len]\n\n    if len(level_point) == 0:\n        return list()\n\n    last_point = level_point[0]\n    trig_point.append(last_point + offset)\n    for i in level_point:\n        if (last_point + hold) &lt; i:\n            trig_point.append(i + offset)\n            last_point = i\n\n    return trig_point\n</code></pre>"},{"location":"api/#wandas.utils.util.cut_sig","title":"<code>cut_sig(data, point_list, cut_len, taper_rate=0, dc_cut=False)</code>","text":"<p>Cut segments from signal at specified points.</p>"},{"location":"api/#wandas.utils.util.cut_sig--parameters","title":"Parameters","text":"<p>data : NDArrayReal     Input signal data. point_list : list of int     List of starting points for cutting. cut_len : int     Length of each segment to cut. taper_rate : float, default=0     Taper rate for Tukey window applied to segments.     A value of 0 means no tapering, 1 means full tapering. dc_cut : bool, default=False     Whether to remove DC component (mean) from segments.</p>"},{"location":"api/#wandas.utils.util.cut_sig--returns","title":"Returns","text":"<p>NDArrayReal     Array containing cut segments with shape (n_segments, cut_len).</p> Source code in <code>wandas/utils/util.py</code> <pre><code>def cut_sig(\n    data: \"NDArrayReal\",\n    point_list: list[int],\n    cut_len: int,\n    taper_rate: float = 0,\n    dc_cut: bool = False,\n) -&gt; \"NDArrayReal\":\n    \"\"\"\n    Cut segments from signal at specified points.\n\n    Parameters\n    ----------\n    data : NDArrayReal\n        Input signal data.\n    point_list : list of int\n        List of starting points for cutting.\n    cut_len : int\n        Length of each segment to cut.\n    taper_rate : float, default=0\n        Taper rate for Tukey window applied to segments.\n        A value of 0 means no tapering, 1 means full tapering.\n    dc_cut : bool, default=False\n        Whether to remove DC component (mean) from segments.\n\n    Returns\n    -------\n    NDArrayReal\n        Array containing cut segments with shape (n_segments, cut_len).\n    \"\"\"\n    length = len(data)\n    point_list_ = [p for p in point_list if p &gt;= 0 and p + cut_len &lt;= length]\n    trial = np.zeros((len(point_list_), cut_len))\n\n    for i, v in enumerate(point_list_):\n        trial[i] = data[v : v + cut_len]\n        if dc_cut:\n            trial[i] = trial[i] - trial[i].mean()\n\n    trial = trial * tukey(cut_len, taper_rate)\n    return trial\n</code></pre>"},{"location":"api/#_6","title":"\u53ef\u8996\u5316\u30e2\u30b8\u30e5\u30fc\u30eb","text":"<p>\u53ef\u8996\u5316\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u30c7\u30fc\u30bf\u306e\u8996\u899a\u5316\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/#wandas.visualization","title":"<code>wandas.visualization</code>","text":""},{"location":"api/#wandas.visualization-modules","title":"Modules","text":""},{"location":"api/#wandas.visualization.plotting","title":"<code>plotting</code>","text":""},{"location":"api/#wandas.visualization.plotting-attributes","title":"Attributes","text":""},{"location":"api/#wandas.visualization.plotting.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.visualization.plotting.TFrame","title":"<code>TFrame = TypeVar('TFrame', bound='BaseFrame[Any]')</code>  <code>module-attribute</code>","text":""},{"location":"api/#wandas.visualization.plotting-classes","title":"Classes","text":""},{"location":"api/#wandas.visualization.plotting.PlotStrategy","title":"<code>PlotStrategy</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[TFrame]</code></p> <p>Base class for plotting strategies</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>class PlotStrategy(abc.ABC, Generic[TFrame]):\n    \"\"\"Base class for plotting strategies\"\"\"\n\n    name: ClassVar[str]\n\n    @abc.abstractmethod\n    def channel_plot(self, x: Any, y: Any, ax: \"Axes\") -&gt; None:\n        \"\"\"Implementation of channel plotting\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def plot(\n        self,\n        bf: TFrame,\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = False,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Implementation of plotting\"\"\"\n        pass\n</code></pre> Attributes\u00b6 <code></code> <code>name</code> <code>class-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>channel_plot(x, y, ax)</code> <code>abstractmethod</code> \u00b6 <p>Implementation of channel plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>@abc.abstractmethod\ndef channel_plot(self, x: Any, y: Any, ax: \"Axes\") -&gt; None:\n    \"\"\"Implementation of channel plotting\"\"\"\n    pass\n</code></pre> <code></code> <code>plot(bf, ax=None, title=None, overlay=False, **kwargs)</code> <code>abstractmethod</code> \u00b6 <p>Implementation of plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>@abc.abstractmethod\ndef plot(\n    self,\n    bf: TFrame,\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = False,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Implementation of plotting\"\"\"\n    pass\n</code></pre>"},{"location":"api/#wandas.visualization.plotting.WaveformPlotStrategy","title":"<code>WaveformPlotStrategy</code>","text":"<p>               Bases: <code>PlotStrategy['ChannelFrame']</code></p> <p>Strategy for waveform plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>class WaveformPlotStrategy(PlotStrategy[\"ChannelFrame\"]):\n    \"\"\"Strategy for waveform plotting\"\"\"\n\n    name = \"waveform\"\n\n    def channel_plot(\n        self,\n        x: Any,\n        y: Any,\n        ax: \"Axes\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Implementation of channel plotting\"\"\"\n        ax.plot(x, y, **kwargs)\n        ax.set_ylabel(\"Amplitude\")\n        ax.grid(True)\n        if \"label\" in kwargs:\n            ax.legend()\n\n    def plot(\n        self,\n        bf: \"ChannelFrame\",\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = False,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Waveform plotting\"\"\"\n        kwargs = kwargs or {}\n        ylabel = kwargs.pop(\"ylabel\", \"Amplitude\")\n        xlabel = kwargs.pop(\"xlabel\", \"Time [s]\")\n        alpha = kwargs.pop(\"alpha\", 1)\n        plot_kwargs = filter_kwargs(\n            Line2D,\n            kwargs,\n            strict_mode=True,\n        )\n        ax_set = filter_kwargs(\n            Axes.set,\n            kwargs,\n            strict_mode=True,\n        )\n        if overlay:\n            if ax is None:\n                fig, ax = plt.subplots(figsize=(10, 4))\n            self.channel_plot(\n                bf.time, bf.data.T, ax, label=bf.labels, alpha=alpha, **plot_kwargs\n            )\n            ax.set(\n                ylabel=ylabel,\n                title=title or bf.label or \"Channel Data\",\n                xlabel=xlabel,\n                **ax_set,\n            )\n            if ax is None:\n                fig.suptitle(title or bf.label or None)\n                plt.tight_layout()\n                plt.show()\n            return ax\n        else:\n            num_channels = bf.n_channels\n            fig, axs = plt.subplots(\n                num_channels, 1, figsize=(10, 4 * num_channels), sharex=True\n            )\n            # Convert axs to list if it is a single Axes object\n            if not isinstance(axs, (list, np.ndarray)):\n                axs = [axs]\n\n            axes_list = list(axs)\n            data = bf.data\n            for ax_i, channel_data, ch_meta in zip(axes_list, data, bf.channels):\n                self.channel_plot(\n                    bf.time, channel_data, ax_i, alpha=alpha, **plot_kwargs\n                )\n                ax_i.set(\n                    ylabel=ylabel,\n                    title=ch_meta.label,\n                    **ax_set,\n                )\n\n            axes_list[-1].set(\n                ylabel=ylabel,\n                xlabel=\"Time [s]\",\n            )\n            fig.suptitle(title or bf.label or \"Channel Data\")\n\n            if ax is None:\n                plt.tight_layout()\n                plt.show()\n\n            return _return_axes_iterator(fig.axes)\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'waveform'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>channel_plot(x, y, ax, **kwargs)</code> \u00b6 <p>Implementation of channel plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def channel_plot(\n    self,\n    x: Any,\n    y: Any,\n    ax: \"Axes\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Implementation of channel plotting\"\"\"\n    ax.plot(x, y, **kwargs)\n    ax.set_ylabel(\"Amplitude\")\n    ax.grid(True)\n    if \"label\" in kwargs:\n        ax.legend()\n</code></pre> <code></code> <code>plot(bf, ax=None, title=None, overlay=False, **kwargs)</code> \u00b6 <p>Waveform plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def plot(\n    self,\n    bf: \"ChannelFrame\",\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = False,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Waveform plotting\"\"\"\n    kwargs = kwargs or {}\n    ylabel = kwargs.pop(\"ylabel\", \"Amplitude\")\n    xlabel = kwargs.pop(\"xlabel\", \"Time [s]\")\n    alpha = kwargs.pop(\"alpha\", 1)\n    plot_kwargs = filter_kwargs(\n        Line2D,\n        kwargs,\n        strict_mode=True,\n    )\n    ax_set = filter_kwargs(\n        Axes.set,\n        kwargs,\n        strict_mode=True,\n    )\n    if overlay:\n        if ax is None:\n            fig, ax = plt.subplots(figsize=(10, 4))\n        self.channel_plot(\n            bf.time, bf.data.T, ax, label=bf.labels, alpha=alpha, **plot_kwargs\n        )\n        ax.set(\n            ylabel=ylabel,\n            title=title or bf.label or \"Channel Data\",\n            xlabel=xlabel,\n            **ax_set,\n        )\n        if ax is None:\n            fig.suptitle(title or bf.label or None)\n            plt.tight_layout()\n            plt.show()\n        return ax\n    else:\n        num_channels = bf.n_channels\n        fig, axs = plt.subplots(\n            num_channels, 1, figsize=(10, 4 * num_channels), sharex=True\n        )\n        # Convert axs to list if it is a single Axes object\n        if not isinstance(axs, (list, np.ndarray)):\n            axs = [axs]\n\n        axes_list = list(axs)\n        data = bf.data\n        for ax_i, channel_data, ch_meta in zip(axes_list, data, bf.channels):\n            self.channel_plot(\n                bf.time, channel_data, ax_i, alpha=alpha, **plot_kwargs\n            )\n            ax_i.set(\n                ylabel=ylabel,\n                title=ch_meta.label,\n                **ax_set,\n            )\n\n        axes_list[-1].set(\n            ylabel=ylabel,\n            xlabel=\"Time [s]\",\n        )\n        fig.suptitle(title or bf.label or \"Channel Data\")\n\n        if ax is None:\n            plt.tight_layout()\n            plt.show()\n\n        return _return_axes_iterator(fig.axes)\n</code></pre>"},{"location":"api/#wandas.visualization.plotting.FrequencyPlotStrategy","title":"<code>FrequencyPlotStrategy</code>","text":"<p>               Bases: <code>PlotStrategy['SpectralFrame']</code></p> <p>Strategy for frequency domain plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>class FrequencyPlotStrategy(PlotStrategy[\"SpectralFrame\"]):\n    \"\"\"Strategy for frequency domain plotting\"\"\"\n\n    name = \"frequency\"\n\n    def channel_plot(\n        self,\n        x: Any,\n        y: Any,\n        ax: \"Axes\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Implementation of channel plotting\"\"\"\n        ax.plot(x, y, **kwargs)\n        ax.grid(True)\n        if \"label\" in kwargs:\n            ax.legend()\n\n    def plot(\n        self,\n        bf: \"SpectralFrame\",\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = False,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Frequency domain plotting\"\"\"\n        kwargs = kwargs or {}\n        is_aw = kwargs.pop(\"Aw\", False)\n        if bf.operation_history[-1][\"operation\"] == \"coherence\":\n            unit = \"\"\n            data = bf.magnitude\n            ylabel = kwargs.pop(\"ylabel\", \"coherence\")\n        else:\n            if is_aw:\n                unit = \"dBA\"\n                data = bf.dBA\n            else:\n                unit = \"dB\"\n                data = bf.dB\n            ylabel = kwargs.pop(\"ylabel\", f\"Spectrum level [{unit}]\")\n        xlabel = kwargs.pop(\"xlabel\", \"Frequency [Hz]\")\n        alpha = kwargs.pop(\"alpha\", 1)\n        plot_kwargs = filter_kwargs(Line2D, kwargs, strict_mode=True)\n        ax_set = filter_kwargs(Axes.set, kwargs, strict_mode=True)\n        if overlay:\n            if ax is None:\n                _, ax = plt.subplots(figsize=(10, 4))\n            self.channel_plot(\n                bf.freqs,\n                data.T,\n                ax,\n                label=bf.labels,\n                alpha=alpha,\n                **plot_kwargs,\n            )\n            ax.set(\n                ylabel=ylabel,\n                xlabel=xlabel,\n                title=title or bf.label or \"Channel Data\",\n                **ax_set,\n            )\n            if ax is None:\n                plt.tight_layout()\n                plt.show()\n            return ax\n        else:\n            num_channels = bf.n_channels\n            fig, axs = plt.subplots(\n                num_channels, 1, figsize=(10, 4 * num_channels), sharex=True\n            )\n            # Convert axs to list if it is a single Axes object\n            if not isinstance(axs, (list, np.ndarray)):\n                axs = [axs]\n\n            axes_list = list(axs)\n            for ax_i, channel_data, ch_meta in zip(axes_list, data, bf.channels):\n                self.channel_plot(\n                    bf.freqs,\n                    channel_data,\n                    ax_i,\n                    label=ch_meta.label,\n                    alpha=alpha,\n                    **plot_kwargs,\n                )\n                ax_i.set(\n                    ylabel=ylabel,\n                    title=ch_meta.label,\n                    xlabel=xlabel,\n                    **ax_set,\n                )\n            axes_list[-1].set(ylabel=ylabel, xlabel=xlabel)\n            fig.suptitle(title or bf.label or \"Channel Data\")\n            if ax is None:\n                plt.tight_layout()\n                plt.show()\n            return _return_axes_iterator(fig.axes)\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'frequency'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>channel_plot(x, y, ax, **kwargs)</code> \u00b6 <p>Implementation of channel plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def channel_plot(\n    self,\n    x: Any,\n    y: Any,\n    ax: \"Axes\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Implementation of channel plotting\"\"\"\n    ax.plot(x, y, **kwargs)\n    ax.grid(True)\n    if \"label\" in kwargs:\n        ax.legend()\n</code></pre> <code></code> <code>plot(bf, ax=None, title=None, overlay=False, **kwargs)</code> \u00b6 <p>Frequency domain plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def plot(\n    self,\n    bf: \"SpectralFrame\",\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = False,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Frequency domain plotting\"\"\"\n    kwargs = kwargs or {}\n    is_aw = kwargs.pop(\"Aw\", False)\n    if bf.operation_history[-1][\"operation\"] == \"coherence\":\n        unit = \"\"\n        data = bf.magnitude\n        ylabel = kwargs.pop(\"ylabel\", \"coherence\")\n    else:\n        if is_aw:\n            unit = \"dBA\"\n            data = bf.dBA\n        else:\n            unit = \"dB\"\n            data = bf.dB\n        ylabel = kwargs.pop(\"ylabel\", f\"Spectrum level [{unit}]\")\n    xlabel = kwargs.pop(\"xlabel\", \"Frequency [Hz]\")\n    alpha = kwargs.pop(\"alpha\", 1)\n    plot_kwargs = filter_kwargs(Line2D, kwargs, strict_mode=True)\n    ax_set = filter_kwargs(Axes.set, kwargs, strict_mode=True)\n    if overlay:\n        if ax is None:\n            _, ax = plt.subplots(figsize=(10, 4))\n        self.channel_plot(\n            bf.freqs,\n            data.T,\n            ax,\n            label=bf.labels,\n            alpha=alpha,\n            **plot_kwargs,\n        )\n        ax.set(\n            ylabel=ylabel,\n            xlabel=xlabel,\n            title=title or bf.label or \"Channel Data\",\n            **ax_set,\n        )\n        if ax is None:\n            plt.tight_layout()\n            plt.show()\n        return ax\n    else:\n        num_channels = bf.n_channels\n        fig, axs = plt.subplots(\n            num_channels, 1, figsize=(10, 4 * num_channels), sharex=True\n        )\n        # Convert axs to list if it is a single Axes object\n        if not isinstance(axs, (list, np.ndarray)):\n            axs = [axs]\n\n        axes_list = list(axs)\n        for ax_i, channel_data, ch_meta in zip(axes_list, data, bf.channels):\n            self.channel_plot(\n                bf.freqs,\n                channel_data,\n                ax_i,\n                label=ch_meta.label,\n                alpha=alpha,\n                **plot_kwargs,\n            )\n            ax_i.set(\n                ylabel=ylabel,\n                title=ch_meta.label,\n                xlabel=xlabel,\n                **ax_set,\n            )\n        axes_list[-1].set(ylabel=ylabel, xlabel=xlabel)\n        fig.suptitle(title or bf.label or \"Channel Data\")\n        if ax is None:\n            plt.tight_layout()\n            plt.show()\n        return _return_axes_iterator(fig.axes)\n</code></pre>"},{"location":"api/#wandas.visualization.plotting.NOctPlotStrategy","title":"<code>NOctPlotStrategy</code>","text":"<p>               Bases: <code>PlotStrategy['NOctFrame']</code></p> <p>Strategy for N-octave band analysis plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>class NOctPlotStrategy(PlotStrategy[\"NOctFrame\"]):\n    \"\"\"Strategy for N-octave band analysis plotting\"\"\"\n\n    name = \"noct\"\n\n    def channel_plot(\n        self,\n        x: Any,\n        y: Any,\n        ax: \"Axes\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Implementation of channel plotting\"\"\"\n        ax.step(x, y, **kwargs)\n        ax.grid(True)\n        if \"label\" in kwargs:\n            ax.legend()\n\n    def plot(\n        self,\n        bf: \"NOctFrame\",\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = False,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"N-octave band analysis plotting\"\"\"\n        kwargs = kwargs or {}\n        is_aw = kwargs.pop(\"Aw\", False)\n\n        if is_aw:\n            unit = \"dBrA\"\n            data = bf.dBA\n        else:\n            unit = \"dBr\"\n            data = bf.dB\n        ylabel = kwargs.pop(\"ylabel\", f\"Spectrum level [{unit}]\")\n        xlabel = kwargs.pop(\"xlabel\", \"Center frequency [Hz]\")\n        alpha = kwargs.pop(\"alpha\", 1)\n        plot_kwargs = filter_kwargs(Line2D, kwargs, strict_mode=True)\n        ax_set = filter_kwargs(Axes.set, kwargs, strict_mode=True)\n        if overlay:\n            if ax is None:\n                _, ax = plt.subplots(figsize=(10, 4))\n            self.channel_plot(\n                bf.freqs,\n                data.T,\n                ax,\n                label=bf.labels,\n                alpha=alpha,\n                **plot_kwargs,\n            )\n            ax.set(\n                ylabel=ylabel,\n                xlabel=xlabel,\n                title=title or bf.label or f\"1/{str(bf.n)}-Octave Spectrum\",\n                **ax_set,\n            )\n            if ax is None:\n                plt.tight_layout()\n                plt.show()\n            return ax\n        else:\n            num_channels = bf.n_channels\n            fig, axs = plt.subplots(\n                num_channels, 1, figsize=(10, 4 * num_channels), sharex=True\n            )\n            # Convert axs to list if it is a single Axes object\n            if not isinstance(axs, (list, np.ndarray)):\n                axs = [axs]\n\n            axes_list = list(axs)\n            for ax_i, channel_data, ch_meta in zip(axes_list, data, bf.channels):\n                self.channel_plot(\n                    bf.freqs,\n                    channel_data,\n                    ax_i,\n                    label=ch_meta.label,\n                    alpha=alpha,\n                    **plot_kwargs,\n                )\n                ax_i.set(\n                    ylabel=ylabel,\n                    title=ch_meta.label,\n                    xlabel=xlabel,\n                    **ax_set,\n                )\n            axes_list[-1].set(ylabel=ylabel, xlabel=xlabel)\n            fig.suptitle(title or bf.label or f\"1/{str(bf.n)}-Octave Spectrum\")\n            if ax is None:\n                plt.tight_layout()\n                plt.show()\n            return _return_axes_iterator(fig.axes)\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'noct'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>channel_plot(x, y, ax, **kwargs)</code> \u00b6 <p>Implementation of channel plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def channel_plot(\n    self,\n    x: Any,\n    y: Any,\n    ax: \"Axes\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Implementation of channel plotting\"\"\"\n    ax.step(x, y, **kwargs)\n    ax.grid(True)\n    if \"label\" in kwargs:\n        ax.legend()\n</code></pre> <code></code> <code>plot(bf, ax=None, title=None, overlay=False, **kwargs)</code> \u00b6 <p>N-octave band analysis plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def plot(\n    self,\n    bf: \"NOctFrame\",\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = False,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"N-octave band analysis plotting\"\"\"\n    kwargs = kwargs or {}\n    is_aw = kwargs.pop(\"Aw\", False)\n\n    if is_aw:\n        unit = \"dBrA\"\n        data = bf.dBA\n    else:\n        unit = \"dBr\"\n        data = bf.dB\n    ylabel = kwargs.pop(\"ylabel\", f\"Spectrum level [{unit}]\")\n    xlabel = kwargs.pop(\"xlabel\", \"Center frequency [Hz]\")\n    alpha = kwargs.pop(\"alpha\", 1)\n    plot_kwargs = filter_kwargs(Line2D, kwargs, strict_mode=True)\n    ax_set = filter_kwargs(Axes.set, kwargs, strict_mode=True)\n    if overlay:\n        if ax is None:\n            _, ax = plt.subplots(figsize=(10, 4))\n        self.channel_plot(\n            bf.freqs,\n            data.T,\n            ax,\n            label=bf.labels,\n            alpha=alpha,\n            **plot_kwargs,\n        )\n        ax.set(\n            ylabel=ylabel,\n            xlabel=xlabel,\n            title=title or bf.label or f\"1/{str(bf.n)}-Octave Spectrum\",\n            **ax_set,\n        )\n        if ax is None:\n            plt.tight_layout()\n            plt.show()\n        return ax\n    else:\n        num_channels = bf.n_channels\n        fig, axs = plt.subplots(\n            num_channels, 1, figsize=(10, 4 * num_channels), sharex=True\n        )\n        # Convert axs to list if it is a single Axes object\n        if not isinstance(axs, (list, np.ndarray)):\n            axs = [axs]\n\n        axes_list = list(axs)\n        for ax_i, channel_data, ch_meta in zip(axes_list, data, bf.channels):\n            self.channel_plot(\n                bf.freqs,\n                channel_data,\n                ax_i,\n                label=ch_meta.label,\n                alpha=alpha,\n                **plot_kwargs,\n            )\n            ax_i.set(\n                ylabel=ylabel,\n                title=ch_meta.label,\n                xlabel=xlabel,\n                **ax_set,\n            )\n        axes_list[-1].set(ylabel=ylabel, xlabel=xlabel)\n        fig.suptitle(title or bf.label or f\"1/{str(bf.n)}-Octave Spectrum\")\n        if ax is None:\n            plt.tight_layout()\n            plt.show()\n        return _return_axes_iterator(fig.axes)\n</code></pre>"},{"location":"api/#wandas.visualization.plotting.SpectrogramPlotStrategy","title":"<code>SpectrogramPlotStrategy</code>","text":"<p>               Bases: <code>PlotStrategy['SpectrogramFrame']</code></p> <p>Strategy for spectrogram plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>class SpectrogramPlotStrategy(PlotStrategy[\"SpectrogramFrame\"]):\n    \"\"\"Strategy for spectrogram plotting\"\"\"\n\n    name = \"spectrogram\"\n\n    def channel_plot(\n        self,\n        x: Any,\n        y: Any,\n        ax: \"Axes\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Implementation of channel plotting\"\"\"\n        pass\n\n    def plot(\n        self,\n        bf: \"SpectrogramFrame\",\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = False,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Spectrogram plotting\"\"\"\n        if overlay:\n            raise ValueError(\"Overlay is not supported for SpectrogramPlotStrategy.\")\n\n        if ax is not None and bf.n_channels &gt; 1:\n            raise ValueError(\"ax must be None when n_channels &gt; 1.\")\n\n        kwargs = kwargs or {}\n\n        is_aw = kwargs.pop(\"Aw\", False)\n        if is_aw:\n            unit = \"dBA\"\n            data = bf.dBA\n        else:\n            unit = \"dB\"\n            data = bf.dB\n\n        specshow_kwargs = filter_kwargs(display.specshow, kwargs, strict_mode=True)\n        ax_set_kwargs = filter_kwargs(Axes.set, kwargs, strict_mode=True)\n\n        cmap = kwargs.pop(\"cmap\", \"jet\")\n        vmin = kwargs.pop(\"vmin\", None)\n        vmax = kwargs.pop(\"vmax\", None)\n\n        if ax is not None:\n            img = display.specshow(\n                data=data[0],\n                sr=bf.sampling_rate,\n                hop_length=bf.hop_length,\n                n_fft=bf.n_fft,\n                win_length=bf.win_length,\n                x_axis=\"time\",\n                y_axis=\"linear\",\n                cmap=cmap,\n                ax=ax,\n                vmin=vmin,\n                vmax=vmax,\n                **specshow_kwargs,\n            )\n            ax.set(\n                title=title or bf.label or \"Spectrogram\",\n                ylabel=\"Frequency [Hz]\",\n                xlabel=\"Time [s]\",\n                **ax_set_kwargs,\n            )\n\n            fig = ax.figure\n            if fig is not None:\n                cbar = fig.colorbar(img, ax=ax)\n                cbar.set_label(f\"Spectrum level [{unit}]\")\n            return ax\n\n        else:\n            # Create a new figure if ax is None\n            num_channels = bf.n_channels\n            fig, axs = plt.subplots(\n                num_channels, 1, figsize=(10, 5 * num_channels), sharex=True\n            )\n            if not isinstance(fig, plt.Figure):\n                raise ValueError(\"fig must be a matplotlib Figure object.\")\n            # Convert axs to array if it is a single Axes object\n            if not isinstance(axs, np.ndarray):\n                axs = np.array([axs])\n\n            for ax_i, channel_data, ch_meta in zip(axs.flatten(), data, bf.channels):\n                img = display.specshow(\n                    data=channel_data,\n                    sr=bf.sampling_rate,\n                    hop_length=bf.hop_length,\n                    n_fft=bf.n_fft,\n                    win_length=bf.win_length,\n                    x_axis=\"time\",\n                    y_axis=\"linear\",\n                    ax=ax_i,\n                    cmap=cmap,\n                    vmin=vmin,\n                    vmax=vmax,\n                    **specshow_kwargs,\n                )\n                ax_i.set(\n                    title=ch_meta.label,\n                    ylabel=\"Frequency [Hz]\",\n                    xlabel=\"Time [s]\",\n                    **ax_set_kwargs,\n                )\n                cbar = ax_i.figure.colorbar(img, ax=ax_i)\n                cbar.set_label(f\"Spectrum level [{unit}]\")\n                fig.suptitle(title or \"Spectrogram Data\")\n            plt.tight_layout()\n            plt.show()\n\n            return _return_axes_iterator(fig.axes)\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'spectrogram'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>channel_plot(x, y, ax, **kwargs)</code> \u00b6 <p>Implementation of channel plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def channel_plot(\n    self,\n    x: Any,\n    y: Any,\n    ax: \"Axes\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Implementation of channel plotting\"\"\"\n    pass\n</code></pre> <code></code> <code>plot(bf, ax=None, title=None, overlay=False, **kwargs)</code> \u00b6 <p>Spectrogram plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def plot(\n    self,\n    bf: \"SpectrogramFrame\",\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = False,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Spectrogram plotting\"\"\"\n    if overlay:\n        raise ValueError(\"Overlay is not supported for SpectrogramPlotStrategy.\")\n\n    if ax is not None and bf.n_channels &gt; 1:\n        raise ValueError(\"ax must be None when n_channels &gt; 1.\")\n\n    kwargs = kwargs or {}\n\n    is_aw = kwargs.pop(\"Aw\", False)\n    if is_aw:\n        unit = \"dBA\"\n        data = bf.dBA\n    else:\n        unit = \"dB\"\n        data = bf.dB\n\n    specshow_kwargs = filter_kwargs(display.specshow, kwargs, strict_mode=True)\n    ax_set_kwargs = filter_kwargs(Axes.set, kwargs, strict_mode=True)\n\n    cmap = kwargs.pop(\"cmap\", \"jet\")\n    vmin = kwargs.pop(\"vmin\", None)\n    vmax = kwargs.pop(\"vmax\", None)\n\n    if ax is not None:\n        img = display.specshow(\n            data=data[0],\n            sr=bf.sampling_rate,\n            hop_length=bf.hop_length,\n            n_fft=bf.n_fft,\n            win_length=bf.win_length,\n            x_axis=\"time\",\n            y_axis=\"linear\",\n            cmap=cmap,\n            ax=ax,\n            vmin=vmin,\n            vmax=vmax,\n            **specshow_kwargs,\n        )\n        ax.set(\n            title=title or bf.label or \"Spectrogram\",\n            ylabel=\"Frequency [Hz]\",\n            xlabel=\"Time [s]\",\n            **ax_set_kwargs,\n        )\n\n        fig = ax.figure\n        if fig is not None:\n            cbar = fig.colorbar(img, ax=ax)\n            cbar.set_label(f\"Spectrum level [{unit}]\")\n        return ax\n\n    else:\n        # Create a new figure if ax is None\n        num_channels = bf.n_channels\n        fig, axs = plt.subplots(\n            num_channels, 1, figsize=(10, 5 * num_channels), sharex=True\n        )\n        if not isinstance(fig, plt.Figure):\n            raise ValueError(\"fig must be a matplotlib Figure object.\")\n        # Convert axs to array if it is a single Axes object\n        if not isinstance(axs, np.ndarray):\n            axs = np.array([axs])\n\n        for ax_i, channel_data, ch_meta in zip(axs.flatten(), data, bf.channels):\n            img = display.specshow(\n                data=channel_data,\n                sr=bf.sampling_rate,\n                hop_length=bf.hop_length,\n                n_fft=bf.n_fft,\n                win_length=bf.win_length,\n                x_axis=\"time\",\n                y_axis=\"linear\",\n                ax=ax_i,\n                cmap=cmap,\n                vmin=vmin,\n                vmax=vmax,\n                **specshow_kwargs,\n            )\n            ax_i.set(\n                title=ch_meta.label,\n                ylabel=\"Frequency [Hz]\",\n                xlabel=\"Time [s]\",\n                **ax_set_kwargs,\n            )\n            cbar = ax_i.figure.colorbar(img, ax=ax_i)\n            cbar.set_label(f\"Spectrum level [{unit}]\")\n            fig.suptitle(title or \"Spectrogram Data\")\n        plt.tight_layout()\n        plt.show()\n\n        return _return_axes_iterator(fig.axes)\n</code></pre>"},{"location":"api/#wandas.visualization.plotting.DescribePlotStrategy","title":"<code>DescribePlotStrategy</code>","text":"<p>               Bases: <code>PlotStrategy['ChannelFrame']</code></p> <p>Strategy for visualizing ChannelFrame data with describe plot</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>class DescribePlotStrategy(PlotStrategy[\"ChannelFrame\"]):\n    \"\"\"Strategy for visualizing ChannelFrame data with describe plot\"\"\"\n\n    name = \"describe\"\n\n    def channel_plot(self, x: Any, y: Any, ax: \"Axes\", **kwargs: Any) -&gt; None:\n        \"\"\"Implementation of channel plotting\"\"\"\n        pass  # This method is not used for describe plot\n\n    def plot(\n        self,\n        bf: \"ChannelFrame\",\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = False,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Implementation of describe method for visualizing ChannelFrame data\"\"\"\n\n        fmin = kwargs.pop(\"fmin\", 0)\n        fmax = kwargs.pop(\"fmax\", None)\n        cmap = kwargs.pop(\"cmap\", \"jet\")\n        vmin = kwargs.pop(\"vmin\", None)\n        vmax = kwargs.pop(\"vmax\", None)\n        xlim = kwargs.pop(\"xlim\", None)\n        ylim = kwargs.pop(\"ylim\", None)\n        is_aw = kwargs.pop(\"Aw\", False)\n        waveform = kwargs.pop(\"waveform\", {})\n        spectral = kwargs.pop(\"spectral\", dict(xlim=(vmin, vmax)))\n\n        gs = gridspec.GridSpec(2, 3, height_ratios=[1, 3], width_ratios=[3, 1, 0.1])\n        gs.update(wspace=0.2)\n\n        fig = plt.figure(figsize=(12, 6))\n        fig.subplots_adjust(wspace=0.0001)\n\n        # First subplot (Time Plot)\n        ax_1 = fig.add_subplot(gs[0])\n        bf.plot(plot_type=\"waveform\", ax=ax_1, overlay=True)\n        ax_1.set(**waveform)\n        ax_1.legend().set_visible(False)\n        ax_1.set(xlabel=\"\", title=\"\")\n\n        # Second subplot (STFT Plot)\n        ax_2 = fig.add_subplot(gs[3], sharex=ax_1)\n        stft_ch = bf.stft()\n        if is_aw:\n            unit = \"dBA\"\n            channel_data = stft_ch.dBA[0]\n        else:\n            unit = \"dB\"\n            channel_data = stft_ch.dB[0]\n        # Get the maximum value of the data and round it to a convenient value\n        if vmax is None:\n            data_max = np.nanmax(channel_data)\n            # Round to a convenient number with increments of 10, 5, or 2\n            for step in [10, 5, 2]:\n                rounded_max = np.ceil(data_max / step) * step\n                if rounded_max &gt;= data_max:\n                    vmax = rounded_max\n                    vmin = vmax - 180\n                    break\n        img = display.specshow(\n            data=channel_data,\n            sr=bf.sampling_rate,\n            hop_length=stft_ch.hop_length,\n            n_fft=stft_ch.n_fft,\n            win_length=stft_ch.win_length,\n            x_axis=\"time\",\n            y_axis=\"linear\",\n            ax=ax_2,\n            fmin=fmin,\n            fmax=fmax,\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n        )\n        ax_2.set(xlim=xlim, ylim=ylim)\n\n        # Third subplot\n        ax_3 = fig.add_subplot(gs[1])\n        ax_3.axis(\"off\")\n\n        # Fourth subplot (Welch Plot)\n        ax_4 = fig.add_subplot(gs[4], sharey=ax_2)\n        welch_ch = bf.welch()\n        if is_aw:\n            unit = \"dBA\"\n            data_db = welch_ch.dBA\n        else:\n            unit = \"dB\"\n            data_db = welch_ch.dB\n        ax_4.plot(data_db.T, welch_ch.freqs.T)\n        ax_4.grid(True)\n        ax_4.set(xlabel=f\"Spectrum level [{unit}]\", **spectral)\n\n        cbar = fig.colorbar(img, ax=ax_4, format=\"%+2.0f\")\n        cbar.set_label(unit)\n        fig.suptitle(title or bf.label or \"Channel Data\")\n\n        return _return_axes_iterator(fig.axes)\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'describe'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>channel_plot(x, y, ax, **kwargs)</code> \u00b6 <p>Implementation of channel plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def channel_plot(self, x: Any, y: Any, ax: \"Axes\", **kwargs: Any) -&gt; None:\n    \"\"\"Implementation of channel plotting\"\"\"\n    pass  # This method is not used for describe plot\n</code></pre> <code></code> <code>plot(bf, ax=None, title=None, overlay=False, **kwargs)</code> \u00b6 <p>Implementation of describe method for visualizing ChannelFrame data</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def plot(\n    self,\n    bf: \"ChannelFrame\",\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = False,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Implementation of describe method for visualizing ChannelFrame data\"\"\"\n\n    fmin = kwargs.pop(\"fmin\", 0)\n    fmax = kwargs.pop(\"fmax\", None)\n    cmap = kwargs.pop(\"cmap\", \"jet\")\n    vmin = kwargs.pop(\"vmin\", None)\n    vmax = kwargs.pop(\"vmax\", None)\n    xlim = kwargs.pop(\"xlim\", None)\n    ylim = kwargs.pop(\"ylim\", None)\n    is_aw = kwargs.pop(\"Aw\", False)\n    waveform = kwargs.pop(\"waveform\", {})\n    spectral = kwargs.pop(\"spectral\", dict(xlim=(vmin, vmax)))\n\n    gs = gridspec.GridSpec(2, 3, height_ratios=[1, 3], width_ratios=[3, 1, 0.1])\n    gs.update(wspace=0.2)\n\n    fig = plt.figure(figsize=(12, 6))\n    fig.subplots_adjust(wspace=0.0001)\n\n    # First subplot (Time Plot)\n    ax_1 = fig.add_subplot(gs[0])\n    bf.plot(plot_type=\"waveform\", ax=ax_1, overlay=True)\n    ax_1.set(**waveform)\n    ax_1.legend().set_visible(False)\n    ax_1.set(xlabel=\"\", title=\"\")\n\n    # Second subplot (STFT Plot)\n    ax_2 = fig.add_subplot(gs[3], sharex=ax_1)\n    stft_ch = bf.stft()\n    if is_aw:\n        unit = \"dBA\"\n        channel_data = stft_ch.dBA[0]\n    else:\n        unit = \"dB\"\n        channel_data = stft_ch.dB[0]\n    # Get the maximum value of the data and round it to a convenient value\n    if vmax is None:\n        data_max = np.nanmax(channel_data)\n        # Round to a convenient number with increments of 10, 5, or 2\n        for step in [10, 5, 2]:\n            rounded_max = np.ceil(data_max / step) * step\n            if rounded_max &gt;= data_max:\n                vmax = rounded_max\n                vmin = vmax - 180\n                break\n    img = display.specshow(\n        data=channel_data,\n        sr=bf.sampling_rate,\n        hop_length=stft_ch.hop_length,\n        n_fft=stft_ch.n_fft,\n        win_length=stft_ch.win_length,\n        x_axis=\"time\",\n        y_axis=\"linear\",\n        ax=ax_2,\n        fmin=fmin,\n        fmax=fmax,\n        cmap=cmap,\n        vmin=vmin,\n        vmax=vmax,\n    )\n    ax_2.set(xlim=xlim, ylim=ylim)\n\n    # Third subplot\n    ax_3 = fig.add_subplot(gs[1])\n    ax_3.axis(\"off\")\n\n    # Fourth subplot (Welch Plot)\n    ax_4 = fig.add_subplot(gs[4], sharey=ax_2)\n    welch_ch = bf.welch()\n    if is_aw:\n        unit = \"dBA\"\n        data_db = welch_ch.dBA\n    else:\n        unit = \"dB\"\n        data_db = welch_ch.dB\n    ax_4.plot(data_db.T, welch_ch.freqs.T)\n    ax_4.grid(True)\n    ax_4.set(xlabel=f\"Spectrum level [{unit}]\", **spectral)\n\n    cbar = fig.colorbar(img, ax=ax_4, format=\"%+2.0f\")\n    cbar.set_label(unit)\n    fig.suptitle(title or bf.label or \"Channel Data\")\n\n    return _return_axes_iterator(fig.axes)\n</code></pre>"},{"location":"api/#wandas.visualization.plotting.MatrixPlotStrategy","title":"<code>MatrixPlotStrategy</code>","text":"<p>               Bases: <code>PlotStrategy[Union['SpectralFrame']]</code></p> <p>Strategy for displaying relationships between channels in matrix format</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>class MatrixPlotStrategy(PlotStrategy[Union[\"SpectralFrame\"]]):\n    \"\"\"Strategy for displaying relationships between channels in matrix format\"\"\"\n\n    name = \"matrix\"\n\n    def channel_plot(\n        self,\n        x: Any,\n        y: Any,\n        ax: \"Axes\",\n        title: Optional[str] = None,\n        ylabel: str = \"\",\n        xlabel: str = \"Frequency [Hz]\",\n        alpha: float = 0,\n        **kwargs: Any,\n    ) -&gt; None:\n        ax.plot(x, y, **kwargs)\n        ax.grid(True)\n        ax.set_xlabel(xlabel)\n        ax.set_ylabel(ylabel)\n        ax.set_title(title or \"\")\n\n    def plot(\n        self,\n        bf: \"SpectralFrame\",\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = False,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        kwargs = kwargs or {}\n        is_aw = kwargs.pop(\"Aw\", False)\n        if (\n            len(bf.operation_history) &gt; 0\n            and bf.operation_history[-1][\"operation\"] == \"coherence\"\n        ):\n            unit = \"\"\n            data = bf.magnitude\n            ylabel = kwargs.pop(\"ylabel\", \"coherence\")\n        else:\n            if is_aw:\n                unit = \"dBA\"\n                data = bf.dBA\n            else:\n                unit = \"dB\"\n                data = bf.dB\n            ylabel = kwargs.pop(\"ylabel\", f\"Spectrum level [{unit}]\")\n        xlabel = kwargs.pop(\"xlabel\", \"Frequency [Hz]\")\n        alpha = kwargs.pop(\"alpha\", 1)\n        plot_kwargs = filter_kwargs(Line2D, kwargs, strict_mode=True)\n        ax_set = filter_kwargs(Axes.set, kwargs, strict_mode=True)\n        num_channels = bf.n_channels\n        if overlay:\n            if ax is None:\n                fig, ax = plt.subplots(1, 1, figsize=(6, 6))\n            self.channel_plot(\n                bf.freqs,\n                data.T,\n                ax,  # \u3053\u3053\u3067\u5fc5\u305aAxes\u578b\n                title=title or bf.label or \"Spectral Data\",\n                ylabel=ylabel,\n                xlabel=xlabel,\n                alpha=alpha,\n                **plot_kwargs,\n            )\n            if ax is not None:\n                ax.set(**ax_set)\n                fig.suptitle(title or bf.label or \"Spectral Data\")\n                plt.tight_layout()\n                plt.show()\n                return ax\n            # ax\u304cNone\u306e\u30b1\u30fc\u30b9\u306f\u3053\u3053\u3067\u767a\u751f\u3057\u306a\u3044\n        else:\n            num_rows = int(np.ceil(np.sqrt(num_channels)))\n            fig, axs = plt.subplots(\n                num_rows,\n                num_rows,\n                figsize=(3 * num_rows, 3 * num_rows),\n                sharex=True,\n                sharey=True,\n            )\n            if isinstance(axs, np.ndarray):\n                axes_list = axs.flatten().tolist()\n            elif isinstance(axs, list):\n                import itertools\n\n                axes_list = list(itertools.chain.from_iterable(axs))\n            else:\n                axes_list = [axs]\n            for ax_i, channel_data, ch_meta in zip(axes_list, data, bf.channels):\n                self.channel_plot(\n                    bf.freqs,\n                    channel_data,\n                    ax_i,\n                    title=ch_meta.label,\n                    ylabel=ylabel,\n                    xlabel=xlabel,\n                    alpha=alpha,\n                    **plot_kwargs,\n                )\n                ax_i.set(**ax_set)\n            fig.suptitle(title or bf.label or \"Spectral Data\")\n            plt.tight_layout()\n            plt.show()\n            return _return_axes_iterator(fig.axes)\n\n        raise NotImplementedError()\n</code></pre> Attributes\u00b6 <code></code> <code>name = 'matrix'</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code></code> <code>channel_plot(x, y, ax, title=None, ylabel='', xlabel='Frequency [Hz]', alpha=0, **kwargs)</code> \u00b6 Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def channel_plot(\n    self,\n    x: Any,\n    y: Any,\n    ax: \"Axes\",\n    title: Optional[str] = None,\n    ylabel: str = \"\",\n    xlabel: str = \"Frequency [Hz]\",\n    alpha: float = 0,\n    **kwargs: Any,\n) -&gt; None:\n    ax.plot(x, y, **kwargs)\n    ax.grid(True)\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    ax.set_title(title or \"\")\n</code></pre> <code></code> <code>plot(bf, ax=None, title=None, overlay=False, **kwargs)</code> \u00b6 Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def plot(\n    self,\n    bf: \"SpectralFrame\",\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = False,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    kwargs = kwargs or {}\n    is_aw = kwargs.pop(\"Aw\", False)\n    if (\n        len(bf.operation_history) &gt; 0\n        and bf.operation_history[-1][\"operation\"] == \"coherence\"\n    ):\n        unit = \"\"\n        data = bf.magnitude\n        ylabel = kwargs.pop(\"ylabel\", \"coherence\")\n    else:\n        if is_aw:\n            unit = \"dBA\"\n            data = bf.dBA\n        else:\n            unit = \"dB\"\n            data = bf.dB\n        ylabel = kwargs.pop(\"ylabel\", f\"Spectrum level [{unit}]\")\n    xlabel = kwargs.pop(\"xlabel\", \"Frequency [Hz]\")\n    alpha = kwargs.pop(\"alpha\", 1)\n    plot_kwargs = filter_kwargs(Line2D, kwargs, strict_mode=True)\n    ax_set = filter_kwargs(Axes.set, kwargs, strict_mode=True)\n    num_channels = bf.n_channels\n    if overlay:\n        if ax is None:\n            fig, ax = plt.subplots(1, 1, figsize=(6, 6))\n        self.channel_plot(\n            bf.freqs,\n            data.T,\n            ax,  # \u3053\u3053\u3067\u5fc5\u305aAxes\u578b\n            title=title or bf.label or \"Spectral Data\",\n            ylabel=ylabel,\n            xlabel=xlabel,\n            alpha=alpha,\n            **plot_kwargs,\n        )\n        if ax is not None:\n            ax.set(**ax_set)\n            fig.suptitle(title or bf.label or \"Spectral Data\")\n            plt.tight_layout()\n            plt.show()\n            return ax\n        # ax\u304cNone\u306e\u30b1\u30fc\u30b9\u306f\u3053\u3053\u3067\u767a\u751f\u3057\u306a\u3044\n    else:\n        num_rows = int(np.ceil(np.sqrt(num_channels)))\n        fig, axs = plt.subplots(\n            num_rows,\n            num_rows,\n            figsize=(3 * num_rows, 3 * num_rows),\n            sharex=True,\n            sharey=True,\n        )\n        if isinstance(axs, np.ndarray):\n            axes_list = axs.flatten().tolist()\n        elif isinstance(axs, list):\n            import itertools\n\n            axes_list = list(itertools.chain.from_iterable(axs))\n        else:\n            axes_list = [axs]\n        for ax_i, channel_data, ch_meta in zip(axes_list, data, bf.channels):\n            self.channel_plot(\n                bf.freqs,\n                channel_data,\n                ax_i,\n                title=ch_meta.label,\n                ylabel=ylabel,\n                xlabel=xlabel,\n                alpha=alpha,\n                **plot_kwargs,\n            )\n            ax_i.set(**ax_set)\n        fig.suptitle(title or bf.label or \"Spectral Data\")\n        plt.tight_layout()\n        plt.show()\n        return _return_axes_iterator(fig.axes)\n\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#wandas.visualization.plotting-functions","title":"Functions","text":""},{"location":"api/#wandas.visualization.plotting.register_plot_strategy","title":"<code>register_plot_strategy(strategy_cls)</code>","text":"<p>Register a new plot strategy from a class</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def register_plot_strategy(strategy_cls: type) -&gt; None:\n    \"\"\"Register a new plot strategy from a class\"\"\"\n    if not issubclass(strategy_cls, PlotStrategy):\n        raise TypeError(\"Strategy class must inherit from PlotStrategy.\")\n    if inspect.isabstract(strategy_cls):\n        raise TypeError(\"Cannot register abstract PlotStrategy class.\")\n    _plot_strategies[strategy_cls.name] = strategy_cls\n</code></pre>"},{"location":"api/#wandas.visualization.plotting.get_plot_strategy","title":"<code>get_plot_strategy(name)</code>","text":"<p>Get plot strategy by name</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def get_plot_strategy(name: str) -&gt; type[PlotStrategy[Any]]:\n    \"\"\"Get plot strategy by name\"\"\"\n    if name not in _plot_strategies:\n        raise ValueError(f\"Unknown plot type: {name}\")\n    return _plot_strategies[name]\n</code></pre>"},{"location":"api/#wandas.visualization.plotting.create_operation","title":"<code>create_operation(name, **params)</code>","text":"<p>Create operation instance from operation name and parameters</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def create_operation(name: str, **params: Any) -&gt; PlotStrategy[Any]:\n    \"\"\"Create operation instance from operation name and parameters\"\"\"\n    operation_class = get_plot_strategy(name)\n    return operation_class(**params)\n</code></pre>"},{"location":"api/#_7","title":"\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u30e2\u30b8\u30e5\u30fc\u30eb","text":"<p>\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u30b5\u30f3\u30d7\u30eb\u30c7\u30fc\u30bf\u3068\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/#wandas.datasets","title":"<code>wandas.datasets</code>","text":""},{"location":"api/#wandas.datasets-modules","title":"Modules","text":""},{"location":"api/#wandas.datasets.sample_data","title":"<code>sample_data</code>","text":""},{"location":"api/#wandas.datasets.sample_data-attributes","title":"Attributes","text":""},{"location":"api/#wandas.datasets.sample_data-functions","title":"Functions","text":""},{"location":"api/#wandas.datasets.sample_data.load_sample_signal","title":"<code>load_sample_signal(frequency=5.0, sampling_rate=100, duration=1.0)</code>","text":"<p>Generate a sample sine wave signal.</p>"},{"location":"api/#wandas.datasets.sample_data.load_sample_signal--parameters","title":"Parameters","text":"<p>frequency : float, default=5.0     Frequency of the signal in Hz. sampling_rate : int, default=100     Sampling rate in Hz. duration : float, default=1.0     Duration of the signal in seconds.</p>"},{"location":"api/#wandas.datasets.sample_data.load_sample_signal--returns","title":"Returns","text":"<p>NDArrayReal     Signal data as a NumPy array.</p> Source code in <code>wandas/datasets/sample_data.py</code> <pre><code>def load_sample_signal(\n    frequency: float = 5.0, sampling_rate: int = 100, duration: float = 1.0\n) -&gt; NDArrayReal:\n    \"\"\"\n    Generate a sample sine wave signal.\n\n    Parameters\n    ----------\n    frequency : float, default=5.0\n        Frequency of the signal in Hz.\n    sampling_rate : int, default=100\n        Sampling rate in Hz.\n    duration : float, default=1.0\n        Duration of the signal in seconds.\n\n    Returns\n    -------\n    NDArrayReal\n        Signal data as a NumPy array.\n    \"\"\"\n    num_samples = int(sampling_rate * duration)\n    t = np.arange(num_samples) / sampling_rate\n    signal: NDArrayReal = np.sin(2 * np.pi * frequency * t, dtype=np.float64)\n    return signal\n</code></pre>"},{"location":"api/core/","title":"\u30b3\u30a2\u30e2\u30b8\u30e5\u30fc\u30eb","text":"<p><code>wandas.core</code> \u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u3001Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u57fa\u76e4\u3068\u306a\u308b\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/core/#baseframe","title":"BaseFrame","text":"<p>BaseFrame\u306f\u3059\u3079\u3066\u306eWandas\u30d5\u30ec\u30fc\u30e0\u306e\u57fa\u5e95\u30af\u30e9\u30b9\u3067\u3059\u3002\u3053\u308c\u306f\u57fa\u672c\u7684\u306a\u30c7\u30fc\u30bf\u69cb\u9020\u3068\u64cd\u4f5c\u3092\u5b9a\u7fa9\u3057\u307e\u3059\u3002</p>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame","title":"<code>wandas.core.base_frame.BaseFrame</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for all signal frame types.</p> <p>This class provides the common interface and functionality for all frame types used in signal processing. It implements basic operations like indexing, iteration, and data manipulation that are shared across all frame types.</p>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The signal data to process. Must be a dask array. sampling_rate : float     The sampling rate of the signal in Hz. label : str, optional     A label for the frame. If not provided, defaults to \"unnamed_frame\". metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame--attributes","title":"Attributes","text":"<p>sampling_rate : float     The sampling rate of the signal in Hz. label : str     The label of the frame. metadata : dict     Additional metadata for the frame. operation_history : list[dict]     History of operations performed on this frame.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>class BaseFrame(ABC, Generic[T]):\n    \"\"\"\n    Abstract base class for all signal frame types.\n\n    This class provides the common interface and functionality for all frame types\n    used in signal processing. It implements basic operations like indexing, iteration,\n    and data manipulation that are shared across all frame types.\n\n    Parameters\n    ----------\n    data : DaArray\n        The signal data to process. Must be a dask array.\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str, optional\n        A label for the frame. If not provided, defaults to \"unnamed_frame\".\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    sampling_rate : float\n        The sampling rate of the signal in Hz.\n    label : str\n        The label of the frame.\n    metadata : dict\n        Additional metadata for the frame.\n    operation_history : list[dict]\n        History of operations performed on this frame.\n    \"\"\"\n\n    _data: DaArray\n    sampling_rate: float\n    label: str\n    metadata: dict[str, Any]\n    operation_history: list[dict[str, Any]]\n    _channel_metadata: list[ChannelMetadata]\n    _previous: Optional[\"BaseFrame[Any]\"]\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ):\n        self._data = data.rechunk(chunks=-1)  # type: ignore [unused-ignore]\n        if self._data.ndim == 1:\n            self._data = self._data.reshape((1, -1))\n        self.sampling_rate = sampling_rate\n        self.label = label or \"unnamed_frame\"\n        self.metadata = metadata or {}\n        self.operation_history = operation_history or []\n        self._previous = previous\n\n        if channel_metadata:\n            self._channel_metadata = copy.deepcopy(channel_metadata)\n        else:\n            self._channel_metadata = [\n                ChannelMetadata(label=f\"ch{i}\", unit=\"\", extra={})\n                for i in range(self._n_channels)\n            ]\n\n        try:\n            # Display information for newer dask versions\n            logger.debug(f\"Dask graph layers: {list(self._data.dask.layers.keys())}\")\n            logger.debug(\n                f\"Dask graph dependencies: {len(self._data.dask.dependencies)}\"\n            )\n        except Exception as e:\n            logger.debug(f\"Dask graph visualization details unavailable: {e}\")\n\n    @property\n    @abstractmethod\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n\n    @property\n    def n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return len(self)\n\n    @property\n    def channels(self) -&gt; list[ChannelMetadata]:\n        \"\"\"Property to access channel metadata.\"\"\"\n        return self._channel_metadata\n\n    @property\n    def previous(self) -&gt; Optional[\"BaseFrame[Any]\"]:\n        \"\"\"\n        Returns the previous frame.\n        \"\"\"\n        return self._previous\n\n    def get_channel(self: S, channel_idx: int) -&gt; S:\n        n_channels = len(self)\n        if channel_idx &lt; 0 or channel_idx &gt;= n_channels:\n            range_max = n_channels - 1\n            raise ValueError(\n                f\"Channel index out of range: {channel_idx} \"\n                f\"(valid range: 0-{range_max})\"\n            )\n        logger.debug(f\"Extracting channel index={channel_idx} (lazy operation).\")\n        channel_data = self._data[channel_idx : channel_idx + 1]\n\n        return self._create_new_instance(\n            data=channel_data,\n            operation_history=self.operation_history,\n            channel_metadata=[self._channel_metadata[channel_idx]],\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Returns the number of channels.\n        \"\"\"\n        return len(self._channel_metadata)\n\n    def __iter__(self: S) -&gt; Iterator[S]:\n        for idx in range(len(self)):\n            yield self[idx]\n\n    def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n        \"\"\"\n        Method to get a channel by name or index.\n\n        Parameters\n        ----------\n        key : str, int, slice, or tuple of slices\n            Channel name (label) or index number.\n\n        Returns\n        -------\n        BaseFrame\n            The corresponding channel.\n\n        Raises\n        ------\n        ValueError\n            If the key length is invalid for the shape.\n        IndexError\n            If the channel index is out of range.\n        TypeError\n            If the key type is invalid.\n        \"\"\"\n        if isinstance(key, str):\n            index = self.label2index(key)\n            return self.get_channel(index)\n\n        elif isinstance(key, tuple):\n            # When key is a tuple, treat the first element as an index\n            if len(key) &gt; len(self.shape):\n                raise ValueError(\n                    f\"Invalid key length: {len(key)} for shape {self.shape}\"\n                )\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key[0]]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, slice):\n            new_data = self._data[key]\n            new_channel_metadata = self._channel_metadata[key]\n            if isinstance(new_channel_metadata, ChannelMetadata):\n                new_channel_metadata = [new_channel_metadata]\n            return self._create_new_instance(\n                data=new_data,\n                operation_history=self.operation_history,\n                channel_metadata=new_channel_metadata,\n            )\n        elif isinstance(key, numbers.Integral):\n            # Access by index number\n            if key &lt; 0 or key &gt;= len(self):\n                raise IndexError(f\"Channel index {key} out of range.\")\n            return self.get_channel(key)\n        else:\n            raise TypeError(\n                f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n            )\n\n    def label2index(self, label: str) -&gt; int:\n        \"\"\"\n        Get the index from a channel label.\n\n        Parameters\n        ----------\n        label : str\n            Channel label.\n\n        Returns\n        -------\n        int\n            Corresponding index.\n\n        Raises\n        ------\n        KeyError\n            If the channel label is not found.\n        \"\"\"\n        for idx, ch in enumerate(self._channel_metadata):\n            if ch.label == label:\n                return idx\n        raise KeyError(f\"Channel label '{label}' not found.\")\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        _shape: tuple[int, ...] = self._data.shape\n        return _shape\n\n    @property\n    def data(self) -&gt; T:\n        \"\"\"\n        Returns the computed data.\n        Calculation is executed the first time this is accessed.\n        \"\"\"\n        return self.compute()\n\n    @property\n    def labels(self) -&gt; list[str]:\n        \"\"\"Get a list of all channel labels.\"\"\"\n        return [ch.label for ch in self._channel_metadata]\n\n    def compute(self) -&gt; T:\n        \"\"\"\n        Compute and return the data.\n        This method materializes lazily computed data into a concrete NumPy array.\n\n        Returns\n        -------\n        NDArrayReal\n            The computed data.\n\n        Raises\n        ------\n        ValueError\n            If the computed result is not a NumPy array.\n        \"\"\"\n        logger.debug(\n            \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n        )\n        result = self._data.compute()\n\n        if not isinstance(result, np.ndarray):\n            raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n        logger.debug(f\"Computation complete, result shape: {result.shape}\")\n        return cast(T, result)\n\n    @abstractmethod\n    def plot(\n        self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n    ) -&gt; Union[Axes, Iterator[Axes]]:\n        \"\"\"Plot the data\"\"\"\n        pass\n\n    def persist(self: S) -&gt; S:\n        \"\"\"Persist the data in memory\"\"\"\n        persisted_data = self._data.persist()\n        return self._create_new_instance(data=persisted_data)\n\n    @abstractmethod\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Abstract method for derived classes to provide\n        additional initialization arguments.\n        \"\"\"\n        pass\n\n    def _create_new_instance(self: S, data: DaArray, **kwargs: Any) -&gt; S:\n        \"\"\"\n        Create a new channel instance based on an existing channel.\n        Keyword arguments can override or extend the original attributes.\n        \"\"\"\n\n        sampling_rate = kwargs.pop(\"sampling_rate\", self.sampling_rate)\n        # if not isinstance(sampling_rate, int):\n        #     raise TypeError(\"Sampling rate must be an integer\")\n\n        label = kwargs.pop(\"label\", self.label)\n        if not isinstance(label, str):\n            raise TypeError(\"Label must be a string\")\n\n        metadata = kwargs.pop(\"metadata\", copy.deepcopy(self.metadata))\n        if not isinstance(metadata, dict):\n            raise TypeError(\"Metadata must be a dictionary\")\n\n        channel_metadata = kwargs.pop(\n            \"channel_metadata\", copy.deepcopy(self._channel_metadata)\n        )\n        if not isinstance(channel_metadata, list):\n            raise TypeError(\"Channel metadata must be a list\")\n\n        # Get additional initialization arguments from derived classes\n        additional_kwargs = self._get_additional_init_kwargs()\n        kwargs.update(additional_kwargs)\n\n        return type(self)(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            channel_metadata=channel_metadata,\n            previous=self,\n            **kwargs,\n        )\n\n    def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n        \"\"\"Implicit conversion to NumPy array\"\"\"\n        result = self.compute()\n        if dtype is not None:\n            return result.astype(dtype)\n        return result\n\n    def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n        \"\"\"Visualize the computation graph and save it to a file\"\"\"\n        try:\n            filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n            self._data.visualize(filename=filename)\n            return filename\n        except Exception as e:\n            logger.warning(f\"Failed to visualize the graph: {e}\")\n            return None\n\n    @abstractmethod\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"Basic implementation of binary operations\"\"\"\n        # Basic logic\n        # Actual implementation is left to derived classes\n        pass\n\n    def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Addition operator\"\"\"\n        return self._binary_op(other, lambda x, y: x + y, \"+\")\n\n    def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Subtraction operator\"\"\"\n        return self._binary_op(other, lambda x, y: x - y, \"-\")\n\n    def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Multiplication operator\"\"\"\n        return self._binary_op(other, lambda x, y: x * y, \"*\")\n\n    def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n        \"\"\"Division operator\"\"\"\n        return self._binary_op(other, lambda x, y: x / y, \"/\")\n\n    def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Apply a named operation.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters to pass to the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        # Apply the operation through abstract method\n        return self._apply_operation_impl(operation_name, **params)\n\n    @abstractmethod\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"Implementation of operation application\"\"\"\n        pass\n\n    def debug_info(self) -&gt; None:\n        \"\"\"Output detailed debug information\"\"\"\n        logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n        logger.debug(f\"Label: {self.label}\")\n        logger.debug(f\"Shape: {self.shape}\")\n        logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n        logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n        self._debug_info_impl()\n        logger.debug(\"=== End Debug Info ===\")\n\n    def _debug_info_impl(self) -&gt; None:\n        \"\"\"Implement derived class-specific debug information\"\"\"\n        pass\n</code></pre>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame-attributes","title":"Attributes","text":""},{"location":"api/core/#wandas.core.base_frame.BaseFrame.sampling_rate","title":"<code>sampling_rate = sampling_rate</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#wandas.core.base_frame.BaseFrame.label","title":"<code>label = label or 'unnamed_frame'</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#wandas.core.base_frame.BaseFrame.metadata","title":"<code>metadata = metadata or {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#wandas.core.base_frame.BaseFrame.operation_history","title":"<code>operation_history = operation_history or []</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#wandas.core.base_frame.BaseFrame.n_channels","title":"<code>n_channels</code>  <code>property</code>","text":"<p>Returns the number of channels.</p>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.channels","title":"<code>channels</code>  <code>property</code>","text":"<p>Property to access channel metadata.</p>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.previous","title":"<code>previous</code>  <code>property</code>","text":"<p>Returns the previous frame.</p>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.shape","title":"<code>shape</code>  <code>property</code>","text":""},{"location":"api/core/#wandas.core.base_frame.BaseFrame.data","title":"<code>data</code>  <code>property</code>","text":"<p>Returns the computed data. Calculation is executed the first time this is accessed.</p>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>Get a list of all channel labels.</p>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame-functions","title":"Functions","text":""},{"location":"api/core/#wandas.core.base_frame.BaseFrame.__init__","title":"<code>__init__(data, sampling_rate, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n):\n    self._data = data.rechunk(chunks=-1)  # type: ignore [unused-ignore]\n    if self._data.ndim == 1:\n        self._data = self._data.reshape((1, -1))\n    self.sampling_rate = sampling_rate\n    self.label = label or \"unnamed_frame\"\n    self.metadata = metadata or {}\n    self.operation_history = operation_history or []\n    self._previous = previous\n\n    if channel_metadata:\n        self._channel_metadata = copy.deepcopy(channel_metadata)\n    else:\n        self._channel_metadata = [\n            ChannelMetadata(label=f\"ch{i}\", unit=\"\", extra={})\n            for i in range(self._n_channels)\n        ]\n\n    try:\n        # Display information for newer dask versions\n        logger.debug(f\"Dask graph layers: {list(self._data.dask.layers.keys())}\")\n        logger.debug(\n            f\"Dask graph dependencies: {len(self._data.dask.dependencies)}\"\n        )\n    except Exception as e:\n        logger.debug(f\"Dask graph visualization details unavailable: {e}\")\n</code></pre>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.get_channel","title":"<code>get_channel(channel_idx)</code>","text":"Source code in <code>wandas/core/base_frame.py</code> <pre><code>def get_channel(self: S, channel_idx: int) -&gt; S:\n    n_channels = len(self)\n    if channel_idx &lt; 0 or channel_idx &gt;= n_channels:\n        range_max = n_channels - 1\n        raise ValueError(\n            f\"Channel index out of range: {channel_idx} \"\n            f\"(valid range: 0-{range_max})\"\n        )\n    logger.debug(f\"Extracting channel index={channel_idx} (lazy operation).\")\n    channel_data = self._data[channel_idx : channel_idx + 1]\n\n    return self._create_new_instance(\n        data=channel_data,\n        operation_history=self.operation_history,\n        channel_metadata=[self._channel_metadata[channel_idx]],\n    )\n</code></pre>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of channels.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of channels.\n    \"\"\"\n    return len(self._channel_metadata)\n</code></pre>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __iter__(self: S) -&gt; Iterator[S]:\n    for idx in range(len(self)):\n        yield self[idx]\n</code></pre>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Method to get a channel by name or index.</p>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.__getitem__--parameters","title":"Parameters","text":"<p>key : str, int, slice, or tuple of slices     Channel name (label) or index number.</p>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.__getitem__--returns","title":"Returns","text":"<p>BaseFrame     The corresponding channel.</p>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.__getitem__--raises","title":"Raises","text":"<p>ValueError     If the key length is invalid for the shape. IndexError     If the channel index is out of range. TypeError     If the key type is invalid.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __getitem__(self: S, key: Union[str, int, slice, tuple[slice, ...]]) -&gt; S:\n    \"\"\"\n    Method to get a channel by name or index.\n\n    Parameters\n    ----------\n    key : str, int, slice, or tuple of slices\n        Channel name (label) or index number.\n\n    Returns\n    -------\n    BaseFrame\n        The corresponding channel.\n\n    Raises\n    ------\n    ValueError\n        If the key length is invalid for the shape.\n    IndexError\n        If the channel index is out of range.\n    TypeError\n        If the key type is invalid.\n    \"\"\"\n    if isinstance(key, str):\n        index = self.label2index(key)\n        return self.get_channel(index)\n\n    elif isinstance(key, tuple):\n        # When key is a tuple, treat the first element as an index\n        if len(key) &gt; len(self.shape):\n            raise ValueError(\n                f\"Invalid key length: {len(key)} for shape {self.shape}\"\n            )\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key[0]]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, slice):\n        new_data = self._data[key]\n        new_channel_metadata = self._channel_metadata[key]\n        if isinstance(new_channel_metadata, ChannelMetadata):\n            new_channel_metadata = [new_channel_metadata]\n        return self._create_new_instance(\n            data=new_data,\n            operation_history=self.operation_history,\n            channel_metadata=new_channel_metadata,\n        )\n    elif isinstance(key, numbers.Integral):\n        # Access by index number\n        if key &lt; 0 or key &gt;= len(self):\n            raise IndexError(f\"Channel index {key} out of range.\")\n        return self.get_channel(key)\n    else:\n        raise TypeError(\n            f\"Invalid key type: {type(key)}. Expected str, int, or tuple.\"\n        )\n</code></pre>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.label2index","title":"<code>label2index(label)</code>","text":"<p>Get the index from a channel label.</p>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.label2index--parameters","title":"Parameters","text":"<p>label : str     Channel label.</p>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.label2index--returns","title":"Returns","text":"<p>int     Corresponding index.</p>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.label2index--raises","title":"Raises","text":"<p>KeyError     If the channel label is not found.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def label2index(self, label: str) -&gt; int:\n    \"\"\"\n    Get the index from a channel label.\n\n    Parameters\n    ----------\n    label : str\n        Channel label.\n\n    Returns\n    -------\n    int\n        Corresponding index.\n\n    Raises\n    ------\n    KeyError\n        If the channel label is not found.\n    \"\"\"\n    for idx, ch in enumerate(self._channel_metadata):\n        if ch.label == label:\n            return idx\n    raise KeyError(f\"Channel label '{label}' not found.\")\n</code></pre>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.compute","title":"<code>compute()</code>","text":"<p>Compute and return the data. This method materializes lazily computed data into a concrete NumPy array.</p>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.compute--returns","title":"Returns","text":"<p>NDArrayReal     The computed data.</p>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.compute--raises","title":"Raises","text":"<p>ValueError     If the computed result is not a NumPy array.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def compute(self) -&gt; T:\n    \"\"\"\n    Compute and return the data.\n    This method materializes lazily computed data into a concrete NumPy array.\n\n    Returns\n    -------\n    NDArrayReal\n        The computed data.\n\n    Raises\n    ------\n    ValueError\n        If the computed result is not a NumPy array.\n    \"\"\"\n    logger.debug(\n        \"COMPUTING DASK ARRAY - This will trigger file reading and all processing\"\n    )\n    result = self._data.compute()\n\n    if not isinstance(result, np.ndarray):\n        raise ValueError(f\"Computed result is not a np.ndarray: {type(result)}\")\n\n    logger.debug(f\"Computation complete, result shape: {result.shape}\")\n    return cast(T, result)\n</code></pre>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.plot","title":"<code>plot(plot_type='default', ax=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Plot the data</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>@abstractmethod\ndef plot(\n    self, plot_type: str = \"default\", ax: Optional[Axes] = None, **kwargs: Any\n) -&gt; Union[Axes, Iterator[Axes]]:\n    \"\"\"Plot the data\"\"\"\n    pass\n</code></pre>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.persist","title":"<code>persist()</code>","text":"<p>Persist the data in memory</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def persist(self: S) -&gt; S:\n    \"\"\"Persist the data in memory\"\"\"\n    persisted_data = self._data.persist()\n    return self._create_new_instance(data=persisted_data)\n</code></pre>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.__array__","title":"<code>__array__(dtype=None)</code>","text":"<p>Implicit conversion to NumPy array</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __array__(self, dtype: npt.DTypeLike = None) -&gt; NDArrayReal:\n    \"\"\"Implicit conversion to NumPy array\"\"\"\n    result = self.compute()\n    if dtype is not None:\n        return result.astype(dtype)\n    return result\n</code></pre>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.visualize_graph","title":"<code>visualize_graph(filename=None)</code>","text":"<p>Visualize the computation graph and save it to a file</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def visualize_graph(self, filename: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"Visualize the computation graph and save it to a file\"\"\"\n    try:\n        filename = filename or f\"graph_{uuid.uuid4().hex[:8]}.png\"\n        self._data.visualize(filename=filename)\n        return filename\n    except Exception as e:\n        logger.warning(f\"Failed to visualize the graph: {e}\")\n        return None\n</code></pre>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.__add__","title":"<code>__add__(other)</code>","text":"<p>Addition operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __add__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Addition operator\"\"\"\n    return self._binary_op(other, lambda x, y: x + y, \"+\")\n</code></pre>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtraction operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __sub__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Subtraction operator\"\"\"\n    return self._binary_op(other, lambda x, y: x - y, \"-\")\n</code></pre>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplication operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __mul__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Multiplication operator\"\"\"\n    return self._binary_op(other, lambda x, y: x * y, \"*\")\n</code></pre>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Division operator</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def __truediv__(self: S, other: Union[S, int, float, NDArrayReal]) -&gt; S:\n    \"\"\"Division operator\"\"\"\n    return self._binary_op(other, lambda x, y: x / y, \"/\")\n</code></pre>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.apply_operation","title":"<code>apply_operation(operation_name, **params)</code>","text":"<p>Apply a named operation.</p>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.apply_operation--parameters","title":"Parameters","text":"<p>operation_name : str     Name of the operation to apply. **params : Any     Parameters to pass to the operation.</p>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.apply_operation--returns","title":"Returns","text":"<p>S     A new instance with the operation applied.</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def apply_operation(self: S, operation_name: str, **params: Any) -&gt; S:\n    \"\"\"\n    Apply a named operation.\n\n    Parameters\n    ----------\n    operation_name : str\n        Name of the operation to apply.\n    **params : Any\n        Parameters to pass to the operation.\n\n    Returns\n    -------\n    S\n        A new instance with the operation applied.\n    \"\"\"\n    # Apply the operation through abstract method\n    return self._apply_operation_impl(operation_name, **params)\n</code></pre>"},{"location":"api/core/#wandas.core.base_frame.BaseFrame.debug_info","title":"<code>debug_info()</code>","text":"<p>Output detailed debug information</p> Source code in <code>wandas/core/base_frame.py</code> <pre><code>def debug_info(self) -&gt; None:\n    \"\"\"Output detailed debug information\"\"\"\n    logger.debug(f\"=== {self.__class__.__name__} Debug Info ===\")\n    logger.debug(f\"Label: {self.label}\")\n    logger.debug(f\"Shape: {self.shape}\")\n    logger.debug(f\"Sampling rate: {self.sampling_rate} Hz\")\n    logger.debug(f\"Operation history: {len(self.operation_history)} operations\")\n    self._debug_info_impl()\n    logger.debug(\"=== End Debug Info ===\")\n</code></pre>"},{"location":"api/core/#channelmetadata","title":"ChannelMetadata","text":"<p>ChannelMetadata\u30af\u30e9\u30b9\u306f\u30aa\u30fc\u30c7\u30a3\u30aa\u30c7\u30fc\u30bf\u306e\u30c1\u30e3\u30f3\u30cd\u30eb\u306b\u95a2\u9023\u3059\u308b\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u7ba1\u7406\u3057\u307e\u3059\u3002</p>"},{"location":"api/core/#wandas.core.metadata.ChannelMetadata","title":"<code>wandas.core.metadata.ChannelMetadata</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data class for storing channel metadata</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>class ChannelMetadata(BaseModel):\n    \"\"\"\n    Data class for storing channel metadata\n    \"\"\"\n\n    label: str = \"\"\n    unit: str = \"\"\n    ref: float = 1.0\n    # Additional metadata for extensibility\n    extra: dict[str, Any] = Field(default_factory=dict)\n\n    def __init__(self, **data: Any):\n        super().__init__(**data)\n        # unit\u304c\u6307\u5b9a\u3055\u308c\u3066\u3044\u3066ref\u304c\u30c7\u30d5\u30a9\u30eb\u30c8\u5024\u306a\u3089unit_to_ref\u3067\u81ea\u52d5\u8a2d\u5b9a\n        if self.unit and (\"ref\" not in data or data.get(\"ref\", 1.0) == 1.0):\n            self.ref = unit_to_ref(self.unit)\n\n    def __getitem__(self, key: str) -&gt; Any:\n        \"\"\"Provide dictionary-like behavior\"\"\"\n        if key == \"label\":\n            return self.label\n        elif key == \"unit\":\n            return self.unit\n        elif key == \"ref\":\n            return self.ref\n        else:\n            return self.extra.get(key)\n\n    def __setitem__(self, key: str, value: Any) -&gt; None:\n        \"\"\"Provide dictionary-like behavior\"\"\"\n        if key == \"label\":\n            self.label = value\n        elif key == \"unit\":\n            self.unit = value\n            self.ref = unit_to_ref(value)\n        elif key == \"ref\":\n            self.ref = value\n        else:\n            self.extra[key] = value\n\n    def to_json(self) -&gt; str:\n        \"\"\"Convert to JSON format\"\"\"\n        json_data: str = self.model_dump_json(indent=4)\n        return json_data\n\n    @classmethod\n    def from_json(cls, json_data: str) -&gt; \"ChannelMetadata\":\n        \"\"\"Convert from JSON format\"\"\"\n        root_model: ChannelMetadata = ChannelMetadata.model_validate_json(json_data)\n\n        return root_model\n</code></pre>"},{"location":"api/core/#wandas.core.metadata.ChannelMetadata-attributes","title":"Attributes","text":""},{"location":"api/core/#wandas.core.metadata.ChannelMetadata.label","title":"<code>label = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/core/#wandas.core.metadata.ChannelMetadata.unit","title":"<code>unit = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/core/#wandas.core.metadata.ChannelMetadata.ref","title":"<code>ref = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/core/#wandas.core.metadata.ChannelMetadata.extra","title":"<code>extra = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/core/#wandas.core.metadata.ChannelMetadata-functions","title":"Functions","text":""},{"location":"api/core/#wandas.core.metadata.ChannelMetadata.__init__","title":"<code>__init__(**data)</code>","text":"Source code in <code>wandas/core/metadata.py</code> <pre><code>def __init__(self, **data: Any):\n    super().__init__(**data)\n    # unit\u304c\u6307\u5b9a\u3055\u308c\u3066\u3044\u3066ref\u304c\u30c7\u30d5\u30a9\u30eb\u30c8\u5024\u306a\u3089unit_to_ref\u3067\u81ea\u52d5\u8a2d\u5b9a\n    if self.unit and (\"ref\" not in data or data.get(\"ref\", 1.0) == 1.0):\n        self.ref = unit_to_ref(self.unit)\n</code></pre>"},{"location":"api/core/#wandas.core.metadata.ChannelMetadata.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Provide dictionary-like behavior</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Any:\n    \"\"\"Provide dictionary-like behavior\"\"\"\n    if key == \"label\":\n        return self.label\n    elif key == \"unit\":\n        return self.unit\n    elif key == \"ref\":\n        return self.ref\n    else:\n        return self.extra.get(key)\n</code></pre>"},{"location":"api/core/#wandas.core.metadata.ChannelMetadata.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Provide dictionary-like behavior</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def __setitem__(self, key: str, value: Any) -&gt; None:\n    \"\"\"Provide dictionary-like behavior\"\"\"\n    if key == \"label\":\n        self.label = value\n    elif key == \"unit\":\n        self.unit = value\n        self.ref = unit_to_ref(value)\n    elif key == \"ref\":\n        self.ref = value\n    else:\n        self.extra[key] = value\n</code></pre>"},{"location":"api/core/#wandas.core.metadata.ChannelMetadata.to_json","title":"<code>to_json()</code>","text":"<p>Convert to JSON format</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Convert to JSON format\"\"\"\n    json_data: str = self.model_dump_json(indent=4)\n    return json_data\n</code></pre>"},{"location":"api/core/#wandas.core.metadata.ChannelMetadata.from_json","title":"<code>from_json(json_data)</code>  <code>classmethod</code>","text":"<p>Convert from JSON format</p> Source code in <code>wandas/core/metadata.py</code> <pre><code>@classmethod\ndef from_json(cls, json_data: str) -&gt; \"ChannelMetadata\":\n    \"\"\"Convert from JSON format\"\"\"\n    root_model: ChannelMetadata = ChannelMetadata.model_validate_json(json_data)\n\n    return root_model\n</code></pre>"},{"location":"api/datasets/","title":"\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u30e2\u30b8\u30e5\u30fc\u30eb","text":"<p><code>wandas.datasets</code> \u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u3001\u30c6\u30b9\u30c8\u3084\u30c7\u30e2\u306b\u4f7f\u7528\u3067\u304d\u308b\u30b5\u30f3\u30d7\u30eb\u30c7\u30fc\u30bf\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/datasets/#_2","title":"\u30b5\u30f3\u30d7\u30eb\u30c7\u30fc\u30bf","text":"<p>\u30c6\u30b9\u30c8\u3084\u30c7\u30e2\u3067\u4f7f\u7528\u3067\u304d\u308b\u30b5\u30f3\u30d7\u30eb\u30aa\u30fc\u30c7\u30a3\u30aa\u30c7\u30fc\u30bf\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/datasets/#wandas.datasets.sample_data","title":"<code>wandas.datasets.sample_data</code>","text":""},{"location":"api/datasets/#wandas.datasets.sample_data-attributes","title":"Attributes","text":""},{"location":"api/datasets/#wandas.datasets.sample_data-functions","title":"Functions","text":""},{"location":"api/datasets/#wandas.datasets.sample_data.load_sample_signal","title":"<code>load_sample_signal(frequency=5.0, sampling_rate=100, duration=1.0)</code>","text":"<p>Generate a sample sine wave signal.</p>"},{"location":"api/datasets/#wandas.datasets.sample_data.load_sample_signal--parameters","title":"Parameters","text":"<p>frequency : float, default=5.0     Frequency of the signal in Hz. sampling_rate : int, default=100     Sampling rate in Hz. duration : float, default=1.0     Duration of the signal in seconds.</p>"},{"location":"api/datasets/#wandas.datasets.sample_data.load_sample_signal--returns","title":"Returns","text":"<p>NDArrayReal     Signal data as a NumPy array.</p> Source code in <code>wandas/datasets/sample_data.py</code> <pre><code>def load_sample_signal(\n    frequency: float = 5.0, sampling_rate: int = 100, duration: float = 1.0\n) -&gt; NDArrayReal:\n    \"\"\"\n    Generate a sample sine wave signal.\n\n    Parameters\n    ----------\n    frequency : float, default=5.0\n        Frequency of the signal in Hz.\n    sampling_rate : int, default=100\n        Sampling rate in Hz.\n    duration : float, default=1.0\n        Duration of the signal in seconds.\n\n    Returns\n    -------\n    NDArrayReal\n        Signal data as a NumPy array.\n    \"\"\"\n    num_samples = int(sampling_rate * duration)\n    t = np.arange(num_samples) / sampling_rate\n    signal: NDArrayReal = np.sin(2 * np.pi * frequency * t, dtype=np.float64)\n    return signal\n</code></pre>"},{"location":"api/frames/","title":"\u30d5\u30ec\u30fc\u30e0\u30e2\u30b8\u30e5\u30fc\u30eb","text":"<p><code>wandas.frames</code> \u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u3001\u30aa\u30fc\u30c7\u30a3\u30aa\u30c7\u30fc\u30bf\u306e\u64cd\u4f5c\u3068\u8868\u73fe\u306e\u305f\u3081\u306e\u69d8\u3005\u306a\u30c7\u30fc\u30bf\u30d5\u30ec\u30fc\u30e0\u30af\u30e9\u30b9\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/frames/#channelframe","title":"ChannelFrame","text":"<p>ChannelFrame\u306f\u6642\u9593\u9818\u57df\u306e\u6ce2\u5f62\u30c7\u30fc\u30bf\u3092\u6271\u3046\u305f\u3081\u306e\u57fa\u672c\u7684\u306a\u30d5\u30ec\u30fc\u30e0\u3067\u3059\u3002</p>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame","title":"<code>wandas.frames.channel.ChannelFrame</code>","text":"<p>               Bases: <code>BaseFrame[NDArrayReal]</code>, <code>ChannelProcessingMixin</code>, <code>ChannelTransformMixin</code></p> <p>Channel-based data frame for handling audio signals and time series data.</p> <p>This frame represents channel-based data such as audio signals and time series data, with each channel containing data samples in the time domain.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>class ChannelFrame(\n    BaseFrame[NDArrayReal], ChannelProcessingMixin, ChannelTransformMixin\n):\n    \"\"\"Channel-based data frame for handling audio signals and time series data.\n\n    This frame represents channel-based data such as audio signals and time series data,\n    with each channel containing data samples in the time domain.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: DaskArray,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"Initialize a ChannelFrame.\n\n        Args:\n            data: Dask array containing channel data.\n            Shape should be (n_channels, n_samples).\n            sampling_rate: The sampling rate of the data in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            operation_history: History of operations applied to the frame.\n            channel_metadata: Metadata for each channel.\n            previous: Reference to the previous frame in the processing chain.\n\n        Raises:\n            ValueError: If data has more than 2 dimensions.\n        \"\"\"\n        if data.ndim == 1:\n            data = da.reshape(data, (1, -1))\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"Returns the number of channels.\"\"\"\n        return self.shape[-2]\n\n    @property\n    def time(self) -&gt; NDArrayReal:\n        \"\"\"Get time array for the signal.\n\n        Returns:\n            Array of time points in seconds.\n        \"\"\"\n        return np.arange(self.n_samples) / self.sampling_rate\n\n    @property\n    def n_samples(self) -&gt; int:\n        \"\"\"Returns the number of samples.\"\"\"\n        n: int = self._data.shape[-1]\n        return n\n\n    @property\n    def duration(self) -&gt; float:\n        \"\"\"Returns the duration in seconds.\"\"\"\n        return self.n_samples / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # Apply processing to data\n        processed_data = operation.process(self._data)\n\n        # Update metadata\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        if operation_name == \"resampling\":\n            # For resampling, update sampling rate\n            return self._create_new_instance(\n                sampling_rate=params[\"target_sr\"],\n                data=processed_data,\n                metadata=new_metadata,\n                operation_history=new_history,\n            )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal, \"DaskArray\"],\n        op: Callable[[\"DaskArray\", Any], \"DaskArray\"],\n        symbol: str,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Common implementation for binary operations\n        - utilizing dask's lazy evaluation.\n\n        Args:\n            other: Right operand for the operation.\n            op: Function to execute the operation (e.g., lambda a, b: a + b).\n            symbol: Symbolic representation of the operation (e.g., '+').\n\n        Returns:\n            A new channel containing the operation result (lazy execution).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, ChannelFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Perform operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other._data)\n\n            # Merge channel metadata\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # Perform operation with scalar, NumPy array, or other types\n        else:\n            # Apply operation directly on dask array (maintaining lazy execution)\n            result_data = op(self._data, other)\n\n            # Operand display string\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # Check for dask.array.Array\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # Update channel metadata\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return ChannelFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n                previous=self,\n            )\n\n    def add(\n        self,\n        other: Union[\"ChannelFrame\", int, float, NDArrayReal],\n        snr: Optional[float] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Add another signal or value to the current signal.\n\n        If SNR is specified, performs addition with consideration for\n        signal-to-noise ratio.\n\n        Args:\n            other: Signal or value to add.\n            snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n                other signal based on this SNR.\n                self is treated as the signal, and other as the noise.\n\n        Returns:\n            A new channel frame containing the addition result (lazy execution).\n        \"\"\"\n        logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n        if isinstance(other, ChannelFrame):\n            # Check if sampling rates match\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n        elif isinstance(other, np.ndarray):\n            other = ChannelFrame.from_numpy(\n                other, self.sampling_rate, label=\"array_data\"\n            )\n        elif isinstance(other, (int, float)):\n            return self + other\n        else:\n            raise TypeError(\n                \"Addition target with SNR must be a ChannelFrame or \"\n                f\"NumPy array: {type(other)}\"\n            )\n\n        # If SNR is specified, adjust the length of the other signal\n        if other.duration != self.duration:\n            other = other.fix_length(length=self.n_samples)\n\n        if snr is None:\n            return self + other\n        return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n\n    def plot(\n        self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Plot the frame data.\n\n        Args:\n            plot_type: Type of plot. Default is \"waveform\".\n            ax: Optional matplotlib axes for plotting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        from ..visualization.plotting import create_operation\n\n        plot_strategy = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def rms_plot(\n        self,\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = True,\n        Aw: bool = False,  # noqa: N803\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Generate an RMS plot.\n\n        Args:\n            ax: Optional matplotlib axes for plotting.\n            title: Title for the plot.\n            overlay: Whether to overlay the plot on the existing axis.\n            Aw: Apply A-weighting.\n            **kwargs: Additional arguments passed to the plot function.\n\n        Returns:\n            Single Axes object or iterator of Axes objects.\n        \"\"\"\n        kwargs = kwargs or {}\n        ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n        rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n        return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n\n    def describe(\n        self, normalize: bool = True, is_close: bool = True, **kwargs: Any\n    ) -&gt; None:\n        \"\"\"Display visual and audio representation of the frame.\n\n        Args:\n            normalize: Whether to normalize the audio data for playback.\n            is_close: Whether to close the figure after displaying.\n            **kwargs: Additional parameters for visualization.\n        \"\"\"\n        if \"axis_config\" in kwargs:\n            logger.warning(\n                \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            axis_config = kwargs[\"axis_config\"]\n            if \"time_plot\" in axis_config:\n                kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n            if \"freq_plot\" in axis_config:\n                if \"xlim\" in axis_config[\"freq_plot\"]:\n                    vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                    kwargs[\"vmin\"] = vlim[0]\n                    kwargs[\"vmax\"] = vlim[1]\n                if \"ylim\" in axis_config[\"freq_plot\"]:\n                    ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                    kwargs[\"ylim\"] = ylim\n\n        if \"cbar_config\" in kwargs:\n            logger.warning(\n                \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n            )\n            cbar_config = kwargs[\"cbar_config\"]\n            if \"vmin\" in cbar_config:\n                kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n            if \"vmax\" in cbar_config:\n                kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n        for ch in self:\n            ax: Axes\n            _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n            if isinstance(_ax, Iterator):\n                ax = next(iter(_ax))\n            elif isinstance(_ax, Axes):\n                ax = _ax\n            else:\n                raise TypeError(\n                    f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n                )\n            # display\u95a2\u6570\u3068Audio\u30af\u30e9\u30b9\u3092\u4f7f\u7528\n            display(ax.figure)\n            if is_close:\n                plt.close(ax.figure)\n            display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))\n\n    @classmethod\n    def from_numpy(\n        cls,\n        data: NDArrayReal,\n        sampling_rate: float,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        ch_labels: Optional[list[str]] = None,\n        ch_units: Optional[Union[list[str], str]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        Args:\n            data: NumPy array containing channel data.\n            sampling_rate: The sampling rate in Hz.\n            label: A label for the frame.\n            metadata: Optional metadata dictionary.\n            ch_labels: Labels for each channel.\n            ch_units: Units for each channel.\n\n        Returns:\n            A new ChannelFrame containing the NumPy data.\n        \"\"\"\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n\n        # Convert NumPy array to dask array\n        dask_data = da_from_array(data)\n        cf = cls(\n            data=dask_data,\n            sampling_rate=sampling_rate,\n            label=label or \"numpy_data\",\n        )\n        if metadata is not None:\n            cf.metadata = metadata\n        if ch_labels is not None:\n            if len(ch_labels) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel labels does not match the number of channels\"\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        if ch_units is not None:\n            if isinstance(ch_units, str):\n                ch_units = [ch_units] * cf.n_channels\n\n            if len(ch_units) != cf.n_channels:\n                raise ValueError(\n                    \"Number of channel units does not match the number of channels\"\n                )\n            for i in range(len(ch_units)):\n                cf._channel_metadata[i].unit = ch_units[i]\n\n        return cf\n\n    @classmethod\n    def from_ndarray(\n        cls,\n        array: NDArrayReal,\n        sampling_rate: float,\n        labels: Optional[list[str]] = None,\n        unit: Optional[Union[list[str], str]] = None,\n        frame_label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from a NumPy array.\n\n        This method is deprecated. Use from_numpy instead.\n\n        Args:\n            array: Signal data. Each row corresponds to a channel.\n            sampling_rate: Sampling rate (Hz).\n            labels: Labels for each channel.\n            unit: Unit of the signal.\n            frame_label: Label for the frame.\n            metadata: Optional metadata dictionary.\n\n        Returns:\n            A new ChannelFrame containing the data.\n        \"\"\"\n        # Redirect to from_numpy for compatibility\n        # However, from_ndarray is deprecated\n        logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n        return cls.from_numpy(\n            data=array,\n            sampling_rate=sampling_rate,\n            label=frame_label,\n            metadata=metadata,\n            ch_labels=labels,\n            ch_units=unit,\n        )\n\n    @classmethod\n    def from_file(\n        cls,\n        path: Union[str, Path],\n        channel: Optional[Union[int, list[int]]] = None,\n        start: Optional[float] = None,\n        end: Optional[float] = None,\n        chunk_size: Optional[int] = None,\n        ch_labels: Optional[list[str]] = None,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Create a ChannelFrame from an audio file.\n\n        Args:\n            path: Path to the audio file.\n            channel: Channel(s) to load.\n            start: Start time in seconds.\n            end: End time in seconds.\n            chunk_size: Chunk size for processing.\n            Specifies the splitting size for lazy processing.\n            ch_labels: Labels for each channel.\n            **kwargs: Additional arguments passed to the file reader.\n\n        Returns:\n            A new ChannelFrame containing the loaded audio data.\n\n        Raises:\n            ValueError: If channel specification is invalid.\n            TypeError: If channel parameter type is invalid.\n            FileNotFoundError: If the file doesn't exist.\n        \"\"\"\n        from .channel import ChannelFrame\n\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"File not found: {path}\")\n\n        # Get file reader\n        reader = get_file_reader(path)\n\n        # Get file info\n        info = reader.get_file_info(path, **kwargs)\n        sr = info[\"samplerate\"]\n        n_channels = info[\"channels\"]\n        n_frames = info[\"frames\"]\n        ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n        logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n        # Channel selection processing\n        all_channels = list(range(n_channels))\n\n        if channel is None:\n            channels_to_load = all_channels\n            logger.debug(f\"Will load all channels: {channels_to_load}\")\n        elif isinstance(channel, int):\n            if channel &lt; 0 or channel &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n            channels_to_load = [channel]\n            logger.debug(f\"Will load single channel: {channel}\")\n        elif isinstance(channel, (list, tuple)):\n            for ch in channel:\n                if ch &lt; 0 or ch &gt;= n_channels:\n                    raise ValueError(\n                        f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                    )\n            channels_to_load = list(channel)\n            logger.debug(f\"Will load specific channels: {channels_to_load}\")\n        else:\n            raise TypeError(\"channel must be int, list, or None\")\n\n        # Index calculation\n        start_idx = 0 if start is None else max(0, int(start * sr))\n        end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n        frames_to_read = end_idx - start_idx\n\n        logger.debug(\n            f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n            f\"start_idx={start_idx}, end_idx={end_idx}\"\n        )\n\n        # Settings for lazy loading\n        expected_shape = (len(channels_to_load), frames_to_read)\n\n        # Define the loading function using the file reader\n        def _load_audio() -&gt; NDArrayReal:\n            logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n            # Use the reader to get audio data with parameters\n            out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n            if not isinstance(out, np.ndarray):\n                raise ValueError(\"Unexpected data type after reading file\")\n            return out\n\n        logger.debug(\n            f\"Creating delayed dask task with expected shape: {expected_shape}\"\n        )\n\n        # Create delayed operation\n        delayed_data = dask_delayed(_load_audio)()\n        logger.debug(\"Wrapping delayed function in dask array\")\n\n        # Create dask array from delayed computation\n        dask_array = da_from_delayed(\n            delayed_data, shape=expected_shape, dtype=np.float32\n        )\n\n        if chunk_size is not None:\n            if chunk_size &lt;= 0:\n                raise ValueError(\"Chunk size must be a positive integer\")\n            logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n            dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n        logger.debug(\n            \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n        )\n\n        cf = ChannelFrame(\n            data=dask_array,\n            sampling_rate=sr,\n            label=path.stem,\n            metadata={\n                \"filename\": str(path),\n            },\n        )\n        if ch_labels is not None:\n            if len(ch_labels) != len(cf):\n                raise ValueError(\n                    \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n                )\n            for i in range(len(ch_labels)):\n                cf._channel_metadata[i].label = ch_labels[i]\n        return cf\n\n    @classmethod\n    def read_wav(\n        cls, filename: str, labels: Optional[list[str]] = None\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a WAV file.\n\n        Args:\n            filename: Path to the WAV file.\n            labels: Labels to set for each channel.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(filename, ch_labels=labels)\n        return cf\n\n    @classmethod\n    def read_csv(\n        cls,\n        filename: str,\n        time_column: Union[int, str] = 0,\n        labels: Optional[list[str]] = None,\n        delimiter: str = \",\",\n        header: Optional[int] = 0,\n    ) -&gt; \"ChannelFrame\":\n        \"\"\"Utility method to read a CSV file.\n\n        Args:\n            filename: Path to the CSV file.\n            time_column: Index or name of the time column.\n            labels: Labels to set for each channel.\n            delimiter: Delimiter character.\n            header: Row number to use as header.\n\n        Returns:\n            A new ChannelFrame containing the data (lazy loading).\n        \"\"\"\n        from .channel import ChannelFrame\n\n        cf = ChannelFrame.from_file(\n            filename,\n            ch_labels=labels,\n            time_column=time_column,\n            delimiter=delimiter,\n            header=header,\n        )\n        return cf\n\n    def to_wav(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n        \"\"\"Save the audio data to a WAV file.\n\n        Args:\n            path: Path to save the file.\n            format: File format. If None, determined from file extension.\n        \"\"\"\n        from wandas.io.wav_io import write_wav\n\n        write_wav(str(path), self, format=format)\n\n    def save(\n        self,\n        path: Union[str, Path],\n        *,\n        format: str = \"hdf5\",\n        compress: Optional[str] = \"gzip\",\n        overwrite: bool = False,\n        dtype: Optional[Union[str, np.dtype[Any]]] = None,\n    ) -&gt; None:\n        \"\"\"Save the ChannelFrame to a WDF (Wandas Data File) format.\n\n        This saves the complete frame including all channel data and metadata\n        in a format that can be loaded back with full fidelity.\n\n        Args:\n            path: Path to save the file. '.wdf' extension will be added if not present.\n            format: Format to use (currently only 'hdf5' is supported)\n            compress: Compression method ('gzip' by default, None for no compression)\n            overwrite: Whether to overwrite existing file\n            dtype: Optional data type conversion before saving (e.g. 'float32')\n\n        Raises:\n            FileExistsError: If the file exists and overwrite=False.\n            NotImplementedError: For unsupported formats.\n\n        Example:\n            &gt;&gt;&gt; cf = ChannelFrame.read_wav(\"audio.wav\")\n            &gt;&gt;&gt; cf.save(\"audio_analysis.wdf\")\n        \"\"\"\n        from ..io.wdf_io import save as wdf_save\n\n        wdf_save(\n            self,\n            path,\n            format=format,\n            compress=compress,\n            overwrite=overwrite,\n            dtype=dtype,\n        )\n\n    @classmethod\n    def load(cls, path: Union[str, Path], *, format: str = \"hdf5\") -&gt; \"ChannelFrame\":\n        \"\"\"Load a ChannelFrame from a WDF (Wandas Data File) file.\n\n        This loads data saved with the save() method, preserving all channel data,\n        metadata, labels, and units.\n\n        Args:\n            path: Path to the WDF file\n            format: Format of the file (currently only 'hdf5' is supported)\n\n        Returns:\n            A new ChannelFrame with all data and metadata loaded\n\n        Raises:\n            FileNotFoundError: If the file doesn't exist\n            NotImplementedError: For unsupported formats\n\n        Example:\n            &gt;&gt;&gt; cf = ChannelFrame.load(\"audio_analysis.wdf\")\n        \"\"\"\n        from ..io.wdf_io import load as wdf_load\n\n        return wdf_load(path, format=format)\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"Provide additional initialization arguments required for ChannelFrame.\"\"\"\n        return {}\n\n    def add_channel(\n        self,\n        data: Union[np.ndarray[Any, Any], DaskArray, \"ChannelFrame\"],\n        label: Optional[str] = None,\n        align: str = \"strict\",\n        suffix_on_dup: Optional[str] = None,\n        inplace: bool = False,\n        **kwargs: Any,\n    ) -&gt; \"ChannelFrame\":\n        # ndarray/dask/\u540c\u578bFrame\u5bfe\u5fdc\n        if isinstance(data, ChannelFrame):\n            if self.sampling_rate != data.sampling_rate:\n                raise ValueError(\"sampling_rate\u4e0d\u4e00\u81f4\")\n            if data.n_samples != self.n_samples:\n                if align == \"pad\":\n                    pad_len = self.n_samples - data.n_samples\n                    arr = data._data\n                    if pad_len &gt; 0:\n                        arr = concatenate(\n                            [\n                                arr,\n                                from_array(\n                                    np.zeros((arr.shape[0], pad_len), dtype=arr.dtype)\n                                ),\n                            ],\n                            axis=1,\n                        )\n                    else:\n                        arr = arr[:, : self.n_samples]\n                elif align == \"truncate\":\n                    arr = data._data[:, : self.n_samples]\n                    if arr.shape[1] &lt; self.n_samples:\n                        pad_len = self.n_samples - arr.shape[1]\n                        arr = concatenate(\n                            [\n                                arr,\n                                from_array(\n                                    np.zeros((arr.shape[0], pad_len), dtype=arr.dtype)\n                                ),\n                            ],\n                            axis=1,\n                        )\n                else:\n                    raise ValueError(\"\u30c7\u30fc\u30bf\u9577\u4e0d\u4e00\u81f4: align\u6307\u5b9a\u3092\u78ba\u8a8d\")\n            else:\n                arr = data._data\n            labels = [ch.label for ch in self._channel_metadata]\n            new_labels = []\n            for chmeta in data._channel_metadata:\n                new_label = chmeta.label\n                if new_label in labels or new_label in new_labels:\n                    if suffix_on_dup:\n                        new_label += suffix_on_dup\n                    else:\n                        raise ValueError(f\"label\u91cd\u8907: {new_label}\")\n                new_labels.append(new_label)\n            new_data = concatenate([self._data, arr], axis=0)\n            from ..core.metadata import ChannelMetadata\n\n            new_chmeta = self._channel_metadata + [\n                ChannelMetadata(label=lbl) for lbl in new_labels\n            ]\n            if inplace:\n                self._data = new_data\n                self._channel_metadata = new_chmeta\n                return self\n            else:\n                return ChannelFrame(\n                    data=new_data,\n                    sampling_rate=self.sampling_rate,\n                    label=self.label,\n                    metadata=self.metadata,\n                    operation_history=self.operation_history,\n                    channel_metadata=new_chmeta,\n                    previous=self,\n                )\n        if isinstance(data, np.ndarray):\n            arr = from_array(data.reshape(1, -1))\n        elif isinstance(data, DaskArray):\n            arr = data[None, ...] if data.ndim == 1 else data\n            if arr.shape[0] != 1:\n                arr = arr.reshape((1, -1))\n        else:\n            raise TypeError(\"add_channel: ndarray/dask/\u540c\u578bFrame\u306e\u307f\u5bfe\u5fdc\")\n        if arr.shape[1] != self.n_samples:\n            if align == \"pad\":\n                pad_len = self.n_samples - arr.shape[1]\n                if pad_len &gt; 0:\n                    arr = concatenate(\n                        [arr, from_array(np.zeros((1, pad_len), dtype=arr.dtype))],\n                        axis=1,\n                    )\n                else:\n                    arr = arr[:, : self.n_samples]\n            elif align == \"truncate\":\n                arr = arr[:, : self.n_samples]\n                if arr.shape[1] &lt; self.n_samples:\n                    pad_len = self.n_samples - arr.shape[1]\n                    arr = concatenate(\n                        [arr, from_array(np.zeros((1, pad_len), dtype=arr.dtype))],\n                        axis=1,\n                    )\n            else:\n                raise ValueError(\"\u30c7\u30fc\u30bf\u9577\u4e0d\u4e00\u81f4: align\u6307\u5b9a\u3092\u78ba\u8a8d\")\n        labels = [ch.label for ch in self._channel_metadata]\n        new_label = label or f\"ch{len(labels)}\"\n        if new_label in labels:\n            if suffix_on_dup:\n                new_label += suffix_on_dup\n            else:\n                raise ValueError(\"label\u91cd\u8907\")\n        new_data = concatenate([self._data, arr], axis=0)\n        from ..core.metadata import ChannelMetadata\n\n        new_chmeta = self._channel_metadata + [ChannelMetadata(label=new_label)]\n        if inplace:\n            self._data = new_data\n            self._channel_metadata = new_chmeta\n            return self\n        else:\n            return ChannelFrame(\n                data=new_data,\n                sampling_rate=self.sampling_rate,\n                label=self.label,\n                metadata=self.metadata,\n                operation_history=self.operation_history,\n                channel_metadata=new_chmeta,\n                previous=self,\n            )\n\n    def remove_channel(\n        self, key: Union[int, str], inplace: bool = False\n    ) -&gt; \"ChannelFrame\":\n        if isinstance(key, int):\n            if not (0 &lt;= key &lt; self.n_channels):\n                raise IndexError(f\"index {key} out of range\")\n            idx = key\n        else:\n            labels = [ch.label for ch in self._channel_metadata]\n            if key not in labels:\n                raise KeyError(f\"label {key} not found\")\n            idx = labels.index(key)\n        new_data = self._data[[i for i in range(self.n_channels) if i != idx], :]\n        new_chmeta = [ch for i, ch in enumerate(self._channel_metadata) if i != idx]\n        if inplace:\n            self._data = new_data\n            self._channel_metadata = new_chmeta\n            return self\n        else:\n            return ChannelFrame(\n                data=new_data,\n                sampling_rate=self.sampling_rate,\n                label=self.label,\n                metadata=self.metadata,\n                operation_history=self.operation_history,\n                channel_metadata=new_chmeta,\n                previous=self,\n            )\n</code></pre>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame-attributes","title":"Attributes","text":""},{"location":"api/frames/#wandas.frames.channel.ChannelFrame.time","title":"<code>time</code>  <code>property</code>","text":"<p>Get time array for the signal.</p> <p>Returns:</p> Type Description <code>NDArrayReal</code> <p>Array of time points in seconds.</p>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame.n_samples","title":"<code>n_samples</code>  <code>property</code>","text":"<p>Returns the number of samples.</p>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Returns the duration in seconds.</p>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame-functions","title":"Functions","text":""},{"location":"api/frames/#wandas.frames.channel.ChannelFrame.__init__","title":"<code>__init__(data, sampling_rate, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a ChannelFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>Dask array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate of the data in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>operation_history</code> <code>Optional[list[dict[str, Any]]]</code> <p>History of operations applied to the frame.</p> <code>None</code> <code>channel_metadata</code> <code>Optional[list[ChannelMetadata]]</code> <p>Metadata for each channel.</p> <code>None</code> <code>previous</code> <code>Optional[BaseFrame[Any]]</code> <p>Reference to the previous frame in the processing chain.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has more than 2 dimensions.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def __init__(\n    self,\n    data: DaskArray,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"Initialize a ChannelFrame.\n\n    Args:\n        data: Dask array containing channel data.\n        Shape should be (n_channels, n_samples).\n        sampling_rate: The sampling rate of the data in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        operation_history: History of operations applied to the frame.\n        channel_metadata: Metadata for each channel.\n        previous: Reference to the previous frame in the processing chain.\n\n    Raises:\n        ValueError: If data has more than 2 dimensions.\n    \"\"\"\n    if data.ndim == 1:\n        data = da.reshape(data, (1, -1))\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame.add","title":"<code>add(other, snr=None)</code>","text":"<p>Add another signal or value to the current signal.</p> <p>If SNR is specified, performs addition with consideration for signal-to-noise ratio.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[ChannelFrame, int, float, NDArrayReal]</code> <p>Signal or value to add.</p> required <code>snr</code> <code>Optional[float]</code> <p>Signal-to-noise ratio (dB). If specified, adjusts the scale of the other signal based on this SNR. self is treated as the signal, and other as the noise.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new channel frame containing the addition result (lazy execution).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def add(\n    self,\n    other: Union[\"ChannelFrame\", int, float, NDArrayReal],\n    snr: Optional[float] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Add another signal or value to the current signal.\n\n    If SNR is specified, performs addition with consideration for\n    signal-to-noise ratio.\n\n    Args:\n        other: Signal or value to add.\n        snr: Signal-to-noise ratio (dB). If specified, adjusts the scale of the\n            other signal based on this SNR.\n            self is treated as the signal, and other as the noise.\n\n    Returns:\n        A new channel frame containing the addition result (lazy execution).\n    \"\"\"\n    logger.debug(f\"Setting up add operation with SNR={snr} (lazy)\")\n\n    if isinstance(other, ChannelFrame):\n        # Check if sampling rates match\n        if self.sampling_rate != other.sampling_rate:\n            raise ValueError(\n                \"Sampling rates do not match. Cannot perform operation.\"\n            )\n\n    elif isinstance(other, np.ndarray):\n        other = ChannelFrame.from_numpy(\n            other, self.sampling_rate, label=\"array_data\"\n        )\n    elif isinstance(other, (int, float)):\n        return self + other\n    else:\n        raise TypeError(\n            \"Addition target with SNR must be a ChannelFrame or \"\n            f\"NumPy array: {type(other)}\"\n        )\n\n    # If SNR is specified, adjust the length of the other signal\n    if other.duration != self.duration:\n        other = other.fix_length(length=self.n_samples)\n\n    if snr is None:\n        return self + other\n    return self.apply_operation(\"add_with_snr\", other=other._data, snr=snr)\n</code></pre>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame.plot","title":"<code>plot(plot_type='waveform', ax=None, **kwargs)</code>","text":"<p>Plot the frame data.</p> <p>Parameters:</p> Name Type Description Default <code>plot_type</code> <code>str</code> <p>Type of plot. Default is \"waveform\".</p> <code>'waveform'</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def plot(\n    self, plot_type: str = \"waveform\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Plot the frame data.\n\n    Args:\n        plot_type: Type of plot. Default is \"waveform\".\n        ax: Optional matplotlib axes for plotting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    from ..visualization.plotting import create_operation\n\n    plot_strategy = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame.rms_plot","title":"<code>rms_plot(ax=None, title=None, overlay=True, Aw=False, **kwargs)</code>","text":"<p>Generate an RMS plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib axes for plotting.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title for the plot.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay the plot on the existing axis.</p> <code>True</code> <code>Aw</code> <code>bool</code> <p>Apply A-weighting.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the plot function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Axes, Iterator[Axes]]</code> <p>Single Axes object or iterator of Axes objects.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def rms_plot(\n    self,\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = True,\n    Aw: bool = False,  # noqa: N803\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Generate an RMS plot.\n\n    Args:\n        ax: Optional matplotlib axes for plotting.\n        title: Title for the plot.\n        overlay: Whether to overlay the plot on the existing axis.\n        Aw: Apply A-weighting.\n        **kwargs: Additional arguments passed to the plot function.\n\n    Returns:\n        Single Axes object or iterator of Axes objects.\n    \"\"\"\n    kwargs = kwargs or {}\n    ylabel = kwargs.pop(\"ylabel\", \"RMS\")\n    rms_ch: ChannelFrame = self.rms_trend(Aw=Aw, dB=True)\n    return rms_ch.plot(ax=ax, ylabel=ylabel, title=title, overlay=overlay, **kwargs)\n</code></pre>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame.describe","title":"<code>describe(normalize=True, is_close=True, **kwargs)</code>","text":"<p>Display visual and audio representation of the frame.</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>Whether to normalize the audio data for playback.</p> <code>True</code> <code>is_close</code> <code>bool</code> <p>Whether to close the figure after displaying.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for visualization.</p> <code>{}</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def describe(\n    self, normalize: bool = True, is_close: bool = True, **kwargs: Any\n) -&gt; None:\n    \"\"\"Display visual and audio representation of the frame.\n\n    Args:\n        normalize: Whether to normalize the audio data for playback.\n        is_close: Whether to close the figure after displaying.\n        **kwargs: Additional parameters for visualization.\n    \"\"\"\n    if \"axis_config\" in kwargs:\n        logger.warning(\n            \"axis_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        axis_config = kwargs[\"axis_config\"]\n        if \"time_plot\" in axis_config:\n            kwargs[\"waveform\"] = axis_config[\"time_plot\"]\n        if \"freq_plot\" in axis_config:\n            if \"xlim\" in axis_config[\"freq_plot\"]:\n                vlim = axis_config[\"freq_plot\"][\"xlim\"]\n                kwargs[\"vmin\"] = vlim[0]\n                kwargs[\"vmax\"] = vlim[1]\n            if \"ylim\" in axis_config[\"freq_plot\"]:\n                ylim = axis_config[\"freq_plot\"][\"ylim\"]\n                kwargs[\"ylim\"] = ylim\n\n    if \"cbar_config\" in kwargs:\n        logger.warning(\n            \"cbar_config is retained for backward compatibility but will be deprecated in the future.\"  # noqa: E501\n        )\n        cbar_config = kwargs[\"cbar_config\"]\n        if \"vmin\" in cbar_config:\n            kwargs[\"vmin\"] = cbar_config[\"vmin\"]\n        if \"vmax\" in cbar_config:\n            kwargs[\"vmax\"] = cbar_config[\"vmax\"]\n\n    for ch in self:\n        ax: Axes\n        _ax = ch.plot(\"describe\", title=f\"{ch.label} {ch.labels[0]}\", **kwargs)\n        if isinstance(_ax, Iterator):\n            ax = next(iter(_ax))\n        elif isinstance(_ax, Axes):\n            ax = _ax\n        else:\n            raise TypeError(\n                f\"Unexpected type for plot result: {type(_ax)}. Expected Axes or Iterator[Axes].\"  # noqa: E501\n            )\n        # display\u95a2\u6570\u3068Audio\u30af\u30e9\u30b9\u3092\u4f7f\u7528\n        display(ax.figure)\n        if is_close:\n            plt.close(ax.figure)\n        display(Audio(ch.data, rate=ch.sampling_rate, normalize=normalize))\n</code></pre>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame.from_numpy","title":"<code>from_numpy(data, sampling_rate, label=None, metadata=None, ch_labels=None, ch_units=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArrayReal</code> <p>NumPy array containing channel data.</p> required <code>sampling_rate</code> <code>float</code> <p>The sampling rate in Hz.</p> required <code>label</code> <code>Optional[str]</code> <p>A label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>ch_units</code> <code>Optional[Union[list[str], str]]</code> <p>Units for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the NumPy data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_numpy(\n    cls,\n    data: NDArrayReal,\n    sampling_rate: float,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    ch_labels: Optional[list[str]] = None,\n    ch_units: Optional[Union[list[str], str]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    Args:\n        data: NumPy array containing channel data.\n        sampling_rate: The sampling rate in Hz.\n        label: A label for the frame.\n        metadata: Optional metadata dictionary.\n        ch_labels: Labels for each channel.\n        ch_units: Units for each channel.\n\n    Returns:\n        A new ChannelFrame containing the NumPy data.\n    \"\"\"\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n\n    # Convert NumPy array to dask array\n    dask_data = da_from_array(data)\n    cf = cls(\n        data=dask_data,\n        sampling_rate=sampling_rate,\n        label=label or \"numpy_data\",\n    )\n    if metadata is not None:\n        cf.metadata = metadata\n    if ch_labels is not None:\n        if len(ch_labels) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel labels does not match the number of channels\"\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    if ch_units is not None:\n        if isinstance(ch_units, str):\n            ch_units = [ch_units] * cf.n_channels\n\n        if len(ch_units) != cf.n_channels:\n            raise ValueError(\n                \"Number of channel units does not match the number of channels\"\n            )\n        for i in range(len(ch_units)):\n            cf._channel_metadata[i].unit = ch_units[i]\n\n    return cf\n</code></pre>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame.from_ndarray","title":"<code>from_ndarray(array, sampling_rate, labels=None, unit=None, frame_label=None, metadata=None)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from a NumPy array.</p> <p>This method is deprecated. Use from_numpy instead.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>NDArrayReal</code> <p>Signal data. Each row corresponds to a channel.</p> required <code>sampling_rate</code> <code>float</code> <p>Sampling rate (Hz).</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>unit</code> <code>Optional[Union[list[str], str]]</code> <p>Unit of the signal.</p> <code>None</code> <code>frame_label</code> <code>Optional[str]</code> <p>Label for the frame.</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_ndarray(\n    cls,\n    array: NDArrayReal,\n    sampling_rate: float,\n    labels: Optional[list[str]] = None,\n    unit: Optional[Union[list[str], str]] = None,\n    frame_label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from a NumPy array.\n\n    This method is deprecated. Use from_numpy instead.\n\n    Args:\n        array: Signal data. Each row corresponds to a channel.\n        sampling_rate: Sampling rate (Hz).\n        labels: Labels for each channel.\n        unit: Unit of the signal.\n        frame_label: Label for the frame.\n        metadata: Optional metadata dictionary.\n\n    Returns:\n        A new ChannelFrame containing the data.\n    \"\"\"\n    # Redirect to from_numpy for compatibility\n    # However, from_ndarray is deprecated\n    logger.warning(\"from_ndarray is deprecated. Use from_numpy instead.\")\n    return cls.from_numpy(\n        data=array,\n        sampling_rate=sampling_rate,\n        label=frame_label,\n        metadata=metadata,\n        ch_labels=labels,\n        ch_units=unit,\n    )\n</code></pre>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame.from_file","title":"<code>from_file(path, channel=None, start=None, end=None, chunk_size=None, ch_labels=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a ChannelFrame from an audio file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the audio file.</p> required <code>channel</code> <code>Optional[Union[int, list[int]]]</code> <p>Channel(s) to load.</p> <code>None</code> <code>start</code> <code>Optional[float]</code> <p>Start time in seconds.</p> <code>None</code> <code>end</code> <code>Optional[float]</code> <p>End time in seconds.</p> <code>None</code> <code>chunk_size</code> <code>Optional[int]</code> <p>Chunk size for processing.</p> <code>None</code> <code>ch_labels</code> <code>Optional[list[str]]</code> <p>Labels for each channel.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the file reader.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the loaded audio data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If channel specification is invalid.</p> <code>TypeError</code> <p>If channel parameter type is invalid.</p> <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    path: Union[str, Path],\n    channel: Optional[Union[int, list[int]]] = None,\n    start: Optional[float] = None,\n    end: Optional[float] = None,\n    chunk_size: Optional[int] = None,\n    ch_labels: Optional[list[str]] = None,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Create a ChannelFrame from an audio file.\n\n    Args:\n        path: Path to the audio file.\n        channel: Channel(s) to load.\n        start: Start time in seconds.\n        end: End time in seconds.\n        chunk_size: Chunk size for processing.\n        Specifies the splitting size for lazy processing.\n        ch_labels: Labels for each channel.\n        **kwargs: Additional arguments passed to the file reader.\n\n    Returns:\n        A new ChannelFrame containing the loaded audio data.\n\n    Raises:\n        ValueError: If channel specification is invalid.\n        TypeError: If channel parameter type is invalid.\n        FileNotFoundError: If the file doesn't exist.\n    \"\"\"\n    from .channel import ChannelFrame\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    # Get file reader\n    reader = get_file_reader(path)\n\n    # Get file info\n    info = reader.get_file_info(path, **kwargs)\n    sr = info[\"samplerate\"]\n    n_channels = info[\"channels\"]\n    n_frames = info[\"frames\"]\n    ch_labels = ch_labels or info.get(\"ch_labels\", None)\n\n    logger.debug(f\"File info: sr={sr}, channels={n_channels}, frames={n_frames}\")\n\n    # Channel selection processing\n    all_channels = list(range(n_channels))\n\n    if channel is None:\n        channels_to_load = all_channels\n        logger.debug(f\"Will load all channels: {channels_to_load}\")\n    elif isinstance(channel, int):\n        if channel &lt; 0 or channel &gt;= n_channels:\n            raise ValueError(\n                f\"Channel specification is out of range: {channel} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n            )\n        channels_to_load = [channel]\n        logger.debug(f\"Will load single channel: {channel}\")\n    elif isinstance(channel, (list, tuple)):\n        for ch in channel:\n            if ch &lt; 0 or ch &gt;= n_channels:\n                raise ValueError(\n                    f\"Channel specification is out of range: {ch} (valid range: 0-{n_channels - 1})\"  # noqa: E501\n                )\n        channels_to_load = list(channel)\n        logger.debug(f\"Will load specific channels: {channels_to_load}\")\n    else:\n        raise TypeError(\"channel must be int, list, or None\")\n\n    # Index calculation\n    start_idx = 0 if start is None else max(0, int(start * sr))\n    end_idx = n_frames if end is None else min(n_frames, int(end * sr))\n    frames_to_read = end_idx - start_idx\n\n    logger.debug(\n        f\"Setting up lazy load from file={path}, frames={frames_to_read}, \"\n        f\"start_idx={start_idx}, end_idx={end_idx}\"\n    )\n\n    # Settings for lazy loading\n    expected_shape = (len(channels_to_load), frames_to_read)\n\n    # Define the loading function using the file reader\n    def _load_audio() -&gt; NDArrayReal:\n        logger.debug(\"&gt;&gt;&gt; EXECUTING DELAYED LOAD &lt;&lt;&lt;\")\n        # Use the reader to get audio data with parameters\n        out = reader.get_data(path, channels_to_load, start_idx, frames_to_read)\n        if not isinstance(out, np.ndarray):\n            raise ValueError(\"Unexpected data type after reading file\")\n        return out\n\n    logger.debug(\n        f\"Creating delayed dask task with expected shape: {expected_shape}\"\n    )\n\n    # Create delayed operation\n    delayed_data = dask_delayed(_load_audio)()\n    logger.debug(\"Wrapping delayed function in dask array\")\n\n    # Create dask array from delayed computation\n    dask_array = da_from_delayed(\n        delayed_data, shape=expected_shape, dtype=np.float32\n    )\n\n    if chunk_size is not None:\n        if chunk_size &lt;= 0:\n            raise ValueError(\"Chunk size must be a positive integer\")\n        logger.debug(f\"Setting chunk size: {chunk_size} for sample axis\")\n        dask_array = dask_array.rechunk({0: -1, 1: chunk_size})\n\n    logger.debug(\n        \"ChannelFrame setup complete - actual file reading will occur on compute()\"  # noqa: E501\n    )\n\n    cf = ChannelFrame(\n        data=dask_array,\n        sampling_rate=sr,\n        label=path.stem,\n        metadata={\n            \"filename\": str(path),\n        },\n    )\n    if ch_labels is not None:\n        if len(ch_labels) != len(cf):\n            raise ValueError(\n                \"Number of channel labels does not match the number of specified channels\"  # noqa: E501\n            )\n        for i in range(len(ch_labels)):\n            cf._channel_metadata[i].label = ch_labels[i]\n    return cf\n</code></pre>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame.read_wav","title":"<code>read_wav(filename, labels=None)</code>  <code>classmethod</code>","text":"<p>Utility method to read a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the WAV file.</p> required <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_wav(\n    cls, filename: str, labels: Optional[list[str]] = None\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a WAV file.\n\n    Args:\n        filename: Path to the WAV file.\n        labels: Labels to set for each channel.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(filename, ch_labels=labels)\n    return cf\n</code></pre>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame.read_csv","title":"<code>read_csv(filename, time_column=0, labels=None, delimiter=',', header=0)</code>  <code>classmethod</code>","text":"<p>Utility method to read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the CSV file.</p> required <code>time_column</code> <code>Union[int, str]</code> <p>Index or name of the time column.</p> <code>0</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels to set for each channel.</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Delimiter character.</p> <code>','</code> <code>header</code> <code>Optional[int]</code> <p>Row number to use as header.</p> <code>0</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame containing the data (lazy loading).</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef read_csv(\n    cls,\n    filename: str,\n    time_column: Union[int, str] = 0,\n    labels: Optional[list[str]] = None,\n    delimiter: str = \",\",\n    header: Optional[int] = 0,\n) -&gt; \"ChannelFrame\":\n    \"\"\"Utility method to read a CSV file.\n\n    Args:\n        filename: Path to the CSV file.\n        time_column: Index or name of the time column.\n        labels: Labels to set for each channel.\n        delimiter: Delimiter character.\n        header: Row number to use as header.\n\n    Returns:\n        A new ChannelFrame containing the data (lazy loading).\n    \"\"\"\n    from .channel import ChannelFrame\n\n    cf = ChannelFrame.from_file(\n        filename,\n        ch_labels=labels,\n        time_column=time_column,\n        delimiter=delimiter,\n        header=header,\n    )\n    return cf\n</code></pre>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame.to_wav","title":"<code>to_wav(path, format=None)</code>","text":"<p>Save the audio data to a WAV file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file.</p> required <code>format</code> <code>Optional[str]</code> <p>File format. If None, determined from file extension.</p> <code>None</code> Source code in <code>wandas/frames/channel.py</code> <pre><code>def to_wav(self, path: Union[str, Path], format: Optional[str] = None) -&gt; None:\n    \"\"\"Save the audio data to a WAV file.\n\n    Args:\n        path: Path to save the file.\n        format: File format. If None, determined from file extension.\n    \"\"\"\n    from wandas.io.wav_io import write_wav\n\n    write_wav(str(path), self, format=format)\n</code></pre>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame.save","title":"<code>save(path, *, format='hdf5', compress='gzip', overwrite=False, dtype=None)</code>","text":"<p>Save the ChannelFrame to a WDF (Wandas Data File) format.</p> <p>This saves the complete frame including all channel data and metadata in a format that can be loaded back with full fidelity.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file. '.wdf' extension will be added if not present.</p> required <code>format</code> <code>str</code> <p>Format to use (currently only 'hdf5' is supported)</p> <code>'hdf5'</code> <code>compress</code> <code>Optional[str]</code> <p>Compression method ('gzip' by default, None for no compression)</p> <code>'gzip'</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing file</p> <code>False</code> <code>dtype</code> <code>Optional[Union[str, dtype[Any]]]</code> <p>Optional data type conversion before saving (e.g. 'float32')</p> <code>None</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If the file exists and overwrite=False.</p> <code>NotImplementedError</code> <p>For unsupported formats.</p> Example <p>cf = ChannelFrame.read_wav(\"audio.wav\") cf.save(\"audio_analysis.wdf\")</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>def save(\n    self,\n    path: Union[str, Path],\n    *,\n    format: str = \"hdf5\",\n    compress: Optional[str] = \"gzip\",\n    overwrite: bool = False,\n    dtype: Optional[Union[str, np.dtype[Any]]] = None,\n) -&gt; None:\n    \"\"\"Save the ChannelFrame to a WDF (Wandas Data File) format.\n\n    This saves the complete frame including all channel data and metadata\n    in a format that can be loaded back with full fidelity.\n\n    Args:\n        path: Path to save the file. '.wdf' extension will be added if not present.\n        format: Format to use (currently only 'hdf5' is supported)\n        compress: Compression method ('gzip' by default, None for no compression)\n        overwrite: Whether to overwrite existing file\n        dtype: Optional data type conversion before saving (e.g. 'float32')\n\n    Raises:\n        FileExistsError: If the file exists and overwrite=False.\n        NotImplementedError: For unsupported formats.\n\n    Example:\n        &gt;&gt;&gt; cf = ChannelFrame.read_wav(\"audio.wav\")\n        &gt;&gt;&gt; cf.save(\"audio_analysis.wdf\")\n    \"\"\"\n    from ..io.wdf_io import save as wdf_save\n\n    wdf_save(\n        self,\n        path,\n        format=format,\n        compress=compress,\n        overwrite=overwrite,\n        dtype=dtype,\n    )\n</code></pre>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame.load","title":"<code>load(path, *, format='hdf5')</code>  <code>classmethod</code>","text":"<p>Load a ChannelFrame from a WDF (Wandas Data File) file.</p> <p>This loads data saved with the save() method, preserving all channel data, metadata, labels, and units.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the WDF file</p> required <code>format</code> <code>str</code> <p>Format of the file (currently only 'hdf5' is supported)</p> <code>'hdf5'</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame with all data and metadata loaded</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist</p> <code>NotImplementedError</code> <p>For unsupported formats</p> Example <p>cf = ChannelFrame.load(\"audio_analysis.wdf\")</p> Source code in <code>wandas/frames/channel.py</code> <pre><code>@classmethod\ndef load(cls, path: Union[str, Path], *, format: str = \"hdf5\") -&gt; \"ChannelFrame\":\n    \"\"\"Load a ChannelFrame from a WDF (Wandas Data File) file.\n\n    This loads data saved with the save() method, preserving all channel data,\n    metadata, labels, and units.\n\n    Args:\n        path: Path to the WDF file\n        format: Format of the file (currently only 'hdf5' is supported)\n\n    Returns:\n        A new ChannelFrame with all data and metadata loaded\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n        NotImplementedError: For unsupported formats\n\n    Example:\n        &gt;&gt;&gt; cf = ChannelFrame.load(\"audio_analysis.wdf\")\n    \"\"\"\n    from ..io.wdf_io import load as wdf_load\n\n    return wdf_load(path, format=format)\n</code></pre>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame.add_channel","title":"<code>add_channel(data, label=None, align='strict', suffix_on_dup=None, inplace=False, **kwargs)</code>","text":"Source code in <code>wandas/frames/channel.py</code> <pre><code>def add_channel(\n    self,\n    data: Union[np.ndarray[Any, Any], DaskArray, \"ChannelFrame\"],\n    label: Optional[str] = None,\n    align: str = \"strict\",\n    suffix_on_dup: Optional[str] = None,\n    inplace: bool = False,\n    **kwargs: Any,\n) -&gt; \"ChannelFrame\":\n    # ndarray/dask/\u540c\u578bFrame\u5bfe\u5fdc\n    if isinstance(data, ChannelFrame):\n        if self.sampling_rate != data.sampling_rate:\n            raise ValueError(\"sampling_rate\u4e0d\u4e00\u81f4\")\n        if data.n_samples != self.n_samples:\n            if align == \"pad\":\n                pad_len = self.n_samples - data.n_samples\n                arr = data._data\n                if pad_len &gt; 0:\n                    arr = concatenate(\n                        [\n                            arr,\n                            from_array(\n                                np.zeros((arr.shape[0], pad_len), dtype=arr.dtype)\n                            ),\n                        ],\n                        axis=1,\n                    )\n                else:\n                    arr = arr[:, : self.n_samples]\n            elif align == \"truncate\":\n                arr = data._data[:, : self.n_samples]\n                if arr.shape[1] &lt; self.n_samples:\n                    pad_len = self.n_samples - arr.shape[1]\n                    arr = concatenate(\n                        [\n                            arr,\n                            from_array(\n                                np.zeros((arr.shape[0], pad_len), dtype=arr.dtype)\n                            ),\n                        ],\n                        axis=1,\n                    )\n            else:\n                raise ValueError(\"\u30c7\u30fc\u30bf\u9577\u4e0d\u4e00\u81f4: align\u6307\u5b9a\u3092\u78ba\u8a8d\")\n        else:\n            arr = data._data\n        labels = [ch.label for ch in self._channel_metadata]\n        new_labels = []\n        for chmeta in data._channel_metadata:\n            new_label = chmeta.label\n            if new_label in labels or new_label in new_labels:\n                if suffix_on_dup:\n                    new_label += suffix_on_dup\n                else:\n                    raise ValueError(f\"label\u91cd\u8907: {new_label}\")\n            new_labels.append(new_label)\n        new_data = concatenate([self._data, arr], axis=0)\n        from ..core.metadata import ChannelMetadata\n\n        new_chmeta = self._channel_metadata + [\n            ChannelMetadata(label=lbl) for lbl in new_labels\n        ]\n        if inplace:\n            self._data = new_data\n            self._channel_metadata = new_chmeta\n            return self\n        else:\n            return ChannelFrame(\n                data=new_data,\n                sampling_rate=self.sampling_rate,\n                label=self.label,\n                metadata=self.metadata,\n                operation_history=self.operation_history,\n                channel_metadata=new_chmeta,\n                previous=self,\n            )\n    if isinstance(data, np.ndarray):\n        arr = from_array(data.reshape(1, -1))\n    elif isinstance(data, DaskArray):\n        arr = data[None, ...] if data.ndim == 1 else data\n        if arr.shape[0] != 1:\n            arr = arr.reshape((1, -1))\n    else:\n        raise TypeError(\"add_channel: ndarray/dask/\u540c\u578bFrame\u306e\u307f\u5bfe\u5fdc\")\n    if arr.shape[1] != self.n_samples:\n        if align == \"pad\":\n            pad_len = self.n_samples - arr.shape[1]\n            if pad_len &gt; 0:\n                arr = concatenate(\n                    [arr, from_array(np.zeros((1, pad_len), dtype=arr.dtype))],\n                    axis=1,\n                )\n            else:\n                arr = arr[:, : self.n_samples]\n        elif align == \"truncate\":\n            arr = arr[:, : self.n_samples]\n            if arr.shape[1] &lt; self.n_samples:\n                pad_len = self.n_samples - arr.shape[1]\n                arr = concatenate(\n                    [arr, from_array(np.zeros((1, pad_len), dtype=arr.dtype))],\n                    axis=1,\n                )\n        else:\n            raise ValueError(\"\u30c7\u30fc\u30bf\u9577\u4e0d\u4e00\u81f4: align\u6307\u5b9a\u3092\u78ba\u8a8d\")\n    labels = [ch.label for ch in self._channel_metadata]\n    new_label = label or f\"ch{len(labels)}\"\n    if new_label in labels:\n        if suffix_on_dup:\n            new_label += suffix_on_dup\n        else:\n            raise ValueError(\"label\u91cd\u8907\")\n    new_data = concatenate([self._data, arr], axis=0)\n    from ..core.metadata import ChannelMetadata\n\n    new_chmeta = self._channel_metadata + [ChannelMetadata(label=new_label)]\n    if inplace:\n        self._data = new_data\n        self._channel_metadata = new_chmeta\n        return self\n    else:\n        return ChannelFrame(\n            data=new_data,\n            sampling_rate=self.sampling_rate,\n            label=self.label,\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=new_chmeta,\n            previous=self,\n        )\n</code></pre>"},{"location":"api/frames/#wandas.frames.channel.ChannelFrame.remove_channel","title":"<code>remove_channel(key, inplace=False)</code>","text":"Source code in <code>wandas/frames/channel.py</code> <pre><code>def remove_channel(\n    self, key: Union[int, str], inplace: bool = False\n) -&gt; \"ChannelFrame\":\n    if isinstance(key, int):\n        if not (0 &lt;= key &lt; self.n_channels):\n            raise IndexError(f\"index {key} out of range\")\n        idx = key\n    else:\n        labels = [ch.label for ch in self._channel_metadata]\n        if key not in labels:\n            raise KeyError(f\"label {key} not found\")\n        idx = labels.index(key)\n    new_data = self._data[[i for i in range(self.n_channels) if i != idx], :]\n    new_chmeta = [ch for i, ch in enumerate(self._channel_metadata) if i != idx]\n    if inplace:\n        self._data = new_data\n        self._channel_metadata = new_chmeta\n        return self\n    else:\n        return ChannelFrame(\n            data=new_data,\n            sampling_rate=self.sampling_rate,\n            label=self.label,\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=new_chmeta,\n            previous=self,\n        )\n</code></pre>"},{"location":"api/frames/#spectralframe","title":"SpectralFrame","text":"<p>SpectralFrame\u306f\u5468\u6ce2\u6570\u9818\u57df\u306e\u30c7\u30fc\u30bf\u3092\u6271\u3046\u305f\u3081\u306e\u30d5\u30ec\u30fc\u30e0\u3067\u3059\u3002</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame","title":"<code>wandas.frames.spectral.SpectralFrame</code>","text":"<p>               Bases: <code>BaseFrame[NDArrayComplex]</code></p> <p>Class for handling frequency-domain signal data.</p> <p>This class represents spectral data, providing methods for spectral analysis, manipulation, and visualization. It handles complex-valued frequency domain data obtained through operations like FFT.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The spectral data. Must be a dask array with shape:     - (channels, frequency_bins) for multi-channel data     - (frequency_bins,) for single-channel data, which will be       reshaped to (1, frequency_bins) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. n_fft : int     The FFT size used to generate this spectral data. window : str, default=\"hann\"     The window function used in the FFT. label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame--attributes","title":"Attributes","text":"<p>magnitude : NDArrayReal     The magnitude spectrum of the data. phase : NDArrayReal     The phase spectrum in radians. power : NDArrayReal     The power spectrum (magnitude squared). dB : NDArrayReal     The spectrum in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrum in decibels. freqs : NDArrayReal     The frequency axis values in Hz.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame--examples","title":"Examples","text":"<p>Create a SpectralFrame from FFT:</p> <p>signal = ChannelFrame.from_numpy(data, sampling_rate=44100) spectrum = signal.fft(n_fft=2048)</p> <p>Plot the magnitude spectrum:</p> <p>spectrum.plot()</p> <p>Perform binary operations:</p> <p>scaled = spectrum * 2.0 summed = spectrum1 + spectrum2  # Must have matching sampling rates</p> <p>Convert back to time domain:</p> <p>time_signal = spectrum.ifft()</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame--notes","title":"Notes","text":"<ul> <li>All operations are performed lazily using dask arrays for efficient memory usage.</li> <li>Binary operations (+, -, *, /) can be performed between SpectralFrames or with   scalar values.</li> <li>The class maintains the processing history and metadata through all operations.</li> </ul> Source code in <code>wandas/frames/spectral.py</code> <pre><code>class SpectralFrame(BaseFrame[NDArrayComplex]):\n    \"\"\"\n    Class for handling frequency-domain signal data.\n\n    This class represents spectral data, providing methods for spectral analysis,\n    manipulation, and visualization. It handles complex-valued frequency domain data\n    obtained through operations like FFT.\n\n    Parameters\n    ----------\n    data : DaArray\n        The spectral data. Must be a dask array with shape:\n        - (channels, frequency_bins) for multi-channel data\n        - (frequency_bins,) for single-channel data, which will be\n          reshaped to (1, frequency_bins)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    n_fft : int\n        The FFT size used to generate this spectral data.\n    window : str, default=\"hann\"\n        The window function used in the FFT.\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    magnitude : NDArrayReal\n        The magnitude spectrum of the data.\n    phase : NDArrayReal\n        The phase spectrum in radians.\n    power : NDArrayReal\n        The power spectrum (magnitude squared).\n    dB : NDArrayReal\n        The spectrum in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrum in decibels.\n    freqs : NDArrayReal\n        The frequency axis values in Hz.\n\n    Examples\n    --------\n    Create a SpectralFrame from FFT:\n    &gt;&gt;&gt; signal = ChannelFrame.from_numpy(data, sampling_rate=44100)\n    &gt;&gt;&gt; spectrum = signal.fft(n_fft=2048)\n\n    Plot the magnitude spectrum:\n    &gt;&gt;&gt; spectrum.plot()\n\n    Perform binary operations:\n    &gt;&gt;&gt; scaled = spectrum * 2.0\n    &gt;&gt;&gt; summed = spectrum1 + spectrum2  # Must have matching sampling rates\n\n    Convert back to time domain:\n    &gt;&gt;&gt; time_signal = spectrum.ifft()\n\n    Notes\n    -----\n    - All operations are performed lazily using dask arrays for efficient memory usage.\n    - Binary operations (+, -, *, /) can be performed between SpectralFrames or with\n      scalar values.\n    - The class maintains the processing history and metadata through all operations.\n    \"\"\"\n\n    n_fft: int\n    window: str\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        n_fft: int,\n        window: str = \"hann\",\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        if data.ndim == 1:\n            data = data.reshape(1, -1)\n        elif data.ndim &gt; 2:\n            raise ValueError(\n                f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n            )\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def magnitude(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the magnitude spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The absolute values of the complex spectrum.\n        \"\"\"\n        return np.abs(self.data)\n\n    @property\n    def phase(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the phase spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The phase angles of the complex spectrum in radians.\n        \"\"\"\n        return np.angle(self.data)\n\n    @property\n    def power(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the power spectrum.\n\n        Returns\n        -------\n        NDArrayReal\n            The squared magnitude spectrum.\n        \"\"\"\n        return self.magnitude**2\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrum in decibels.\n\n        The reference values are taken from channel metadata. If no reference\n        is specified, uses 1.0.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrum in dB relative to channel references.\n        \"\"\"\n        mag: NDArrayReal = self.magnitude\n        ref_values: NDArrayReal = np.array([ch.ref for ch in self._channel_metadata])\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(mag / ref_values[:, np.newaxis], 1e-12)\n        )\n\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrum in decibels.\n\n        Applies A-weighting filter to the spectrum for better correlation with\n        perceived loudness.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrum in dB.\n        \"\"\"\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels.\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the frequency axis values in Hz.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of frequency values corresponding to each frequency bin.\n        \"\"\"\n        return np.fft.rfftfreq(self.n_fft, 1.0 / self.sampling_rate)\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Implementation of operation application for spectral data.\n\n        This internal method handles the application of various operations to\n        spectral data, maintaining lazy evaluation through dask.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters for the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n\n        # Apply processing to data\n        processed_data = operation.process(self._data)\n\n        # Update metadata\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\n            \"SpectralFrame\", int, float, complex, NDArrayComplex, NDArrayReal, \"DaArray\"\n        ],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"\n        Common implementation for binary operations.\n\n        This method handles binary operations between SpectralFrames and various types\n        of operands, maintaining lazy evaluation through dask arrays.\n\n        Parameters\n        ----------\n        other : Union[SpectralFrame, int, float, complex,\n                        NDArrayComplex, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation (e.g., lambda a, b: a + b)\n        symbol : str\n            String representation of the operation (e.g., '+')\n\n        Returns\n        -------\n        SpectralFrame\n            A new SpectralFrame containing the result of the operation.\n\n        Raises\n        ------\n        ValueError\n            If attempting to operate with a SpectralFrame\n            with a different sampling rate.\n        \"\"\"\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        # Handle potentially None metadata and operation_history\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        # Check if other is a ChannelFrame - improved type checking\n        if isinstance(other, SpectralFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"Sampling rates do not match. Cannot perform operation.\"\n                )\n\n            # Directly operate on dask arrays (maintaining lazy execution)\n            result_data = op(self._data, other._data)\n\n            # Combine channel metadata\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return SpectralFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n\n        # Operation with scalar, NumPy array, or other types\n        else:\n            # Apply operation directly to dask array (maintaining lazy execution)\n            result_data = op(self._data, other)\n\n            # String representation of operand for display\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, complex):\n                other_str = f\"complex({other.real}, {other.imag})\"\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):  # Check for dask.array.Array\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            # Update channel metadata\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return SpectralFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n            )\n\n    def plot(\n        self,\n        plot_type: str = \"frequency\",\n        ax: Optional[\"Axes\"] = None,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the spectral data using various visualization strategies.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"frequency\"\n            Type of plot to create. Options include:\n            - \"frequency\": Standard frequency plot\n            - \"matrix\": Matrix plot for comparing channels\n            - Other types as defined by available plot strategies\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - title: Plot title\n            - xlabel, ylabel: Axis labels\n            - vmin, vmax: Value limits for plots\n            - cmap: Colormap name\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def ifft(self) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.\n\n        This method transforms the frequency-domain data back to the time domain using\n        the inverse FFT operation. The window function used in the forward FFT is\n        taken into account to ensure proper reconstruction.\n\n        Returns\n        -------\n        ChannelFrame\n            A new ChannelFrame containing the time-domain signal.\n        \"\"\"\n        from ..processing import IFFT, create_operation\n        from .channel import ChannelFrame\n\n        params = {\"n_fft\": self.n_fft, \"window\": self.window}\n        operation_name = \"ifft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"IFFT\", operation)\n        # Apply processing to data\n        time_series = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # Create new instance\n        return ChannelFrame(\n            data=time_series,\n            sampling_rate=self.sampling_rate,\n            label=f\"ifft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Provide additional initialization arguments required for SpectralFrame.\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments for SpectralFrame.\n        \"\"\"\n        return {\n            \"n_fft\": self.n_fft,\n            \"window\": self.window,\n        }\n\n    def noct_synthesis(\n        self,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"\n        Synthesize N-octave band spectrum.\n\n        This method combines frequency components into N-octave bands according to\n        standard acoustical band definitions. This is commonly used in noise and\n        vibration analysis.\n\n        Parameters\n        ----------\n        fmin : float\n            Lower frequency bound in Hz.\n        fmax : float\n            Upper frequency bound in Hz.\n        n : int, default=3\n            Number of bands per octave (e.g., 3 for third-octave bands).\n        G : int, default=10\n            Reference band number.\n        fr : int, default=1000\n            Reference frequency in Hz.\n\n        Returns\n        -------\n        NOctFrame\n            A new NOctFrame containing the N-octave band spectrum.\n\n        Raises\n        ------\n        ValueError\n            If the sampling rate is not 48000 Hz, which is required for this operation.\n        \"\"\"\n        if self.sampling_rate != 48000:\n            raise ValueError(\n                \"noct_synthesis can only be used with a sampling rate of 48000 Hz.\"\n            )\n        from ..processing import NOctSynthesis\n        from .noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_synthesis\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from ..processing import create_operation\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSynthesis\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_synthesis\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=self,\n        )\n\n    def plot_matrix(\n        self,\n        plot_type: str = \"matrix\",\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot channel relationships in matrix format.\n\n        This method creates a matrix plot showing relationships between channels,\n        such as coherence, transfer functions, or cross-spectral density.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"matrix\"\n            Type of matrix plot to create.\n        **kwargs : dict\n            Additional plot parameters:\n            - vmin, vmax: Color scale limits\n            - cmap: Colormap name\n            - title: Plot title\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n</code></pre>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame-attributes","title":"Attributes","text":""},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.n_fft","title":"<code>n_fft = n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.magnitude","title":"<code>magnitude</code>  <code>property</code>","text":"<p>Get the magnitude spectrum.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.magnitude--returns","title":"Returns","text":"<p>NDArrayReal     The absolute values of the complex spectrum.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.phase","title":"<code>phase</code>  <code>property</code>","text":"<p>Get the phase spectrum.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.phase--returns","title":"Returns","text":"<p>NDArrayReal     The phase angles of the complex spectrum in radians.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.power","title":"<code>power</code>  <code>property</code>","text":"<p>Get the power spectrum.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.power--returns","title":"Returns","text":"<p>NDArrayReal     The squared magnitude spectrum.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrum in decibels.</p> <p>The reference values are taken from channel metadata. If no reference is specified, uses 1.0.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrum in dB relative to channel references.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrum in decibels.</p> <p>Applies A-weighting filter to the spectrum for better correlation with perceived loudness.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrum in dB.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the frequency axis values in Hz.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of frequency values corresponding to each frequency bin.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame-functions","title":"Functions","text":""},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.__init__","title":"<code>__init__(data, sampling_rate, n_fft, window='hann', label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"Source code in <code>wandas/frames/spectral.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    n_fft: int,\n    window: str = \"hann\",\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    if data.ndim == 1:\n        data = data.reshape(1, -1)\n    elif data.ndim &gt; 2:\n        raise ValueError(\n            f\"Data must be 1-dimensional or 2-dimensional. Shape: {data.shape}\"\n        )\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.plot","title":"<code>plot(plot_type='frequency', ax=None, **kwargs)</code>","text":"<p>Plot the spectral data using various visualization strategies.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"frequency\"     Type of plot to create. Options include:     - \"frequency\": Standard frequency plot     - \"matrix\": Matrix plot for comparing channels     - Other types as defined by available plot strategies ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - title: Plot title     - xlabel, ylabel: Axis labels     - vmin, vmax: Value limits for plots     - cmap: Colormap name     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def plot(\n    self,\n    plot_type: str = \"frequency\",\n    ax: Optional[\"Axes\"] = None,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the spectral data using various visualization strategies.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"frequency\"\n        Type of plot to create. Options include:\n        - \"frequency\": Standard frequency plot\n        - \"matrix\": Matrix plot for comparing channels\n        - Other types as defined by available plot strategies\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - title: Plot title\n        - xlabel, ylabel: Axis labels\n        - vmin, vmax: Value limits for plots\n        - cmap: Colormap name\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.ifft","title":"<code>ifft()</code>","text":"<p>Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.</p> <p>This method transforms the frequency-domain data back to the time domain using the inverse FFT operation. The window function used in the forward FFT is taken into account to ensure proper reconstruction.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.ifft--returns","title":"Returns","text":"<p>ChannelFrame     A new ChannelFrame containing the time-domain signal.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def ifft(self) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Compute the Inverse Fast Fourier Transform (IFFT) to return to time domain.\n\n    This method transforms the frequency-domain data back to the time domain using\n    the inverse FFT operation. The window function used in the forward FFT is\n    taken into account to ensure proper reconstruction.\n\n    Returns\n    -------\n    ChannelFrame\n        A new ChannelFrame containing the time-domain signal.\n    \"\"\"\n    from ..processing import IFFT, create_operation\n    from .channel import ChannelFrame\n\n    params = {\"n_fft\": self.n_fft, \"window\": self.window}\n    operation_name = \"ifft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"IFFT\", operation)\n    # Apply processing to data\n    time_series = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # Create new instance\n    return ChannelFrame(\n        data=time_series,\n        sampling_rate=self.sampling_rate,\n        label=f\"ifft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis","title":"<code>noct_synthesis(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Synthesize N-octave band spectrum.</p> <p>This method combines frequency components into N-octave bands according to standard acoustical band definitions. This is commonly used in noise and vibration analysis.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--parameters","title":"Parameters","text":"<p>fmin : float     Lower frequency bound in Hz. fmax : float     Upper frequency bound in Hz. n : int, default=3     Number of bands per octave (e.g., 3 for third-octave bands). G : int, default=10     Reference band number. fr : int, default=1000     Reference frequency in Hz.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--returns","title":"Returns","text":"<p>NOctFrame     A new NOctFrame containing the N-octave band spectrum.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.noct_synthesis--raises","title":"Raises","text":"<p>ValueError     If the sampling rate is not 48000 Hz, which is required for this operation.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def noct_synthesis(\n    self,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"\n    Synthesize N-octave band spectrum.\n\n    This method combines frequency components into N-octave bands according to\n    standard acoustical band definitions. This is commonly used in noise and\n    vibration analysis.\n\n    Parameters\n    ----------\n    fmin : float\n        Lower frequency bound in Hz.\n    fmax : float\n        Upper frequency bound in Hz.\n    n : int, default=3\n        Number of bands per octave (e.g., 3 for third-octave bands).\n    G : int, default=10\n        Reference band number.\n    fr : int, default=1000\n        Reference frequency in Hz.\n\n    Returns\n    -------\n    NOctFrame\n        A new NOctFrame containing the N-octave band spectrum.\n\n    Raises\n    ------\n    ValueError\n        If the sampling rate is not 48000 Hz, which is required for this operation.\n    \"\"\"\n    if self.sampling_rate != 48000:\n        raise ValueError(\n            \"noct_synthesis can only be used with a sampling rate of 48000 Hz.\"\n        )\n    from ..processing import NOctSynthesis\n    from .noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_synthesis\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n    from ..processing import create_operation\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSynthesis\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_synthesis\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=self,\n    )\n</code></pre>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix","title":"<code>plot_matrix(plot_type='matrix', **kwargs)</code>","text":"<p>Plot channel relationships in matrix format.</p> <p>This method creates a matrix plot showing relationships between channels, such as coherence, transfer functions, or cross-spectral density.</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"matrix\"     Type of matrix plot to create. **kwargs : dict     Additional plot parameters:     - vmin, vmax: Color scale limits     - cmap: Colormap name     - title: Plot title</p>"},{"location":"api/frames/#wandas.frames.spectral.SpectralFrame.plot_matrix--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot.</p> Source code in <code>wandas/frames/spectral.py</code> <pre><code>def plot_matrix(\n    self,\n    plot_type: str = \"matrix\",\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot channel relationships in matrix format.\n\n    This method creates a matrix plot showing relationships between channels,\n    such as coherence, transfer functions, or cross-spectral density.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"matrix\"\n        Type of matrix plot to create.\n    **kwargs : dict\n        Additional plot parameters:\n        - vmin, vmax: Color scale limits\n        - cmap: Colormap name\n        - title: Plot title\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    plot_strategy: PlotStrategy[SpectralFrame] = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"api/frames/#spectrogramframe","title":"SpectrogramFrame","text":"<p>SpectrogramFrame\u306f\u6642\u9593-\u5468\u6ce2\u6570\u9818\u57df\uff08\u30b9\u30da\u30af\u30c8\u30ed\u30b0\u30e9\u30e0\uff09\u306e\u30c7\u30fc\u30bf\u3092\u6271\u3046\u30d5\u30ec\u30fc\u30e0\u3067\u3059\u3002</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame","title":"<code>wandas.frames.spectrogram.SpectrogramFrame</code>","text":"<p>               Bases: <code>BaseFrame[NDArrayComplex]</code></p> <p>Class for handling time-frequency domain data (spectrograms).</p> <p>This class represents spectrogram data obtained through Short-Time Fourier Transform (STFT) or similar time-frequency analysis methods. It provides methods for visualization, manipulation, and conversion back to time domain.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The spectrogram data. Must be a dask array with shape:     - (channels, frequency_bins, time_frames) for multi-channel data     - (frequency_bins, time_frames) for single-channel data, which will be       reshaped to (1, frequency_bins, time_frames) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. n_fft : int     The FFT size used to generate this spectrogram. hop_length : int     Number of samples between successive frames. win_length : int, optional     The window length in samples. If None, defaults to n_fft. window : str, default=\"hann\"     The window function to use (e.g., \"hann\", \"hamming\", \"blackman\"). label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame--attributes","title":"Attributes","text":"<p>magnitude : NDArrayReal     The magnitude spectrogram. phase : NDArrayReal     The phase spectrogram in radians. power : NDArrayReal     The power spectrogram. dB : NDArrayReal     The spectrogram in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrogram in decibels. n_frames : int     Number of time frames. n_freq_bins : int     Number of frequency bins. freqs : NDArrayReal     The frequency axis values in Hz. times : NDArrayReal     The time axis values in seconds.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame--examples","title":"Examples","text":"<p>Create a spectrogram from a time-domain signal:</p> <p>signal = ChannelFrame.from_wav(\"audio.wav\") spectrogram = signal.stft(n_fft=2048, hop_length=512)</p> <p>Extract a specific time frame:</p> <p>frame_at_1s = spectrogram.get_frame_at(int(1.0 * sampling_rate / hop_length))</p> <p>Convert back to time domain:</p> <p>reconstructed = spectrogram.to_channel_frame()</p> <p>Plot the spectrogram:</p> <p>spectrogram.plot()</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>class SpectrogramFrame(BaseFrame[NDArrayComplex]):\n    \"\"\"\n    Class for handling time-frequency domain data (spectrograms).\n\n    This class represents spectrogram data obtained through\n    Short-Time Fourier Transform (STFT)\n    or similar time-frequency analysis methods. It provides methods for visualization,\n    manipulation, and conversion back to time domain.\n\n    Parameters\n    ----------\n    data : DaArray\n        The spectrogram data. Must be a dask array with shape:\n        - (channels, frequency_bins, time_frames) for multi-channel data\n        - (frequency_bins, time_frames) for single-channel data, which will be\n          reshaped to (1, frequency_bins, time_frames)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    n_fft : int\n        The FFT size used to generate this spectrogram.\n    hop_length : int\n        Number of samples between successive frames.\n    win_length : int, optional\n        The window length in samples. If None, defaults to n_fft.\n    window : str, default=\"hann\"\n        The window function to use (e.g., \"hann\", \"hamming\", \"blackman\").\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    magnitude : NDArrayReal\n        The magnitude spectrogram.\n    phase : NDArrayReal\n        The phase spectrogram in radians.\n    power : NDArrayReal\n        The power spectrogram.\n    dB : NDArrayReal\n        The spectrogram in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrogram in decibels.\n    n_frames : int\n        Number of time frames.\n    n_freq_bins : int\n        Number of frequency bins.\n    freqs : NDArrayReal\n        The frequency axis values in Hz.\n    times : NDArrayReal\n        The time axis values in seconds.\n\n    Examples\n    --------\n    Create a spectrogram from a time-domain signal:\n    &gt;&gt;&gt; signal = ChannelFrame.from_wav(\"audio.wav\")\n    &gt;&gt;&gt; spectrogram = signal.stft(n_fft=2048, hop_length=512)\n\n    Extract a specific time frame:\n    &gt;&gt;&gt; frame_at_1s = spectrogram.get_frame_at(int(1.0 * sampling_rate / hop_length))\n\n    Convert back to time domain:\n    &gt;&gt;&gt; reconstructed = spectrogram.to_channel_frame()\n\n    Plot the spectrogram:\n    &gt;&gt;&gt; spectrogram.plot()\n    \"\"\"\n\n    n_fft: int\n    hop_length: int\n    win_length: int\n    window: str\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        if data.ndim == 2:\n            data = da.expand_dims(data, axis=0)  # type: ignore [unused-ignore]\n        elif data.ndim != 3:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306f2\u6b21\u5143\u307e\u305f\u306f3\u6b21\u5143\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u5f62\u72b6: {data.shape}\"\n            )\n        if not data.shape[-2] == n_fft // 2 + 1:\n            raise ValueError(\n                f\"\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u304c\u7121\u52b9\u3067\u3059\u3002\u5468\u6ce2\u6570\u30d3\u30f3\u6570\u306f {n_fft // 2 + 1} \u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\"  # noqa: E501\n            )\n\n        self.n_fft = n_fft\n        self.hop_length = hop_length\n        self.win_length = win_length if win_length is not None else n_fft\n        self.window = window\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def magnitude(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the magnitude spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The absolute values of the complex spectrogram.\n        \"\"\"\n        return np.abs(self.data)\n\n    @property\n    def phase(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the phase spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The phase angles of the complex spectrogram in radians.\n        \"\"\"\n        return np.angle(self.data)\n\n    @property\n    def power(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the power spectrogram.\n\n        Returns\n        -------\n        NDArrayReal\n            The squared magnitude of the complex spectrogram.\n        \"\"\"\n        return np.abs(self.data) ** 2\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrogram in decibels relative to each channel's reference value.\n\n        The reference value for each channel is specified in its metadata.\n        A minimum value of -120 dB is enforced to avoid numerical issues.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrogram in decibels.\n        \"\"\"\n        # dB\u898f\u5b9a\u5024\u3092_channel_metadata\u304b\u3089\u53ce\u96c6\n        ref = np.array([ch.ref for ch in self._channel_metadata])\n        # dB\u5909\u63db\n        # 0\u9664\u7b97\u3092\u907f\u3051\u308b\u305f\u3081\u306b\u3001\u6700\u5927\u5024\u30681e-12\u306e\u3044\u305a\u308c\u304b\u3092\u4f7f\u7528\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(self.magnitude / ref[..., np.newaxis, np.newaxis], 1e-12)\n        )\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrogram in decibels.\n\n        A-weighting applies a frequency-dependent weighting filter that approximates\n        the human ear's response. This is particularly useful for analyzing noise\n        and acoustic measurements.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrogram in decibels.\n        \"\"\"\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted[:, np.newaxis]  # \u5468\u6ce2\u6570\u8ef8\u306b\u6cbf\u3063\u3066\u30d6\u30ed\u30fc\u30c9\u30ad\u30e3\u30b9\u30c8\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels.\n        \"\"\"\n        return self.shape[0]\n\n    @property\n    def n_frames(self) -&gt; int:\n        \"\"\"\n        Get the number of time frames.\n\n        Returns\n        -------\n        int\n            The number of time frames in the spectrogram.\n        \"\"\"\n        return self.shape[-1]\n\n    @property\n    def n_freq_bins(self) -&gt; int:\n        \"\"\"\n        Get the number of frequency bins.\n\n        Returns\n        -------\n        int\n            The number of frequency bins (n_fft // 2 + 1).\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the frequency axis values in Hz.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of frequency values corresponding to each frequency bin.\n        \"\"\"\n        return np.fft.rfftfreq(self.n_fft, 1.0 / self.sampling_rate)\n\n    @property\n    def times(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the time axis values in seconds.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of time values corresponding to each time frame.\n        \"\"\"\n        return np.arange(self.n_frames) * self.hop_length / self.sampling_rate\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Implementation of operation application for spectrogram data.\n\n        This internal method handles the application of various operations to\n        spectrogram data, maintaining lazy evaluation through dask.\n\n        Parameters\n        ----------\n        operation_name : str\n            Name of the operation to apply.\n        **params : Any\n            Parameters for the operation.\n\n        Returns\n        -------\n        S\n            A new instance with the operation applied.\n        \"\"\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n        from wandas.processing import create_operation\n\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        processed_data = operation.process(self._data)\n\n        operation_metadata = {\"operation\": operation_name, \"params\": params}\n        new_history = self.operation_history.copy()\n        new_history.append(operation_metadata)\n        new_metadata = {**self.metadata}\n        new_metadata[operation_name] = params\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n        return self._create_new_instance(\n            data=processed_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n        )\n\n    def _binary_op(\n        self,\n        other: Union[\n            \"SpectrogramFrame\",\n            int,\n            float,\n            complex,\n            NDArrayComplex,\n            NDArrayReal,\n            \"DaArray\",\n        ],\n        op: Callable[[\"DaArray\", Any], \"DaArray\"],\n        symbol: str,\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"\n        Common implementation for binary operations.\n\n        This method handles binary operations between\n        SpectrogramFrames and various types\n        of operands, maintaining lazy evaluation through dask arrays.\n\n        Parameters\n        ----------\n        other : Union[SpectrogramFrame, int, float, complex,\n            NDArrayComplex, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation (e.g., lambda a, b: a + b)\n        symbol : str\n            String representation of the operation (e.g., '+')\n\n        Returns\n        -------\n        SpectrogramFrame\n            A new SpectrogramFrame containing the result of the operation.\n\n        Raises\n        ------\n        ValueError\n            If attempting to operate with a SpectrogramFrame\n            with a different sampling rate.\n        \"\"\"\n        logger.debug(f\"Setting up {symbol} operation (lazy)\")\n\n        metadata = {}\n        if self.metadata is not None:\n            metadata = self.metadata.copy()\n\n        operation_history = []\n        if self.operation_history is not None:\n            operation_history = self.operation_history.copy()\n\n        if isinstance(other, SpectrogramFrame):\n            if self.sampling_rate != other.sampling_rate:\n                raise ValueError(\n                    \"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u304c\u4e00\u81f4\u3057\u3066\u3044\u307e\u305b\u3093\u3002\u6f14\u7b97\u3067\u304d\u307e\u305b\u3093\u3002\"\n                )\n\n            result_data = op(self._data, other._data)\n\n            merged_channel_metadata = []\n            for self_ch, other_ch in zip(\n                self._channel_metadata, other._channel_metadata\n            ):\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch['label']} {symbol} {other_ch['label']})\"\n                merged_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other.label})\n\n            return SpectrogramFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                hop_length=self.hop_length,\n                win_length=self.win_length,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other.label})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=merged_channel_metadata,\n                previous=self,\n            )\n        else:\n            result_data = op(self._data, other)\n\n            if isinstance(other, (int, float)):\n                other_str = str(other)\n            elif isinstance(other, complex):\n                other_str = f\"complex({other.real}, {other.imag})\"\n            elif isinstance(other, np.ndarray):\n                other_str = f\"ndarray{other.shape}\"\n            elif hasattr(other, \"shape\"):\n                other_str = f\"dask.array{other.shape}\"\n            else:\n                other_str = str(type(other).__name__)\n\n            updated_channel_metadata: list[ChannelMetadata] = []\n            for self_ch in self._channel_metadata:\n                ch = self_ch.model_copy(deep=True)\n                ch[\"label\"] = f\"({self_ch.label} {symbol} {other_str})\"\n                updated_channel_metadata.append(ch)\n\n            operation_history.append({\"operation\": symbol, \"with\": other_str})\n\n            return SpectrogramFrame(\n                data=result_data,\n                sampling_rate=self.sampling_rate,\n                n_fft=self.n_fft,\n                hop_length=self.hop_length,\n                win_length=self.win_length,\n                window=self.window,\n                label=f\"({self.label} {symbol} {other_str})\",\n                metadata=metadata,\n                operation_history=operation_history,\n                channel_metadata=updated_channel_metadata,\n            )\n\n    def plot(\n        self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the spectrogram using various visualization strategies.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"spectrogram\"\n            Type of plot to create.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - vmin, vmax: Colormap scaling\n            - cmap: Colormap name\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n        plot_strategy: PlotStrategy[SpectrogramFrame] = create_operation(plot_type)\n\n        # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def plot_Aw(  # noqa: N802\n        self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the A-weighted spectrogram.\n\n        A convenience method that calls plot() with Aw=True, applying A-weighting\n        to the spectrogram before plotting.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"spectrogram\"\n            Type of plot to create.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to plot().\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot.\n        \"\"\"\n        return self.plot(plot_type=plot_type, ax=ax, Aw=True, **kwargs)\n\n    def get_frame_at(self, time_idx: int) -&gt; \"SpectralFrame\":\n        \"\"\"\n        Extract spectral data at a specific time frame.\n\n        Parameters\n        ----------\n        time_idx : int\n            Index of the time frame to extract.\n\n        Returns\n        -------\n        SpectralFrame\n            A new SpectralFrame containing the spectral data at the specified time.\n\n        Raises\n        ------\n        IndexError\n            If time_idx is out of range.\n        \"\"\"\n        from wandas.frames.spectral import SpectralFrame\n\n        if time_idx &lt; 0 or time_idx &gt;= self.n_frames:\n            raise IndexError(\n                f\"\u6642\u9593\u30a4\u30f3\u30c7\u30c3\u30af\u30b9 {time_idx} \u304c\u7bc4\u56f2\u5916\u3067\u3059\u3002\u6709\u52b9\u7bc4\u56f2: 0-{self.n_frames - 1}\"  # noqa: E501\n            )\n\n        frame_data = self._data[..., time_idx]\n\n        return SpectralFrame(\n            data=frame_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=self.n_fft,\n            window=self.window,\n            label=f\"{self.label} (Frame {time_idx}, Time {self.times[time_idx]:.3f}s)\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def to_channel_frame(self) -&gt; \"ChannelFrame\":\n        \"\"\"\n        Convert the spectrogram back to time domain using inverse STFT.\n\n        This method performs an inverse Short-Time Fourier Transform (ISTFT) to\n        reconstruct the time-domain signal from the spectrogram.\n\n        Returns\n        -------\n        ChannelFrame\n            A new ChannelFrame containing the reconstructed time-domain signal.\n        \"\"\"\n        from wandas.frames.channel import ChannelFrame\n        from wandas.processing import ISTFT, create_operation\n\n        params = {\n            \"n_fft\": self.n_fft,\n            \"hop_length\": self.hop_length,\n            \"win_length\": self.win_length,\n            \"window\": self.window,\n        }\n        operation_name = \"istft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"ISTFT\", operation)\n        # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n        time_series = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n        )\n\n        # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n        return ChannelFrame(\n            data=time_series,\n            sampling_rate=self.sampling_rate,\n            label=f\"istft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n        )\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get additional initialization arguments for SpectrogramFrame.\n\n        This internal method provides the additional initialization arguments\n        required by SpectrogramFrame beyond those required by BaseFrame.\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments.\n        \"\"\"\n        return {\n            \"n_fft\": self.n_fft,\n            \"hop_length\": self.hop_length,\n            \"win_length\": self.win_length,\n            \"window\": self.window,\n        }\n</code></pre>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame-attributes","title":"Attributes","text":""},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_fft","title":"<code>n_fft = n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.hop_length","title":"<code>hop_length = hop_length</code>  <code>instance-attribute</code>","text":""},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.win_length","title":"<code>win_length = win_length if win_length is not None else n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.magnitude","title":"<code>magnitude</code>  <code>property</code>","text":"<p>Get the magnitude spectrogram.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.magnitude--returns","title":"Returns","text":"<p>NDArrayReal     The absolute values of the complex spectrogram.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.phase","title":"<code>phase</code>  <code>property</code>","text":"<p>Get the phase spectrogram.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.phase--returns","title":"Returns","text":"<p>NDArrayReal     The phase angles of the complex spectrogram in radians.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.power","title":"<code>power</code>  <code>property</code>","text":"<p>Get the power spectrogram.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.power--returns","title":"Returns","text":"<p>NDArrayReal     The squared magnitude of the complex spectrogram.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrogram in decibels relative to each channel's reference value.</p> <p>The reference value for each channel is specified in its metadata. A minimum value of -120 dB is enforced to avoid numerical issues.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrogram in decibels.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrogram in decibels.</p> <p>A-weighting applies a frequency-dependent weighting filter that approximates the human ear's response. This is particularly useful for analyzing noise and acoustic measurements.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrogram in decibels.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_frames","title":"<code>n_frames</code>  <code>property</code>","text":"<p>Get the number of time frames.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_frames--returns","title":"Returns","text":"<p>int     The number of time frames in the spectrogram.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_freq_bins","title":"<code>n_freq_bins</code>  <code>property</code>","text":"<p>Get the number of frequency bins.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.n_freq_bins--returns","title":"Returns","text":"<p>int     The number of frequency bins (n_fft // 2 + 1).</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the frequency axis values in Hz.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of frequency values corresponding to each frequency bin.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.times","title":"<code>times</code>  <code>property</code>","text":"<p>Get the time axis values in seconds.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.times--returns","title":"Returns","text":"<p>NDArrayReal     Array of time values corresponding to each time frame.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame-functions","title":"Functions","text":""},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.__init__","title":"<code>__init__(data, sampling_rate, n_fft, hop_length, win_length=None, window='hann', label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    if data.ndim == 2:\n        data = da.expand_dims(data, axis=0)  # type: ignore [unused-ignore]\n    elif data.ndim != 3:\n        raise ValueError(\n            f\"\u30c7\u30fc\u30bf\u306f2\u6b21\u5143\u307e\u305f\u306f3\u6b21\u5143\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u5f62\u72b6: {data.shape}\"\n        )\n    if not data.shape[-2] == n_fft // 2 + 1:\n        raise ValueError(\n            f\"\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u304c\u7121\u52b9\u3067\u3059\u3002\u5468\u6ce2\u6570\u30d3\u30f3\u6570\u306f {n_fft // 2 + 1} \u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\"  # noqa: E501\n        )\n\n    self.n_fft = n_fft\n    self.hop_length = hop_length\n    self.win_length = win_length if win_length is not None else n_fft\n    self.window = window\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot","title":"<code>plot(plot_type='spectrogram', ax=None, **kwargs)</code>","text":"<p>Plot the spectrogram using various visualization strategies.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"spectrogram\"     Type of plot to create. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - vmin, vmax: Colormap scaling     - cmap: Colormap name     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def plot(\n    self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the spectrogram using various visualization strategies.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"spectrogram\"\n        Type of plot to create.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - vmin, vmax: Colormap scaling\n        - cmap: Colormap name\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # \u30d7\u30ed\u30c3\u30c8\u6226\u7565\u3092\u53d6\u5f97\n    plot_strategy: PlotStrategy[SpectrogramFrame] = create_operation(plot_type)\n\n    # \u30d7\u30ed\u30c3\u30c8\u5b9f\u884c\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw","title":"<code>plot_Aw(plot_type='spectrogram', ax=None, **kwargs)</code>","text":"<p>Plot the A-weighted spectrogram.</p> <p>A convenience method that calls plot() with Aw=True, applying A-weighting to the spectrogram before plotting.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"spectrogram\"     Type of plot to create. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to plot().</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.plot_Aw--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def plot_Aw(  # noqa: N802\n    self, plot_type: str = \"spectrogram\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the A-weighted spectrogram.\n\n    A convenience method that calls plot() with Aw=True, applying A-weighting\n    to the spectrogram before plotting.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"spectrogram\"\n        Type of plot to create.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to plot().\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot.\n    \"\"\"\n    return self.plot(plot_type=plot_type, ax=ax, Aw=True, **kwargs)\n</code></pre>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at","title":"<code>get_frame_at(time_idx)</code>","text":"<p>Extract spectral data at a specific time frame.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--parameters","title":"Parameters","text":"<p>time_idx : int     Index of the time frame to extract.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--returns","title":"Returns","text":"<p>SpectralFrame     A new SpectralFrame containing the spectral data at the specified time.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.get_frame_at--raises","title":"Raises","text":"<p>IndexError     If time_idx is out of range.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def get_frame_at(self, time_idx: int) -&gt; \"SpectralFrame\":\n    \"\"\"\n    Extract spectral data at a specific time frame.\n\n    Parameters\n    ----------\n    time_idx : int\n        Index of the time frame to extract.\n\n    Returns\n    -------\n    SpectralFrame\n        A new SpectralFrame containing the spectral data at the specified time.\n\n    Raises\n    ------\n    IndexError\n        If time_idx is out of range.\n    \"\"\"\n    from wandas.frames.spectral import SpectralFrame\n\n    if time_idx &lt; 0 or time_idx &gt;= self.n_frames:\n        raise IndexError(\n            f\"\u6642\u9593\u30a4\u30f3\u30c7\u30c3\u30af\u30b9 {time_idx} \u304c\u7bc4\u56f2\u5916\u3067\u3059\u3002\u6709\u52b9\u7bc4\u56f2: 0-{self.n_frames - 1}\"  # noqa: E501\n        )\n\n    frame_data = self._data[..., time_idx]\n\n    return SpectralFrame(\n        data=frame_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=self.n_fft,\n        window=self.window,\n        label=f\"{self.label} (Frame {time_idx}, Time {self.times[time_idx]:.3f}s)\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.to_channel_frame","title":"<code>to_channel_frame()</code>","text":"<p>Convert the spectrogram back to time domain using inverse STFT.</p> <p>This method performs an inverse Short-Time Fourier Transform (ISTFT) to reconstruct the time-domain signal from the spectrogram.</p>"},{"location":"api/frames/#wandas.frames.spectrogram.SpectrogramFrame.to_channel_frame--returns","title":"Returns","text":"<p>ChannelFrame     A new ChannelFrame containing the reconstructed time-domain signal.</p> Source code in <code>wandas/frames/spectrogram.py</code> <pre><code>def to_channel_frame(self) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Convert the spectrogram back to time domain using inverse STFT.\n\n    This method performs an inverse Short-Time Fourier Transform (ISTFT) to\n    reconstruct the time-domain signal from the spectrogram.\n\n    Returns\n    -------\n    ChannelFrame\n        A new ChannelFrame containing the reconstructed time-domain signal.\n    \"\"\"\n    from wandas.frames.channel import ChannelFrame\n    from wandas.processing import ISTFT, create_operation\n\n    params = {\n        \"n_fft\": self.n_fft,\n        \"hop_length\": self.hop_length,\n        \"win_length\": self.win_length,\n        \"window\": self.window,\n    }\n    operation_name = \"istft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # \u64cd\u4f5c\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"ISTFT\", operation)\n    # \u30c7\u30fc\u30bf\u306b\u51e6\u7406\u3092\u9069\u7528\n    time_series = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new ChannelFrame with operation {operation_name} added to graph\"\n    )\n\n    # \u65b0\u3057\u3044\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\n    return ChannelFrame(\n        data=time_series,\n        sampling_rate=self.sampling_rate,\n        label=f\"istft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n    )\n</code></pre>"},{"location":"api/frames/#noctframe","title":"NOctFrame","text":"<p>NOctFrame\u306f\u30aa\u30af\u30bf\u30fc\u30d6\u30d0\u30f3\u30c9\u89e3\u6790\u306e\u305f\u3081\u306e\u30d5\u30ec\u30fc\u30e0\u30af\u30e9\u30b9\u3067\u3059\u3002</p>"},{"location":"api/frames/#wandas.frames.noct.NOctFrame","title":"<code>wandas.frames.noct.NOctFrame</code>","text":"<p>               Bases: <code>BaseFrame[NDArrayReal]</code></p> <p>Class for handling N-octave band analysis data.</p> <p>This class represents frequency data analyzed in fractional octave bands, typically used in acoustic and vibration analysis. It handles real-valued data representing energy or power in each frequency band, following standard acoustical band definitions.</p>"},{"location":"api/frames/#wandas.frames.noct.NOctFrame--parameters","title":"Parameters","text":"<p>data : DaArray     The N-octave band data. Must be a dask array with shape:     - (channels, frequency_bins) for multi-channel data     - (frequency_bins,) for single-channel data, which will be       reshaped to (1, frequency_bins) sampling_rate : float     The sampling rate of the original time-domain signal in Hz. fmin : float, default=0     Lower frequency bound in Hz. fmax : float, default=0     Upper frequency bound in Hz. n : int, default=3     Number of bands per octave (e.g., 3 for third-octave bands). G : int, default=10     Reference band number according to IEC 61260-1:2014. fr : int, default=1000     Reference frequency in Hz, typically 1000 Hz for acoustic analysis. label : str, optional     A label for the frame. metadata : dict, optional     Additional metadata for the frame. operation_history : list[dict], optional     History of operations performed on this frame. channel_metadata : list[ChannelMetadata], optional     Metadata for each channel in the frame. previous : BaseFrame, optional     The frame that this frame was derived from.</p>"},{"location":"api/frames/#wandas.frames.noct.NOctFrame--attributes","title":"Attributes","text":"<p>freqs : NDArrayReal     The center frequencies of each band in Hz, calculated according to     the standard fractional octave band definitions. dB : NDArrayReal     The spectrum in decibels relative to channel reference values. dBA : NDArrayReal     The A-weighted spectrum in decibels, applying frequency weighting     for better correlation with perceived loudness. fmin : float     Lower frequency bound in Hz. fmax : float     Upper frequency bound in Hz. n : int     Number of bands per octave. G : int     Reference band number. fr : int     Reference frequency in Hz.</p>"},{"location":"api/frames/#wandas.frames.noct.NOctFrame--examples","title":"Examples","text":"<p>Create an N-octave band spectrum from a time-domain signal:</p> <p>signal = ChannelFrame.from_wav(\"audio.wav\") spectrum = signal.noct_spectrum(fmin=20, fmax=20000, n=3)</p> <p>Plot the N-octave band spectrum:</p> <p>spectrum.plot()</p> <p>Plot with A-weighting applied:</p> <p>spectrum.plot(Aw=True)</p>"},{"location":"api/frames/#wandas.frames.noct.NOctFrame--notes","title":"Notes","text":"<ul> <li>Binary operations (addition, multiplication, etc.) are not currently   supported for N-octave band data.</li> <li>The actual frequency bands are determined by the parameters n, G, and fr   according to IEC 61260-1:2014 standard for fractional octave band filters.</li> <li>The class follows acoustic standards for band definitions and analysis,   making it suitable for noise measurements and sound level analysis.</li> <li>A-weighting is available for better correlation with human hearing   perception, following IEC 61672-1:2013.</li> </ul> Source code in <code>wandas/frames/noct.py</code> <pre><code>class NOctFrame(BaseFrame[NDArrayReal]):\n    \"\"\"\n    Class for handling N-octave band analysis data.\n\n    This class represents frequency data analyzed in fractional octave bands,\n    typically used in acoustic and vibration analysis. It handles real-valued\n    data representing energy or power in each frequency band, following standard\n    acoustical band definitions.\n\n    Parameters\n    ----------\n    data : DaArray\n        The N-octave band data. Must be a dask array with shape:\n        - (channels, frequency_bins) for multi-channel data\n        - (frequency_bins,) for single-channel data, which will be\n          reshaped to (1, frequency_bins)\n    sampling_rate : float\n        The sampling rate of the original time-domain signal in Hz.\n    fmin : float, default=0\n        Lower frequency bound in Hz.\n    fmax : float, default=0\n        Upper frequency bound in Hz.\n    n : int, default=3\n        Number of bands per octave (e.g., 3 for third-octave bands).\n    G : int, default=10\n        Reference band number according to IEC 61260-1:2014.\n    fr : int, default=1000\n        Reference frequency in Hz, typically 1000 Hz for acoustic analysis.\n    label : str, optional\n        A label for the frame.\n    metadata : dict, optional\n        Additional metadata for the frame.\n    operation_history : list[dict], optional\n        History of operations performed on this frame.\n    channel_metadata : list[ChannelMetadata], optional\n        Metadata for each channel in the frame.\n    previous : BaseFrame, optional\n        The frame that this frame was derived from.\n\n    Attributes\n    ----------\n    freqs : NDArrayReal\n        The center frequencies of each band in Hz, calculated according to\n        the standard fractional octave band definitions.\n    dB : NDArrayReal\n        The spectrum in decibels relative to channel reference values.\n    dBA : NDArrayReal\n        The A-weighted spectrum in decibels, applying frequency weighting\n        for better correlation with perceived loudness.\n    fmin : float\n        Lower frequency bound in Hz.\n    fmax : float\n        Upper frequency bound in Hz.\n    n : int\n        Number of bands per octave.\n    G : int\n        Reference band number.\n    fr : int\n        Reference frequency in Hz.\n\n    Examples\n    --------\n    Create an N-octave band spectrum from a time-domain signal:\n    &gt;&gt;&gt; signal = ChannelFrame.from_wav(\"audio.wav\")\n    &gt;&gt;&gt; spectrum = signal.noct_spectrum(fmin=20, fmax=20000, n=3)\n\n    Plot the N-octave band spectrum:\n    &gt;&gt;&gt; spectrum.plot()\n\n    Plot with A-weighting applied:\n    &gt;&gt;&gt; spectrum.plot(Aw=True)\n\n    Notes\n    -----\n    - Binary operations (addition, multiplication, etc.) are not currently\n      supported for N-octave band data.\n    - The actual frequency bands are determined by the parameters n, G, and fr\n      according to IEC 61260-1:2014 standard for fractional octave band filters.\n    - The class follows acoustic standards for band definitions and analysis,\n      making it suitable for noise measurements and sound level analysis.\n    - A-weighting is available for better correlation with human hearing\n      perception, following IEC 61672-1:2013.\n    \"\"\"\n\n    fmin: float\n    fmax: float\n    n: int\n    G: int\n    fr: int\n\n    def __init__(\n        self,\n        data: DaArray,\n        sampling_rate: float,\n        fmin: float = 0,\n        fmax: float = 0,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n        label: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        operation_history: Optional[list[dict[str, Any]]] = None,\n        channel_metadata: Optional[list[ChannelMetadata]] = None,\n        previous: Optional[\"BaseFrame[Any]\"] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a NOctFrame instance.\n\n        Sets up N-octave band analysis parameters and prepares the frame for\n        storing band-filtered data. Data shape is validated to ensure compatibility\n        with N-octave band analysis.\n\n        See class docstring for parameter descriptions.\n        \"\"\"\n        self.n = n\n        self.G = G\n        self.fr = fr\n        self.fmin = fmin\n        self.fmax = fmax\n        super().__init__(\n            data=data,\n            sampling_rate=sampling_rate,\n            label=label,\n            metadata=metadata,\n            operation_history=operation_history,\n            channel_metadata=channel_metadata,\n            previous=previous,\n        )\n\n    @property\n    def dB(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the spectrum in decibels relative to each channel's reference value.\n\n        The reference value for each channel is specified in its metadata.\n        A minimum value of -120 dB is enforced to avoid numerical issues.\n\n        Returns\n        -------\n        NDArrayReal\n            The spectrum in decibels. Shape matches the input data shape:\n            (channels, frequency_bins).\n        \"\"\"\n        # Collect dB reference values from _channel_metadata\n        ref = np.array([ch.ref for ch in self._channel_metadata])\n        # Convert to dB\n        # Use either the maximum value or 1e-12 to avoid division by zero\n        level: NDArrayReal = 20 * np.log10(\n            np.maximum(self.data / ref[..., np.newaxis], 1e-12)\n        )\n        return level\n\n    @property\n    def dBA(self) -&gt; NDArrayReal:  # noqa: N802\n        \"\"\"\n        Get the A-weighted spectrum in decibels.\n\n        A-weighting applies a frequency-dependent weighting filter that approximates\n        the human ear's response to different frequencies. This is particularly useful\n        for analyzing noise and acoustic measurements as it provides a better\n        correlation with perceived loudness.\n\n        The weighting is applied according to IEC 61672-1:2013 standard.\n\n        Returns\n        -------\n        NDArrayReal\n            The A-weighted spectrum in decibels. Shape matches the input data shape:\n            (channels, frequency_bins).\n        \"\"\"\n        # Collect dB reference values from _channel_metadata\n        weighted: NDArrayReal = librosa.A_weighting(frequencies=self.freqs, min_db=None)\n        return self.dB + weighted\n\n    @property\n    def _n_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of channels in the data.\n\n        Returns\n        -------\n        int\n            The number of channels in the N-octave band data.\n        \"\"\"\n        return self.shape[-2]\n\n    @property\n    def freqs(self) -&gt; NDArrayReal:\n        \"\"\"\n        Get the center frequencies of each band in Hz.\n\n        These frequencies are calculated based on the N-octave band parameters\n        (n, G, fr) and the frequency bounds (fmin, fmax) according to\n        IEC 61260-1:2014 standard for fractional octave band filters.\n\n        Returns\n        -------\n        NDArrayReal\n            Array of center frequencies for each frequency band.\n\n        Raises\n        ------\n        ValueError\n            If the center frequencies cannot be calculated or the result\n            is not a numpy array.\n        \"\"\"\n        _, freqs = _center_freq(\n            fmax=self.fmax,\n            fmin=self.fmin,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        if isinstance(freqs, np.ndarray):\n            return freqs\n        else:\n            raise ValueError(\"freqs is not numpy array.\")\n\n    def _binary_op(\n        self: S,\n        other: Union[S, int, float, NDArrayReal, DaArray],\n        op: Callable[[DaArray, Any], DaArray],\n        symbol: str,\n    ) -&gt; S:\n        \"\"\"\n        Binary operations are not currently supported for N-octave band data.\n\n        Parameters\n        ----------\n        other : Union[S, int, float, NDArrayReal, DaArray]\n            The right operand of the operation.\n        op : callable\n            Function to execute the operation.\n        symbol : str\n            String representation of the operation (e.g., '+', '-', '*', '/').\n\n        Raises\n        ------\n        NotImplementedError\n            Always raises this error as operations are not implemented\n            for N-octave band data.\n        \"\"\"\n        raise NotImplementedError(\n            f\"Operation {symbol} is not implemented for NOctFrame.\"\n        )\n        return self\n\n    def _apply_operation_impl(self: S, operation_name: str, **params: Any) -&gt; S:\n        \"\"\"\n        Apply operations using lazy evaluation.\n        \"\"\"\n        # Apply operations using lazy evaluation\n        raise NotImplementedError(\n            f\"Operation {operation_name} is not implemented for NOctFrame.\"\n        )\n        return self\n\n    def plot(\n        self, plot_type: str = \"noct\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"\n        Plot the N-octave band data using various visualization strategies.\n\n        Supports standard plotting configurations for acoustic analysis,\n        including decibel scales and A-weighting.\n\n        Parameters\n        ----------\n        plot_type : str, default=\"noct\"\n            Type of plot to create. The default \"noct\" type creates a bar plot\n            suitable for displaying N-octave band data.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on. If None, creates new axes.\n        **kwargs : dict\n            Additional keyword arguments passed to the plot strategy.\n            Common options include:\n            - dB: Whether to plot in decibels\n            - Aw: Whether to apply A-weighting\n            - title: Plot title\n            - xlabel, ylabel: Axis labels\n            - xscale: Set to \"log\" for logarithmic frequency axis\n            - grid: Whether to show grid lines\n\n        Returns\n        -------\n        Union[Axes, Iterator[Axes]]\n            The matplotlib axes containing the plot, or an iterator of axes\n            for multi-plot outputs.\n        \"\"\"\n        from wandas.visualization.plotting import create_operation\n\n        logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n        # Get plot strategy\n        plot_strategy: PlotStrategy[NOctFrame] = create_operation(plot_type)\n\n        # Execute plot\n        _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n        logger.debug(\"Plot rendering complete\")\n\n        return _ax\n\n    def _get_additional_init_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get additional initialization arguments for NOctFrame.\n\n        This internal method provides the additional initialization arguments\n        required by NOctFrame beyond those required by BaseFrame. These include\n        the N-octave band analysis parameters that define the frequency bands.\n\n        Returns\n        -------\n        dict[str, Any]\n            Additional initialization arguments specific to NOctFrame:\n            - n: Number of bands per octave\n            - G: Reference band number\n            - fr: Reference frequency\n            - fmin: Lower frequency bound\n            - fmax: Upper frequency bound\n        \"\"\"\n        return {\n            \"n\": self.n,\n            \"G\": self.G,\n            \"fr\": self.fr,\n            \"fmin\": self.fmin,\n            \"fmax\": self.fmax,\n        }\n</code></pre>"},{"location":"api/frames/#wandas.frames.noct.NOctFrame-attributes","title":"Attributes","text":""},{"location":"api/frames/#wandas.frames.noct.NOctFrame.n","title":"<code>n = n</code>  <code>instance-attribute</code>","text":""},{"location":"api/frames/#wandas.frames.noct.NOctFrame.G","title":"<code>G = G</code>  <code>instance-attribute</code>","text":""},{"location":"api/frames/#wandas.frames.noct.NOctFrame.fr","title":"<code>fr = fr</code>  <code>instance-attribute</code>","text":""},{"location":"api/frames/#wandas.frames.noct.NOctFrame.fmin","title":"<code>fmin = fmin</code>  <code>instance-attribute</code>","text":""},{"location":"api/frames/#wandas.frames.noct.NOctFrame.fmax","title":"<code>fmax = fmax</code>  <code>instance-attribute</code>","text":""},{"location":"api/frames/#wandas.frames.noct.NOctFrame.dB","title":"<code>dB</code>  <code>property</code>","text":"<p>Get the spectrum in decibels relative to each channel's reference value.</p> <p>The reference value for each channel is specified in its metadata. A minimum value of -120 dB is enforced to avoid numerical issues.</p>"},{"location":"api/frames/#wandas.frames.noct.NOctFrame.dB--returns","title":"Returns","text":"<p>NDArrayReal     The spectrum in decibels. Shape matches the input data shape:     (channels, frequency_bins).</p>"},{"location":"api/frames/#wandas.frames.noct.NOctFrame.dBA","title":"<code>dBA</code>  <code>property</code>","text":"<p>Get the A-weighted spectrum in decibels.</p> <p>A-weighting applies a frequency-dependent weighting filter that approximates the human ear's response to different frequencies. This is particularly useful for analyzing noise and acoustic measurements as it provides a better correlation with perceived loudness.</p> <p>The weighting is applied according to IEC 61672-1:2013 standard.</p>"},{"location":"api/frames/#wandas.frames.noct.NOctFrame.dBA--returns","title":"Returns","text":"<p>NDArrayReal     The A-weighted spectrum in decibels. Shape matches the input data shape:     (channels, frequency_bins).</p>"},{"location":"api/frames/#wandas.frames.noct.NOctFrame.freqs","title":"<code>freqs</code>  <code>property</code>","text":"<p>Get the center frequencies of each band in Hz.</p> <p>These frequencies are calculated based on the N-octave band parameters (n, G, fr) and the frequency bounds (fmin, fmax) according to IEC 61260-1:2014 standard for fractional octave band filters.</p>"},{"location":"api/frames/#wandas.frames.noct.NOctFrame.freqs--returns","title":"Returns","text":"<p>NDArrayReal     Array of center frequencies for each frequency band.</p>"},{"location":"api/frames/#wandas.frames.noct.NOctFrame.freqs--raises","title":"Raises","text":"<p>ValueError     If the center frequencies cannot be calculated or the result     is not a numpy array.</p>"},{"location":"api/frames/#wandas.frames.noct.NOctFrame-functions","title":"Functions","text":""},{"location":"api/frames/#wandas.frames.noct.NOctFrame.__init__","title":"<code>__init__(data, sampling_rate, fmin=0, fmax=0, n=3, G=10, fr=1000, label=None, metadata=None, operation_history=None, channel_metadata=None, previous=None)</code>","text":"<p>Initialize a NOctFrame instance.</p> <p>Sets up N-octave band analysis parameters and prepares the frame for storing band-filtered data. Data shape is validated to ensure compatibility with N-octave band analysis.</p> <p>See class docstring for parameter descriptions.</p> Source code in <code>wandas/frames/noct.py</code> <pre><code>def __init__(\n    self,\n    data: DaArray,\n    sampling_rate: float,\n    fmin: float = 0,\n    fmax: float = 0,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n    label: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    operation_history: Optional[list[dict[str, Any]]] = None,\n    channel_metadata: Optional[list[ChannelMetadata]] = None,\n    previous: Optional[\"BaseFrame[Any]\"] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a NOctFrame instance.\n\n    Sets up N-octave band analysis parameters and prepares the frame for\n    storing band-filtered data. Data shape is validated to ensure compatibility\n    with N-octave band analysis.\n\n    See class docstring for parameter descriptions.\n    \"\"\"\n    self.n = n\n    self.G = G\n    self.fr = fr\n    self.fmin = fmin\n    self.fmax = fmax\n    super().__init__(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=label,\n        metadata=metadata,\n        operation_history=operation_history,\n        channel_metadata=channel_metadata,\n        previous=previous,\n    )\n</code></pre>"},{"location":"api/frames/#wandas.frames.noct.NOctFrame.plot","title":"<code>plot(plot_type='noct', ax=None, **kwargs)</code>","text":"<p>Plot the N-octave band data using various visualization strategies.</p> <p>Supports standard plotting configurations for acoustic analysis, including decibel scales and A-weighting.</p>"},{"location":"api/frames/#wandas.frames.noct.NOctFrame.plot--parameters","title":"Parameters","text":"<p>plot_type : str, default=\"noct\"     Type of plot to create. The default \"noct\" type creates a bar plot     suitable for displaying N-octave band data. ax : matplotlib.axes.Axes, optional     Axes to plot on. If None, creates new axes. **kwargs : dict     Additional keyword arguments passed to the plot strategy.     Common options include:     - dB: Whether to plot in decibels     - Aw: Whether to apply A-weighting     - title: Plot title     - xlabel, ylabel: Axis labels     - xscale: Set to \"log\" for logarithmic frequency axis     - grid: Whether to show grid lines</p>"},{"location":"api/frames/#wandas.frames.noct.NOctFrame.plot--returns","title":"Returns","text":"<p>Union[Axes, Iterator[Axes]]     The matplotlib axes containing the plot, or an iterator of axes     for multi-plot outputs.</p> Source code in <code>wandas/frames/noct.py</code> <pre><code>def plot(\n    self, plot_type: str = \"noct\", ax: Optional[\"Axes\"] = None, **kwargs: Any\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"\n    Plot the N-octave band data using various visualization strategies.\n\n    Supports standard plotting configurations for acoustic analysis,\n    including decibel scales and A-weighting.\n\n    Parameters\n    ----------\n    plot_type : str, default=\"noct\"\n        Type of plot to create. The default \"noct\" type creates a bar plot\n        suitable for displaying N-octave band data.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on. If None, creates new axes.\n    **kwargs : dict\n        Additional keyword arguments passed to the plot strategy.\n        Common options include:\n        - dB: Whether to plot in decibels\n        - Aw: Whether to apply A-weighting\n        - title: Plot title\n        - xlabel, ylabel: Axis labels\n        - xscale: Set to \"log\" for logarithmic frequency axis\n        - grid: Whether to show grid lines\n\n    Returns\n    -------\n    Union[Axes, Iterator[Axes]]\n        The matplotlib axes containing the plot, or an iterator of axes\n        for multi-plot outputs.\n    \"\"\"\n    from wandas.visualization.plotting import create_operation\n\n    logger.debug(f\"Plotting audio with plot_type={plot_type} (will compute now)\")\n\n    # Get plot strategy\n    plot_strategy: PlotStrategy[NOctFrame] = create_operation(plot_type)\n\n    # Execute plot\n    _ax = plot_strategy.plot(self, ax=ax, **kwargs)\n\n    logger.debug(\"Plot rendering complete\")\n\n    return _ax\n</code></pre>"},{"location":"api/frames/#mixins","title":"Mixins","text":"<p>\u30d5\u30ec\u30fc\u30e0\u306e\u6a5f\u80fd\u3092\u62e1\u5f35\u3059\u308b\u305f\u3081\u306e\u30df\u30c3\u30af\u30b9\u30a4\u30f3\u3067\u3059\u3002</p>"},{"location":"api/frames/#channelprocessingmixin","title":"ChannelProcessingMixin","text":""},{"location":"api/frames/#wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin","title":"<code>wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin</code>","text":"<p>Mixin that provides methods related to signal processing.</p> <p>This mixin provides processing methods applied to audio signals and other time-series data, such as signal processing filters and transformation operations.</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>class ChannelProcessingMixin:\n    \"\"\"Mixin that provides methods related to signal processing.\n\n    This mixin provides processing methods applied to audio signals and\n    other time-series data, such as signal processing filters and\n    transformation operations.\n    \"\"\"\n\n    def high_pass_filter(\n        self: T_Processing, cutoff: float, order: int = 4\n    ) -&gt; T_Processing:\n        \"\"\"Apply a high-pass filter to the signal.\n\n        Args:\n            cutoff: Filter cutoff frequency (Hz)\n            order: Filter order. Default is 4.\n\n        Returns:\n            New ChannelFrame after filter application\n        \"\"\"\n        logger.debug(\n            f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        result = self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n        return cast(T_Processing, result)\n\n    def low_pass_filter(\n        self: T_Processing, cutoff: float, order: int = 4\n    ) -&gt; T_Processing:\n        \"\"\"Apply a low-pass filter to the signal.\n\n        Args:\n            cutoff: Filter cutoff frequency (Hz)\n            order: Filter order. Default is 4.\n\n        Returns:\n            New ChannelFrame after filter application\n        \"\"\"\n        logger.debug(\n            f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n        )\n        result = self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n        return cast(T_Processing, result)\n\n    def band_pass_filter(\n        self: T_Processing, low_cutoff: float, high_cutoff: float, order: int = 4\n    ) -&gt; T_Processing:\n        \"\"\"Apply a band-pass filter to the signal.\n\n        Args:\n            low_cutoff: Lower cutoff frequency (Hz)\n            high_cutoff: Higher cutoff frequency (Hz)\n            order: Filter order. Default is 4.\n\n        Returns:\n            New ChannelFrame after filter application\n        \"\"\"\n        logger.debug(\n            f\"Setting up bandpass filter: low_cutoff={low_cutoff}, \"\n            f\"high_cutoff={high_cutoff}, order={order} (lazy)\"\n        )\n        result = self.apply_operation(\n            \"bandpass_filter\",\n            low_cutoff=low_cutoff,\n            high_cutoff=high_cutoff,\n            order=order,\n        )\n        return cast(T_Processing, result)\n\n    def normalize(\n        self: T_Processing, target_level: float = -20, channel_wise: bool = True\n    ) -&gt; T_Processing:\n        \"\"\"Normalize signal levels.\n\n        This method adjusts the signal amplitude to reach the target RMS level.\n\n        Args:\n            target_level: Target RMS level (dB). Default is -20.\n            channel_wise: If True, normalize each channel individually.\n                If False, apply the same scaling to all channels.\n\n        Returns:\n            New ChannelFrame containing the normalized signal\n        \"\"\"\n        logger.debug(\n            f\"Setting up normalize: target_level={target_level}, \"\n            f\"channel_wise={channel_wise} (lazy)\"\n        )\n        result = self.apply_operation(\n            \"normalize\", target_level=target_level, channel_wise=channel_wise\n        )\n        return cast(T_Processing, result)\n\n    def a_weighting(self: T_Processing) -&gt; T_Processing:\n        \"\"\"Apply A-weighting filter to the signal.\n\n        A-weighting adjusts the frequency response to approximate human\n        auditory perception, according to the IEC 61672-1:2013 standard.\n\n        Returns:\n            New ChannelFrame containing the A-weighted signal\n        \"\"\"\n        result = self.apply_operation(\"a_weighting\")\n        return cast(T_Processing, result)\n\n    def abs(self: T_Processing) -&gt; T_Processing:\n        \"\"\"Compute the absolute value of the signal.\n\n        Returns:\n            New ChannelFrame containing the absolute values\n        \"\"\"\n        result = self.apply_operation(\"abs\")\n        return cast(T_Processing, result)\n\n    def power(self: T_Processing, exponent: float = 2.0) -&gt; T_Processing:\n        \"\"\"Compute the power of the signal.\n\n        Args:\n            exponent: Exponent to raise the signal to. Default is 2.0.\n\n        Returns:\n            New ChannelFrame containing the powered signal\n        \"\"\"\n        result = self.apply_operation(\"power\", exponent=exponent)\n        return cast(T_Processing, result)\n\n    def _reduce_channels(self: T_Processing, op: str) -&gt; T_Processing:\n        \"\"\"Helper to reduce all channels with the given operation ('sum' or 'mean').\"\"\"\n        if op == \"sum\":\n            reduced_data = self._data.sum(axis=0, keepdims=True)\n            label = \"sum\"\n        elif op == \"mean\":\n            reduced_data = self._data.mean(axis=0, keepdims=True)\n            label = \"mean\"\n        else:\n            raise ValueError(f\"Unsupported reduction operation: {op}\")\n\n        units = [ch.unit for ch in self._channel_metadata]\n        if all(u == units[0] for u in units):\n            reduced_unit = units[0]\n        else:\n            reduced_unit = \"\"\n\n        reduced_extra = {\"source_extras\": [ch.extra for ch in self._channel_metadata]}\n        new_channel_metadata = [\n            ChannelMetadata(\n                label=label,\n                unit=reduced_unit,\n                extra=reduced_extra,\n            )\n        ]\n        new_history = (\n            self.operation_history.copy() if hasattr(self, \"operation_history\") else []\n        )\n        new_history.append({\"operation\": op})\n        new_metadata = self.metadata.copy() if hasattr(self, \"metadata\") else {}\n        result = self._create_new_instance(\n            data=reduced_data,\n            metadata=new_metadata,\n            operation_history=new_history,\n            channel_metadata=new_channel_metadata,\n        )\n        return result\n\n    def sum(self: T_Processing) -&gt; T_Processing:\n        \"\"\"Sum all channels.\n\n        Returns:\n            A new ChannelFrame with summed signal.\n        \"\"\"\n        return cast(T_Processing, cast(Any, self)._reduce_channels(\"sum\"))\n\n    def mean(self: T_Processing) -&gt; T_Processing:\n        \"\"\"Average all channels.\n\n        Returns:\n            A new ChannelFrame with averaged signal.\n        \"\"\"\n        return cast(T_Processing, cast(Any, self)._reduce_channels(\"mean\"))\n\n    def trim(\n        self: T_Processing,\n        start: float = 0,\n        end: Optional[float] = None,\n    ) -&gt; T_Processing:\n        \"\"\"Trim the signal to the specified time range.\n\n        Args:\n            start: Start time (seconds)\n            end: End time (seconds)\n\n        Returns:\n            New ChannelFrame containing the trimmed signal\n\n        Raises:\n            ValueError: If end time is earlier than start time\n        \"\"\"\n        if end is None:\n            end = self.duration\n        if start &gt; end:\n            raise ValueError(\"start must be less than end\")\n        result = self.apply_operation(\"trim\", start=start, end=end)\n        return cast(T_Processing, result)\n\n    def fix_length(\n        self: T_Processing,\n        length: Optional[int] = None,\n        duration: Optional[float] = None,\n    ) -&gt; T_Processing:\n        \"\"\"Adjust the signal to the specified length.\n\n        Args:\n            duration: Signal length in seconds\n            length: Signal length in samples\n\n        Returns:\n            New ChannelFrame containing the adjusted signal\n        \"\"\"\n\n        result = self.apply_operation(\"fix_length\", length=length, duration=duration)\n        return cast(T_Processing, result)\n\n    def rms_trend(\n        self: T_Processing,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; T_Processing:\n        \"\"\"Compute the RMS trend of the signal.\n\n        This method calculates the root mean square value over a sliding window.\n\n        Args:\n            frame_length: Size of the sliding window in samples. Default is 2048.\n            hop_length: Hop length between windows in samples. Default is 512.\n            dB: Whether to return RMS values in decibels. Default is False.\n            Aw: Whether to apply A-weighting. Default is False.\n\n        Returns:\n            New ChannelFrame containing the RMS trend\n        \"\"\"\n        # Access _channel_metadata to retrieve reference values\n        frame = cast(ProcessingFrameProtocol, self)\n\n        # Ensure _channel_metadata exists before referencing\n        ref_values = []\n        if hasattr(frame, \"_channel_metadata\") and frame._channel_metadata:\n            ref_values = [ch.ref for ch in frame._channel_metadata]\n\n        result = self.apply_operation(\n            \"rms_trend\",\n            frame_length=frame_length,\n            hop_length=hop_length,\n            ref=ref_values,\n            dB=dB,\n            Aw=Aw,\n        )\n\n        # Update sampling rate\n        result_obj = cast(T_Processing, result)\n        if hasattr(result_obj, \"sampling_rate\"):\n            result_obj.sampling_rate = frame.sampling_rate / hop_length\n\n        return result_obj\n\n    def channel_difference(\n        self: T_Processing, other_channel: Union[int, str] = 0\n    ) -&gt; T_Processing:\n        \"\"\"Compute the difference between channels.\n\n        Args:\n            other_channel: Index or label of the reference channel. Default is 0.\n\n        Returns:\n            New ChannelFrame containing the channel difference\n        \"\"\"\n        # label2index is a method of BaseFrame\n        if isinstance(other_channel, str):\n            if hasattr(self, \"label2index\"):\n                other_channel = self.label2index(other_channel)\n\n        result = self.apply_operation(\"channel_difference\", other_channel=other_channel)\n        return cast(T_Processing, result)\n\n    def resampling(\n        self: T_Processing,\n        target_sr: float,\n        **kwargs: Any,\n    ) -&gt; T_Processing:\n        \"\"\"Resample audio data.\n\n        Args:\n            target_sr: Target sampling rate (Hz)\n            **kwargs: Additional resampling parameters\n\n        Returns:\n            Resampled ChannelFrame\n        \"\"\"\n        return cast(\n            T_Processing,\n            self.apply_operation(\n                \"resampling\",\n                target_sr=target_sr,\n                **kwargs,\n            ),\n        )\n\n    def hpss_harmonic(\n        self: T_Processing,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; T_Processing:\n        \"\"\"\n        Extract harmonic components using HPSS\n         (Harmonic-Percussive Source Separation).\n\n        This method separates the harmonic (tonal) components from the signal.\n\n        Args:\n            kernel_size: Median filter size for HPSS.\n            power: Exponent for the Weiner filter used in HPSS.\n            margin: Margin size for the separation.\n            n_fft: Size of FFT window.\n            hop_length: Hop length for STFT.\n            win_length: Window length for STFT.\n            window: Window type for STFT.\n            center: If True, center the frames.\n            pad_mode: Padding mode for STFT.\n\n        Returns:\n            A new ChannelFrame containing the harmonic components.\n        \"\"\"\n        result = self.apply_operation(\n            \"hpss_harmonic\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n        return cast(T_Processing, result)\n\n    def hpss_percussive(\n        self: T_Processing,\n        kernel_size: Union[\n            \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n        ] = 31,\n        power: float = 2,\n        margin: Union[\n            \"_FloatLike_co\",\n            tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n            list[\"_FloatLike_co\"],\n        ] = 1,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: \"_WindowSpec\" = \"hann\",\n        center: bool = True,\n        pad_mode: \"_PadModeSTFT\" = \"constant\",\n    ) -&gt; T_Processing:\n        \"\"\"\n        Extract percussive components using HPSS\n        (Harmonic-Percussive Source Separation).\n\n        This method separates the percussive (tonal) components from the signal.\n\n        Args:\n            kernel_size: Median filter size for HPSS.\n            power: Exponent for the Weiner filter used in HPSS.\n            margin: Margin size for the separation.\n\n        Returns:\n            A new ChannelFrame containing the harmonic components.\n        \"\"\"\n        result = self.apply_operation(\n            \"hpss_percussive\",\n            kernel_size=kernel_size,\n            power=power,\n            margin=margin,\n            n_fft=n_fft,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            center=center,\n            pad_mode=pad_mode,\n        )\n        return cast(T_Processing, result)\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin-functions","title":"Functions","text":""},{"location":"api/frames/#wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin.high_pass_filter","title":"<code>high_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a high-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>Filter cutoff frequency (Hz)</p> required <code>order</code> <code>int</code> <p>Filter order. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame after filter application</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def high_pass_filter(\n    self: T_Processing, cutoff: float, order: int = 4\n) -&gt; T_Processing:\n    \"\"\"Apply a high-pass filter to the signal.\n\n    Args:\n        cutoff: Filter cutoff frequency (Hz)\n        order: Filter order. Default is 4.\n\n    Returns:\n        New ChannelFrame after filter application\n    \"\"\"\n    logger.debug(\n        f\"Setting up highpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    result = self.apply_operation(\"highpass_filter\", cutoff=cutoff, order=order)\n    return cast(T_Processing, result)\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin.low_pass_filter","title":"<code>low_pass_filter(cutoff, order=4)</code>","text":"<p>Apply a low-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float</code> <p>Filter cutoff frequency (Hz)</p> required <code>order</code> <code>int</code> <p>Filter order. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame after filter application</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def low_pass_filter(\n    self: T_Processing, cutoff: float, order: int = 4\n) -&gt; T_Processing:\n    \"\"\"Apply a low-pass filter to the signal.\n\n    Args:\n        cutoff: Filter cutoff frequency (Hz)\n        order: Filter order. Default is 4.\n\n    Returns:\n        New ChannelFrame after filter application\n    \"\"\"\n    logger.debug(\n        f\"Setting up lowpass filter: cutoff={cutoff}, order={order} (lazy)\"\n    )\n    result = self.apply_operation(\"lowpass_filter\", cutoff=cutoff, order=order)\n    return cast(T_Processing, result)\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin.band_pass_filter","title":"<code>band_pass_filter(low_cutoff, high_cutoff, order=4)</code>","text":"<p>Apply a band-pass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>low_cutoff</code> <code>float</code> <p>Lower cutoff frequency (Hz)</p> required <code>high_cutoff</code> <code>float</code> <p>Higher cutoff frequency (Hz)</p> required <code>order</code> <code>int</code> <p>Filter order. Default is 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame after filter application</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def band_pass_filter(\n    self: T_Processing, low_cutoff: float, high_cutoff: float, order: int = 4\n) -&gt; T_Processing:\n    \"\"\"Apply a band-pass filter to the signal.\n\n    Args:\n        low_cutoff: Lower cutoff frequency (Hz)\n        high_cutoff: Higher cutoff frequency (Hz)\n        order: Filter order. Default is 4.\n\n    Returns:\n        New ChannelFrame after filter application\n    \"\"\"\n    logger.debug(\n        f\"Setting up bandpass filter: low_cutoff={low_cutoff}, \"\n        f\"high_cutoff={high_cutoff}, order={order} (lazy)\"\n    )\n    result = self.apply_operation(\n        \"bandpass_filter\",\n        low_cutoff=low_cutoff,\n        high_cutoff=high_cutoff,\n        order=order,\n    )\n    return cast(T_Processing, result)\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin.normalize","title":"<code>normalize(target_level=-20, channel_wise=True)</code>","text":"<p>Normalize signal levels.</p> <p>This method adjusts the signal amplitude to reach the target RMS level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target RMS level (dB). Default is -20.</p> <code>-20</code> <code>channel_wise</code> <code>bool</code> <p>If True, normalize each channel individually. If False, apply the same scaling to all channels.</p> <code>True</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the normalized signal</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def normalize(\n    self: T_Processing, target_level: float = -20, channel_wise: bool = True\n) -&gt; T_Processing:\n    \"\"\"Normalize signal levels.\n\n    This method adjusts the signal amplitude to reach the target RMS level.\n\n    Args:\n        target_level: Target RMS level (dB). Default is -20.\n        channel_wise: If True, normalize each channel individually.\n            If False, apply the same scaling to all channels.\n\n    Returns:\n        New ChannelFrame containing the normalized signal\n    \"\"\"\n    logger.debug(\n        f\"Setting up normalize: target_level={target_level}, \"\n        f\"channel_wise={channel_wise} (lazy)\"\n    )\n    result = self.apply_operation(\n        \"normalize\", target_level=target_level, channel_wise=channel_wise\n    )\n    return cast(T_Processing, result)\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin.a_weighting","title":"<code>a_weighting()</code>","text":"<p>Apply A-weighting filter to the signal.</p> <p>A-weighting adjusts the frequency response to approximate human auditory perception, according to the IEC 61672-1:2013 standard.</p> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the A-weighted signal</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def a_weighting(self: T_Processing) -&gt; T_Processing:\n    \"\"\"Apply A-weighting filter to the signal.\n\n    A-weighting adjusts the frequency response to approximate human\n    auditory perception, according to the IEC 61672-1:2013 standard.\n\n    Returns:\n        New ChannelFrame containing the A-weighted signal\n    \"\"\"\n    result = self.apply_operation(\"a_weighting\")\n    return cast(T_Processing, result)\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin.abs","title":"<code>abs()</code>","text":"<p>Compute the absolute value of the signal.</p> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the absolute values</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def abs(self: T_Processing) -&gt; T_Processing:\n    \"\"\"Compute the absolute value of the signal.\n\n    Returns:\n        New ChannelFrame containing the absolute values\n    \"\"\"\n    result = self.apply_operation(\"abs\")\n    return cast(T_Processing, result)\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin.power","title":"<code>power(exponent=2.0)</code>","text":"<p>Compute the power of the signal.</p> <p>Parameters:</p> Name Type Description Default <code>exponent</code> <code>float</code> <p>Exponent to raise the signal to. Default is 2.0.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the powered signal</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def power(self: T_Processing, exponent: float = 2.0) -&gt; T_Processing:\n    \"\"\"Compute the power of the signal.\n\n    Args:\n        exponent: Exponent to raise the signal to. Default is 2.0.\n\n    Returns:\n        New ChannelFrame containing the powered signal\n    \"\"\"\n    result = self.apply_operation(\"power\", exponent=exponent)\n    return cast(T_Processing, result)\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin.sum","title":"<code>sum()</code>","text":"<p>Sum all channels.</p> <p>Returns:</p> Type Description <code>T_Processing</code> <p>A new ChannelFrame with summed signal.</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def sum(self: T_Processing) -&gt; T_Processing:\n    \"\"\"Sum all channels.\n\n    Returns:\n        A new ChannelFrame with summed signal.\n    \"\"\"\n    return cast(T_Processing, cast(Any, self)._reduce_channels(\"sum\"))\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin.mean","title":"<code>mean()</code>","text":"<p>Average all channels.</p> <p>Returns:</p> Type Description <code>T_Processing</code> <p>A new ChannelFrame with averaged signal.</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def mean(self: T_Processing) -&gt; T_Processing:\n    \"\"\"Average all channels.\n\n    Returns:\n        A new ChannelFrame with averaged signal.\n    \"\"\"\n    return cast(T_Processing, cast(Any, self)._reduce_channels(\"mean\"))\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin.trim","title":"<code>trim(start=0, end=None)</code>","text":"<p>Trim the signal to the specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>Start time (seconds)</p> <code>0</code> <code>end</code> <code>Optional[float]</code> <p>End time (seconds)</p> <code>None</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the trimmed signal</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If end time is earlier than start time</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def trim(\n    self: T_Processing,\n    start: float = 0,\n    end: Optional[float] = None,\n) -&gt; T_Processing:\n    \"\"\"Trim the signal to the specified time range.\n\n    Args:\n        start: Start time (seconds)\n        end: End time (seconds)\n\n    Returns:\n        New ChannelFrame containing the trimmed signal\n\n    Raises:\n        ValueError: If end time is earlier than start time\n    \"\"\"\n    if end is None:\n        end = self.duration\n    if start &gt; end:\n        raise ValueError(\"start must be less than end\")\n    result = self.apply_operation(\"trim\", start=start, end=end)\n    return cast(T_Processing, result)\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin.fix_length","title":"<code>fix_length(length=None, duration=None)</code>","text":"<p>Adjust the signal to the specified length.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>Optional[float]</code> <p>Signal length in seconds</p> <code>None</code> <code>length</code> <code>Optional[int]</code> <p>Signal length in samples</p> <code>None</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the adjusted signal</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def fix_length(\n    self: T_Processing,\n    length: Optional[int] = None,\n    duration: Optional[float] = None,\n) -&gt; T_Processing:\n    \"\"\"Adjust the signal to the specified length.\n\n    Args:\n        duration: Signal length in seconds\n        length: Signal length in samples\n\n    Returns:\n        New ChannelFrame containing the adjusted signal\n    \"\"\"\n\n    result = self.apply_operation(\"fix_length\", length=length, duration=duration)\n    return cast(T_Processing, result)\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin.rms_trend","title":"<code>rms_trend(frame_length=2048, hop_length=512, dB=False, Aw=False)</code>","text":"<p>Compute the RMS trend of the signal.</p> <p>This method calculates the root mean square value over a sliding window.</p> <p>Parameters:</p> Name Type Description Default <code>frame_length</code> <code>int</code> <p>Size of the sliding window in samples. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>int</code> <p>Hop length between windows in samples. Default is 512.</p> <code>512</code> <code>dB</code> <code>bool</code> <p>Whether to return RMS values in decibels. Default is False.</p> <code>False</code> <code>Aw</code> <code>bool</code> <p>Whether to apply A-weighting. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the RMS trend</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def rms_trend(\n    self: T_Processing,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; T_Processing:\n    \"\"\"Compute the RMS trend of the signal.\n\n    This method calculates the root mean square value over a sliding window.\n\n    Args:\n        frame_length: Size of the sliding window in samples. Default is 2048.\n        hop_length: Hop length between windows in samples. Default is 512.\n        dB: Whether to return RMS values in decibels. Default is False.\n        Aw: Whether to apply A-weighting. Default is False.\n\n    Returns:\n        New ChannelFrame containing the RMS trend\n    \"\"\"\n    # Access _channel_metadata to retrieve reference values\n    frame = cast(ProcessingFrameProtocol, self)\n\n    # Ensure _channel_metadata exists before referencing\n    ref_values = []\n    if hasattr(frame, \"_channel_metadata\") and frame._channel_metadata:\n        ref_values = [ch.ref for ch in frame._channel_metadata]\n\n    result = self.apply_operation(\n        \"rms_trend\",\n        frame_length=frame_length,\n        hop_length=hop_length,\n        ref=ref_values,\n        dB=dB,\n        Aw=Aw,\n    )\n\n    # Update sampling rate\n    result_obj = cast(T_Processing, result)\n    if hasattr(result_obj, \"sampling_rate\"):\n        result_obj.sampling_rate = frame.sampling_rate / hop_length\n\n    return result_obj\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin.channel_difference","title":"<code>channel_difference(other_channel=0)</code>","text":"<p>Compute the difference between channels.</p> <p>Parameters:</p> Name Type Description Default <code>other_channel</code> <code>Union[int, str]</code> <p>Index or label of the reference channel. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>New ChannelFrame containing the channel difference</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def channel_difference(\n    self: T_Processing, other_channel: Union[int, str] = 0\n) -&gt; T_Processing:\n    \"\"\"Compute the difference between channels.\n\n    Args:\n        other_channel: Index or label of the reference channel. Default is 0.\n\n    Returns:\n        New ChannelFrame containing the channel difference\n    \"\"\"\n    # label2index is a method of BaseFrame\n    if isinstance(other_channel, str):\n        if hasattr(self, \"label2index\"):\n            other_channel = self.label2index(other_channel)\n\n    result = self.apply_operation(\"channel_difference\", other_channel=other_channel)\n    return cast(T_Processing, result)\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin.resampling","title":"<code>resampling(target_sr, **kwargs)</code>","text":"<p>Resample audio data.</p> <p>Parameters:</p> Name Type Description Default <code>target_sr</code> <code>float</code> <p>Target sampling rate (Hz)</p> required <code>**kwargs</code> <code>Any</code> <p>Additional resampling parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>Resampled ChannelFrame</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def resampling(\n    self: T_Processing,\n    target_sr: float,\n    **kwargs: Any,\n) -&gt; T_Processing:\n    \"\"\"Resample audio data.\n\n    Args:\n        target_sr: Target sampling rate (Hz)\n        **kwargs: Additional resampling parameters\n\n    Returns:\n        Resampled ChannelFrame\n    \"\"\"\n    return cast(\n        T_Processing,\n        self.apply_operation(\n            \"resampling\",\n            target_sr=target_sr,\n            **kwargs,\n        ),\n    )\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin.hpss_harmonic","title":"<code>hpss_harmonic(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract harmonic components using HPSS  (Harmonic-Percussive Source Separation).</p> <p>This method separates the harmonic (tonal) components from the signal.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Union[_IntLike_co, tuple[_IntLike_co, _IntLike_co], list[_IntLike_co]]</code> <p>Median filter size for HPSS.</p> <code>31</code> <code>power</code> <code>float</code> <p>Exponent for the Weiner filter used in HPSS.</p> <code>2</code> <code>margin</code> <code>Union[_FloatLike_co, tuple[_FloatLike_co, _FloatLike_co], list[_FloatLike_co]]</code> <p>Margin size for the separation.</p> <code>1</code> <code>n_fft</code> <code>int</code> <p>Size of FFT window.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Hop length for STFT.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Window length for STFT.</p> <code>None</code> <code>window</code> <code>_WindowSpec</code> <p>Window type for STFT.</p> <code>'hann'</code> <code>center</code> <code>bool</code> <p>If True, center the frames.</p> <code>True</code> <code>pad_mode</code> <code>_PadModeSTFT</code> <p>Padding mode for STFT.</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>A new ChannelFrame containing the harmonic components.</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def hpss_harmonic(\n    self: T_Processing,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; T_Processing:\n    \"\"\"\n    Extract harmonic components using HPSS\n     (Harmonic-Percussive Source Separation).\n\n    This method separates the harmonic (tonal) components from the signal.\n\n    Args:\n        kernel_size: Median filter size for HPSS.\n        power: Exponent for the Weiner filter used in HPSS.\n        margin: Margin size for the separation.\n        n_fft: Size of FFT window.\n        hop_length: Hop length for STFT.\n        win_length: Window length for STFT.\n        window: Window type for STFT.\n        center: If True, center the frames.\n        pad_mode: Padding mode for STFT.\n\n    Returns:\n        A new ChannelFrame containing the harmonic components.\n    \"\"\"\n    result = self.apply_operation(\n        \"hpss_harmonic\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n    return cast(T_Processing, result)\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_processing_mixin.ChannelProcessingMixin.hpss_percussive","title":"<code>hpss_percussive(kernel_size=31, power=2, margin=1, n_fft=2048, hop_length=None, win_length=None, window='hann', center=True, pad_mode='constant')</code>","text":"<p>Extract percussive components using HPSS (Harmonic-Percussive Source Separation).</p> <p>This method separates the percussive (tonal) components from the signal.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Union[_IntLike_co, tuple[_IntLike_co, _IntLike_co], list[_IntLike_co]]</code> <p>Median filter size for HPSS.</p> <code>31</code> <code>power</code> <code>float</code> <p>Exponent for the Weiner filter used in HPSS.</p> <code>2</code> <code>margin</code> <code>Union[_FloatLike_co, tuple[_FloatLike_co, _FloatLike_co], list[_FloatLike_co]]</code> <p>Margin size for the separation.</p> <code>1</code> <p>Returns:</p> Type Description <code>T_Processing</code> <p>A new ChannelFrame containing the harmonic components.</p> Source code in <code>wandas/frames/mixins/channel_processing_mixin.py</code> <pre><code>def hpss_percussive(\n    self: T_Processing,\n    kernel_size: Union[\n        \"_IntLike_co\", tuple[\"_IntLike_co\", \"_IntLike_co\"], list[\"_IntLike_co\"]\n    ] = 31,\n    power: float = 2,\n    margin: Union[\n        \"_FloatLike_co\",\n        tuple[\"_FloatLike_co\", \"_FloatLike_co\"],\n        list[\"_FloatLike_co\"],\n    ] = 1,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: \"_WindowSpec\" = \"hann\",\n    center: bool = True,\n    pad_mode: \"_PadModeSTFT\" = \"constant\",\n) -&gt; T_Processing:\n    \"\"\"\n    Extract percussive components using HPSS\n    (Harmonic-Percussive Source Separation).\n\n    This method separates the percussive (tonal) components from the signal.\n\n    Args:\n        kernel_size: Median filter size for HPSS.\n        power: Exponent for the Weiner filter used in HPSS.\n        margin: Margin size for the separation.\n\n    Returns:\n        A new ChannelFrame containing the harmonic components.\n    \"\"\"\n    result = self.apply_operation(\n        \"hpss_percussive\",\n        kernel_size=kernel_size,\n        power=power,\n        margin=margin,\n        n_fft=n_fft,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        center=center,\n        pad_mode=pad_mode,\n    )\n    return cast(T_Processing, result)\n</code></pre>"},{"location":"api/frames/#channeltransformmixin","title":"ChannelTransformMixin","text":""},{"location":"api/frames/#wandas.frames.mixins.channel_transform_mixin.ChannelTransformMixin","title":"<code>wandas.frames.mixins.channel_transform_mixin.ChannelTransformMixin</code>","text":"<p>Mixin providing methods related to frequency transformations.</p> <p>This mixin provides operations related to frequency analysis and transformations such as FFT, STFT, and Welch method.</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>class ChannelTransformMixin:\n    \"\"\"Mixin providing methods related to frequency transformations.\n\n    This mixin provides operations related to frequency analysis and\n    transformations such as FFT, STFT, and Welch method.\n    \"\"\"\n\n    def fft(\n        self: T_Transform, n_fft: Optional[int] = None, window: str = \"hann\"\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Calculate Fast Fourier Transform (FFT).\n\n        Args:\n            n_fft: Number of FFT points. Default is the next power of 2 of the data\n                length.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            SpectralFrame containing FFT results\n        \"\"\"\n        from wandas.frames.spectral import SpectralFrame\n        from wandas.processing import FFT, create_operation\n\n        params = {\"n_fft\": n_fft, \"window\": window}\n        operation_name = \"fft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"FFT\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        if n_fft is None:\n            is_even = spectrum_data.shape[-1] % 2 == 0\n            _n_fft = (\n                spectrum_data.shape[-1] * 2 - 2\n                if is_even\n                else spectrum_data.shape[-1] * 2 - 1\n            )\n        else:\n            _n_fft = n_fft\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=_n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=base_self,\n        )\n\n    def welch(\n        self: T_Transform,\n        n_fft: Optional[int] = None,\n        hop_length: Optional[int] = None,\n        win_length: int = 2048,\n        window: str = \"hann\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Calculate power spectral density using Welch's method.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between frames.\n                Default is n_fft//4.\n            win_length: Window length. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            SpectralFrame containing power spectral density\n        \"\"\"\n        from wandas.frames.spectral import SpectralFrame\n        from wandas.processing import Welch, create_operation\n\n        params = dict(\n            n_fft=n_fft or win_length,\n            hop_length=hop_length,\n            win_length=win_length,\n            window=window,\n            average=average,\n        )\n        operation_name = \"welch\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Welch\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        return SpectralFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Spectrum of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": \"welch\", \"params\": params},\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=base_self,\n        )\n\n    def noct_spectrum(\n        self: T_Transform,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ) -&gt; \"NOctFrame\":\n        \"\"\"Calculate N-octave band spectrum.\n\n        Args:\n            fmin: Minimum center frequency (Hz). Default is 20 Hz.\n            fmax: Maximum center frequency (Hz). Default is 20000 Hz.\n            n: Band division (1: octave, 3: 1/3 octave). Default is 3.\n            G: Reference gain (dB). Default is 10 dB.\n            fr: Reference frequency (Hz). Default is 1000 Hz.\n\n        Returns:\n            NOctFrame containing N-octave band spectrum\n        \"\"\"\n        from wandas.processing import NOctSpectrum, create_operation\n\n        from ..noct import NOctFrame\n\n        params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n        operation_name = \"noct_spectrum\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"NOctSpectrum\", operation)\n        # Apply processing to data\n        spectrum_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        return NOctFrame(\n            data=spectrum_data,\n            sampling_rate=self.sampling_rate,\n            fmin=fmin,\n            fmax=fmax,\n            n=n,\n            G=G,\n            fr=fr,\n            label=f\"1/{n}Oct of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\n                    \"operation\": \"noct_spectrum\",\n                    \"params\": params,\n                },\n            ],\n            channel_metadata=self._channel_metadata,\n            previous=base_self,\n        )\n\n    def stft(\n        self: T_Transform,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ) -&gt; \"SpectrogramFrame\":\n        \"\"\"Calculate Short-Time Fourier Transform.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between frames.\n                Default is n_fft//4.\n            win_length: Window length. Default is n_fft.\n            window: Window type. Default is \"hann\".\n\n        Returns:\n            SpectrogramFrame containing STFT results\n        \"\"\"\n        from wandas.processing import STFT, create_operation\n\n        from ..spectrogram import SpectrogramFrame\n\n        # Set hop length and window length\n        _hop_length = hop_length if hop_length is not None else n_fft // 4\n        _win_length = win_length if win_length is not None else n_fft\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": _hop_length,\n            \"win_length\": _win_length,\n            \"window\": window,\n        }\n        operation_name = \"stft\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"STFT\", operation)\n\n        # Apply processing to data\n        spectrogram_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n        )\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        # Create new instance\n        return SpectrogramFrame(\n            data=spectrogram_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=n_fft,\n            hop_length=_hop_length,\n            win_length=_win_length,\n            window=window,\n            label=f\"stft({self.label})\",\n            metadata=self.metadata,\n            operation_history=self.operation_history,\n            channel_metadata=self._channel_metadata,\n            previous=base_self,\n        )\n\n    def coherence(\n        self: T_Transform,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Calculate magnitude squared coherence.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between frames.\n                Default is n_fft//4.\n            win_length: Window length. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrend method. Options: \"constant\", \"linear\", None.\n\n        Returns:\n            SpectralFrame containing magnitude squared coherence\n        \"\"\"\n        from wandas.core.metadata import ChannelMetadata\n        from wandas.processing import Coherence, create_operation\n\n        from ..spectral import SpectralFrame\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n        }\n        operation_name = \"coherence\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"Coherence\", operation)\n\n        # Apply processing to data\n        coherence_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=coherence_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Coherence of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=base_self,\n        )\n\n    def csd(\n        self: T_Transform,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Calculate cross-spectral density matrix.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between frames.\n                Default is n_fft//4.\n            win_length: Window length. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrend method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            SpectralFrame containing cross-spectral density matrix\n        \"\"\"\n        from wandas.core.metadata import ChannelMetadata\n        from wandas.frames.spectral import SpectralFrame\n        from wandas.processing import CSD, create_operation\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"csd\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"CSD\", operation)\n\n        # Apply processing to data\n        csd_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=csd_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=base_self,\n        )\n\n    def transfer_function(\n        self: T_Transform,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        detrend: str = \"constant\",\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ) -&gt; \"SpectralFrame\":\n        \"\"\"Calculate transfer function matrix.\n\n        The transfer function represents the signal transfer characteristics between\n        channels in the frequency domain and represents the input-output relationship\n        of the system.\n\n        Args:\n            n_fft: Number of FFT points. Default is 2048.\n            hop_length: Number of samples between frames.\n                Default is n_fft//4.\n            win_length: Window length. Default is n_fft.\n            window: Window type. Default is \"hann\".\n            detrend: Detrend method. Options: \"constant\", \"linear\", None.\n            scaling: Scaling method. Options: \"spectrum\", \"density\".\n            average: Method for averaging segments. Default is \"mean\".\n\n        Returns:\n            SpectralFrame containing transfer function matrix\n        \"\"\"\n        from wandas.core.metadata import ChannelMetadata\n        from wandas.frames.spectral import SpectralFrame\n        from wandas.processing import TransferFunction, create_operation\n\n        params = {\n            \"n_fft\": n_fft,\n            \"hop_length\": hop_length,\n            \"win_length\": win_length,\n            \"window\": window,\n            \"detrend\": detrend,\n            \"scaling\": scaling,\n            \"average\": average,\n        }\n        operation_name = \"transfer_function\"\n        logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n        # Create operation instance\n        operation = create_operation(operation_name, self.sampling_rate, **params)\n        operation = cast(\"TransferFunction\", operation)\n\n        # Apply processing to data\n        tf_data = operation.process(self._data)\n\n        logger.debug(\n            f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n        )\n\n        # Cast self as BaseFrame type\n        base_self = cast(BaseFrame[Any], self)\n\n        # Create new channel metadata\n        channel_metadata = []\n        for in_ch in self._channel_metadata:\n            for out_ch in self._channel_metadata:\n                meta = ChannelMetadata()\n                meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n                meta.unit = \"\"\n                meta.ref = 1\n                meta[\"metadata\"] = dict(\n                    in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n                )\n                channel_metadata.append(meta)\n\n        # Create new instance\n        return SpectralFrame(\n            data=tf_data,\n            sampling_rate=self.sampling_rate,\n            n_fft=operation.n_fft,\n            window=operation.window,\n            label=f\"Transfer function of {self.label}\",\n            metadata={**self.metadata, **params},\n            operation_history=[\n                *self.operation_history,\n                {\"operation\": operation_name, \"params\": params},\n            ],\n            channel_metadata=channel_metadata,\n            previous=base_self,\n        )\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_transform_mixin.ChannelTransformMixin-functions","title":"Functions","text":""},{"location":"api/frames/#wandas.frames.mixins.channel_transform_mixin.ChannelTransformMixin.fft","title":"<code>fft(n_fft=None, window='hann')</code>","text":"<p>Calculate Fast Fourier Transform (FFT).</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is the next power of 2 of the data length.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>SpectralFrame containing FFT results</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def fft(\n    self: T_Transform, n_fft: Optional[int] = None, window: str = \"hann\"\n) -&gt; \"SpectralFrame\":\n    \"\"\"Calculate Fast Fourier Transform (FFT).\n\n    Args:\n        n_fft: Number of FFT points. Default is the next power of 2 of the data\n            length.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        SpectralFrame containing FFT results\n    \"\"\"\n    from wandas.frames.spectral import SpectralFrame\n    from wandas.processing import FFT, create_operation\n\n    params = {\"n_fft\": n_fft, \"window\": window}\n    operation_name = \"fft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"FFT\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    if n_fft is None:\n        is_even = spectrum_data.shape[-1] % 2 == 0\n        _n_fft = (\n            spectrum_data.shape[-1] * 2 - 2\n            if is_even\n            else spectrum_data.shape[-1] * 2 - 1\n        )\n    else:\n        _n_fft = n_fft\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=_n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, \"window\": window, \"n_fft\": _n_fft},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"fft\", \"params\": {\"n_fft\": _n_fft, \"window\": window}},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=base_self,\n    )\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_transform_mixin.ChannelTransformMixin.welch","title":"<code>welch(n_fft=None, hop_length=None, win_length=2048, window='hann', average='mean')</code>","text":"<p>Calculate power spectral density using Welch's method.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>Optional[int]</code> <p>Number of FFT points. Default is 2048.</p> <code>None</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between frames. Default is n_fft//4.</p> <code>None</code> <code>win_length</code> <code>int</code> <p>Window length. Default is n_fft.</p> <code>2048</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>SpectralFrame containing power spectral density</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def welch(\n    self: T_Transform,\n    n_fft: Optional[int] = None,\n    hop_length: Optional[int] = None,\n    win_length: int = 2048,\n    window: str = \"hann\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Calculate power spectral density using Welch's method.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between frames.\n            Default is n_fft//4.\n        win_length: Window length. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        SpectralFrame containing power spectral density\n    \"\"\"\n    from wandas.frames.spectral import SpectralFrame\n    from wandas.processing import Welch, create_operation\n\n    params = dict(\n        n_fft=n_fft or win_length,\n        hop_length=hop_length,\n        win_length=win_length,\n        window=window,\n        average=average,\n    )\n    operation_name = \"welch\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Welch\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    return SpectralFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Spectrum of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": \"welch\", \"params\": params},\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=base_self,\n    )\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_transform_mixin.ChannelTransformMixin.noct_spectrum","title":"<code>noct_spectrum(fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Calculate N-octave band spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>fmin</code> <code>float</code> <p>Minimum center frequency (Hz). Default is 20 Hz.</p> required <code>fmax</code> <code>float</code> <p>Maximum center frequency (Hz). Default is 20000 Hz.</p> required <code>n</code> <code>int</code> <p>Band division (1: octave, 3: 1/3 octave). Default is 3.</p> <code>3</code> <code>G</code> <code>int</code> <p>Reference gain (dB). Default is 10 dB.</p> <code>10</code> <code>fr</code> <code>int</code> <p>Reference frequency (Hz). Default is 1000 Hz.</p> <code>1000</code> <p>Returns:</p> Type Description <code>NOctFrame</code> <p>NOctFrame containing N-octave band spectrum</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def noct_spectrum(\n    self: T_Transform,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n) -&gt; \"NOctFrame\":\n    \"\"\"Calculate N-octave band spectrum.\n\n    Args:\n        fmin: Minimum center frequency (Hz). Default is 20 Hz.\n        fmax: Maximum center frequency (Hz). Default is 20000 Hz.\n        n: Band division (1: octave, 3: 1/3 octave). Default is 3.\n        G: Reference gain (dB). Default is 10 dB.\n        fr: Reference frequency (Hz). Default is 1000 Hz.\n\n    Returns:\n        NOctFrame containing N-octave band spectrum\n    \"\"\"\n    from wandas.processing import NOctSpectrum, create_operation\n\n    from ..noct import NOctFrame\n\n    params = {\"fmin\": fmin, \"fmax\": fmax, \"n\": n, \"G\": G, \"fr\": fr}\n    operation_name = \"noct_spectrum\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"NOctSpectrum\", operation)\n    # Apply processing to data\n    spectrum_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    return NOctFrame(\n        data=spectrum_data,\n        sampling_rate=self.sampling_rate,\n        fmin=fmin,\n        fmax=fmax,\n        n=n,\n        G=G,\n        fr=fr,\n        label=f\"1/{n}Oct of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\n                \"operation\": \"noct_spectrum\",\n                \"params\": params,\n            },\n        ],\n        channel_metadata=self._channel_metadata,\n        previous=base_self,\n    )\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_transform_mixin.ChannelTransformMixin.stft","title":"<code>stft(n_fft=2048, hop_length=None, win_length=None, window='hann')</code>","text":"<p>Calculate Short-Time Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between frames. Default is n_fft//4.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Window length. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <p>Returns:</p> Type Description <code>SpectrogramFrame</code> <p>SpectrogramFrame containing STFT results</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def stft(\n    self: T_Transform,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n) -&gt; \"SpectrogramFrame\":\n    \"\"\"Calculate Short-Time Fourier Transform.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between frames.\n            Default is n_fft//4.\n        win_length: Window length. Default is n_fft.\n        window: Window type. Default is \"hann\".\n\n    Returns:\n        SpectrogramFrame containing STFT results\n    \"\"\"\n    from wandas.processing import STFT, create_operation\n\n    from ..spectrogram import SpectrogramFrame\n\n    # Set hop length and window length\n    _hop_length = hop_length if hop_length is not None else n_fft // 4\n    _win_length = win_length if win_length is not None else n_fft\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": _hop_length,\n        \"win_length\": _win_length,\n        \"window\": window,\n    }\n    operation_name = \"stft\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"STFT\", operation)\n\n    # Apply processing to data\n    spectrogram_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectrogramFrame with operation {operation_name} added to graph\"  # noqa: E501\n    )\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    # Create new instance\n    return SpectrogramFrame(\n        data=spectrogram_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=n_fft,\n        hop_length=_hop_length,\n        win_length=_win_length,\n        window=window,\n        label=f\"stft({self.label})\",\n        metadata=self.metadata,\n        operation_history=self.operation_history,\n        channel_metadata=self._channel_metadata,\n        previous=base_self,\n    )\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_transform_mixin.ChannelTransformMixin.coherence","title":"<code>coherence(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant')</code>","text":"<p>Calculate magnitude squared coherence.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between frames. Default is n_fft//4.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Window length. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrend method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>SpectralFrame containing magnitude squared coherence</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def coherence(\n    self: T_Transform,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Calculate magnitude squared coherence.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between frames.\n            Default is n_fft//4.\n        win_length: Window length. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrend method. Options: \"constant\", \"linear\", None.\n\n    Returns:\n        SpectralFrame containing magnitude squared coherence\n    \"\"\"\n    from wandas.core.metadata import ChannelMetadata\n    from wandas.processing import Coherence, create_operation\n\n    from ..spectral import SpectralFrame\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n    }\n    operation_name = \"coherence\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"Coherence\", operation)\n\n    # Apply processing to data\n    coherence_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$\\\\gamma_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=coherence_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Coherence of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=base_self,\n    )\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_transform_mixin.ChannelTransformMixin.csd","title":"<code>csd(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Calculate cross-spectral density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between frames. Default is n_fft//4.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Window length. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrend method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>SpectralFrame containing cross-spectral density matrix</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def csd(\n    self: T_Transform,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Calculate cross-spectral density matrix.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between frames.\n            Default is n_fft//4.\n        win_length: Window length. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrend method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        SpectralFrame containing cross-spectral density matrix\n    \"\"\"\n    from wandas.core.metadata import ChannelMetadata\n    from wandas.frames.spectral import SpectralFrame\n    from wandas.processing import CSD, create_operation\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"csd\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"CSD\", operation)\n\n    # Apply processing to data\n    csd_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"{operation_name}({in_ch.label}, {out_ch.label})\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=csd_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"$C_{{{in_ch.label}, {out_ch.label}}}$\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=base_self,\n    )\n</code></pre>"},{"location":"api/frames/#wandas.frames.mixins.channel_transform_mixin.ChannelTransformMixin.transfer_function","title":"<code>transfer_function(n_fft=2048, hop_length=None, win_length=None, window='hann', detrend='constant', scaling='spectrum', average='mean')</code>","text":"<p>Calculate transfer function matrix.</p> <p>The transfer function represents the signal transfer characteristics between channels in the frequency domain and represents the input-output relationship of the system.</p> <p>Parameters:</p> Name Type Description Default <code>n_fft</code> <code>int</code> <p>Number of FFT points. Default is 2048.</p> <code>2048</code> <code>hop_length</code> <code>Optional[int]</code> <p>Number of samples between frames. Default is n_fft//4.</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Window length. Default is n_fft.</p> <code>None</code> <code>window</code> <code>str</code> <p>Window type. Default is \"hann\".</p> <code>'hann'</code> <code>detrend</code> <code>str</code> <p>Detrend method. Options: \"constant\", \"linear\", None.</p> <code>'constant'</code> <code>scaling</code> <code>str</code> <p>Scaling method. Options: \"spectrum\", \"density\".</p> <code>'spectrum'</code> <code>average</code> <code>str</code> <p>Method for averaging segments. Default is \"mean\".</p> <code>'mean'</code> <p>Returns:</p> Type Description <code>SpectralFrame</code> <p>SpectralFrame containing transfer function matrix</p> Source code in <code>wandas/frames/mixins/channel_transform_mixin.py</code> <pre><code>def transfer_function(\n    self: T_Transform,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    detrend: str = \"constant\",\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n) -&gt; \"SpectralFrame\":\n    \"\"\"Calculate transfer function matrix.\n\n    The transfer function represents the signal transfer characteristics between\n    channels in the frequency domain and represents the input-output relationship\n    of the system.\n\n    Args:\n        n_fft: Number of FFT points. Default is 2048.\n        hop_length: Number of samples between frames.\n            Default is n_fft//4.\n        win_length: Window length. Default is n_fft.\n        window: Window type. Default is \"hann\".\n        detrend: Detrend method. Options: \"constant\", \"linear\", None.\n        scaling: Scaling method. Options: \"spectrum\", \"density\".\n        average: Method for averaging segments. Default is \"mean\".\n\n    Returns:\n        SpectralFrame containing transfer function matrix\n    \"\"\"\n    from wandas.core.metadata import ChannelMetadata\n    from wandas.frames.spectral import SpectralFrame\n    from wandas.processing import TransferFunction, create_operation\n\n    params = {\n        \"n_fft\": n_fft,\n        \"hop_length\": hop_length,\n        \"win_length\": win_length,\n        \"window\": window,\n        \"detrend\": detrend,\n        \"scaling\": scaling,\n        \"average\": average,\n    }\n    operation_name = \"transfer_function\"\n    logger.debug(f\"Applying operation={operation_name} with params={params} (lazy)\")\n\n    # Create operation instance\n    operation = create_operation(operation_name, self.sampling_rate, **params)\n    operation = cast(\"TransferFunction\", operation)\n\n    # Apply processing to data\n    tf_data = operation.process(self._data)\n\n    logger.debug(\n        f\"Created new SpectralFrame with operation {operation_name} added to graph\"\n    )\n\n    # Cast self as BaseFrame type\n    base_self = cast(BaseFrame[Any], self)\n\n    # Create new channel metadata\n    channel_metadata = []\n    for in_ch in self._channel_metadata:\n        for out_ch in self._channel_metadata:\n            meta = ChannelMetadata()\n            meta.label = f\"$H_{{{in_ch.label}, {out_ch.label}}}$\"\n            meta.unit = \"\"\n            meta.ref = 1\n            meta[\"metadata\"] = dict(\n                in_ch=in_ch[\"metadata\"], out_ch=out_ch[\"metadata\"]\n            )\n            channel_metadata.append(meta)\n\n    # Create new instance\n    return SpectralFrame(\n        data=tf_data,\n        sampling_rate=self.sampling_rate,\n        n_fft=operation.n_fft,\n        window=operation.window,\n        label=f\"Transfer function of {self.label}\",\n        metadata={**self.metadata, **params},\n        operation_history=[\n            *self.operation_history,\n            {\"operation\": operation_name, \"params\": params},\n        ],\n        channel_metadata=channel_metadata,\n        previous=base_self,\n    )\n</code></pre>"},{"location":"api/io/","title":"\u5165\u51fa\u529b\u30e2\u30b8\u30e5\u30fc\u30eb","text":"<p><code>wandas.io</code> \u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u3001\u69d8\u3005\u306a\u30d5\u30a1\u30a4\u30eb\u5f62\u5f0f\u306e\u8aad\u307f\u66f8\u304d\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/io/#_2","title":"\u30d5\u30a1\u30a4\u30eb\u30ea\u30fc\u30c0\u30fc","text":"<p>\u69d8\u3005\u306a\u30d5\u30a1\u30a4\u30eb\u5f62\u5f0f\u304b\u3089\u30c7\u30fc\u30bf\u3092\u8aad\u307f\u8fbc\u3080\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/io/#wandas.io.readers","title":"<code>wandas.io.readers</code>","text":""},{"location":"api/io/#wandas.io.readers-attributes","title":"Attributes","text":""},{"location":"api/io/#wandas.io.readers.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/io/#wandas.io.readers-classes","title":"Classes","text":""},{"location":"api/io/#wandas.io.readers.FileReader","title":"<code>FileReader</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for audio file readers.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>class FileReader(ABC):\n    \"\"\"Base class for audio file readers.\"\"\"\n\n    # Class attribute for supported file extensions\n    supported_extensions: list[str] = []\n\n    @classmethod\n    @abstractmethod\n    def get_file_info(cls, path: Union[str, Path], **kwargs: Any) -&gt; dict[str, Any]:\n        \"\"\"Get basic information about the audio file.\"\"\"\n        pass\n\n    @classmethod\n    @abstractmethod\n    def get_data(\n        cls,\n        path: Union[str, Path],\n        channels: list[int],\n        start_idx: int,\n        frames: int,\n        **kwargs: Any,\n    ) -&gt; ArrayLike:\n        \"\"\"Read audio data from the file.\"\"\"\n        pass\n\n    @classmethod\n    def can_read(cls, path: Union[str, Path]) -&gt; bool:\n        \"\"\"Check if this reader can handle the file based on extension.\"\"\"\n        ext = Path(path).suffix.lower()\n        return ext in cls.supported_extensions\n</code></pre>"},{"location":"api/io/#wandas.io.readers.FileReader-attributes","title":"Attributes","text":""},{"location":"api/io/#wandas.io.readers.FileReader.supported_extensions","title":"<code>supported_extensions = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/#wandas.io.readers.FileReader-functions","title":"Functions","text":""},{"location":"api/io/#wandas.io.readers.FileReader.get_file_info","title":"<code>get_file_info(path, **kwargs)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Get basic information about the audio file.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get_file_info(cls, path: Union[str, Path], **kwargs: Any) -&gt; dict[str, Any]:\n    \"\"\"Get basic information about the audio file.\"\"\"\n    pass\n</code></pre>"},{"location":"api/io/#wandas.io.readers.FileReader.get_data","title":"<code>get_data(path, channels, start_idx, frames, **kwargs)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Read audio data from the file.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get_data(\n    cls,\n    path: Union[str, Path],\n    channels: list[int],\n    start_idx: int,\n    frames: int,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Read audio data from the file.\"\"\"\n    pass\n</code></pre>"},{"location":"api/io/#wandas.io.readers.FileReader.can_read","title":"<code>can_read(path)</code>  <code>classmethod</code>","text":"<p>Check if this reader can handle the file based on extension.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>@classmethod\ndef can_read(cls, path: Union[str, Path]) -&gt; bool:\n    \"\"\"Check if this reader can handle the file based on extension.\"\"\"\n    ext = Path(path).suffix.lower()\n    return ext in cls.supported_extensions\n</code></pre>"},{"location":"api/io/#wandas.io.readers.SoundFileReader","title":"<code>SoundFileReader</code>","text":"<p>               Bases: <code>FileReader</code></p> <p>Audio file reader using SoundFile library.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>class SoundFileReader(FileReader):\n    \"\"\"Audio file reader using SoundFile library.\"\"\"\n\n    # SoundFile supported formats\n    supported_extensions = [\".wav\", \".flac\", \".ogg\", \".aiff\", \".aif\", \".snd\"]\n\n    @classmethod\n    def get_file_info(cls, path: Union[str, Path], **kwargs: Any) -&gt; dict[str, Any]:\n        \"\"\"Get basic information about the audio file.\"\"\"\n        info = sf.info(str(path))\n        return {\n            \"samplerate\": info.samplerate,\n            \"channels\": info.channels,\n            \"frames\": info.frames,\n            \"format\": info.format,\n            \"subtype\": info.subtype,\n            \"duration\": info.frames / info.samplerate,\n        }\n\n    @classmethod\n    def get_data(\n        cls,\n        path: Union[str, Path],\n        channels: list[int],\n        start_idx: int,\n        frames: int,\n        **kwargs: Any,\n    ) -&gt; ArrayLike:\n        \"\"\"Read audio data from the file.\"\"\"\n        logger.debug(f\"Reading {frames} frames from {path} starting at {start_idx}\")\n\n        with sf.SoundFile(str(path)) as f:\n            if start_idx &gt; 0:\n                f.seek(start_idx)\n            data = f.read(frames=frames, dtype=\"float32\", always_2d=True)\n\n            # Select requested channels\n            if len(channels) &lt; f.channels:\n                data = data[:, channels]\n\n            # Transpose to get (channels, samples) format\n            result: ArrayLike = data.T\n            if not isinstance(result, np.ndarray):\n                raise ValueError(\"Unexpected data type after reading file\")\n\n        _shape = result.shape\n        logger.debug(f\"File read complete, returning data with shape {_shape}\")\n        return result\n</code></pre>"},{"location":"api/io/#wandas.io.readers.SoundFileReader-attributes","title":"Attributes","text":""},{"location":"api/io/#wandas.io.readers.SoundFileReader.supported_extensions","title":"<code>supported_extensions = ['.wav', '.flac', '.ogg', '.aiff', '.aif', '.snd']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/#wandas.io.readers.SoundFileReader-functions","title":"Functions","text":""},{"location":"api/io/#wandas.io.readers.SoundFileReader.get_file_info","title":"<code>get_file_info(path, **kwargs)</code>  <code>classmethod</code>","text":"<p>Get basic information about the audio file.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>@classmethod\ndef get_file_info(cls, path: Union[str, Path], **kwargs: Any) -&gt; dict[str, Any]:\n    \"\"\"Get basic information about the audio file.\"\"\"\n    info = sf.info(str(path))\n    return {\n        \"samplerate\": info.samplerate,\n        \"channels\": info.channels,\n        \"frames\": info.frames,\n        \"format\": info.format,\n        \"subtype\": info.subtype,\n        \"duration\": info.frames / info.samplerate,\n    }\n</code></pre>"},{"location":"api/io/#wandas.io.readers.SoundFileReader.get_data","title":"<code>get_data(path, channels, start_idx, frames, **kwargs)</code>  <code>classmethod</code>","text":"<p>Read audio data from the file.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>@classmethod\ndef get_data(\n    cls,\n    path: Union[str, Path],\n    channels: list[int],\n    start_idx: int,\n    frames: int,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Read audio data from the file.\"\"\"\n    logger.debug(f\"Reading {frames} frames from {path} starting at {start_idx}\")\n\n    with sf.SoundFile(str(path)) as f:\n        if start_idx &gt; 0:\n            f.seek(start_idx)\n        data = f.read(frames=frames, dtype=\"float32\", always_2d=True)\n\n        # Select requested channels\n        if len(channels) &lt; f.channels:\n            data = data[:, channels]\n\n        # Transpose to get (channels, samples) format\n        result: ArrayLike = data.T\n        if not isinstance(result, np.ndarray):\n            raise ValueError(\"Unexpected data type after reading file\")\n\n    _shape = result.shape\n    logger.debug(f\"File read complete, returning data with shape {_shape}\")\n    return result\n</code></pre>"},{"location":"api/io/#wandas.io.readers.CSVFileReader","title":"<code>CSVFileReader</code>","text":"<p>               Bases: <code>FileReader</code></p> <p>CSV file reader for time series data.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>class CSVFileReader(FileReader):\n    \"\"\"CSV file reader for time series data.\"\"\"\n\n    # CSV supported formats\n    supported_extensions = [\".csv\"]\n\n    @classmethod\n    def get_file_info(cls, path: Union[str, Path], **kwargs: Any) -&gt; dict[str, Any]:\n        delimiter = kwargs.get(\"delimiter\", \",\")\n        header = kwargs.get(\"header\", 0)\n        \"\"\"Get basic information about the CSV file.\"\"\"\n        # Read first few lines to determine structure\n        df = pd.read_csv(path, delimiter=delimiter, header=header)\n\n        # Estimate sampling rate from first column (assuming it's time)\n        time_column = 0\n        try:\n            time_values = np.array(df.iloc[:, time_column].values)\n            if len(time_values) &gt; 1:\n                estimated_sr = int(1 / np.mean(np.diff(time_values)))\n            else:\n                estimated_sr = 0  # Cannot determine from single row\n        except Exception:\n            estimated_sr = 0  # Default if can't calculate\n\n        frames = df.shape[0]\n        duration = frames / estimated_sr if estimated_sr &gt; 0 else None\n\n        # Return file info\n        return {\n            \"samplerate\": estimated_sr,\n            \"channels\": df.shape[1] - 1,  # Assuming first column is time\n            \"frames\": frames,\n            \"format\": \"CSV\",\n            \"duration\": duration,\n            \"ch_labels\": df.columns[1:].tolist(),  # Assuming first column is time\n        }\n\n    @classmethod\n    def get_data(\n        cls,\n        path: Union[str, Path],\n        channels: list[int],\n        start_idx: int,\n        frames: int,\n        **kwargs: Any,\n    ) -&gt; ArrayLike:\n        \"\"\"Read data from the CSV file.\"\"\"\n        logger.debug(f\"Reading CSV data from {path} starting at {start_idx}\")\n\n        # Read the CSV file\n        time_column = kwargs.get(\"time_column\", 0)\n        delimiter = kwargs.get(\"delimiter\", \",\")\n        header = kwargs.get(\"header\", 0)\n        # Read first few lines to determine structure\n        df = pd.read_csv(path, delimiter=delimiter, header=header)\n\n        # Remove time column\n        df = df.drop(\n            columns=[time_column]\n            if isinstance(time_column, str)\n            else df.columns[time_column]\n        )\n\n        # Select requested channels - adjust indices to account for time column removal\n        if channels:\n            try:\n                data_df = df.iloc[:, channels]\n            except IndexError:\n                raise ValueError(f\"Requested channels {channels} out of range\")\n        else:\n            data_df = df\n\n        # Handle start_idx and frames for partial reading\n        end_idx = start_idx + frames if frames &gt; 0 else None\n        data_df = data_df.iloc[start_idx:end_idx]\n\n        # Convert to numpy array and transpose to (channels, samples) format\n        result = data_df.values.T\n\n        if not isinstance(result, np.ndarray):\n            raise ValueError(\"Unexpected data type after reading file\")\n\n        _shape = result.shape\n        logger.debug(f\"CSV read complete, returning data with shape {_shape}\")\n        return result\n</code></pre>"},{"location":"api/io/#wandas.io.readers.CSVFileReader-attributes","title":"Attributes","text":""},{"location":"api/io/#wandas.io.readers.CSVFileReader.supported_extensions","title":"<code>supported_extensions = ['.csv']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/io/#wandas.io.readers.CSVFileReader-functions","title":"Functions","text":""},{"location":"api/io/#wandas.io.readers.CSVFileReader.get_file_info","title":"<code>get_file_info(path, **kwargs)</code>  <code>classmethod</code>","text":"Source code in <code>wandas/io/readers.py</code> <pre><code>@classmethod\ndef get_file_info(cls, path: Union[str, Path], **kwargs: Any) -&gt; dict[str, Any]:\n    delimiter = kwargs.get(\"delimiter\", \",\")\n    header = kwargs.get(\"header\", 0)\n    \"\"\"Get basic information about the CSV file.\"\"\"\n    # Read first few lines to determine structure\n    df = pd.read_csv(path, delimiter=delimiter, header=header)\n\n    # Estimate sampling rate from first column (assuming it's time)\n    time_column = 0\n    try:\n        time_values = np.array(df.iloc[:, time_column].values)\n        if len(time_values) &gt; 1:\n            estimated_sr = int(1 / np.mean(np.diff(time_values)))\n        else:\n            estimated_sr = 0  # Cannot determine from single row\n    except Exception:\n        estimated_sr = 0  # Default if can't calculate\n\n    frames = df.shape[0]\n    duration = frames / estimated_sr if estimated_sr &gt; 0 else None\n\n    # Return file info\n    return {\n        \"samplerate\": estimated_sr,\n        \"channels\": df.shape[1] - 1,  # Assuming first column is time\n        \"frames\": frames,\n        \"format\": \"CSV\",\n        \"duration\": duration,\n        \"ch_labels\": df.columns[1:].tolist(),  # Assuming first column is time\n    }\n</code></pre>"},{"location":"api/io/#wandas.io.readers.CSVFileReader.get_data","title":"<code>get_data(path, channels, start_idx, frames, **kwargs)</code>  <code>classmethod</code>","text":"<p>Read data from the CSV file.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>@classmethod\ndef get_data(\n    cls,\n    path: Union[str, Path],\n    channels: list[int],\n    start_idx: int,\n    frames: int,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Read data from the CSV file.\"\"\"\n    logger.debug(f\"Reading CSV data from {path} starting at {start_idx}\")\n\n    # Read the CSV file\n    time_column = kwargs.get(\"time_column\", 0)\n    delimiter = kwargs.get(\"delimiter\", \",\")\n    header = kwargs.get(\"header\", 0)\n    # Read first few lines to determine structure\n    df = pd.read_csv(path, delimiter=delimiter, header=header)\n\n    # Remove time column\n    df = df.drop(\n        columns=[time_column]\n        if isinstance(time_column, str)\n        else df.columns[time_column]\n    )\n\n    # Select requested channels - adjust indices to account for time column removal\n    if channels:\n        try:\n            data_df = df.iloc[:, channels]\n        except IndexError:\n            raise ValueError(f\"Requested channels {channels} out of range\")\n    else:\n        data_df = df\n\n    # Handle start_idx and frames for partial reading\n    end_idx = start_idx + frames if frames &gt; 0 else None\n    data_df = data_df.iloc[start_idx:end_idx]\n\n    # Convert to numpy array and transpose to (channels, samples) format\n    result = data_df.values.T\n\n    if not isinstance(result, np.ndarray):\n        raise ValueError(\"Unexpected data type after reading file\")\n\n    _shape = result.shape\n    logger.debug(f\"CSV read complete, returning data with shape {_shape}\")\n    return result\n</code></pre>"},{"location":"api/io/#wandas.io.readers-functions","title":"Functions","text":""},{"location":"api/io/#wandas.io.readers.get_file_reader","title":"<code>get_file_reader(path)</code>","text":"<p>Get an appropriate file reader for the given path.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>def get_file_reader(path: Union[str, Path]) -&gt; FileReader:\n    \"\"\"Get an appropriate file reader for the given path.\"\"\"\n    path_str = str(path)\n    ext = Path(path).suffix.lower()\n\n    # Try each reader in order\n    for reader in _file_readers:\n        if ext in reader.__class__.supported_extensions:\n            logger.debug(f\"Using {reader.__class__.__name__} for {path_str}\")\n            return reader\n\n    # If no reader found, raise error\n    raise ValueError(f\"No suitable file reader found for {path_str}\")\n</code></pre>"},{"location":"api/io/#wandas.io.readers.register_file_reader","title":"<code>register_file_reader(reader_class)</code>","text":"<p>Register a new file reader.</p> Source code in <code>wandas/io/readers.py</code> <pre><code>def register_file_reader(reader_class: type) -&gt; None:\n    \"\"\"Register a new file reader.\"\"\"\n    reader = reader_class()\n    _file_readers.append(reader)\n    logger.debug(f\"Registered new file reader: {reader_class.__name__}\")\n</code></pre>"},{"location":"api/io/#wav","title":"WAV\u30d5\u30a1\u30a4\u30eb\u5165\u51fa\u529b","text":"<p>WAV\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u66f8\u304d\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/io/#wandas.io.wav_io","title":"<code>wandas.io.wav_io</code>","text":""},{"location":"api/io/#wandas.io.wav_io-attributes","title":"Attributes","text":""},{"location":"api/io/#wandas.io.wav_io.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/io/#wandas.io.wav_io-classes","title":"Classes","text":""},{"location":"api/io/#wandas.io.wav_io-functions","title":"Functions","text":""},{"location":"api/io/#wandas.io.wav_io.read_wav","title":"<code>read_wav(filename, labels=None)</code>","text":"<p>Read a WAV file and create a ChannelFrame object.</p>"},{"location":"api/io/#wandas.io.wav_io.read_wav--parameters","title":"Parameters","text":"<p>filename : str     Path to the WAV file or URL to the WAV file. labels : list of str, optional     Labels for each channel.</p>"},{"location":"api/io/#wandas.io.wav_io.read_wav--returns","title":"Returns","text":"<p>ChannelFrame     ChannelFrame object containing the audio data.</p> Source code in <code>wandas/io/wav_io.py</code> <pre><code>def read_wav(filename: str, labels: Optional[list[str]] = None) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Read a WAV file and create a ChannelFrame object.\n\n    Parameters\n    ----------\n    filename : str\n        Path to the WAV file or URL to the WAV file.\n    labels : list of str, optional\n        Labels for each channel.\n\n    Returns\n    -------\n    ChannelFrame\n        ChannelFrame object containing the audio data.\n    \"\"\"\n    from wandas.frames.channel import ChannelFrame\n\n    # \u30d5\u30a1\u30a4\u30eb\u540d\u304cURL\u304b\u3069\u3046\u304b\u3092\u5224\u65ad\n    if filename.startswith(\"http://\") or filename.startswith(\"https://\"):\n        # URL\u306e\u5834\u5408\u3001requests\u3092\u4f7f\u7528\u3057\u3066\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\n\n        response = requests.get(filename)\n        file_obj = io.BytesIO(response.content)\n        file_label = os.path.basename(filename)\n        # \u30e1\u30e2\u30ea\u30de\u30c3\u30d4\u30f3\u30b0\u306f\u4f7f\u7528\u305b\u305a\u306b\u8aad\u307f\u8fbc\u3080\n        sampling_rate, data = wavfile.read(file_obj)\n    else:\n        # \u30ed\u30fc\u30ab\u30eb\u30d5\u30a1\u30a4\u30eb\u30d1\u30b9\u306e\u5834\u5408\n        file_label = os.path.basename(filename)\n        # \u30c7\u30fc\u30bf\u306e\u8aad\u307f\u8fbc\u307f\uff08\u30e1\u30e2\u30ea\u30de\u30c3\u30d4\u30f3\u30b0\u3092\u4f7f\u7528\uff09\n        sampling_rate, data = wavfile.read(filename, mmap=True)\n\n    # \u30c7\u30fc\u30bf\u3092(num_channels, num_samples)\u5f62\u72b6\u306eNumPy\u914d\u5217\u306b\u5909\u63db\n    if data.ndim == 1:\n        # \u30e2\u30ce\u30e9\u30eb\uff1a(samples,) -&gt; (1, samples)\n        data = np.expand_dims(data, axis=0)\n    else:\n        # \u30b9\u30c6\u30ec\u30aa\uff1a(samples, channels) -&gt; (channels, samples)\n        data = data.T\n\n    # NumPy\u914d\u5217\u304b\u3089ChannelFrame\u3092\u4f5c\u6210\n    channel_frame = ChannelFrame.from_numpy(\n        data=data,\n        sampling_rate=sampling_rate,\n        label=file_label,\n        ch_labels=labels,\n    )\n\n    return channel_frame\n</code></pre>"},{"location":"api/io/#wandas.io.wav_io.write_wav","title":"<code>write_wav(filename, target, format=None)</code>","text":"<p>Write a ChannelFrame object to a WAV file.</p>"},{"location":"api/io/#wandas.io.wav_io.write_wav--parameters","title":"Parameters","text":"<p>filename : str     Path to the WAV file. target : ChannelFrame     ChannelFrame object containing the data to write. format : str, optional     File format. If None, determined from file extension.</p>"},{"location":"api/io/#wandas.io.wav_io.write_wav--raises","title":"Raises","text":"<p>ValueError     If target is not a ChannelFrame object.</p> Source code in <code>wandas/io/wav_io.py</code> <pre><code>def write_wav(\n    filename: str, target: \"ChannelFrame\", format: Optional[str] = None\n) -&gt; None:\n    \"\"\"\n    Write a ChannelFrame object to a WAV file.\n\n    Parameters\n    ----------\n    filename : str\n        Path to the WAV file.\n    target : ChannelFrame\n        ChannelFrame object containing the data to write.\n    format : str, optional\n        File format. If None, determined from file extension.\n\n    Raises\n    ------\n    ValueError\n        If target is not a ChannelFrame object.\n    \"\"\"\n    from wandas.frames.channel import ChannelFrame\n\n    if not isinstance(target, ChannelFrame):\n        raise ValueError(\"target must be a ChannelFrame object.\")\n\n    logger.debug(f\"Saving audio data to file: {filename} (will compute now)\")\n    data = target.compute()\n    data = data.T\n    if data.shape[1] == 1:\n        data = data.squeeze(axis=1)\n    if data.dtype == float and max([np.abs(data.max()), np.abs(data.min())]) &lt; 1:\n        sf.write(\n            str(filename),\n            data,\n            int(target.sampling_rate),\n            subtype=\"FLOAT\",\n            format=format,\n        )\n    else:\n        sf.write(str(filename), data, int(target.sampling_rate), format=format)\n    logger.debug(f\"Save complete: {filename}\")\n</code></pre>"},{"location":"api/io/#wdf","title":"WDF\u30d5\u30a1\u30a4\u30eb\u5165\u51fa\u529b","text":"<p>WDF\uff08Wandas Data File\uff09\u5f62\u5f0f\u306e\u8aad\u307f\u66f8\u304d\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002\u3053\u306e\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u306f\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u542b\u3080\u5b8c\u5168\u306a\u4fdd\u5b58\u304c\u53ef\u80fd\u3067\u3059\u3002</p>"},{"location":"api/io/#wandas.io.wdf_io","title":"<code>wandas.io.wdf_io</code>","text":"<p>WDF (Wandas Data File) I/O module for saving and loading ChannelFrame objects.</p> <p>This module provides functionality to save and load ChannelFrame objects in the WDF (Wandas Data File) format, which is based on HDF5. The format preserves all metadata including sampling rate, channel labels, units, and frame metadata.</p>"},{"location":"api/io/#wandas.io.wdf_io-attributes","title":"Attributes","text":""},{"location":"api/io/#wandas.io.wdf_io.da_from_array","title":"<code>da_from_array = da.from_array</code>  <code>module-attribute</code>","text":""},{"location":"api/io/#wandas.io.wdf_io.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/io/#wandas.io.wdf_io.WDF_FORMAT_VERSION","title":"<code>WDF_FORMAT_VERSION = '0.1'</code>  <code>module-attribute</code>","text":""},{"location":"api/io/#wandas.io.wdf_io-classes","title":"Classes","text":""},{"location":"api/io/#wandas.io.wdf_io-functions","title":"Functions","text":""},{"location":"api/io/#wandas.io.wdf_io.save","title":"<code>save(frame, path, *, format='hdf5', compress='gzip', overwrite=False, dtype=None)</code>","text":"<p>Save a frame to a file.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>BaseFrame[Any]</code> <p>The frame to save.</p> required <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file. '.wdf' extension will be added if not present.</p> required <code>format</code> <code>str</code> <p>Format to use (currently only 'hdf5' is supported)</p> <code>'hdf5'</code> <code>compress</code> <code>Optional[str]</code> <p>Compression method ('gzip' by default, None for no compression)</p> <code>'gzip'</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing file</p> <code>False</code> <code>dtype</code> <code>Optional[Union[str, dtype[Any]]]</code> <p>Optional data type conversion before saving (e.g. 'float32')</p> <code>None</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If the file exists and overwrite=False.</p> <code>NotImplementedError</code> <p>For unsupported formats.</p> Source code in <code>wandas/io/wdf_io.py</code> <pre><code>def save(\n    frame: BaseFrame[Any],\n    path: Union[str, Path],\n    *,\n    format: str = \"hdf5\",\n    compress: Optional[str] = \"gzip\",\n    overwrite: bool = False,\n    dtype: Optional[Union[str, np.dtype[Any]]] = None,\n) -&gt; None:\n    \"\"\"Save a frame to a file.\n\n    Args:\n        frame: The frame to save.\n        path: Path to save the file. '.wdf' extension will be added if not present.\n        format: Format to use (currently only 'hdf5' is supported)\n        compress: Compression method ('gzip' by default, None for no compression)\n        overwrite: Whether to overwrite existing file\n        dtype: Optional data type conversion before saving (e.g. 'float32')\n\n    Raises:\n        FileExistsError: If the file exists and overwrite=False.\n        NotImplementedError: For unsupported formats.\n    \"\"\"\n    # Handle path\n    path = Path(path)\n    if path.suffix != \".wdf\":\n        path = path.with_suffix(\".wdf\")\n\n    # Check if file exists\n    if path.exists() and not overwrite:\n        raise FileExistsError(\n            f\"File {path} already exists. Set overwrite=True to overwrite.\"\n        )\n\n    # Currently only HDF5 is supported\n    if format.lower() != \"hdf5\":\n        raise NotImplementedError(\n            f\"Format {format} not supported. Only 'hdf5' is currently implemented.\"\n        )\n\n    # Compute data arrays (this triggers actual computation)\n    logger.info(\"Computing data arrays for saving...\")\n    computed_data = frame.compute()\n    if dtype is not None:\n        computed_data = computed_data.astype(dtype)\n\n    # Create file\n    logger.info(f\"Creating HDF5 file at {path}...\")\n    with h5py.File(path, \"w\") as f:\n        # Set file version\n        f.attrs[\"version\"] = WDF_FORMAT_VERSION\n\n        # Store frame metadata\n        f.attrs[\"sampling_rate\"] = frame.sampling_rate\n        f.attrs[\"label\"] = frame.label or \"\"\n        f.attrs[\"frame_type\"] = type(frame).__name__\n\n        # Create channels group\n        channels_grp = f.create_group(\"channels\")\n\n        # Store each channel\n        for i, (channel_data, ch_meta) in enumerate(\n            zip(computed_data, frame._channel_metadata)\n        ):\n            ch_grp = channels_grp.create_group(f\"{i}\")\n\n            # Store channel data\n            if compress:\n                ch_grp.create_dataset(\"data\", data=channel_data, compression=compress)\n            else:\n                ch_grp.create_dataset(\"data\", data=channel_data)\n\n            # Store metadata\n            ch_grp.attrs[\"label\"] = ch_meta.label\n            ch_grp.attrs[\"unit\"] = ch_meta.unit\n\n            # Store extra metadata as JSON\n            if ch_meta.extra:\n                ch_grp.attrs[\"metadata_json\"] = json.dumps(ch_meta.extra)\n\n        # Store operation history\n        if frame.operation_history:\n            op_grp = f.create_group(\"operation_history\")\n            for i, op in enumerate(frame.operation_history):\n                op_sub_grp = op_grp.create_group(f\"operation_{i}\")\n                for k, v in op.items():\n                    # Store simple attributes directly\n                    if isinstance(v, (str, int, float, bool, np.number)):\n                        op_sub_grp.attrs[k] = v\n                    else:\n                        # For complex types, serialize to JSON\n                        try:\n                            op_sub_grp.attrs[k] = json.dumps(v)\n                        except (TypeError, OverflowError) as e:\n                            logger.warning(\n                                f\"Could not serialize operation key '{k}': {e}\"\n                            )\n                            op_sub_grp.attrs[k] = str(v)\n\n        # Store frame metadata\n        if frame.metadata:\n            meta_grp = f.create_group(\"meta\")\n            # Store metadata as JSON\n            meta_grp.attrs[\"json\"] = json.dumps(frame.metadata)\n\n            # Also store individual metadata items as attributes for compatibility\n            for k, v in frame.metadata.items():\n                if isinstance(v, (str, int, float, bool, np.number)):\n                    meta_grp.attrs[k] = v\n\n    logger.info(f\"Frame saved to {path}\")\n</code></pre>"},{"location":"api/io/#wandas.io.wdf_io.load","title":"<code>load(path, *, format='hdf5')</code>","text":"<p>Load a ChannelFrame object from a WDF (Wandas Data File) file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the WDF file to load.</p> required <code>format</code> <code>str</code> <p>Format of the file. Currently only \"hdf5\" is supported.</p> <code>'hdf5'</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame object with data and metadata loaded from the file.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> <code>NotImplementedError</code> <p>If format is not \"hdf5\".</p> <code>ValueError</code> <p>If the file format is invalid or incompatible.</p> Example <p>cf = ChannelFrame.load(\"audio_data.wdf\")</p> Source code in <code>wandas/io/wdf_io.py</code> <pre><code>def load(path: Union[str, Path], *, format: str = \"hdf5\") -&gt; \"ChannelFrame\":\n    \"\"\"Load a ChannelFrame object from a WDF (Wandas Data File) file.\n\n    Args:\n        path: Path to the WDF file to load.\n        format: Format of the file. Currently only \"hdf5\" is supported.\n\n    Returns:\n        A new ChannelFrame object with data and metadata loaded from the file.\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist.\n        NotImplementedError: If format is not \"hdf5\".\n        ValueError: If the file format is invalid or incompatible.\n\n    Example:\n        &gt;&gt;&gt; cf = ChannelFrame.load(\"audio_data.wdf\")\n    \"\"\"\n    # Ensure ChannelFrame is imported here to avoid circular imports\n    from ..core.metadata import ChannelMetadata\n    from ..frames.channel import ChannelFrame\n\n    if format != \"hdf5\":\n        raise NotImplementedError(f\"Format '{format}' is not supported\")\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    logger.debug(f\"Loading ChannelFrame from {path}\")\n\n    with h5py.File(path, \"r\") as f:\n        # Check format version for compatibility\n        version = f.attrs.get(\"version\", \"unknown\")\n        if version != WDF_FORMAT_VERSION:\n            logger.warning(\n                f\"File format version mismatch: file={version}, current={WDF_FORMAT_VERSION}\"  # noqa: E501\n            )\n\n        # Get global attributes\n        sampling_rate = float(f.attrs[\"sampling_rate\"])\n        frame_label = f.attrs.get(\"label\", \"\")\n\n        # Get frame metadata\n        frame_metadata = {}\n        if \"meta\" in f:\n            meta_json = f[\"meta\"].attrs.get(\"json\", \"{}\")\n            frame_metadata = json.loads(meta_json)\n\n        # Load channel data and metadata\n        all_channel_data = []\n        channel_metadata_list = []\n\n        if \"channels\" in f:\n            channels_group = f[\"channels\"]\n            # Sort channel indices numerically\n            channel_indices = sorted([int(key) for key in channels_group.keys()])\n\n            for idx in channel_indices:\n                ch_group = channels_group[f\"{idx}\"]\n\n                # Load channel data\n                channel_data = ch_group[\"data\"][()]\n\n                # Append to combined array\n                all_channel_data.append(channel_data)\n\n                # Load channel metadata\n                label = ch_group.attrs.get(\"label\", f\"Ch{idx}\")\n                unit = ch_group.attrs.get(\"unit\", \"\")\n\n                # Load additional metadata if present\n                ch_extra = {}\n                if \"metadata_json\" in ch_group.attrs:\n                    ch_extra = json.loads(ch_group.attrs[\"metadata_json\"])\n\n                # Create ChannelMetadata object\n                channel_metadata = ChannelMetadata(\n                    label=label, unit=unit, extra=ch_extra\n                )\n                channel_metadata_list.append(channel_metadata)\n\n        # Stack channel data into a single array\n        if all_channel_data:\n            combined_data = np.stack(all_channel_data, axis=0)\n        else:\n            raise ValueError(\"No channel data found in the file\")\n\n        # Create a new ChannelFrame\n        dask_data = da_from_array(combined_data)\n\n        cf = ChannelFrame(\n            data=dask_data,\n            sampling_rate=sampling_rate,\n            label=frame_label if frame_label else None,\n            metadata=frame_metadata,\n            channel_metadata=channel_metadata_list,\n        )\n\n        logger.debug(\n            f\"ChannelFrame loaded from {path}: {len(cf)} channels, {cf.n_samples} samples\"  # noqa: E501\n        )\n        return cf\n</code></pre>"},{"location":"api/processing/","title":"\u51e6\u7406\u30e2\u30b8\u30e5\u30fc\u30eb","text":"<p><code>wandas.processing</code> \u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u3001\u30aa\u30fc\u30c7\u30a3\u30aa\u30c7\u30fc\u30bf\u306b\u5bfe\u3059\u308b\u69d8\u3005\u306a\u51e6\u7406\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/processing/#_2","title":"\u57fa\u672c\u51e6\u7406","text":"<p>\u57fa\u672c\u7684\u306a\u51e6\u7406\u64cd\u4f5c\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/processing/#wandas.processing.base","title":"<code>wandas.processing.base</code>","text":""},{"location":"api/processing/#wandas.processing.base-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.base.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.base.InputArrayType","title":"<code>InputArrayType = TypeVar('InputArrayType', NDArrayReal, NDArrayComplex)</code>  <code>module-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.base.OutputArrayType","title":"<code>OutputArrayType = TypeVar('OutputArrayType', NDArrayReal, NDArrayComplex)</code>  <code>module-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.base-classes","title":"Classes","text":""},{"location":"api/processing/#wandas.processing.base.AudioOperation","title":"<code>AudioOperation</code>","text":"<p>               Bases: <code>Generic[InputArrayType, OutputArrayType]</code></p> <p>Abstract base class for audio processing operations.</p> Source code in <code>wandas/processing/base.py</code> <pre><code>class AudioOperation(Generic[InputArrayType, OutputArrayType]):\n    \"\"\"Abstract base class for audio processing operations.\"\"\"\n\n    # Class variable: operation name\n    name: ClassVar[str]\n\n    def __init__(self, sampling_rate: float, **params: Any):\n        \"\"\"\n        Initialize AudioOperation.\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        **params : Any\n            Operation-specific parameters\n        \"\"\"\n        self.sampling_rate = sampling_rate\n        self.params = params\n\n        # Validate parameters during initialization\n        self.validate_params()\n\n        # Create processor function (lazy initialization possible)\n        self._setup_processor()\n\n        logger.debug(\n            f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n        )\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n        pass\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up processor function (implemented by subclasses)\"\"\"\n        pass\n\n    def _process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function (implemented by subclasses)\"\"\"\n        # Default is no-op function\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    @dask.delayed  # type: ignore [misc, unused-ignore]\n    def process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n        \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n        # Default is no-op function\n        logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n        return self._process_array(x)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation (implemented by subclasses)\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        \"\"\"\n        Execute operation and return result\n        data shape is (channels, samples)\n        \"\"\"\n        # Add task as delayed processing\n        logger.debug(\"Adding delayed operation to computation graph\")\n        delayed_result = self.process_array(data)\n        # Convert delayed result to dask array and return\n        output_shape = self.calculate_output_shape(data.shape)\n        return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"api/processing/#wandas.processing.base.AudioOperation-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.base.AudioOperation.name","title":"<code>name</code>  <code>class-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.base.AudioOperation.sampling_rate","title":"<code>sampling_rate = sampling_rate</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.base.AudioOperation.params","title":"<code>params = params</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.base.AudioOperation-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.base.AudioOperation.__init__","title":"<code>__init__(sampling_rate, **params)</code>","text":"<p>Initialize AudioOperation.</p>"},{"location":"api/processing/#wandas.processing.base.AudioOperation.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) **params : Any     Operation-specific parameters</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def __init__(self, sampling_rate: float, **params: Any):\n    \"\"\"\n    Initialize AudioOperation.\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    **params : Any\n        Operation-specific parameters\n    \"\"\"\n    self.sampling_rate = sampling_rate\n    self.params = params\n\n    # Validate parameters during initialization\n    self.validate_params()\n\n    # Create processor function (lazy initialization possible)\n    self._setup_processor()\n\n    logger.debug(\n        f\"Initialized {self.__class__.__name__} operation with params: {params}\"\n    )\n</code></pre>"},{"location":"api/processing/#wandas.processing.base.AudioOperation.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters (raises exception if invalid)</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters (raises exception if invalid)\"\"\"\n    pass\n</code></pre>"},{"location":"api/processing/#wandas.processing.base.AudioOperation.process_array","title":"<code>process_array(x)</code>","text":"<p>Processing function wrapped with @dask.delayed</p> Source code in <code>wandas/processing/base.py</code> <pre><code>@dask.delayed  # type: ignore [misc, unused-ignore]\ndef process_array(self, x: InputArrayType) -&gt; OutputArrayType:\n    \"\"\"Processing function wrapped with @dask.delayed\"\"\"\n    # Default is no-op function\n    logger.debug(f\"Default process operation on data with shape: {x.shape}\")\n    return self._process_array(x)\n</code></pre>"},{"location":"api/processing/#wandas.processing.base.AudioOperation.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation (implemented by subclasses)</p>"},{"location":"api/processing/#wandas.processing.base.AudioOperation.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/processing/#wandas.processing.base.AudioOperation.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation (implemented by subclasses)\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"api/processing/#wandas.processing.base.AudioOperation.process","title":"<code>process(data)</code>","text":"<p>Execute operation and return result data shape is (channels, samples)</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    \"\"\"\n    Execute operation and return result\n    data shape is (channels, samples)\n    \"\"\"\n    # Add task as delayed processing\n    logger.debug(\"Adding delayed operation to computation graph\")\n    delayed_result = self.process_array(data)\n    # Convert delayed result to dask array and return\n    output_shape = self.calculate_output_shape(data.shape)\n    return _da_from_delayed(delayed_result, shape=output_shape, dtype=data.dtype)\n</code></pre>"},{"location":"api/processing/#wandas.processing.base-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.base.register_operation","title":"<code>register_operation(operation_class)</code>","text":"<p>Register a new operation type</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def register_operation(operation_class: type) -&gt; None:\n    \"\"\"Register a new operation type\"\"\"\n\n    if not issubclass(operation_class, AudioOperation):\n        raise TypeError(\"Strategy class must inherit from AudioOperation.\")\n    if inspect.isabstract(operation_class):\n        raise TypeError(\"Cannot register abstract AudioOperation class.\")\n\n    _OPERATION_REGISTRY[operation_class.name] = operation_class\n</code></pre>"},{"location":"api/processing/#wandas.processing.base.get_operation","title":"<code>get_operation(name)</code>","text":"<p>Get operation class by name</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def get_operation(name: str) -&gt; type[AudioOperation[Any, Any]]:\n    \"\"\"Get operation class by name\"\"\"\n    if name not in _OPERATION_REGISTRY:\n        raise ValueError(f\"Unknown operation type: {name}\")\n    return _OPERATION_REGISTRY[name]\n</code></pre>"},{"location":"api/processing/#wandas.processing.base.create_operation","title":"<code>create_operation(name, sampling_rate, **params)</code>","text":"<p>Create operation instance from name and parameters</p> Source code in <code>wandas/processing/base.py</code> <pre><code>def create_operation(\n    name: str, sampling_rate: float, **params: Any\n) -&gt; AudioOperation[Any, Any]:\n    \"\"\"Create operation instance from name and parameters\"\"\"\n    operation_class = get_operation(name)\n    return operation_class(sampling_rate, **params)\n</code></pre>"},{"location":"api/processing/#_3","title":"\u30a8\u30d5\u30a7\u30af\u30c8","text":"<p>\u30aa\u30fc\u30c7\u30a3\u30aa\u30a8\u30d5\u30a7\u30af\u30c8\u51e6\u7406\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/processing/#wandas.processing.effects","title":"<code>wandas.processing.effects</code>","text":""},{"location":"api/processing/#wandas.processing.effects-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.effects.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.effects-classes","title":"Classes","text":""},{"location":"api/processing/#wandas.processing.effects.HpssHarmonic","title":"<code>HpssHarmonic</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>HPSS Harmonic operation</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>class HpssHarmonic(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"HPSS Harmonic operation\"\"\"\n\n    name = \"hpss_harmonic\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize HPSS Harmonic\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        self.kwargs = kwargs\n        super().__init__(sampling_rate, **kwargs)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for HPSS Harmonic\"\"\"\n        logger.debug(f\"Applying HPSS Harmonic to array with shape: {x.shape}\")\n        result: NDArrayReal = effects.harmonic(x, **self.kwargs)\n        logger.debug(\n            f\"HPSS Harmonic applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.effects.HpssHarmonic-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.effects.HpssHarmonic.name","title":"<code>name = 'hpss_harmonic'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.effects.HpssHarmonic.kwargs","title":"<code>kwargs = kwargs</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.effects.HpssHarmonic-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.effects.HpssHarmonic.__init__","title":"<code>__init__(sampling_rate, **kwargs)</code>","text":"<p>Initialize HPSS Harmonic</p>"},{"location":"api/processing/#wandas.processing.effects.HpssHarmonic.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize HPSS Harmonic\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    self.kwargs = kwargs\n    super().__init__(sampling_rate, **kwargs)\n</code></pre>"},{"location":"api/processing/#wandas.processing.effects.HpssHarmonic.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"Source code in <code>wandas/processing/effects.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    return input_shape\n</code></pre>"},{"location":"api/processing/#wandas.processing.effects.HpssPercussive","title":"<code>HpssPercussive</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>HPSS Percussive operation</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>class HpssPercussive(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"HPSS Percussive operation\"\"\"\n\n    name = \"hpss_percussive\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize HPSS Percussive\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        self.kwargs = kwargs\n        super().__init__(sampling_rate, **kwargs)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for HPSS Percussive\"\"\"\n        logger.debug(f\"Applying HPSS Percussive to array with shape: {x.shape}\")\n        result: NDArrayReal = effects.percussive(x, **self.kwargs)\n        logger.debug(\n            f\"HPSS Percussive applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.effects.HpssPercussive-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.effects.HpssPercussive.name","title":"<code>name = 'hpss_percussive'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.effects.HpssPercussive.kwargs","title":"<code>kwargs = kwargs</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.effects.HpssPercussive-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.effects.HpssPercussive.__init__","title":"<code>__init__(sampling_rate, **kwargs)</code>","text":"<p>Initialize HPSS Percussive</p>"},{"location":"api/processing/#wandas.processing.effects.HpssPercussive.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize HPSS Percussive\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    self.kwargs = kwargs\n    super().__init__(sampling_rate, **kwargs)\n</code></pre>"},{"location":"api/processing/#wandas.processing.effects.HpssPercussive.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"Source code in <code>wandas/processing/effects.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    return input_shape\n</code></pre>"},{"location":"api/processing/#wandas.processing.effects.AddWithSNR","title":"<code>AddWithSNR</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Addition operation considering SNR</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>class AddWithSNR(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Addition operation considering SNR\"\"\"\n\n    name = \"add_with_snr\"\n\n    def __init__(self, sampling_rate: float, other: DaArray, snr: float = 1.0):\n        \"\"\"\n        Initialize addition operation considering SNR\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        other : DaArray\n            Noise signal to add (channel-frame format)\n        snr : float\n            Signal-to-noise ratio (dB)\n        \"\"\"\n        super().__init__(sampling_rate, other=other, snr=snr)\n\n        self.other = other\n        self.snr = snr\n        logger.debug(f\"Initialized AddWithSNR operation with SNR: {snr} dB\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape (same as input)\n        \"\"\"\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Perform addition processing considering SNR\"\"\"\n        logger.debug(f\"Applying SNR-based addition with shape: {x.shape}\")\n        other: NDArrayReal = self.other.compute()\n\n        # Use multi-channel versions of calculate_rms and calculate_desired_noise_rms\n        clean_rms = util.calculate_rms(x)\n        other_rms = util.calculate_rms(other)\n\n        # Adjust noise gain based on specified SNR (apply per channel)\n        desired_noise_rms = util.calculate_desired_noise_rms(clean_rms, self.snr)\n\n        # Apply gain per channel using broadcasting\n        gain = desired_noise_rms / other_rms\n        # Add adjusted noise to signal\n        result: NDArrayReal = x + other * gain\n        return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.effects.AddWithSNR-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.effects.AddWithSNR.name","title":"<code>name = 'add_with_snr'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.effects.AddWithSNR.other","title":"<code>other = other</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.effects.AddWithSNR.snr","title":"<code>snr = snr</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.effects.AddWithSNR-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.effects.AddWithSNR.__init__","title":"<code>__init__(sampling_rate, other, snr=1.0)</code>","text":"<p>Initialize addition operation considering SNR</p>"},{"location":"api/processing/#wandas.processing.effects.AddWithSNR.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) other : DaArray     Noise signal to add (channel-frame format) snr : float     Signal-to-noise ratio (dB)</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>def __init__(self, sampling_rate: float, other: DaArray, snr: float = 1.0):\n    \"\"\"\n    Initialize addition operation considering SNR\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    other : DaArray\n        Noise signal to add (channel-frame format)\n    snr : float\n        Signal-to-noise ratio (dB)\n    \"\"\"\n    super().__init__(sampling_rate, other=other, snr=snr)\n\n    self.other = other\n    self.snr = snr\n    logger.debug(f\"Initialized AddWithSNR operation with SNR: {snr} dB\")\n</code></pre>"},{"location":"api/processing/#wandas.processing.effects.AddWithSNR.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/processing/#wandas.processing.effects.AddWithSNR.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/processing/#wandas.processing.effects.AddWithSNR.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (same as input)</p> Source code in <code>wandas/processing/effects.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape (same as input)\n    \"\"\"\n    return input_shape\n</code></pre>"},{"location":"api/processing/#wandas.processing.effects-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.effects-modules","title":"Modules","text":""},{"location":"api/processing/#_4","title":"\u30d5\u30a3\u30eb\u30bf\u30fc","text":"<p>\u69d8\u3005\u306a\u30aa\u30fc\u30c7\u30a3\u30aa\u30d5\u30a3\u30eb\u30bf\u30fc\u51e6\u7406\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/processing/#wandas.processing.filters","title":"<code>wandas.processing.filters</code>","text":""},{"location":"api/processing/#wandas.processing.filters-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.filters.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.filters-classes","title":"Classes","text":""},{"location":"api/processing/#wandas.processing.filters.HighPassFilter","title":"<code>HighPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>High-pass filter operation</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>class HighPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"High-pass filter operation\"\"\"\n\n    name = \"highpass_filter\"\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize high-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            limit = self.sampling_rate / 2\n            raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up high-pass filter processor\"\"\"\n        # Calculate filter coefficients (once) - safely retrieve from instance variables\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # Precompute and save filter coefficients\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"high\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Highpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying highpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.filters.HighPassFilter-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.filters.HighPassFilter.name","title":"<code>name = 'highpass_filter'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.filters.HighPassFilter.cutoff","title":"<code>cutoff = cutoff</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.filters.HighPassFilter.order","title":"<code>order = order</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.filters.HighPassFilter-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.filters.HighPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize high-pass filter</p>"},{"location":"api/processing/#wandas.processing.filters.HighPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize high-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"api/processing/#wandas.processing.filters.HighPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        limit = self.sampling_rate / 2\n        raise ValueError(f\"Cutoff frequency must be between 0 Hz and {limit} Hz\")\n</code></pre>"},{"location":"api/processing/#wandas.processing.filters.HighPassFilter.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"Source code in <code>wandas/processing/filters.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    return input_shape\n</code></pre>"},{"location":"api/processing/#wandas.processing.filters.LowPassFilter","title":"<code>LowPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Low-pass filter operation</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>class LowPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Low-pass filter operation\"\"\"\n\n    name = \"lowpass_filter\"\n    a: NDArrayReal\n    b: NDArrayReal\n\n    def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n        \"\"\"\n        Initialize low-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        cutoff : float\n            Cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.cutoff = cutoff\n        self.order = order\n        super().__init__(sampling_rate, cutoff=cutoff, order=order)\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n            raise ValueError(\n                f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n            )\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up low-pass filter processor\"\"\"\n        nyquist = 0.5 * self.sampling_rate\n        normal_cutoff = self.cutoff / nyquist\n\n        # Precompute and save filter coefficients\n        self.b, self.a = signal.butter(self.order, normal_cutoff, btype=\"low\")  # type: ignore [unused-ignore]\n        logger.debug(f\"Lowpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying lowpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.filters.LowPassFilter-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.filters.LowPassFilter.name","title":"<code>name = 'lowpass_filter'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.filters.LowPassFilter.a","title":"<code>a</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.filters.LowPassFilter.b","title":"<code>b</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.filters.LowPassFilter.cutoff","title":"<code>cutoff = cutoff</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.filters.LowPassFilter.order","title":"<code>order = order</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.filters.LowPassFilter-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.filters.LowPassFilter.__init__","title":"<code>__init__(sampling_rate, cutoff, order=4)</code>","text":"<p>Initialize low-pass filter</p>"},{"location":"api/processing/#wandas.processing.filters.LowPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) cutoff : float     Cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def __init__(self, sampling_rate: float, cutoff: float, order: int = 4):\n    \"\"\"\n    Initialize low-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    cutoff : float\n        Cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.cutoff = cutoff\n    self.order = order\n    super().__init__(sampling_rate, cutoff=cutoff, order=order)\n</code></pre>"},{"location":"api/processing/#wandas.processing.filters.LowPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    if self.cutoff &lt;= 0 or self.cutoff &gt;= self.sampling_rate / 2:\n        raise ValueError(\n            f\"Cutoff frequency must be between 0 Hz and {self.sampling_rate / 2} Hz\"\n        )\n</code></pre>"},{"location":"api/processing/#wandas.processing.filters.LowPassFilter.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"Source code in <code>wandas/processing/filters.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    return input_shape\n</code></pre>"},{"location":"api/processing/#wandas.processing.filters.BandPassFilter","title":"<code>BandPassFilter</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Band-pass filter operation</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>class BandPassFilter(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Band-pass filter operation\"\"\"\n\n    name = \"bandpass_filter\"\n    a: NDArrayReal\n    b: NDArrayReal\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        low_cutoff: float,\n        high_cutoff: float,\n        order: int = 4,\n    ):\n        \"\"\"\n        Initialize band-pass filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        low_cutoff : float\n            Lower cutoff frequency (Hz)\n        high_cutoff : float\n            Higher cutoff frequency (Hz)\n        order : int, optional\n            Filter order, default is 4\n        \"\"\"\n        self.low_cutoff = low_cutoff\n        self.high_cutoff = high_cutoff\n        self.order = order\n        super().__init__(\n            sampling_rate, low_cutoff=low_cutoff, high_cutoff=high_cutoff, order=order\n        )\n\n    def validate_params(self) -&gt; None:\n        \"\"\"Validate parameters\"\"\"\n        nyquist = self.sampling_rate / 2\n        if self.low_cutoff &lt;= 0 or self.low_cutoff &gt;= nyquist:\n            raise ValueError(\n                f\"Lower cutoff frequency must be between 0 Hz and {nyquist} Hz\"\n            )\n        if self.high_cutoff &lt;= 0 or self.high_cutoff &gt;= nyquist:\n            raise ValueError(\n                f\"Higher cutoff frequency must be between 0 Hz and {nyquist} Hz\"\n            )\n        if self.low_cutoff &gt;= self.high_cutoff:\n            raise ValueError(\n                f\"Lower cutoff frequency ({self.low_cutoff} Hz) must be less than \"\n                f\"higher cutoff frequency ({self.high_cutoff} Hz)\"\n            )\n\n    def _setup_processor(self) -&gt; None:\n        \"\"\"Set up band-pass filter processor\"\"\"\n        nyquist = 0.5 * self.sampling_rate\n        low_normal_cutoff = self.low_cutoff / nyquist\n        high_normal_cutoff = self.high_cutoff / nyquist\n\n        # Precompute and save filter coefficients\n        self.b, self.a = signal.butter(\n            self.order, [low_normal_cutoff, high_normal_cutoff], btype=\"band\"\n        )  # type: ignore [unused-ignore]\n        logger.debug(f\"Bandpass filter coefficients calculated: b={self.b}, a={self.a}\")\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Filter processing wrapped with @dask.delayed\"\"\"\n        logger.debug(f\"Applying bandpass filter to array with shape: {x.shape}\")\n        result: NDArrayReal = signal.filtfilt(self.b, self.a, x, axis=1)\n        logger.debug(f\"Filter applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.filters.BandPassFilter-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.filters.BandPassFilter.name","title":"<code>name = 'bandpass_filter'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.filters.BandPassFilter.a","title":"<code>a</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.filters.BandPassFilter.b","title":"<code>b</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.filters.BandPassFilter.low_cutoff","title":"<code>low_cutoff = low_cutoff</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.filters.BandPassFilter.high_cutoff","title":"<code>high_cutoff = high_cutoff</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.filters.BandPassFilter.order","title":"<code>order = order</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.filters.BandPassFilter-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.filters.BandPassFilter.__init__","title":"<code>__init__(sampling_rate, low_cutoff, high_cutoff, order=4)</code>","text":"<p>Initialize band-pass filter</p>"},{"location":"api/processing/#wandas.processing.filters.BandPassFilter.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) low_cutoff : float     Lower cutoff frequency (Hz) high_cutoff : float     Higher cutoff frequency (Hz) order : int, optional     Filter order, default is 4</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    low_cutoff: float,\n    high_cutoff: float,\n    order: int = 4,\n):\n    \"\"\"\n    Initialize band-pass filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    low_cutoff : float\n        Lower cutoff frequency (Hz)\n    high_cutoff : float\n        Higher cutoff frequency (Hz)\n    order : int, optional\n        Filter order, default is 4\n    \"\"\"\n    self.low_cutoff = low_cutoff\n    self.high_cutoff = high_cutoff\n    self.order = order\n    super().__init__(\n        sampling_rate, low_cutoff=low_cutoff, high_cutoff=high_cutoff, order=order\n    )\n</code></pre>"},{"location":"api/processing/#wandas.processing.filters.BandPassFilter.validate_params","title":"<code>validate_params()</code>","text":"<p>Validate parameters</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def validate_params(self) -&gt; None:\n    \"\"\"Validate parameters\"\"\"\n    nyquist = self.sampling_rate / 2\n    if self.low_cutoff &lt;= 0 or self.low_cutoff &gt;= nyquist:\n        raise ValueError(\n            f\"Lower cutoff frequency must be between 0 Hz and {nyquist} Hz\"\n        )\n    if self.high_cutoff &lt;= 0 or self.high_cutoff &gt;= nyquist:\n        raise ValueError(\n            f\"Higher cutoff frequency must be between 0 Hz and {nyquist} Hz\"\n        )\n    if self.low_cutoff &gt;= self.high_cutoff:\n        raise ValueError(\n            f\"Lower cutoff frequency ({self.low_cutoff} Hz) must be less than \"\n            f\"higher cutoff frequency ({self.high_cutoff} Hz)\"\n        )\n</code></pre>"},{"location":"api/processing/#wandas.processing.filters.BandPassFilter.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"Source code in <code>wandas/processing/filters.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    return input_shape\n</code></pre>"},{"location":"api/processing/#wandas.processing.filters.AWeighting","title":"<code>AWeighting</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>A-weighting filter operation</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>class AWeighting(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"A-weighting filter operation\"\"\"\n\n    name = \"a_weighting\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize A-weighting filter\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        return input_shape\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for A-weighting filter\"\"\"\n        logger.debug(f\"Applying A-weighting to array with shape: {x.shape}\")\n        result = A_weight(x, self.sampling_rate)\n\n        # Handle case where A_weight returns a tuple\n        if isinstance(result, tuple):\n            # Use the first element of the tuple\n            result = result[0]\n\n        logger.debug(\n            f\"A-weighting applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"api/processing/#wandas.processing.filters.AWeighting-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.filters.AWeighting.name","title":"<code>name = 'a_weighting'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.filters.AWeighting-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.filters.AWeighting.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize A-weighting filter</p>"},{"location":"api/processing/#wandas.processing.filters.AWeighting.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/filters.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize A-weighting filter\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"api/processing/#wandas.processing.filters.AWeighting.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"Source code in <code>wandas/processing/filters.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    return input_shape\n</code></pre>"},{"location":"api/processing/#wandas.processing.filters-functions","title":"Functions","text":""},{"location":"api/processing/#_5","title":"\u30b9\u30da\u30af\u30c8\u30eb\u51e6\u7406","text":"<p>\u30b9\u30da\u30af\u30c8\u30eb\u89e3\u6790\u3068\u51e6\u7406\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/processing/#wandas.processing.spectral","title":"<code>wandas.processing.spectral</code>","text":""},{"location":"api/processing/#wandas.processing.spectral-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.spectral.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral-classes","title":"Classes","text":""},{"location":"api/processing/#wandas.processing.spectral.FFT","title":"<code>FFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>FFT (Fast Fourier Transform) operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class FFT(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"FFT (Fast Fourier Transform) operation\"\"\"\n\n    name = \"fft\"\n    n_fft: Optional[int]\n    window: str\n\n    def __init__(\n        self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n    ):\n        \"\"\"\n        Initialize FFT operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int, optional\n            FFT size, default is None (determined by input size)\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(sampling_rate, n_fft=n_fft, window=window)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        \u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059\n\n        Parameters\n        ----------\n        input_shape : tuple\n            \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)\n\n        Returns\n        -------\n        tuple\n            \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)\n        \"\"\"\n        n_freqs = self.n_fft // 2 + 1 if self.n_fft else input_shape[-1] // 2 + 1\n        return (*input_shape[:-1], n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"FFT\u64cd\u4f5c\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u95a2\u6570\u3092\u4f5c\u6210\"\"\"\n        from scipy.signal import get_window\n\n        win = get_window(self.window, x.shape[-1])\n        x = x * win\n        result: NDArrayComplex = np.fft.rfft(x, n=self.n_fft, axis=-1)\n        result[..., 1:-1] *= 2.0\n        # \u7a93\u95a2\u6570\u88dc\u6b63\n        scaling_factor = np.sum(win)\n        result = result / scaling_factor\n        return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.FFT-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.spectral.FFT.name","title":"<code>name = 'fft'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.FFT.n_fft","title":"<code>n_fft = n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.FFT.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.FFT-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.spectral.FFT.__init__","title":"<code>__init__(sampling_rate, n_fft=None, window='hann')</code>","text":"<p>Initialize FFT operation</p>"},{"location":"api/processing/#wandas.processing.spectral.FFT.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int, optional     FFT size, default is None (determined by input size) window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n):\n    \"\"\"\n    Initialize FFT operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int, optional\n        FFT size, default is None (determined by input size)\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(sampling_rate, n_fft=n_fft, window=window)\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.FFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>\u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059</p>"},{"location":"api/processing/#wandas.processing.spectral.FFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)</p>"},{"location":"api/processing/#wandas.processing.spectral.FFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    \u64cd\u4f5c\u5f8c\u306e\u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6\u3092\u8a08\u7b97\u3057\u307e\u3059\n\n    Parameters\n    ----------\n    input_shape : tuple\n        \u5165\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, samples)\n\n    Returns\n    -------\n    tuple\n        \u51fa\u529b\u30c7\u30fc\u30bf\u306e\u5f62\u72b6 (channels, freqs)\n    \"\"\"\n    n_freqs = self.n_fft // 2 + 1 if self.n_fft else input_shape[-1] // 2 + 1\n    return (*input_shape[:-1], n_freqs)\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.IFFT","title":"<code>IFFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayComplex, NDArrayReal]</code></p> <p>IFFT (Inverse Fast Fourier Transform) operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class IFFT(AudioOperation[NDArrayComplex, NDArrayReal]):\n    \"\"\"IFFT (Inverse Fast Fourier Transform) operation\"\"\"\n\n    name = \"ifft\"\n    n_fft: Optional[int]\n    window: str\n\n    def __init__(\n        self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n    ):\n        \"\"\"\n        Initialize IFFT operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : Optional[int], optional\n            IFFT size, default is None (determined based on input size)\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.window = window\n        super().__init__(sampling_rate, n_fft=n_fft, window=window)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, freqs)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, samples)\n        \"\"\"\n        n_samples = 2 * (input_shape[-1] - 1) if self.n_fft is None else self.n_fft\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayComplex) -&gt; NDArrayReal:\n        \"\"\"Create processor function for IFFT operation\"\"\"\n        logger.debug(f\"Applying IFFT to array with shape: {x.shape}\")\n\n        # Restore frequency component scaling (remove the 2.0 multiplier applied in FFT)\n        _x = x.copy()\n        _x[..., 1:-1] /= 2.0\n\n        # Execute IFFT\n        result: NDArrayReal = np.fft.irfft(_x, n=self.n_fft, axis=-1)\n\n        # Window function correction (inverse of FFT operation)\n        from scipy.signal import get_window\n\n        win = get_window(self.window, result.shape[-1])\n\n        # Correct the FFT window function scaling\n        scaling_factor = np.sum(win) / result.shape[-1]\n        result = result / scaling_factor\n\n        logger.debug(f\"IFFT applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.IFFT-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.spectral.IFFT.name","title":"<code>name = 'ifft'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.IFFT.n_fft","title":"<code>n_fft = n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.IFFT.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.IFFT-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.spectral.IFFT.__init__","title":"<code>__init__(sampling_rate, n_fft=None, window='hann')</code>","text":"<p>Initialize IFFT operation</p>"},{"location":"api/processing/#wandas.processing.spectral.IFFT.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : Optional[int], optional     IFFT size, default is None (determined based on input size) window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self, sampling_rate: float, n_fft: Optional[int] = None, window: str = \"hann\"\n):\n    \"\"\"\n    Initialize IFFT operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : Optional[int], optional\n        IFFT size, default is None (determined based on input size)\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.window = window\n    super().__init__(sampling_rate, n_fft=n_fft, window=window)\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.IFFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/processing/#wandas.processing.spectral.IFFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, freqs)</p>"},{"location":"api/processing/#wandas.processing.spectral.IFFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, samples)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, freqs)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, samples)\n    \"\"\"\n    n_samples = 2 * (input_shape[-1] - 1) if self.n_fft is None else self.n_fft\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.STFT","title":"<code>STFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Short-Time Fourier Transform operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class STFT(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Short-Time Fourier Transform operation\"\"\"\n\n    name = \"stft\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ):\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.noverlap = (\n            self.win_length - self.hop_length if hop_length is not None else None\n        )\n        self.window = window\n\n        self.SFT = ShortTimeFFT(\n            win=get_window(window, self.win_length),\n            hop=self.hop_length,\n            fs=sampling_rate,\n            mfft=self.n_fft,\n            scale_to=\"magnitude\",\n        )\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        n_samples = input_shape[-1]\n        n_f = len(self.SFT.f)\n        n_t = len(self.SFT.t(n_samples))\n        return (input_shape[0], n_f, n_t)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Apply SciPy STFT processing to multiple channels at once\"\"\"\n        logger.debug(f\"Applying SciPy STFT to array with shape: {x.shape}\")\n\n        # Convert 1D input to 2D\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n\n        # Apply STFT to all channels at once\n        result: NDArrayComplex = self.SFT.stft(x)\n        result[..., 1:-1, :] *= 2.0\n        logger.debug(f\"SciPy STFT applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.STFT-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.spectral.STFT.name","title":"<code>name = 'stft'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.STFT.n_fft","title":"<code>n_fft = n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.STFT.win_length","title":"<code>win_length = win_length if win_length is not None else n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.STFT.hop_length","title":"<code>hop_length = hop_length if hop_length is not None else self.win_length // 4</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.STFT.noverlap","title":"<code>noverlap = self.win_length - self.hop_length if hop_length is not None else None</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.STFT.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.STFT.SFT","title":"<code>SFT = ShortTimeFFT(win=get_window(window, self.win_length), hop=self.hop_length, fs=sampling_rate, mfft=self.n_fft, scale_to='magnitude')</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.STFT-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.spectral.STFT.__init__","title":"<code>__init__(sampling_rate, n_fft=2048, hop_length=None, win_length=None, window='hann')</code>","text":"Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n):\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.noverlap = (\n        self.win_length - self.hop_length if hop_length is not None else None\n    )\n    self.window = window\n\n    self.SFT = ShortTimeFFT(\n        win=get_window(window, self.win_length),\n        hop=self.hop_length,\n        fs=sampling_rate,\n        mfft=self.n_fft,\n        scale_to=\"magnitude\",\n    )\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        win_length=self.win_length,\n        hop_length=self.hop_length,\n        window=window,\n    )\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.STFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/processing/#wandas.processing.spectral.STFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/processing/#wandas.processing.spectral.STFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    n_samples = input_shape[-1]\n    n_f = len(self.SFT.f)\n    n_t = len(self.SFT.t(n_samples))\n    return (input_shape[0], n_f, n_t)\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.ISTFT","title":"<code>ISTFT</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayComplex, NDArrayReal]</code></p> <p>Inverse Short-Time Fourier Transform operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class ISTFT(AudioOperation[NDArrayComplex, NDArrayReal]):\n    \"\"\"Inverse Short-Time Fourier Transform operation\"\"\"\n\n    name = \"istft\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        length: Optional[int] = None,\n    ):\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.length = length\n\n        # Instantiate ShortTimeFFT for ISTFT calculation\n        self.SFT = ShortTimeFFT(\n            win=get_window(window, self.win_length),\n            hop=self.hop_length,\n            fs=sampling_rate,\n            mfft=self.n_fft,\n            scale_to=\"magnitude\",  # Consistent scaling with STFT\n        )\n\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n            length=length,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, freqs, time_frames)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, samples)\n        \"\"\"\n        k0: int = 0\n        q_max = input_shape[-1] + self.SFT.p_min\n        k_max = (q_max - 1) * self.SFT.hop + self.SFT.m_num - self.SFT.m_num_mid\n        k_q0, k_q1 = self.SFT.nearest_k_p(k0), self.SFT.nearest_k_p(k_max, left=False)\n        n_pts = k_q1 - k_q0 + self.SFT.m_num - self.SFT.m_num_mid\n\n        return input_shape[:-2] + (n_pts,)\n\n    def _process_array(self, x: NDArrayComplex) -&gt; NDArrayReal:\n        \"\"\"\n        Apply SciPy ISTFT processing to multiple channels at once using ShortTimeFFT\"\"\"\n        logger.debug(\n            f\"Applying SciPy ISTFT (ShortTimeFFT) to array with shape: {x.shape}\"\n        )\n\n        # Convert 2D input to 3D (assume single channel)\n        if x.ndim == 2:\n            x = x.reshape(1, *x.shape)\n\n        # Adjust scaling back if STFT applied factor of 2\n        _x = np.copy(x)\n        _x[..., 1:-1, :] /= 2.0\n\n        # Apply ISTFT using the ShortTimeFFT instance\n        result: NDArrayReal = self.SFT.istft(_x)\n\n        # Trim to desired length if specified\n        if self.length is not None:\n            result = result[..., : self.length]\n\n        logger.debug(\n            f\"ShortTimeFFT applied, returning result with shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.ISTFT-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.spectral.ISTFT.name","title":"<code>name = 'istft'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.ISTFT.n_fft","title":"<code>n_fft = n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.ISTFT.win_length","title":"<code>win_length = win_length if win_length is not None else n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.ISTFT.hop_length","title":"<code>hop_length = hop_length if hop_length is not None else self.win_length // 4</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.ISTFT.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.ISTFT.length","title":"<code>length = length</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.ISTFT.SFT","title":"<code>SFT = ShortTimeFFT(win=get_window(window, self.win_length), hop=self.hop_length, fs=sampling_rate, mfft=self.n_fft, scale_to='magnitude')</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.ISTFT-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.spectral.ISTFT.__init__","title":"<code>__init__(sampling_rate, n_fft=2048, hop_length=None, win_length=None, window='hann', length=None)</code>","text":"Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    length: Optional[int] = None,\n):\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.length = length\n\n    # Instantiate ShortTimeFFT for ISTFT calculation\n    self.SFT = ShortTimeFFT(\n        win=get_window(window, self.win_length),\n        hop=self.hop_length,\n        fs=sampling_rate,\n        mfft=self.n_fft,\n        scale_to=\"magnitude\",  # Consistent scaling with STFT\n    )\n\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        win_length=self.win_length,\n        hop_length=self.hop_length,\n        window=window,\n        length=length,\n    )\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.ISTFT.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/processing/#wandas.processing.spectral.ISTFT.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, freqs, time_frames)</p>"},{"location":"api/processing/#wandas.processing.spectral.ISTFT.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, samples)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, freqs, time_frames)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, samples)\n    \"\"\"\n    k0: int = 0\n    q_max = input_shape[-1] + self.SFT.p_min\n    k_max = (q_max - 1) * self.SFT.hop + self.SFT.m_num - self.SFT.m_num_mid\n    k_q0, k_q1 = self.SFT.nearest_k_p(k0), self.SFT.nearest_k_p(k_max, left=False)\n    n_pts = k_q1 - k_q0 + self.SFT.m_num - self.SFT.m_num_mid\n\n    return input_shape[:-2] + (n_pts,)\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.Welch","title":"<code>Welch</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Welch</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class Welch(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Welch\"\"\"\n\n    name = \"welch\"\n    n_fft: int\n    window: str\n    hop_length: Optional[int]\n    win_length: Optional[int]\n    average: str\n    detrend: str\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n        average: str = \"mean\",\n        detrend: str = \"constant\",\n    ):\n        \"\"\"\n        Initialize Welch operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int, optional\n            FFT size, default is 2048\n        window : str, optional\n            Window function type, default is 'hann'\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.noverlap = (\n            self.win_length - self.hop_length if hop_length is not None else None\n        )\n        self.window = window\n        self.average = average\n        self.detrend = detrend\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            win_length=self.win_length,\n            hop_length=self.hop_length,\n            window=window,\n            average=average,\n            detrend=detrend,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, freqs)\n        \"\"\"\n        n_freqs = self.n_fft // 2 + 1\n        return (*input_shape[:-1], n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for Welch operation\"\"\"\n        from scipy import signal as ss\n\n        _, result = ss.welch(\n            x,\n            nperseg=self.win_length,\n            noverlap=self.noverlap,\n            nfft=self.n_fft,\n            window=self.window,\n            average=self.average,\n            detrend=self.detrend,\n            scaling=\"spectrum\",\n        )\n\n        if not isinstance(x, np.ndarray):\n            # Trigger computation for Dask array\n            raise ValueError(\n                \"Welch operation requires a Dask array, but received a non-ndarray.\"\n            )\n        return np.array(result)\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.Welch-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.spectral.Welch.name","title":"<code>name = 'welch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.Welch.n_fft","title":"<code>n_fft = n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.Welch.win_length","title":"<code>win_length = win_length if win_length is not None else n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.Welch.hop_length","title":"<code>hop_length = hop_length if hop_length is not None else self.win_length // 4</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.Welch.noverlap","title":"<code>noverlap = self.win_length - self.hop_length if hop_length is not None else None</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.Welch.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.Welch.average","title":"<code>average = average</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.Welch.detrend","title":"<code>detrend = detrend</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.Welch-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.spectral.Welch.__init__","title":"<code>__init__(sampling_rate, n_fft=2048, hop_length=None, win_length=None, window='hann', average='mean', detrend='constant')</code>","text":"<p>Initialize Welch operation</p>"},{"location":"api/processing/#wandas.processing.spectral.Welch.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int, optional     FFT size, default is 2048 window : str, optional     Window function type, default is 'hann'</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n    average: str = \"mean\",\n    detrend: str = \"constant\",\n):\n    \"\"\"\n    Initialize Welch operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int, optional\n        FFT size, default is 2048\n    window : str, optional\n        Window function type, default is 'hann'\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.noverlap = (\n        self.win_length - self.hop_length if hop_length is not None else None\n    )\n    self.window = window\n    self.average = average\n    self.detrend = detrend\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        win_length=self.win_length,\n        hop_length=self.hop_length,\n        window=window,\n        average=average,\n        detrend=detrend,\n    )\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.Welch.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/processing/#wandas.processing.spectral.Welch.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"api/processing/#wandas.processing.spectral.Welch.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, freqs)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, freqs)\n    \"\"\"\n    n_freqs = self.n_fft // 2 + 1\n    return (*input_shape[:-1], n_freqs)\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.NOctSpectrum","title":"<code>NOctSpectrum</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>N-octave spectrum operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class NOctSpectrum(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"N-octave spectrum operation\"\"\"\n\n    name = \"noct_spectrum\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ):\n        \"\"\"\n        Initialize N-octave spectrum\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        fmin : float\n            Minimum frequency (Hz)\n        fmax : float\n            Maximum frequency (Hz)\n        n : int, optional\n            Number of octave divisions, default is 3\n        G : int, optional\n            Reference level, default is 10\n        fr : int, optional\n            Reference frequency, default is 1000\n        \"\"\"\n        super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n        self.fmin = fmin\n        self.fmax = fmax\n        self.n = n\n        self.G = G\n        self.fr = fr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate output shape for octave spectrum\n        _, fpref = _center_freq(\n            fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n        )\n        return (input_shape[0], fpref.shape[0])\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for octave spectrum\"\"\"\n        logger.debug(f\"Applying NoctSpectrum to array with shape: {x.shape}\")\n        spec, _ = noct_spectrum(\n            sig=x.T,\n            fs=self.sampling_rate,\n            fmin=self.fmin,\n            fmax=self.fmax,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        if spec.ndim == 1:\n            # Add channel dimension for 1D\n            spec = np.expand_dims(spec, axis=0)\n        else:\n            spec = spec.T\n        logger.debug(f\"NoctSpectrum applied, returning result with shape: {spec.shape}\")\n        return np.array(spec)\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.NOctSpectrum-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.spectral.NOctSpectrum.name","title":"<code>name = 'noct_spectrum'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.NOctSpectrum.fmin","title":"<code>fmin = fmin</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.NOctSpectrum.fmax","title":"<code>fmax = fmax</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.NOctSpectrum.n","title":"<code>n = n</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.NOctSpectrum.G","title":"<code>G = G</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.NOctSpectrum.fr","title":"<code>fr = fr</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.NOctSpectrum-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.spectral.NOctSpectrum.__init__","title":"<code>__init__(sampling_rate, fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Initialize N-octave spectrum</p>"},{"location":"api/processing/#wandas.processing.spectral.NOctSpectrum.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) fmin : float     Minimum frequency (Hz) fmax : float     Maximum frequency (Hz) n : int, optional     Number of octave divisions, default is 3 G : int, optional     Reference level, default is 10 fr : int, optional     Reference frequency, default is 1000</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n):\n    \"\"\"\n    Initialize N-octave spectrum\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    fmin : float\n        Minimum frequency (Hz)\n    fmax : float\n        Maximum frequency (Hz)\n    n : int, optional\n        Number of octave divisions, default is 3\n    G : int, optional\n        Reference level, default is 10\n    fr : int, optional\n        Reference frequency, default is 1000\n    \"\"\"\n    super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n    self.fmin = fmin\n    self.fmax = fmax\n    self.n = n\n    self.G = G\n    self.fr = fr\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.NOctSpectrum.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/processing/#wandas.processing.spectral.NOctSpectrum.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/processing/#wandas.processing.spectral.NOctSpectrum.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate output shape for octave spectrum\n    _, fpref = _center_freq(\n        fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n    )\n    return (input_shape[0], fpref.shape[0])\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.NOctSynthesis","title":"<code>NOctSynthesis</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Octave synthesis operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class NOctSynthesis(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Octave synthesis operation\"\"\"\n\n    name = \"noct_synthesis\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        fmin: float,\n        fmax: float,\n        n: int = 3,\n        G: int = 10,  # noqa: N803\n        fr: int = 1000,\n    ):\n        \"\"\"\n        Initialize octave synthesis\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        fmin : float\n            Minimum frequency (Hz)\n        fmax : float\n            Maximum frequency (Hz)\n        n : int, optional\n            Number of octave divisions, default is 3\n        G : int, optional\n            Reference level, default is 10\n        fr : int, optional\n            Reference frequency, default is 1000\n        \"\"\"\n        super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n\n        self.fmin = fmin\n        self.fmax = fmax\n        self.n = n\n        self.G = G\n        self.fr = fr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate output shape for octave spectrum\n        _, fpref = _center_freq(\n            fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n        )\n        return (input_shape[0], fpref.shape[0])\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for octave synthesis\"\"\"\n        logger.debug(f\"Applying NoctSynthesis to array with shape: {x.shape}\")\n        # Calculate n from shape[-1]\n        n = x.shape[-1]  # Calculate n from shape[-1]\n        if n % 2 == 0:\n            n = n * 2 - 1\n        else:\n            n = (n - 1) * 2\n        freqs = np.fft.rfftfreq(n, d=1 / self.sampling_rate)\n        result, _ = noct_synthesis(\n            spectrum=np.abs(x).T,\n            freqs=freqs,\n            fmin=self.fmin,\n            fmax=self.fmax,\n            n=self.n,\n            G=self.G,\n            fr=self.fr,\n        )\n        result = result.T\n        logger.debug(\n            f\"NoctSynthesis applied, returning result with shape: {result.shape}\"\n        )\n        return np.array(result)\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.NOctSynthesis-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.spectral.NOctSynthesis.name","title":"<code>name = 'noct_synthesis'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.NOctSynthesis.fmin","title":"<code>fmin = fmin</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.NOctSynthesis.fmax","title":"<code>fmax = fmax</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.NOctSynthesis.n","title":"<code>n = n</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.NOctSynthesis.G","title":"<code>G = G</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.NOctSynthesis.fr","title":"<code>fr = fr</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.NOctSynthesis-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.spectral.NOctSynthesis.__init__","title":"<code>__init__(sampling_rate, fmin, fmax, n=3, G=10, fr=1000)</code>","text":"<p>Initialize octave synthesis</p>"},{"location":"api/processing/#wandas.processing.spectral.NOctSynthesis.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) fmin : float     Minimum frequency (Hz) fmax : float     Maximum frequency (Hz) n : int, optional     Number of octave divisions, default is 3 G : int, optional     Reference level, default is 10 fr : int, optional     Reference frequency, default is 1000</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    fmin: float,\n    fmax: float,\n    n: int = 3,\n    G: int = 10,  # noqa: N803\n    fr: int = 1000,\n):\n    \"\"\"\n    Initialize octave synthesis\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    fmin : float\n        Minimum frequency (Hz)\n    fmax : float\n        Maximum frequency (Hz)\n    n : int, optional\n        Number of octave divisions, default is 3\n    G : int, optional\n        Reference level, default is 10\n    fr : int, optional\n        Reference frequency, default is 1000\n    \"\"\"\n    super().__init__(sampling_rate, fmin=fmin, fmax=fmax, n=n, G=G, fr=fr)\n\n    self.fmin = fmin\n    self.fmax = fmax\n    self.n = n\n    self.G = G\n    self.fr = fr\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.NOctSynthesis.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/processing/#wandas.processing.spectral.NOctSynthesis.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/processing/#wandas.processing.spectral.NOctSynthesis.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate output shape for octave spectrum\n    _, fpref = _center_freq(\n        fmin=self.fmin, fmax=self.fmax, n=self.n, G=self.G, fr=self.fr\n    )\n    return (input_shape[0], fpref.shape[0])\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.Coherence","title":"<code>Coherence</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Coherence estimation operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class Coherence(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Coherence estimation operation\"\"\"\n\n    name = \"coherence\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n    ):\n        \"\"\"\n        Initialize coherence estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Processor function for coherence estimation operation\"\"\"\n        logger.debug(f\"Applying coherence estimation to array with shape: {x.shape}\")\n        from scipy import signal as ss\n\n        _, coh = ss.coherence(\n            x=x[:, np.newaxis],\n            y=x[np.newaxis, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n        )\n\n        # Reshape result to (n_channels * n_channels, n_freqs)\n        result: NDArrayReal = coh.transpose(1, 0, 2).reshape(-1, coh.shape[-1])\n\n        logger.debug(f\"Coherence estimation applied, result shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.Coherence-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.spectral.Coherence.name","title":"<code>name = 'coherence'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.Coherence.n_fft","title":"<code>n_fft = n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.Coherence.win_length","title":"<code>win_length = win_length if win_length is not None else n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.Coherence.hop_length","title":"<code>hop_length = hop_length if hop_length is not None else self.win_length // 4</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.Coherence.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.Coherence.detrend","title":"<code>detrend = detrend</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.Coherence-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.spectral.Coherence.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend)</code>","text":"<p>Initialize coherence estimation operation</p>"},{"location":"api/processing/#wandas.processing.spectral.Coherence.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n):\n    \"\"\"\n    Initialize coherence estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n    )\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.Coherence.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/processing/#wandas.processing.spectral.Coherence.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"api/processing/#wandas.processing.spectral.Coherence.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.CSD","title":"<code>CSD</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Cross-spectral density estimation operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class CSD(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Cross-spectral density estimation operation\"\"\"\n\n    name = \"csd\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n        scaling: str,\n        average: str,\n    ):\n        \"\"\"\n        Initialize cross-spectral density estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        scaling : str\n            Type of scaling\n        average : str\n            Method of averaging\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        self.scaling = scaling\n        self.average = average\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n            scaling=scaling,\n            average=average,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Processor function for cross-spectral density estimation operation\"\"\"\n        logger.debug(f\"Applying CSD estimation to array with shape: {x.shape}\")\n        from scipy import signal as ss\n\n        # Calculate all combinations using scipy's csd function\n        _, csd_result = ss.csd(\n            x=x[:, np.newaxis],\n            y=x[np.newaxis, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n        )\n\n        # Reshape result to (n_channels * n_channels, n_freqs)\n        result: NDArrayComplex = csd_result.transpose(1, 0, 2).reshape(\n            -1, csd_result.shape[-1]\n        )\n\n        logger.debug(f\"CSD estimation applied, result shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.CSD-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.spectral.CSD.name","title":"<code>name = 'csd'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.CSD.n_fft","title":"<code>n_fft = n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.CSD.win_length","title":"<code>win_length = win_length if win_length is not None else n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.CSD.hop_length","title":"<code>hop_length = hop_length if hop_length is not None else self.win_length // 4</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.CSD.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.CSD.detrend","title":"<code>detrend = detrend</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.CSD.scaling","title":"<code>scaling = scaling</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.CSD.average","title":"<code>average = average</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.CSD-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.spectral.CSD.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend, scaling, average)</code>","text":"<p>Initialize cross-spectral density estimation operation</p>"},{"location":"api/processing/#wandas.processing.spectral.CSD.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend scaling : str     Type of scaling average : str     Method of averaging</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n    scaling: str,\n    average: str,\n):\n    \"\"\"\n    Initialize cross-spectral density estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    scaling : str\n        Type of scaling\n    average : str\n        Method of averaging\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    self.scaling = scaling\n    self.average = average\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n        scaling=scaling,\n        average=average,\n    )\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.CSD.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/processing/#wandas.processing.spectral.CSD.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"api/processing/#wandas.processing.spectral.CSD.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.TransferFunction","title":"<code>TransferFunction</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayComplex]</code></p> <p>Transfer function estimation operation</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>class TransferFunction(AudioOperation[NDArrayReal, NDArrayComplex]):\n    \"\"\"Transfer function estimation operation\"\"\"\n\n    name = \"transfer_function\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        n_fft: int,\n        hop_length: int,\n        win_length: int,\n        window: str,\n        detrend: str,\n        scaling: str = \"spectrum\",\n        average: str = \"mean\",\n    ):\n        \"\"\"\n        Initialize transfer function estimation operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        n_fft : int\n            FFT size\n        hop_length : int\n            Hop length\n        win_length : int\n            Window length\n        window : str\n            Window function\n        detrend : str\n            Type of detrend\n        scaling : str\n            Type of scaling\n        average : str\n            Method of averaging\n        \"\"\"\n        self.n_fft = n_fft\n        self.win_length = win_length if win_length is not None else n_fft\n        self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n        self.window = window\n        self.detrend = detrend\n        self.scaling = scaling\n        self.average = average\n        super().__init__(\n            sampling_rate,\n            n_fft=n_fft,\n            hop_length=self.hop_length,\n            win_length=self.win_length,\n            window=window,\n            detrend=detrend,\n            scaling=scaling,\n            average=average,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels * channels, freqs)\n        \"\"\"\n        n_channels = input_shape[0]\n        n_freqs = self.n_fft // 2 + 1\n        return (n_channels * n_channels, n_freqs)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayComplex:\n        \"\"\"Processor function for transfer function estimation operation\"\"\"\n        logger.debug(\n            f\"Applying transfer function estimation to array with shape: {x.shape}\"\n        )\n        from scipy import signal as ss\n\n        # Calculate cross-spectral density between all channels\n        f, p_yx = ss.csd(\n            x=x[:, np.newaxis, :],\n            y=x[np.newaxis, :, :],\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n            axis=-1,\n        )\n        # p_yx shape: (num_channels, num_channels, num_frequencies)\n\n        # Calculate power spectral density for each channel\n        f, p_xx = ss.welch(\n            x=x,\n            fs=self.sampling_rate,\n            nperseg=self.win_length,\n            noverlap=self.win_length - self.hop_length,\n            nfft=self.n_fft,\n            window=self.window,\n            detrend=self.detrend,\n            scaling=self.scaling,\n            average=self.average,\n            axis=-1,\n        )\n        # p_xx shape: (num_channels, num_frequencies)\n\n        # Calculate transfer function H(f) = P_yx / P_xx\n        h_f = p_yx / p_xx[np.newaxis, :, :]\n        result: NDArrayComplex = h_f.transpose(1, 0, 2).reshape(-1, h_f.shape[-1])\n\n        logger.debug(\n            f\"Transfer function estimation applied, result shape: {result.shape}\"\n        )\n        return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.TransferFunction-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.spectral.TransferFunction.name","title":"<code>name = 'transfer_function'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.TransferFunction.n_fft","title":"<code>n_fft = n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.TransferFunction.win_length","title":"<code>win_length = win_length if win_length is not None else n_fft</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.TransferFunction.hop_length","title":"<code>hop_length = hop_length if hop_length is not None else self.win_length // 4</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.TransferFunction.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.TransferFunction.detrend","title":"<code>detrend = detrend</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.TransferFunction.scaling","title":"<code>scaling = scaling</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.TransferFunction.average","title":"<code>average = average</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.spectral.TransferFunction-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.spectral.TransferFunction.__init__","title":"<code>__init__(sampling_rate, n_fft, hop_length, win_length, window, detrend, scaling='spectrum', average='mean')</code>","text":"<p>Initialize transfer function estimation operation</p>"},{"location":"api/processing/#wandas.processing.spectral.TransferFunction.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) n_fft : int     FFT size hop_length : int     Hop length win_length : int     Window length window : str     Window function detrend : str     Type of detrend scaling : str     Type of scaling average : str     Method of averaging</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    n_fft: int,\n    hop_length: int,\n    win_length: int,\n    window: str,\n    detrend: str,\n    scaling: str = \"spectrum\",\n    average: str = \"mean\",\n):\n    \"\"\"\n    Initialize transfer function estimation operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    n_fft : int\n        FFT size\n    hop_length : int\n        Hop length\n    win_length : int\n        Window length\n    window : str\n        Window function\n    detrend : str\n        Type of detrend\n    scaling : str\n        Type of scaling\n    average : str\n        Method of averaging\n    \"\"\"\n    self.n_fft = n_fft\n    self.win_length = win_length if win_length is not None else n_fft\n    self.hop_length = hop_length if hop_length is not None else self.win_length // 4\n    self.window = window\n    self.detrend = detrend\n    self.scaling = scaling\n    self.average = average\n    super().__init__(\n        sampling_rate,\n        n_fft=n_fft,\n        hop_length=self.hop_length,\n        win_length=self.win_length,\n        window=window,\n        detrend=detrend,\n        scaling=scaling,\n        average=average,\n    )\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral.TransferFunction.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/processing/#wandas.processing.spectral.TransferFunction.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"api/processing/#wandas.processing.spectral.TransferFunction.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels * channels, freqs)</p> Source code in <code>wandas/processing/spectral.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels * channels, freqs)\n    \"\"\"\n    n_channels = input_shape[0]\n    n_freqs = self.n_fft // 2 + 1\n    return (n_channels * n_channels, n_freqs)\n</code></pre>"},{"location":"api/processing/#wandas.processing.spectral-functions","title":"Functions","text":""},{"location":"api/processing/#_6","title":"\u7d71\u8a08\u51e6\u7406","text":"<p>\u30aa\u30fc\u30c7\u30a3\u30aa\u30c7\u30fc\u30bf\u306e\u7d71\u8a08\u5206\u6790\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/processing/#wandas.processing.stats","title":"<code>wandas.processing.stats</code>","text":""},{"location":"api/processing/#wandas.processing.stats-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.stats.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.stats-classes","title":"Classes","text":""},{"location":"api/processing/#wandas.processing.stats.ABS","title":"<code>ABS</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Absolute value operation</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>class ABS(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Absolute value operation\"\"\"\n\n    name = \"abs\"\n\n    def __init__(self, sampling_rate: float):\n        \"\"\"\n        Initialize absolute value operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate)\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        return da.abs(data)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"api/processing/#wandas.processing.stats.ABS-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.stats.ABS.name","title":"<code>name = 'abs'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.stats.ABS-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.stats.ABS.__init__","title":"<code>__init__(sampling_rate)</code>","text":"<p>Initialize absolute value operation</p>"},{"location":"api/processing/#wandas.processing.stats.ABS.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz)</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>def __init__(self, sampling_rate: float):\n    \"\"\"\n    Initialize absolute value operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate)\n</code></pre>"},{"location":"api/processing/#wandas.processing.stats.ABS.process","title":"<code>process(data)</code>","text":"Source code in <code>wandas/processing/stats.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n    return da.abs(data)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"api/processing/#wandas.processing.stats.Power","title":"<code>Power</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Power operation</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>class Power(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Power operation\"\"\"\n\n    name = \"power\"\n\n    def __init__(self, sampling_rate: float, exponent: float):\n        \"\"\"\n        Initialize power operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        exponent : float\n            Power exponent\n        \"\"\"\n        super().__init__(sampling_rate)\n        self.exp = exponent\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        return da.power(data, self.exp)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"api/processing/#wandas.processing.stats.Power-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.stats.Power.name","title":"<code>name = 'power'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.stats.Power.exp","title":"<code>exp = exponent</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.stats.Power-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.stats.Power.__init__","title":"<code>__init__(sampling_rate, exponent)</code>","text":"<p>Initialize power operation</p>"},{"location":"api/processing/#wandas.processing.stats.Power.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) exponent : float     Power exponent</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>def __init__(self, sampling_rate: float, exponent: float):\n    \"\"\"\n    Initialize power operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    exponent : float\n        Power exponent\n    \"\"\"\n    super().__init__(sampling_rate)\n    self.exp = exponent\n</code></pre>"},{"location":"api/processing/#wandas.processing.stats.Power.process","title":"<code>process(data)</code>","text":"Source code in <code>wandas/processing/stats.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n    return da.power(data, self.exp)  # type: ignore [unused-ignore]\n</code></pre>"},{"location":"api/processing/#wandas.processing.stats.Sum","title":"<code>Sum</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Sum calculation</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>class Sum(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Sum calculation\"\"\"\n\n    name = \"sum\"\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # Use Dask's aggregate function directly without map_blocks\n        return data.sum(axis=0, keepdims=True)\n</code></pre>"},{"location":"api/processing/#wandas.processing.stats.Sum-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.stats.Sum.name","title":"<code>name = 'sum'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.stats.Sum-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.stats.Sum.process","title":"<code>process(data)</code>","text":"Source code in <code>wandas/processing/stats.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    # Use Dask's aggregate function directly without map_blocks\n    return data.sum(axis=0, keepdims=True)\n</code></pre>"},{"location":"api/processing/#wandas.processing.stats.Mean","title":"<code>Mean</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Mean calculation</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>class Mean(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Mean calculation\"\"\"\n\n    name = \"mean\"\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # Use Dask's aggregate function directly without map_blocks\n        return data.mean(axis=0, keepdims=True)\n</code></pre>"},{"location":"api/processing/#wandas.processing.stats.Mean-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.stats.Mean.name","title":"<code>name = 'mean'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.stats.Mean-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.stats.Mean.process","title":"<code>process(data)</code>","text":"Source code in <code>wandas/processing/stats.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    # Use Dask's aggregate function directly without map_blocks\n    return data.mean(axis=0, keepdims=True)\n</code></pre>"},{"location":"api/processing/#wandas.processing.stats.ChannelDifference","title":"<code>ChannelDifference</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Channel difference calculation operation</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>class ChannelDifference(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Channel difference calculation operation\"\"\"\n\n    name = \"channel_difference\"\n    other_channel: int\n\n    def __init__(self, sampling_rate: float, other_channel: int = 0):\n        \"\"\"\n        Initialize channel difference calculation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        other_channel : int\n            Channel to calculate difference with, default is 0\n        \"\"\"\n        self.other_channel = other_channel\n        super().__init__(sampling_rate, other_channel=other_channel)\n\n    def process(self, data: DaArray) -&gt; DaArray:\n        # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n        result = data - data[self.other_channel]\n        return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.stats.ChannelDifference-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.stats.ChannelDifference.name","title":"<code>name = 'channel_difference'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.stats.ChannelDifference.other_channel","title":"<code>other_channel = other_channel</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.stats.ChannelDifference-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.stats.ChannelDifference.__init__","title":"<code>__init__(sampling_rate, other_channel=0)</code>","text":"<p>Initialize channel difference calculation</p>"},{"location":"api/processing/#wandas.processing.stats.ChannelDifference.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) other_channel : int     Channel to calculate difference with, default is 0</p> Source code in <code>wandas/processing/stats.py</code> <pre><code>def __init__(self, sampling_rate: float, other_channel: int = 0):\n    \"\"\"\n    Initialize channel difference calculation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    other_channel : int\n        Channel to calculate difference with, default is 0\n    \"\"\"\n    self.other_channel = other_channel\n    super().__init__(sampling_rate, other_channel=other_channel)\n</code></pre>"},{"location":"api/processing/#wandas.processing.stats.ChannelDifference.process","title":"<code>process(data)</code>","text":"Source code in <code>wandas/processing/stats.py</code> <pre><code>def process(self, data: DaArray) -&gt; DaArray:\n    # map_blocks\u3092\u4f7f\u308f\u305a\u3001\u76f4\u63a5Dask\u306e\u96c6\u7d04\u95a2\u6570\u3092\u4f7f\u7528\n    result = data - data[self.other_channel]\n    return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.stats-functions","title":"Functions","text":""},{"location":"api/processing/#_7","title":"\u6642\u9593\u9818\u57df\u51e6\u7406","text":"<p>\u6642\u9593\u9818\u57df\u306e\u51e6\u7406\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/processing/#wandas.processing.temporal","title":"<code>wandas.processing.temporal</code>","text":""},{"location":"api/processing/#wandas.processing.temporal-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.temporal.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.temporal-classes","title":"Classes","text":""},{"location":"api/processing/#wandas.processing.temporal.ReSampling","title":"<code>ReSampling</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Resampling operation</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>class ReSampling(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Resampling operation\"\"\"\n\n    name = \"resampling\"\n\n    def __init__(self, sampling_rate: float, target_sr: float):\n        \"\"\"\n        Initialize resampling operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        target_sampling_rate : float\n            Target sampling rate (Hz)\n        \"\"\"\n        super().__init__(sampling_rate, target_sr=target_sr)\n        self.target_sr = target_sr\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after resampling\n        ratio = float(self.target_sr) / float(self.sampling_rate)\n        n_samples = int(np.ceil(input_shape[-1] * ratio))\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for resampling operation\"\"\"\n        logger.debug(f\"Applying resampling to array with shape: {x.shape}\")\n        result: NDArrayReal = librosa.resample(\n            x, orig_sr=self.sampling_rate, target_sr=self.target_sr\n        )\n        logger.debug(f\"Resampling applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.temporal.ReSampling-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.temporal.ReSampling.name","title":"<code>name = 'resampling'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.temporal.ReSampling.target_sr","title":"<code>target_sr = target_sr</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.temporal.ReSampling-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.temporal.ReSampling.__init__","title":"<code>__init__(sampling_rate, target_sr)</code>","text":"<p>Initialize resampling operation</p>"},{"location":"api/processing/#wandas.processing.temporal.ReSampling.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) target_sampling_rate : float     Target sampling rate (Hz)</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def __init__(self, sampling_rate: float, target_sr: float):\n    \"\"\"\n    Initialize resampling operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    target_sampling_rate : float\n        Target sampling rate (Hz)\n    \"\"\"\n    super().__init__(sampling_rate, target_sr=target_sr)\n    self.target_sr = target_sr\n</code></pre>"},{"location":"api/processing/#wandas.processing.temporal.ReSampling.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/processing/#wandas.processing.temporal.ReSampling.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/processing/#wandas.processing.temporal.ReSampling.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after resampling\n    ratio = float(self.target_sr) / float(self.sampling_rate)\n    n_samples = int(np.ceil(input_shape[-1] * ratio))\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"api/processing/#wandas.processing.temporal.Trim","title":"<code>Trim</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>Trimming operation</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>class Trim(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"Trimming operation\"\"\"\n\n    name = \"trim\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        start: float,\n        end: float,\n    ):\n        \"\"\"\n        Initialize trimming operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        start : float\n            Start time for trimming (seconds)\n        end : float\n            End time for trimming (seconds)\n        \"\"\"\n        super().__init__(sampling_rate, start=start, end=end)\n        self.start = start\n        self.end = end\n        self.start_sample = int(start * sampling_rate)\n        self.end_sample = int(end * sampling_rate)\n        logger.debug(\n            f\"Initialized Trim operation with start: {self.start}, end: {self.end}\"\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        # Calculate length after trimming\n        # Exclude parts where there is no signal\n        end_sample = min(self.end_sample, input_shape[-1])\n        n_samples = end_sample - self.start_sample\n        return (*input_shape[:-1], n_samples)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for trimming operation\"\"\"\n        logger.debug(f\"Applying trim to array with shape: {x.shape}\")\n        # Apply trimming\n        result = x[..., self.start_sample : self.end_sample]\n        logger.debug(f\"Trim applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.temporal.Trim-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.temporal.Trim.name","title":"<code>name = 'trim'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.temporal.Trim.start","title":"<code>start = start</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.temporal.Trim.end","title":"<code>end = end</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.temporal.Trim.start_sample","title":"<code>start_sample = int(start * sampling_rate)</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.temporal.Trim.end_sample","title":"<code>end_sample = int(end * sampling_rate)</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.temporal.Trim-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.temporal.Trim.__init__","title":"<code>__init__(sampling_rate, start, end)</code>","text":"<p>Initialize trimming operation</p>"},{"location":"api/processing/#wandas.processing.temporal.Trim.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) start : float     Start time for trimming (seconds) end : float     End time for trimming (seconds)</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    start: float,\n    end: float,\n):\n    \"\"\"\n    Initialize trimming operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    start : float\n        Start time for trimming (seconds)\n    end : float\n        End time for trimming (seconds)\n    \"\"\"\n    super().__init__(sampling_rate, start=start, end=end)\n    self.start = start\n    self.end = end\n    self.start_sample = int(start * sampling_rate)\n    self.end_sample = int(end * sampling_rate)\n    logger.debug(\n        f\"Initialized Trim operation with start: {self.start}, end: {self.end}\"\n    )\n</code></pre>"},{"location":"api/processing/#wandas.processing.temporal.Trim.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/processing/#wandas.processing.temporal.Trim.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/processing/#wandas.processing.temporal.Trim.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    # Calculate length after trimming\n    # Exclude parts where there is no signal\n    end_sample = min(self.end_sample, input_shape[-1])\n    n_samples = end_sample - self.start_sample\n    return (*input_shape[:-1], n_samples)\n</code></pre>"},{"location":"api/processing/#wandas.processing.temporal.FixLength","title":"<code>FixLength</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>\u4fe1\u53f7\u306e\u9577\u3055\u3092\u6307\u5b9a\u3055\u308c\u305f\u9577\u3055\u306b\u8abf\u6574\u3059\u308b\u64cd\u4f5c</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>class FixLength(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"\u4fe1\u53f7\u306e\u9577\u3055\u3092\u6307\u5b9a\u3055\u308c\u305f\u9577\u3055\u306b\u8abf\u6574\u3059\u308b\u64cd\u4f5c\"\"\"\n\n    name = \"fix_length\"\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        length: Optional[int] = None,\n        duration: Optional[float] = None,\n    ):\n        \"\"\"\n        Initialize fix length operation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        length : Optional[int]\n            Target length for fixing\n        duration : Optional[float]\n            Target length for fixing\n        \"\"\"\n        if length is None:\n            if duration is None:\n                raise ValueError(\"Either length or duration must be provided.\")\n            else:\n                length = int(duration * sampling_rate)\n        self.target_length = length\n\n        super().__init__(sampling_rate, target_length=self.target_length)\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape\n\n        Returns\n        -------\n        tuple\n            Output data shape\n        \"\"\"\n        return (*input_shape[:-1], self.target_length)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for padding operation\"\"\"\n        logger.debug(f\"Applying padding to array with shape: {x.shape}\")\n        # Apply padding\n        pad_width = self.target_length - x.shape[-1]\n        if pad_width &gt; 0:\n            result = np.pad(x, ((0, 0), (0, pad_width)), mode=\"constant\")\n        else:\n            result = x[..., : self.target_length]\n        logger.debug(f\"Padding applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.temporal.FixLength-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.temporal.FixLength.name","title":"<code>name = 'fix_length'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.temporal.FixLength.target_length","title":"<code>target_length = length</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.temporal.FixLength-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.temporal.FixLength.__init__","title":"<code>__init__(sampling_rate, length=None, duration=None)</code>","text":"<p>Initialize fix length operation</p>"},{"location":"api/processing/#wandas.processing.temporal.FixLength.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) length : Optional[int]     Target length for fixing duration : Optional[float]     Target length for fixing</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    length: Optional[int] = None,\n    duration: Optional[float] = None,\n):\n    \"\"\"\n    Initialize fix length operation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    length : Optional[int]\n        Target length for fixing\n    duration : Optional[float]\n        Target length for fixing\n    \"\"\"\n    if length is None:\n        if duration is None:\n            raise ValueError(\"Either length or duration must be provided.\")\n        else:\n            length = int(duration * sampling_rate)\n    self.target_length = length\n\n    super().__init__(sampling_rate, target_length=self.target_length)\n</code></pre>"},{"location":"api/processing/#wandas.processing.temporal.FixLength.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/processing/#wandas.processing.temporal.FixLength.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape</p>"},{"location":"api/processing/#wandas.processing.temporal.FixLength.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape\n\n    Returns\n    -------\n    tuple\n        Output data shape\n    \"\"\"\n    return (*input_shape[:-1], self.target_length)\n</code></pre>"},{"location":"api/processing/#wandas.processing.temporal.RmsTrend","title":"<code>RmsTrend</code>","text":"<p>               Bases: <code>AudioOperation[NDArrayReal, NDArrayReal]</code></p> <p>RMS calculation</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>class RmsTrend(AudioOperation[NDArrayReal, NDArrayReal]):\n    \"\"\"RMS calculation\"\"\"\n\n    name = \"rms_trend\"\n    frame_length: int\n    hop_length: int\n    Aw: bool\n\n    def __init__(\n        self,\n        sampling_rate: float,\n        frame_length: int = 2048,\n        hop_length: int = 512,\n        ref: Union[list[float], float] = 1.0,\n        dB: bool = False,  # noqa: N803\n        Aw: bool = False,  # noqa: N803\n    ) -&gt; None:\n        \"\"\"\n        Initialize RMS calculation\n\n        Parameters\n        ----------\n        sampling_rate : float\n            Sampling rate (Hz)\n        frame_length : int\n            Frame length, default is 2048\n        hop_length : int\n            Hop length, default is 512\n        ref : Union[list[float], float]\n            Reference value(s) for dB calculation\n        dB : bool\n            Whether to convert to decibels\n        Aw : bool\n            Whether to apply A-weighting before RMS calculation\n        \"\"\"\n        self.frame_length = frame_length\n        self.hop_length = hop_length\n        self.dB = dB\n        self.Aw = Aw\n        self.ref = np.array(ref if isinstance(ref, list) else [ref])\n        super().__init__(\n            sampling_rate,\n            frame_length=frame_length,\n            hop_length=hop_length,\n            dB=dB,\n            Aw=Aw,\n            ref=self.ref,\n        )\n\n    def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n        \"\"\"\n        Calculate output data shape after operation\n\n        Parameters\n        ----------\n        input_shape : tuple\n            Input data shape (channels, samples)\n\n        Returns\n        -------\n        tuple\n            Output data shape (channels, frames)\n        \"\"\"\n        n_frames = librosa.feature.rms(\n            y=np.ones((1, input_shape[-1])),\n            frame_length=self.frame_length,\n            hop_length=self.hop_length,\n        ).shape[-1]\n        return (*input_shape[:-1], n_frames)\n\n    def _process_array(self, x: NDArrayReal) -&gt; NDArrayReal:\n        \"\"\"Create processor function for RMS calculation\"\"\"\n        logger.debug(f\"Applying RMS to array with shape: {x.shape}\")\n\n        if self.Aw:\n            # Apply A-weighting\n            _x = A_weight(x, self.sampling_rate)\n            if isinstance(_x, np.ndarray):\n                # A_weight\u304c\u30bf\u30d7\u30eb\u3092\u8fd4\u3059\u5834\u5408\u3001\u6700\u521d\u306e\u8981\u7d20\u3092\u4f7f\u7528\n                x = _x\n            elif isinstance(_x, tuple):\n                # Use the first element if A_weight returns a tuple\n                x = _x[0]\n            else:\n                raise ValueError(\"A_weighting returned an unexpected type.\")\n\n        # Calculate RMS\n        result: NDArrayReal = librosa.feature.rms(\n            y=x, frame_length=self.frame_length, hop_length=self.hop_length\n        )[..., 0, :]\n\n        if self.dB:\n            # Convert to dB\n            result = 20 * np.log10(\n                np.maximum(result / self.ref[..., np.newaxis], 1e-12)\n            )\n        #\n        logger.debug(f\"RMS applied, returning result with shape: {result.shape}\")\n        return result\n</code></pre>"},{"location":"api/processing/#wandas.processing.temporal.RmsTrend-attributes","title":"Attributes","text":""},{"location":"api/processing/#wandas.processing.temporal.RmsTrend.name","title":"<code>name = 'rms_trend'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.temporal.RmsTrend.frame_length","title":"<code>frame_length = frame_length</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.temporal.RmsTrend.hop_length","title":"<code>hop_length = hop_length</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.temporal.RmsTrend.dB","title":"<code>dB = dB</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.temporal.RmsTrend.Aw","title":"<code>Aw = Aw</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.temporal.RmsTrend.ref","title":"<code>ref = np.array(ref if isinstance(ref, list) else [ref])</code>  <code>instance-attribute</code>","text":""},{"location":"api/processing/#wandas.processing.temporal.RmsTrend-functions","title":"Functions","text":""},{"location":"api/processing/#wandas.processing.temporal.RmsTrend.__init__","title":"<code>__init__(sampling_rate, frame_length=2048, hop_length=512, ref=1.0, dB=False, Aw=False)</code>","text":"<p>Initialize RMS calculation</p>"},{"location":"api/processing/#wandas.processing.temporal.RmsTrend.__init__--parameters","title":"Parameters","text":"<p>sampling_rate : float     Sampling rate (Hz) frame_length : int     Frame length, default is 2048 hop_length : int     Hop length, default is 512 ref : Union[list[float], float]     Reference value(s) for dB calculation dB : bool     Whether to convert to decibels Aw : bool     Whether to apply A-weighting before RMS calculation</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def __init__(\n    self,\n    sampling_rate: float,\n    frame_length: int = 2048,\n    hop_length: int = 512,\n    ref: Union[list[float], float] = 1.0,\n    dB: bool = False,  # noqa: N803\n    Aw: bool = False,  # noqa: N803\n) -&gt; None:\n    \"\"\"\n    Initialize RMS calculation\n\n    Parameters\n    ----------\n    sampling_rate : float\n        Sampling rate (Hz)\n    frame_length : int\n        Frame length, default is 2048\n    hop_length : int\n        Hop length, default is 512\n    ref : Union[list[float], float]\n        Reference value(s) for dB calculation\n    dB : bool\n        Whether to convert to decibels\n    Aw : bool\n        Whether to apply A-weighting before RMS calculation\n    \"\"\"\n    self.frame_length = frame_length\n    self.hop_length = hop_length\n    self.dB = dB\n    self.Aw = Aw\n    self.ref = np.array(ref if isinstance(ref, list) else [ref])\n    super().__init__(\n        sampling_rate,\n        frame_length=frame_length,\n        hop_length=hop_length,\n        dB=dB,\n        Aw=Aw,\n        ref=self.ref,\n    )\n</code></pre>"},{"location":"api/processing/#wandas.processing.temporal.RmsTrend.calculate_output_shape","title":"<code>calculate_output_shape(input_shape)</code>","text":"<p>Calculate output data shape after operation</p>"},{"location":"api/processing/#wandas.processing.temporal.RmsTrend.calculate_output_shape--parameters","title":"Parameters","text":"<p>input_shape : tuple     Input data shape (channels, samples)</p>"},{"location":"api/processing/#wandas.processing.temporal.RmsTrend.calculate_output_shape--returns","title":"Returns","text":"<p>tuple     Output data shape (channels, frames)</p> Source code in <code>wandas/processing/temporal.py</code> <pre><code>def calculate_output_shape(self, input_shape: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Calculate output data shape after operation\n\n    Parameters\n    ----------\n    input_shape : tuple\n        Input data shape (channels, samples)\n\n    Returns\n    -------\n    tuple\n        Output data shape (channels, frames)\n    \"\"\"\n    n_frames = librosa.feature.rms(\n        y=np.ones((1, input_shape[-1])),\n        frame_length=self.frame_length,\n        hop_length=self.hop_length,\n    ).shape[-1]\n    return (*input_shape[:-1], n_frames)\n</code></pre>"},{"location":"api/processing/#wandas.processing.temporal-functions","title":"Functions","text":""},{"location":"api/utils/","title":"\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u30e2\u30b8\u30e5\u30fc\u30eb","text":"<p><code>wandas.utils</code> \u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u3001Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u4f7f\u7528\u3055\u308c\u308b\u69d8\u3005\u306a\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/utils/#_2","title":"\u30d5\u30ec\u30fc\u30e0\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8","text":"<p>\u8907\u6570\u306e\u30c7\u30fc\u30bf\u30d5\u30ec\u30fc\u30e0\u3092\u7ba1\u7406\u3059\u308b\u305f\u3081\u306e\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/utils/#wandas.utils.frame_dataset","title":"<code>wandas.utils.frame_dataset</code>","text":""},{"location":"api/utils/#wandas.utils.frame_dataset-attributes","title":"Attributes","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.FrameType","title":"<code>FrameType = Union[ChannelFrame, SpectrogramFrame]</code>  <code>module-attribute</code>","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.F","title":"<code>F = TypeVar('F', bound=FrameType)</code>  <code>module-attribute</code>","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.F_out","title":"<code>F_out = TypeVar('F_out', bound=FrameType)</code>  <code>module-attribute</code>","text":""},{"location":"api/utils/#wandas.utils.frame_dataset-classes","title":"Classes","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.LazyFrame","title":"<code>LazyFrame</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[F]</code></p> <p>A class that encapsulates a frame and its loading state.</p> <p>Attributes:</p> Name Type Description <code>file_path</code> <code>Path</code> <p>File path associated with the frame</p> <code>frame</code> <code>Optional[F]</code> <p>Loaded frame object (None if not loaded)</p> <code>is_loaded</code> <code>bool</code> <p>Flag indicating if the frame is loaded</p> <code>load_attempted</code> <code>bool</code> <p>Flag indicating if loading was attempted (for error detection)</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>@dataclass\nclass LazyFrame(Generic[F]):\n    \"\"\"\n    A class that encapsulates a frame and its loading state.\n\n    Attributes:\n        file_path: File path associated with the frame\n        frame: Loaded frame object (None if not loaded)\n        is_loaded: Flag indicating if the frame is loaded\n        load_attempted: Flag indicating if loading was attempted (for error detection)\n    \"\"\"\n\n    file_path: Path\n    frame: Optional[F] = None\n    is_loaded: bool = False\n    load_attempted: bool = False\n\n    def ensure_loaded(self, loader: Callable[[Path], Optional[F]]) -&gt; Optional[F]:\n        \"\"\"\n        Ensures the frame is loaded, loading it if necessary.\n\n        Args:\n            loader: Function to load a frame from a file path\n\n        Returns:\n            The loaded frame, or None if loading failed\n        \"\"\"\n        # Return the current frame if already loaded\n        if self.is_loaded:\n            return self.frame\n\n        # Attempt to load if not loaded yet\n        try:\n            self.load_attempted = True\n            self.frame = loader(self.file_path)\n            self.is_loaded = True\n            return self.frame\n        except Exception as e:\n            logger.error(f\"Failed to load file {self.file_path}: {str(e)}\")\n            self.is_loaded = True  # Loading was attempted\n            self.frame = None\n            return None\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Reset the frame state.\n        \"\"\"\n        self.frame = None\n        self.is_loaded = False\n        self.load_attempted = False\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.LazyFrame-attributes","title":"Attributes","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.LazyFrame.file_path","title":"<code>file_path</code>  <code>instance-attribute</code>","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.LazyFrame.frame","title":"<code>frame = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.LazyFrame.is_loaded","title":"<code>is_loaded = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.LazyFrame.load_attempted","title":"<code>load_attempted = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.LazyFrame-functions","title":"Functions","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.LazyFrame.__init__","title":"<code>__init__(file_path, frame=None, is_loaded=False, load_attempted=False)</code>","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.LazyFrame.ensure_loaded","title":"<code>ensure_loaded(loader)</code>","text":"<p>Ensures the frame is loaded, loading it if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>Callable[[Path], Optional[F]]</code> <p>Function to load a frame from a file path</p> required <p>Returns:</p> Type Description <code>Optional[F]</code> <p>The loaded frame, or None if loading failed</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def ensure_loaded(self, loader: Callable[[Path], Optional[F]]) -&gt; Optional[F]:\n    \"\"\"\n    Ensures the frame is loaded, loading it if necessary.\n\n    Args:\n        loader: Function to load a frame from a file path\n\n    Returns:\n        The loaded frame, or None if loading failed\n    \"\"\"\n    # Return the current frame if already loaded\n    if self.is_loaded:\n        return self.frame\n\n    # Attempt to load if not loaded yet\n    try:\n        self.load_attempted = True\n        self.frame = loader(self.file_path)\n        self.is_loaded = True\n        return self.frame\n    except Exception as e:\n        logger.error(f\"Failed to load file {self.file_path}: {str(e)}\")\n        self.is_loaded = True  # Loading was attempted\n        self.frame = None\n        return None\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.LazyFrame.reset","title":"<code>reset()</code>","text":"<p>Reset the frame state.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Reset the frame state.\n    \"\"\"\n    self.frame = None\n    self.is_loaded = False\n    self.load_attempted = False\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.FrameDataset","title":"<code>FrameDataset</code>","text":"<p>               Bases: <code>Generic[F]</code>, <code>ABC</code></p> <p>Abstract base dataset class for processing files in a folder. Includes lazy loading capability to efficiently handle large datasets. Subclasses handle specific frame types (ChannelFrame, SpectrogramFrame, etc.).</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>class FrameDataset(Generic[F], ABC):\n    \"\"\"\n    Abstract base dataset class for processing files in a folder.\n    Includes lazy loading capability to efficiently handle large datasets.\n    Subclasses handle specific frame types (ChannelFrame, SpectrogramFrame, etc.).\n    \"\"\"\n\n    def __init__(\n        self,\n        folder_path: str,\n        sampling_rate: Optional[int] = None,\n        signal_length: Optional[int] = None,\n        file_extensions: Optional[list[str]] = None,\n        lazy_loading: bool = True,\n        recursive: bool = False,\n        source_dataset: Optional[\"FrameDataset[Any]\"] = None,\n        transform: Optional[Callable[[Any], Optional[F]]] = None,\n    ):\n        self.folder_path = Path(folder_path)\n        if source_dataset is None and not self.folder_path.exists():\n            raise FileNotFoundError(f\"Folder does not exist: {self.folder_path}\")\n\n        self.sampling_rate = sampling_rate\n        self.signal_length = signal_length\n        self.file_extensions = file_extensions or [\".wav\"]\n        self._recursive = recursive\n        self._lazy_loading = lazy_loading\n\n        # Changed to a list of LazyFrame\n        self._lazy_frames: list[LazyFrame[F]] = []\n\n        self._source_dataset = source_dataset\n        self._transform = transform\n\n        if self._source_dataset:\n            self._initialize_from_source()\n        else:\n            self._initialize_from_folder()\n\n    def _initialize_from_source(self) -&gt; None:\n        \"\"\"Initialize from a source dataset.\"\"\"\n        if self._source_dataset is None:\n            return\n\n        # Copy file paths from source\n        file_paths = self._source_dataset._get_file_paths()\n        self._lazy_frames = [LazyFrame(file_path) for file_path in file_paths]\n\n        # Inherit other properties\n        self.sampling_rate = self.sampling_rate or self._source_dataset.sampling_rate\n        self.signal_length = self.signal_length or self._source_dataset.signal_length\n        self.file_extensions = (\n            self.file_extensions or self._source_dataset.file_extensions\n        )\n        self._recursive = self._source_dataset._recursive\n        self.folder_path = self._source_dataset.folder_path\n\n    def _initialize_from_folder(self) -&gt; None:\n        \"\"\"Initialize from a folder.\"\"\"\n        self._discover_files()\n        if not self._lazy_loading:\n            self._load_all_files()\n\n    def _discover_files(self) -&gt; None:\n        \"\"\"Discover files in the folder and store them in a list of LazyFrame.\"\"\"\n        file_paths = []\n        for ext in self.file_extensions:\n            pattern = f\"**/*{ext}\" if self._recursive else f\"*{ext}\"\n            file_paths.extend(\n                sorted(p for p in self.folder_path.glob(pattern) if p.is_file())\n            )\n\n        # Remove duplicates and sort\n        file_paths = sorted(list(set(file_paths)))\n\n        # Create a list of LazyFrame\n        self._lazy_frames = [LazyFrame(file_path) for file_path in file_paths]\n\n    def _load_all_files(self) -&gt; None:\n        \"\"\"Load all files.\"\"\"\n        for i in tqdm(range(len(self._lazy_frames)), desc=\"Loading/transforming\"):\n            try:\n                self._ensure_loaded(i)\n            except Exception as e:\n                filepath = self._lazy_frames[i].file_path\n                logger.warning(\n                    f\"Failed to load/transform index {i} ({filepath}): {str(e)}\"\n                )\n        self._lazy_loading = False\n\n    @abstractmethod\n    def _load_file(self, file_path: Path) -&gt; Optional[F]:\n        \"\"\"Abstract method to load a frame from a file.\"\"\"\n        pass\n\n    def _load_from_source(self, index: int) -&gt; Optional[F]:\n        \"\"\"Load a frame from the source dataset and transform it if necessary.\"\"\"\n        if self._source_dataset is None or self._transform is None:\n            return None\n\n        source_frame = self._source_dataset._ensure_loaded(index)\n        if source_frame is None:\n            return None\n\n        try:\n            return self._transform(source_frame)\n        except Exception as e:\n            logger.warning(f\"Failed to transform index {index}: {str(e)}\")\n            return None\n\n    def _ensure_loaded(self, index: int) -&gt; Optional[F]:\n        \"\"\"Ensure the frame at the given index is loaded.\"\"\"\n        if not (0 &lt;= index &lt; len(self._lazy_frames)):\n            raise IndexError(\n                f\"Index {index} is out of range (0-{len(self._lazy_frames) - 1})\"\n            )\n\n        lazy_frame = self._lazy_frames[index]\n\n        # Return if already loaded\n        if lazy_frame.is_loaded:\n            return lazy_frame.frame\n\n        try:\n            # Convert from source dataset\n            if self._transform and self._source_dataset:\n                lazy_frame.load_attempted = True\n                frame = self._load_from_source(index)\n                lazy_frame.frame = frame\n                lazy_frame.is_loaded = True\n                return frame\n            # Load directly from file\n            else:\n                return lazy_frame.ensure_loaded(self._load_file)\n        except Exception as e:\n            f_path = lazy_frame.file_path\n            logger.error(\n                f\"Failed to load or initialize index {index} ({f_path}): {str(e)}\"\n            )\n            lazy_frame.frame = None\n            lazy_frame.is_loaded = True\n            lazy_frame.load_attempted = True\n            return None\n\n    def _get_file_paths(self) -&gt; list[Path]:\n        \"\"\"Get a list of file paths.\"\"\"\n        return [lazy_frame.file_path for lazy_frame in self._lazy_frames]\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of files in the dataset.\"\"\"\n        return len(self._lazy_frames)\n\n    def __getitem__(self, index: int) -&gt; Optional[F]:\n        \"\"\"Get the frame at the specified index.\"\"\"\n        return self._ensure_loaded(index)\n\n    @overload\n    def apply(self, func: Callable[[F], Optional[F_out]]) -&gt; \"FrameDataset[F_out]\": ...\n\n    @overload\n    def apply(self, func: Callable[[F], Optional[Any]]) -&gt; \"FrameDataset[Any]\": ...\n\n    def apply(self, func: Callable[[F], Optional[Any]]) -&gt; \"FrameDataset[Any]\":\n        \"\"\"Apply a function to the entire dataset to create a new dataset.\"\"\"\n        new_dataset = type(self)(\n            folder_path=str(self.folder_path),\n            lazy_loading=True,\n            source_dataset=self,\n            transform=func,\n            sampling_rate=self.sampling_rate,\n            signal_length=self.signal_length,\n            file_extensions=self.file_extensions,\n            recursive=self._recursive,\n        )\n        return cast(\"FrameDataset[Any]\", new_dataset)\n\n    def save(self, output_folder: str, filename_prefix: str = \"\") -&gt; None:\n        \"\"\"Save processed frames to files.\"\"\"\n        raise NotImplementedError(\"The save method is not currently implemented.\")\n\n    def sample(\n        self,\n        n: Optional[int] = None,\n        ratio: Optional[float] = None,\n        seed: Optional[int] = None,\n    ) -&gt; \"FrameDataset[F]\":\n        \"\"\"Get a sample from the dataset.\"\"\"\n        if seed is not None:\n            random.seed(seed)\n\n        total = len(self._lazy_frames)\n        if total == 0:\n            return type(self)(\n                str(self.folder_path),\n                sampling_rate=self.sampling_rate,\n                signal_length=self.signal_length,\n                file_extensions=self.file_extensions,\n                lazy_loading=self._lazy_loading,\n                recursive=self._recursive,\n            )\n\n        # Determine sample size\n        if n is None and ratio is None:\n            n = max(1, min(10, int(total * 0.1)))\n        elif n is None and ratio is not None:\n            n = max(1, int(total * ratio))\n        elif n is not None:\n            n = max(1, n)\n        else:\n            n = 1\n\n        n = min(n, total)\n\n        # Randomly select indices\n        sampled_indices = sorted(random.sample(range(total), n))\n\n        return _SampledFrameDataset(self, sampled_indices)\n\n    def get_metadata(self) -&gt; dict[str, Any]:\n        \"\"\"Get metadata for the dataset.\"\"\"\n        actual_sr: Optional[Union[int, float]] = self.sampling_rate\n        frame_type_name = \"Unknown\"\n\n        # Count loaded frames\n        loaded_count = sum(\n            1 for lazy_frame in self._lazy_frames if lazy_frame.is_loaded\n        )\n\n        # Get metadata from the first frame (if possible)\n        first_frame: Optional[F] = None\n        if len(self._lazy_frames) &gt; 0:\n            try:\n                if self._lazy_frames[0].is_loaded:\n                    first_frame = self._lazy_frames[0].frame\n\n                if first_frame:\n                    actual_sr = getattr(\n                        first_frame, \"sampling_rate\", self.sampling_rate\n                    )\n                    frame_type_name = type(first_frame).__name__\n            except Exception as e:\n                logger.warning(\n                    f\"Error accessing the first frame during metadata retrieval: {e}\"\n                )\n\n        return {\n            \"folder_path\": str(self.folder_path),\n            \"file_count\": len(self._lazy_frames),\n            \"loaded_count\": loaded_count,\n            \"target_sampling_rate\": self.sampling_rate,\n            \"actual_sampling_rate\": actual_sr,\n            \"signal_length\": self.signal_length,\n            \"file_extensions\": self.file_extensions,\n            \"lazy_loading\": self._lazy_loading,\n            \"recursive\": self._recursive,\n            \"frame_type\": frame_type_name,\n            \"has_transform\": self._transform is not None,\n            \"is_sampled\": isinstance(self, _SampledFrameDataset),\n        }\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.FrameDataset-attributes","title":"Attributes","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.FrameDataset.folder_path","title":"<code>folder_path = Path(folder_path)</code>  <code>instance-attribute</code>","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.FrameDataset.sampling_rate","title":"<code>sampling_rate = sampling_rate</code>  <code>instance-attribute</code>","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.FrameDataset.signal_length","title":"<code>signal_length = signal_length</code>  <code>instance-attribute</code>","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.FrameDataset.file_extensions","title":"<code>file_extensions = file_extensions or ['.wav']</code>  <code>instance-attribute</code>","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.FrameDataset-functions","title":"Functions","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.FrameDataset.__init__","title":"<code>__init__(folder_path, sampling_rate=None, signal_length=None, file_extensions=None, lazy_loading=True, recursive=False, source_dataset=None, transform=None)</code>","text":"Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def __init__(\n    self,\n    folder_path: str,\n    sampling_rate: Optional[int] = None,\n    signal_length: Optional[int] = None,\n    file_extensions: Optional[list[str]] = None,\n    lazy_loading: bool = True,\n    recursive: bool = False,\n    source_dataset: Optional[\"FrameDataset[Any]\"] = None,\n    transform: Optional[Callable[[Any], Optional[F]]] = None,\n):\n    self.folder_path = Path(folder_path)\n    if source_dataset is None and not self.folder_path.exists():\n        raise FileNotFoundError(f\"Folder does not exist: {self.folder_path}\")\n\n    self.sampling_rate = sampling_rate\n    self.signal_length = signal_length\n    self.file_extensions = file_extensions or [\".wav\"]\n    self._recursive = recursive\n    self._lazy_loading = lazy_loading\n\n    # Changed to a list of LazyFrame\n    self._lazy_frames: list[LazyFrame[F]] = []\n\n    self._source_dataset = source_dataset\n    self._transform = transform\n\n    if self._source_dataset:\n        self._initialize_from_source()\n    else:\n        self._initialize_from_folder()\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.FrameDataset.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of files in the dataset.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of files in the dataset.\"\"\"\n    return len(self._lazy_frames)\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.FrameDataset.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Get the frame at the specified index.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def __getitem__(self, index: int) -&gt; Optional[F]:\n    \"\"\"Get the frame at the specified index.\"\"\"\n    return self._ensure_loaded(index)\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.FrameDataset.apply","title":"<code>apply(func)</code>","text":"<pre><code>apply(\n    func: Callable[[F], Optional[F_out]],\n) -&gt; FrameDataset[F_out]\n</code></pre><pre><code>apply(\n    func: Callable[[F], Optional[Any]],\n) -&gt; FrameDataset[Any]\n</code></pre> <p>Apply a function to the entire dataset to create a new dataset.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def apply(self, func: Callable[[F], Optional[Any]]) -&gt; \"FrameDataset[Any]\":\n    \"\"\"Apply a function to the entire dataset to create a new dataset.\"\"\"\n    new_dataset = type(self)(\n        folder_path=str(self.folder_path),\n        lazy_loading=True,\n        source_dataset=self,\n        transform=func,\n        sampling_rate=self.sampling_rate,\n        signal_length=self.signal_length,\n        file_extensions=self.file_extensions,\n        recursive=self._recursive,\n    )\n    return cast(\"FrameDataset[Any]\", new_dataset)\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.FrameDataset.save","title":"<code>save(output_folder, filename_prefix='')</code>","text":"<p>Save processed frames to files.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def save(self, output_folder: str, filename_prefix: str = \"\") -&gt; None:\n    \"\"\"Save processed frames to files.\"\"\"\n    raise NotImplementedError(\"The save method is not currently implemented.\")\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.FrameDataset.sample","title":"<code>sample(n=None, ratio=None, seed=None)</code>","text":"<p>Get a sample from the dataset.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def sample(\n    self,\n    n: Optional[int] = None,\n    ratio: Optional[float] = None,\n    seed: Optional[int] = None,\n) -&gt; \"FrameDataset[F]\":\n    \"\"\"Get a sample from the dataset.\"\"\"\n    if seed is not None:\n        random.seed(seed)\n\n    total = len(self._lazy_frames)\n    if total == 0:\n        return type(self)(\n            str(self.folder_path),\n            sampling_rate=self.sampling_rate,\n            signal_length=self.signal_length,\n            file_extensions=self.file_extensions,\n            lazy_loading=self._lazy_loading,\n            recursive=self._recursive,\n        )\n\n    # Determine sample size\n    if n is None and ratio is None:\n        n = max(1, min(10, int(total * 0.1)))\n    elif n is None and ratio is not None:\n        n = max(1, int(total * ratio))\n    elif n is not None:\n        n = max(1, n)\n    else:\n        n = 1\n\n    n = min(n, total)\n\n    # Randomly select indices\n    sampled_indices = sorted(random.sample(range(total), n))\n\n    return _SampledFrameDataset(self, sampled_indices)\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.FrameDataset.get_metadata","title":"<code>get_metadata()</code>","text":"<p>Get metadata for the dataset.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def get_metadata(self) -&gt; dict[str, Any]:\n    \"\"\"Get metadata for the dataset.\"\"\"\n    actual_sr: Optional[Union[int, float]] = self.sampling_rate\n    frame_type_name = \"Unknown\"\n\n    # Count loaded frames\n    loaded_count = sum(\n        1 for lazy_frame in self._lazy_frames if lazy_frame.is_loaded\n    )\n\n    # Get metadata from the first frame (if possible)\n    first_frame: Optional[F] = None\n    if len(self._lazy_frames) &gt; 0:\n        try:\n            if self._lazy_frames[0].is_loaded:\n                first_frame = self._lazy_frames[0].frame\n\n            if first_frame:\n                actual_sr = getattr(\n                    first_frame, \"sampling_rate\", self.sampling_rate\n                )\n                frame_type_name = type(first_frame).__name__\n        except Exception as e:\n            logger.warning(\n                f\"Error accessing the first frame during metadata retrieval: {e}\"\n            )\n\n    return {\n        \"folder_path\": str(self.folder_path),\n        \"file_count\": len(self._lazy_frames),\n        \"loaded_count\": loaded_count,\n        \"target_sampling_rate\": self.sampling_rate,\n        \"actual_sampling_rate\": actual_sr,\n        \"signal_length\": self.signal_length,\n        \"file_extensions\": self.file_extensions,\n        \"lazy_loading\": self._lazy_loading,\n        \"recursive\": self._recursive,\n        \"frame_type\": frame_type_name,\n        \"has_transform\": self._transform is not None,\n        \"is_sampled\": isinstance(self, _SampledFrameDataset),\n    }\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.ChannelFrameDataset","title":"<code>ChannelFrameDataset</code>","text":"<p>               Bases: <code>FrameDataset[ChannelFrame]</code></p> <p>Dataset class for handling audio files as ChannelFrames in a folder.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>class ChannelFrameDataset(FrameDataset[ChannelFrame]):\n    \"\"\"\n    Dataset class for handling audio files as ChannelFrames in a folder.\n    \"\"\"\n\n    def __init__(\n        self,\n        folder_path: str,\n        sampling_rate: Optional[int] = None,\n        signal_length: Optional[int] = None,\n        file_extensions: Optional[list[str]] = None,\n        lazy_loading: bool = True,\n        recursive: bool = False,\n        source_dataset: Optional[\"FrameDataset[Any]\"] = None,\n        transform: Optional[Callable[[Any], Optional[ChannelFrame]]] = None,\n    ):\n        _file_extensions = file_extensions or [\n            \".wav\",\n            \".mp3\",\n            \".flac\",\n            \".csv\",\n        ]\n\n        super().__init__(\n            folder_path=folder_path,\n            sampling_rate=sampling_rate,\n            signal_length=signal_length,\n            file_extensions=_file_extensions,\n            lazy_loading=lazy_loading,\n            recursive=recursive,\n            source_dataset=source_dataset,\n            transform=transform,\n        )\n\n    def _load_file(self, file_path: Path) -&gt; Optional[ChannelFrame]:\n        \"\"\"Load an audio file and return a ChannelFrame.\"\"\"\n        try:\n            frame = ChannelFrame.from_file(file_path)\n            if self.sampling_rate and frame.sampling_rate != self.sampling_rate:\n                logger.info(\n                    f\"Resampling file {file_path.name} ({frame.sampling_rate} Hz) to \"\n                    f\"dataset rate ({self.sampling_rate} Hz).\"\n                )\n                frame = frame.resampling(target_sr=self.sampling_rate)\n            return frame\n        except Exception as e:\n            logger.error(f\"Failed to load or initialize file {file_path}: {str(e)}\")\n            return None\n\n    def resample(self, target_sr: int) -&gt; \"ChannelFrameDataset\":\n        \"\"\"Resample all frames in the dataset.\"\"\"\n\n        def _resample_func(frame: ChannelFrame) -&gt; Optional[ChannelFrame]:\n            if frame is None:\n                return None\n            try:\n                return frame.resampling(target_sr=target_sr)\n            except Exception as e:\n                logger.warning(f\"Resampling error (target_sr={target_sr}): {e}\")\n                return None\n\n        new_dataset = self.apply(_resample_func)\n        return cast(ChannelFrameDataset, new_dataset)\n\n    def trim(self, start: float, end: float) -&gt; \"ChannelFrameDataset\":\n        \"\"\"Trim all frames in the dataset.\"\"\"\n\n        def _trim_func(frame: ChannelFrame) -&gt; Optional[ChannelFrame]:\n            if frame is None:\n                return None\n            try:\n                return frame.trim(start=start, end=end)\n            except Exception as e:\n                logger.warning(f\"Trimming error (start={start}, end={end}): {e}\")\n                return None\n\n        new_dataset = self.apply(_trim_func)\n        return cast(ChannelFrameDataset, new_dataset)\n\n    def normalize(self, **kwargs: Any) -&gt; \"ChannelFrameDataset\":\n        \"\"\"Normalize all frames in the dataset.\"\"\"\n\n        def _normalize_func(frame: ChannelFrame) -&gt; Optional[ChannelFrame]:\n            if frame is None:\n                return None\n            try:\n                return frame.normalize(**kwargs)\n            except Exception as e:\n                logger.warning(f\"Normalization error ({kwargs}): {e}\")\n                return None\n\n        new_dataset = self.apply(_normalize_func)\n        return cast(ChannelFrameDataset, new_dataset)\n\n    def stft(\n        self,\n        n_fft: int = 2048,\n        hop_length: Optional[int] = None,\n        win_length: Optional[int] = None,\n        window: str = \"hann\",\n    ) -&gt; \"SpectrogramFrameDataset\":\n        \"\"\"Apply STFT to all frames in the dataset.\"\"\"\n        _hop = hop_length or n_fft // 4\n\n        def _stft_func(frame: ChannelFrame) -&gt; Optional[SpectrogramFrame]:\n            if frame is None:\n                return None\n            try:\n                return frame.stft(\n                    n_fft=n_fft,\n                    hop_length=_hop,\n                    win_length=win_length,\n                    window=window,\n                )\n            except Exception as e:\n                logger.warning(f\"STFT error (n_fft={n_fft}, hop={_hop}): {e}\")\n                return None\n\n        new_dataset = SpectrogramFrameDataset(\n            folder_path=str(self.folder_path),\n            lazy_loading=True,\n            source_dataset=self,\n            transform=_stft_func,\n            sampling_rate=self.sampling_rate,\n        )\n        return new_dataset\n\n    @classmethod\n    def from_folder(\n        cls,\n        folder_path: str,\n        sampling_rate: Optional[int] = None,\n        file_extensions: Optional[list[str]] = None,\n        recursive: bool = False,\n        lazy_loading: bool = True,\n    ) -&gt; \"ChannelFrameDataset\":\n        \"\"\"Class method to create a ChannelFrameDataset from a folder.\"\"\"\n        extensions = (\n            file_extensions\n            if file_extensions is not None\n            else [\".wav\", \".mp3\", \".flac\", \".csv\"]\n        )\n\n        return cls(\n            folder_path,\n            sampling_rate=sampling_rate,\n            file_extensions=extensions,\n            lazy_loading=lazy_loading,\n            recursive=recursive,\n        )\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.ChannelFrameDataset-functions","title":"Functions","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.ChannelFrameDataset.__init__","title":"<code>__init__(folder_path, sampling_rate=None, signal_length=None, file_extensions=None, lazy_loading=True, recursive=False, source_dataset=None, transform=None)</code>","text":"Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def __init__(\n    self,\n    folder_path: str,\n    sampling_rate: Optional[int] = None,\n    signal_length: Optional[int] = None,\n    file_extensions: Optional[list[str]] = None,\n    lazy_loading: bool = True,\n    recursive: bool = False,\n    source_dataset: Optional[\"FrameDataset[Any]\"] = None,\n    transform: Optional[Callable[[Any], Optional[ChannelFrame]]] = None,\n):\n    _file_extensions = file_extensions or [\n        \".wav\",\n        \".mp3\",\n        \".flac\",\n        \".csv\",\n    ]\n\n    super().__init__(\n        folder_path=folder_path,\n        sampling_rate=sampling_rate,\n        signal_length=signal_length,\n        file_extensions=_file_extensions,\n        lazy_loading=lazy_loading,\n        recursive=recursive,\n        source_dataset=source_dataset,\n        transform=transform,\n    )\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.ChannelFrameDataset.resample","title":"<code>resample(target_sr)</code>","text":"<p>Resample all frames in the dataset.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def resample(self, target_sr: int) -&gt; \"ChannelFrameDataset\":\n    \"\"\"Resample all frames in the dataset.\"\"\"\n\n    def _resample_func(frame: ChannelFrame) -&gt; Optional[ChannelFrame]:\n        if frame is None:\n            return None\n        try:\n            return frame.resampling(target_sr=target_sr)\n        except Exception as e:\n            logger.warning(f\"Resampling error (target_sr={target_sr}): {e}\")\n            return None\n\n    new_dataset = self.apply(_resample_func)\n    return cast(ChannelFrameDataset, new_dataset)\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.ChannelFrameDataset.trim","title":"<code>trim(start, end)</code>","text":"<p>Trim all frames in the dataset.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def trim(self, start: float, end: float) -&gt; \"ChannelFrameDataset\":\n    \"\"\"Trim all frames in the dataset.\"\"\"\n\n    def _trim_func(frame: ChannelFrame) -&gt; Optional[ChannelFrame]:\n        if frame is None:\n            return None\n        try:\n            return frame.trim(start=start, end=end)\n        except Exception as e:\n            logger.warning(f\"Trimming error (start={start}, end={end}): {e}\")\n            return None\n\n    new_dataset = self.apply(_trim_func)\n    return cast(ChannelFrameDataset, new_dataset)\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.ChannelFrameDataset.normalize","title":"<code>normalize(**kwargs)</code>","text":"<p>Normalize all frames in the dataset.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def normalize(self, **kwargs: Any) -&gt; \"ChannelFrameDataset\":\n    \"\"\"Normalize all frames in the dataset.\"\"\"\n\n    def _normalize_func(frame: ChannelFrame) -&gt; Optional[ChannelFrame]:\n        if frame is None:\n            return None\n        try:\n            return frame.normalize(**kwargs)\n        except Exception as e:\n            logger.warning(f\"Normalization error ({kwargs}): {e}\")\n            return None\n\n    new_dataset = self.apply(_normalize_func)\n    return cast(ChannelFrameDataset, new_dataset)\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.ChannelFrameDataset.stft","title":"<code>stft(n_fft=2048, hop_length=None, win_length=None, window='hann')</code>","text":"<p>Apply STFT to all frames in the dataset.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def stft(\n    self,\n    n_fft: int = 2048,\n    hop_length: Optional[int] = None,\n    win_length: Optional[int] = None,\n    window: str = \"hann\",\n) -&gt; \"SpectrogramFrameDataset\":\n    \"\"\"Apply STFT to all frames in the dataset.\"\"\"\n    _hop = hop_length or n_fft // 4\n\n    def _stft_func(frame: ChannelFrame) -&gt; Optional[SpectrogramFrame]:\n        if frame is None:\n            return None\n        try:\n            return frame.stft(\n                n_fft=n_fft,\n                hop_length=_hop,\n                win_length=win_length,\n                window=window,\n            )\n        except Exception as e:\n            logger.warning(f\"STFT error (n_fft={n_fft}, hop={_hop}): {e}\")\n            return None\n\n    new_dataset = SpectrogramFrameDataset(\n        folder_path=str(self.folder_path),\n        lazy_loading=True,\n        source_dataset=self,\n        transform=_stft_func,\n        sampling_rate=self.sampling_rate,\n    )\n    return new_dataset\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.ChannelFrameDataset.from_folder","title":"<code>from_folder(folder_path, sampling_rate=None, file_extensions=None, recursive=False, lazy_loading=True)</code>  <code>classmethod</code>","text":"<p>Class method to create a ChannelFrameDataset from a folder.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>@classmethod\ndef from_folder(\n    cls,\n    folder_path: str,\n    sampling_rate: Optional[int] = None,\n    file_extensions: Optional[list[str]] = None,\n    recursive: bool = False,\n    lazy_loading: bool = True,\n) -&gt; \"ChannelFrameDataset\":\n    \"\"\"Class method to create a ChannelFrameDataset from a folder.\"\"\"\n    extensions = (\n        file_extensions\n        if file_extensions is not None\n        else [\".wav\", \".mp3\", \".flac\", \".csv\"]\n    )\n\n    return cls(\n        folder_path,\n        sampling_rate=sampling_rate,\n        file_extensions=extensions,\n        lazy_loading=lazy_loading,\n        recursive=recursive,\n    )\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.SpectrogramFrameDataset","title":"<code>SpectrogramFrameDataset</code>","text":"<p>               Bases: <code>FrameDataset[SpectrogramFrame]</code></p> <p>Dataset class for handling spectrogram data as SpectrogramFrames. Expected to be generated mainly as a result of ChannelFrameDataset.stft().</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>class SpectrogramFrameDataset(FrameDataset[SpectrogramFrame]):\n    \"\"\"\n    Dataset class for handling spectrogram data as SpectrogramFrames.\n    Expected to be generated mainly as a result of ChannelFrameDataset.stft().\n    \"\"\"\n\n    def __init__(\n        self,\n        folder_path: str,\n        sampling_rate: Optional[int] = None,\n        signal_length: Optional[int] = None,\n        file_extensions: Optional[list[str]] = None,\n        lazy_loading: bool = True,\n        recursive: bool = False,\n        source_dataset: Optional[\"FrameDataset[Any]\"] = None,\n        transform: Optional[Callable[[Any], Optional[SpectrogramFrame]]] = None,\n    ):\n        super().__init__(\n            folder_path=folder_path,\n            sampling_rate=sampling_rate,\n            signal_length=signal_length,\n            file_extensions=file_extensions,\n            lazy_loading=lazy_loading,\n            recursive=recursive,\n            source_dataset=source_dataset,\n            transform=transform,\n        )\n\n    def _load_file(self, file_path: Path) -&gt; Optional[SpectrogramFrame]:\n        \"\"\"Direct loading from files is not currently supported.\"\"\"\n        logger.warning(\n            \"No method defined for directly loading SpectrogramFrames. Normally \"\n            \"created from ChannelFrameDataset.stft().\"\n        )\n        raise NotImplementedError(\n            \"No method defined for directly loading SpectrogramFrames\"\n        )\n\n    def plot(self, index: int, **kwargs: Any) -&gt; None:\n        \"\"\"Plot the spectrogram at the specified index.\"\"\"\n        try:\n            frame = self._ensure_loaded(index)\n\n            if frame is None:\n                logger.warning(\n                    f\"Cannot plot index {index} as it failed to load/transform.\"\n                )\n                return\n\n            plot_method = getattr(frame, \"plot\", None)\n            if callable(plot_method):\n                plot_method(**kwargs)\n            else:\n                logger.warning(\n                    f\"Frame (index {index}, type {type(frame).__name__}) does not \"\n                    f\"have a plot method implemented.\"\n                )\n        except Exception as e:\n            logger.error(f\"An error occurred while plotting index {index}: {e}\")\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.SpectrogramFrameDataset-functions","title":"Functions","text":""},{"location":"api/utils/#wandas.utils.frame_dataset.SpectrogramFrameDataset.__init__","title":"<code>__init__(folder_path, sampling_rate=None, signal_length=None, file_extensions=None, lazy_loading=True, recursive=False, source_dataset=None, transform=None)</code>","text":"Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def __init__(\n    self,\n    folder_path: str,\n    sampling_rate: Optional[int] = None,\n    signal_length: Optional[int] = None,\n    file_extensions: Optional[list[str]] = None,\n    lazy_loading: bool = True,\n    recursive: bool = False,\n    source_dataset: Optional[\"FrameDataset[Any]\"] = None,\n    transform: Optional[Callable[[Any], Optional[SpectrogramFrame]]] = None,\n):\n    super().__init__(\n        folder_path=folder_path,\n        sampling_rate=sampling_rate,\n        signal_length=signal_length,\n        file_extensions=file_extensions,\n        lazy_loading=lazy_loading,\n        recursive=recursive,\n        source_dataset=source_dataset,\n        transform=transform,\n    )\n</code></pre>"},{"location":"api/utils/#wandas.utils.frame_dataset.SpectrogramFrameDataset.plot","title":"<code>plot(index, **kwargs)</code>","text":"<p>Plot the spectrogram at the specified index.</p> Source code in <code>wandas/utils/frame_dataset.py</code> <pre><code>def plot(self, index: int, **kwargs: Any) -&gt; None:\n    \"\"\"Plot the spectrogram at the specified index.\"\"\"\n    try:\n        frame = self._ensure_loaded(index)\n\n        if frame is None:\n            logger.warning(\n                f\"Cannot plot index {index} as it failed to load/transform.\"\n            )\n            return\n\n        plot_method = getattr(frame, \"plot\", None)\n        if callable(plot_method):\n            plot_method(**kwargs)\n        else:\n            logger.warning(\n                f\"Frame (index {index}, type {type(frame).__name__}) does not \"\n                f\"have a plot method implemented.\"\n            )\n    except Exception as e:\n        logger.error(f\"An error occurred while plotting index {index}: {e}\")\n</code></pre>"},{"location":"api/utils/#_3","title":"\u30b5\u30f3\u30d7\u30eb\u751f\u6210","text":"<p>\u30c6\u30b9\u30c8\u7528\u306e\u30b5\u30f3\u30d7\u30eb\u30c7\u30fc\u30bf\u3092\u751f\u6210\u3059\u308b\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/utils/#wandas.utils.generate_sample","title":"<code>wandas.utils.generate_sample</code>","text":""},{"location":"api/utils/#wandas.utils.generate_sample-classes","title":"Classes","text":""},{"location":"api/utils/#wandas.utils.generate_sample-functions","title":"Functions","text":""},{"location":"api/utils/#wandas.utils.generate_sample.generate_sin","title":"<code>generate_sin(freqs=1000, sampling_rate=16000, duration=1.0, label=None)</code>","text":"<p>Generate sample sine wave signals.</p>"},{"location":"api/utils/#wandas.utils.generate_sample.generate_sin--parameters","title":"Parameters","text":"<p>freqs : float or list of float, default=1000     Frequency of the sine wave(s) in Hz.     If multiple frequencies are specified, multiple channels will be created. sampling_rate : int, default=16000     Sampling rate in Hz. duration : float, default=1.0     Duration of the signal in seconds. label : str, optional     Label for the entire signal.</p>"},{"location":"api/utils/#wandas.utils.generate_sample.generate_sin--returns","title":"Returns","text":"<p>ChannelFrame     ChannelFrame object containing the sine wave(s).</p> Source code in <code>wandas/utils/generate_sample.py</code> <pre><code>def generate_sin(\n    freqs: Union[float, list[float]] = 1000,\n    sampling_rate: int = 16000,\n    duration: float = 1.0,\n    label: Optional[str] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Generate sample sine wave signals.\n\n    Parameters\n    ----------\n    freqs : float or list of float, default=1000\n        Frequency of the sine wave(s) in Hz.\n        If multiple frequencies are specified, multiple channels will be created.\n    sampling_rate : int, default=16000\n        Sampling rate in Hz.\n    duration : float, default=1.0\n        Duration of the signal in seconds.\n    label : str, optional\n        Label for the entire signal.\n\n    Returns\n    -------\n    ChannelFrame\n        ChannelFrame object containing the sine wave(s).\n    \"\"\"\n    # \u76f4\u63a5\u3001generate_sin_lazy\u95a2\u6570\u3092\u547c\u3073\u51fa\u3059\n    return generate_sin_lazy(\n        freqs=freqs, sampling_rate=sampling_rate, duration=duration, label=label\n    )\n</code></pre>"},{"location":"api/utils/#wandas.utils.generate_sample.generate_sin_lazy","title":"<code>generate_sin_lazy(freqs=1000, sampling_rate=16000, duration=1.0, label=None)</code>","text":"<p>Generate sample sine wave signals using lazy computation.</p>"},{"location":"api/utils/#wandas.utils.generate_sample.generate_sin_lazy--parameters","title":"Parameters","text":"<p>freqs : float or list of float, default=1000     Frequency of the sine wave(s) in Hz.     If multiple frequencies are specified, multiple channels will be created. sampling_rate : int, default=16000     Sampling rate in Hz. duration : float, default=1.0     Duration of the signal in seconds. label : str, optional     Label for the entire signal.</p>"},{"location":"api/utils/#wandas.utils.generate_sample.generate_sin_lazy--returns","title":"Returns","text":"<p>ChannelFrame     Lazy ChannelFrame object containing the sine wave(s).</p> Source code in <code>wandas/utils/generate_sample.py</code> <pre><code>def generate_sin_lazy(\n    freqs: Union[float, list[float]] = 1000,\n    sampling_rate: int = 16000,\n    duration: float = 1.0,\n    label: Optional[str] = None,\n) -&gt; \"ChannelFrame\":\n    \"\"\"\n    Generate sample sine wave signals using lazy computation.\n\n    Parameters\n    ----------\n    freqs : float or list of float, default=1000\n        Frequency of the sine wave(s) in Hz.\n        If multiple frequencies are specified, multiple channels will be created.\n    sampling_rate : int, default=16000\n        Sampling rate in Hz.\n    duration : float, default=1.0\n        Duration of the signal in seconds.\n    label : str, optional\n        Label for the entire signal.\n\n    Returns\n    -------\n    ChannelFrame\n        Lazy ChannelFrame object containing the sine wave(s).\n    \"\"\"\n    from wandas.frames.channel import ChannelFrame\n\n    label = label or \"Generated Sin\"\n    t = np.linspace(0, duration, int(sampling_rate * duration), endpoint=False)\n\n    _freqs: list[float]\n    if isinstance(freqs, float):\n        _freqs = [freqs]\n    elif isinstance(freqs, list):\n        _freqs = freqs\n    else:\n        raise ValueError(\"freqs must be a float or a list of floats.\")\n\n    channels = []\n    labels = []\n    for idx, freq in enumerate(_freqs):\n        data = np.sin(2 * np.pi * freq * t) * 2 * np.sqrt(2)\n        labels.append(f\"Channel {idx + 1}\")\n        channels.append(data)\n    return ChannelFrame.from_numpy(\n        data=np.array(channels),\n        label=label,\n        sampling_rate=sampling_rate,\n        ch_labels=labels,\n    )\n</code></pre>"},{"location":"api/utils/#_4","title":"\u578b\u5b9a\u7fa9","text":"<p>Wandas\u3067\u4f7f\u7528\u3055\u308c\u308b\u578b\u5b9a\u7fa9\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/utils/#wandas.utils.types","title":"<code>wandas.utils.types</code>","text":""},{"location":"api/utils/#wandas.utils.types-attributes","title":"Attributes","text":""},{"location":"api/utils/#wandas.utils.types.Real","title":"<code>Real = np.number[Any]</code>  <code>module-attribute</code>","text":""},{"location":"api/utils/#wandas.utils.types.Complex","title":"<code>Complex = np.complexfloating[Any, Any]</code>  <code>module-attribute</code>","text":""},{"location":"api/utils/#wandas.utils.types.NDArrayReal","title":"<code>NDArrayReal = npt.NDArray[Real]</code>  <code>module-attribute</code>","text":""},{"location":"api/utils/#wandas.utils.types.NDArrayComplex","title":"<code>NDArrayComplex = npt.NDArray[Complex]</code>  <code>module-attribute</code>","text":""},{"location":"api/utils/#_5","title":"\u4e00\u822c\u7684\u306a\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3","text":"<p>\u305d\u306e\u4ed6\u306e\u4e00\u822c\u7684\u306a\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u95a2\u6570\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/utils/#wandas.utils.util","title":"<code>wandas.utils.util</code>","text":""},{"location":"api/utils/#wandas.utils.util-attributes","title":"Attributes","text":""},{"location":"api/utils/#wandas.utils.util-functions","title":"Functions","text":""},{"location":"api/utils/#wandas.utils.util.unit_to_ref","title":"<code>unit_to_ref(unit)</code>","text":"<p>Convert unit to reference value.</p>"},{"location":"api/utils/#wandas.utils.util.unit_to_ref--parameters","title":"Parameters","text":"<p>unit : str     Unit string.</p>"},{"location":"api/utils/#wandas.utils.util.unit_to_ref--returns","title":"Returns","text":"<p>float     Reference value for the unit. For 'Pa', returns 2e-5 (20 \u03bcPa).     For other units, returns 1.0.</p> Source code in <code>wandas/utils/util.py</code> <pre><code>def unit_to_ref(unit: str) -&gt; float:\n    \"\"\"\n    Convert unit to reference value.\n\n    Parameters\n    ----------\n    unit : str\n        Unit string.\n\n    Returns\n    -------\n    float\n        Reference value for the unit. For 'Pa', returns 2e-5 (20 \u03bcPa).\n        For other units, returns 1.0.\n    \"\"\"\n    if unit == \"Pa\":\n        return 2e-5\n\n    else:\n        return 1.0\n</code></pre>"},{"location":"api/utils/#wandas.utils.util.calculate_rms","title":"<code>calculate_rms(wave)</code>","text":"<p>Calculate the root mean square of the wave.</p>"},{"location":"api/utils/#wandas.utils.util.calculate_rms--parameters","title":"Parameters","text":"<p>wave : NDArrayReal     Input waveform data. Can be multi-channel (shape: [channels, samples])     or single channel (shape: [samples]).</p>"},{"location":"api/utils/#wandas.utils.util.calculate_rms--returns","title":"Returns","text":"<p>Union[float, NDArray[np.float64]]     RMS value(s). For multi-channel input, returns an array of RMS values,     one per channel. For single-channel input, returns a single RMS value.</p> Source code in <code>wandas/utils/util.py</code> <pre><code>def calculate_rms(wave: \"NDArrayReal\") -&gt; \"NDArrayReal\":\n    \"\"\"\n    Calculate the root mean square of the wave.\n\n    Parameters\n    ----------\n    wave : NDArrayReal\n        Input waveform data. Can be multi-channel (shape: [channels, samples])\n        or single channel (shape: [samples]).\n\n    Returns\n    -------\n    Union[float, NDArray[np.float64]]\n        RMS value(s). For multi-channel input, returns an array of RMS values,\n        one per channel. For single-channel input, returns a single RMS value.\n    \"\"\"\n    # Calculate RMS considering axis (over the last dimension)\n    axis_to_use = -1 if wave.ndim &gt; 1 else None\n    rms_values: NDArrayReal = np.sqrt(\n        np.mean(np.square(wave), axis=axis_to_use, keepdims=True)\n    )\n    return rms_values\n</code></pre>"},{"location":"api/utils/#wandas.utils.util.calculate_desired_noise_rms","title":"<code>calculate_desired_noise_rms(clean_rms, snr)</code>","text":"<p>Calculate the desired noise RMS based on clean signal RMS and target SNR.</p>"},{"location":"api/utils/#wandas.utils.util.calculate_desired_noise_rms--parameters","title":"Parameters","text":"<p>clean_rms : \"NDArrayReal\"     RMS value(s) of the clean signal.     Can be a single value or an array for multi-channel. snr : float     Target Signal-to-Noise Ratio in dB.</p>"},{"location":"api/utils/#wandas.utils.util.calculate_desired_noise_rms--returns","title":"Returns","text":"<p>\"NDArrayReal\"     Desired noise RMS value(s) to achieve the target SNR.</p> Source code in <code>wandas/utils/util.py</code> <pre><code>def calculate_desired_noise_rms(clean_rms: \"NDArrayReal\", snr: float) -&gt; \"NDArrayReal\":\n    \"\"\"\n    Calculate the desired noise RMS based on clean signal RMS and target SNR.\n\n    Parameters\n    ----------\n    clean_rms : \"NDArrayReal\"\n        RMS value(s) of the clean signal.\n        Can be a single value or an array for multi-channel.\n    snr : float\n        Target Signal-to-Noise Ratio in dB.\n\n    Returns\n    -------\n    \"NDArrayReal\"\n        Desired noise RMS value(s) to achieve the target SNR.\n    \"\"\"\n    a = snr / 20\n    noise_rms = clean_rms / (10**a)\n    return noise_rms\n</code></pre>"},{"location":"api/utils/#wandas.utils.util.amplitude_to_db","title":"<code>amplitude_to_db(amplitude, ref)</code>","text":"<p>Convert amplitude to decibel.</p>"},{"location":"api/utils/#wandas.utils.util.amplitude_to_db--parameters","title":"Parameters","text":"<p>amplitude : NDArrayReal     Input amplitude data. ref : float     Reference value for conversion.</p>"},{"location":"api/utils/#wandas.utils.util.amplitude_to_db--returns","title":"Returns","text":"<p>NDArrayReal     Amplitude data converted to decibels.</p> Source code in <code>wandas/utils/util.py</code> <pre><code>def amplitude_to_db(amplitude: \"NDArrayReal\", ref: float) -&gt; \"NDArrayReal\":\n    \"\"\"\n    Convert amplitude to decibel.\n\n    Parameters\n    ----------\n    amplitude : NDArrayReal\n        Input amplitude data.\n    ref : float\n        Reference value for conversion.\n\n    Returns\n    -------\n    NDArrayReal\n        Amplitude data converted to decibels.\n    \"\"\"\n    db: NDArrayReal = librosa.amplitude_to_db(\n        np.abs(amplitude), ref=ref, amin=1e-15, top_db=None\n    )\n    return db\n</code></pre>"},{"location":"api/utils/#wandas.utils.util.level_trigger","title":"<code>level_trigger(data, level, offset=0, hold=1)</code>","text":"<p>Find points where the signal crosses the specified level from below.</p>"},{"location":"api/utils/#wandas.utils.util.level_trigger--parameters","title":"Parameters","text":"<p>data : NDArrayReal     Input signal data. level : float     Threshold level for triggering. offset : int, default=0     Offset to add to trigger points. hold : int, default=1     Minimum number of samples between successive trigger points.</p>"},{"location":"api/utils/#wandas.utils.util.level_trigger--returns","title":"Returns","text":"<p>list of int     List of sample indices where the signal crosses the level.</p> Source code in <code>wandas/utils/util.py</code> <pre><code>def level_trigger(\n    data: \"NDArrayReal\", level: float, offset: int = 0, hold: int = 1\n) -&gt; list[int]:\n    \"\"\"\n    Find points where the signal crosses the specified level from below.\n\n    Parameters\n    ----------\n    data : NDArrayReal\n        Input signal data.\n    level : float\n        Threshold level for triggering.\n    offset : int, default=0\n        Offset to add to trigger points.\n    hold : int, default=1\n        Minimum number of samples between successive trigger points.\n\n    Returns\n    -------\n    list of int\n        List of sample indices where the signal crosses the level.\n    \"\"\"\n    trig_point: list[int] = []\n\n    sig_len = len(data)\n    diff = np.diff(np.sign(data - level))\n    level_point = np.where(diff &gt; 0)[0]\n    level_point = level_point[(level_point + hold) &lt; sig_len]\n\n    if len(level_point) == 0:\n        return list()\n\n    last_point = level_point[0]\n    trig_point.append(last_point + offset)\n    for i in level_point:\n        if (last_point + hold) &lt; i:\n            trig_point.append(i + offset)\n            last_point = i\n\n    return trig_point\n</code></pre>"},{"location":"api/utils/#wandas.utils.util.cut_sig","title":"<code>cut_sig(data, point_list, cut_len, taper_rate=0, dc_cut=False)</code>","text":"<p>Cut segments from signal at specified points.</p>"},{"location":"api/utils/#wandas.utils.util.cut_sig--parameters","title":"Parameters","text":"<p>data : NDArrayReal     Input signal data. point_list : list of int     List of starting points for cutting. cut_len : int     Length of each segment to cut. taper_rate : float, default=0     Taper rate for Tukey window applied to segments.     A value of 0 means no tapering, 1 means full tapering. dc_cut : bool, default=False     Whether to remove DC component (mean) from segments.</p>"},{"location":"api/utils/#wandas.utils.util.cut_sig--returns","title":"Returns","text":"<p>NDArrayReal     Array containing cut segments with shape (n_segments, cut_len).</p> Source code in <code>wandas/utils/util.py</code> <pre><code>def cut_sig(\n    data: \"NDArrayReal\",\n    point_list: list[int],\n    cut_len: int,\n    taper_rate: float = 0,\n    dc_cut: bool = False,\n) -&gt; \"NDArrayReal\":\n    \"\"\"\n    Cut segments from signal at specified points.\n\n    Parameters\n    ----------\n    data : NDArrayReal\n        Input signal data.\n    point_list : list of int\n        List of starting points for cutting.\n    cut_len : int\n        Length of each segment to cut.\n    taper_rate : float, default=0\n        Taper rate for Tukey window applied to segments.\n        A value of 0 means no tapering, 1 means full tapering.\n    dc_cut : bool, default=False\n        Whether to remove DC component (mean) from segments.\n\n    Returns\n    -------\n    NDArrayReal\n        Array containing cut segments with shape (n_segments, cut_len).\n    \"\"\"\n    length = len(data)\n    point_list_ = [p for p in point_list if p &gt;= 0 and p + cut_len &lt;= length]\n    trial = np.zeros((len(point_list_), cut_len))\n\n    for i, v in enumerate(point_list_):\n        trial[i] = data[v : v + cut_len]\n        if dc_cut:\n            trial[i] = trial[i] - trial[i].mean()\n\n    trial = trial * tukey(cut_len, taper_rate)\n    return trial\n</code></pre>"},{"location":"api/visualization/","title":"\u53ef\u8996\u5316\u30e2\u30b8\u30e5\u30fc\u30eb","text":"<p><code>wandas.visualization</code> \u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u3001\u30aa\u30fc\u30c7\u30a3\u30aa\u30c7\u30fc\u30bf\u3092\u8996\u899a\u7684\u306b\u8868\u73fe\u3059\u308b\u305f\u3081\u306e\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/visualization/#_2","title":"\u30d7\u30ed\u30c3\u30c6\u30a3\u30f3\u30b0","text":"<p>\u30aa\u30fc\u30c7\u30a3\u30aa\u30c7\u30fc\u30bf\u3092\u8996\u899a\u5316\u3059\u308b\u305f\u3081\u306e\u30d7\u30ed\u30c3\u30c6\u30a3\u30f3\u30b0\u95a2\u6570\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002</p>"},{"location":"api/visualization/#wandas.visualization.plotting","title":"<code>wandas.visualization.plotting</code>","text":""},{"location":"api/visualization/#wandas.visualization.plotting-attributes","title":"Attributes","text":""},{"location":"api/visualization/#wandas.visualization.plotting.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/visualization/#wandas.visualization.plotting.TFrame","title":"<code>TFrame = TypeVar('TFrame', bound='BaseFrame[Any]')</code>  <code>module-attribute</code>","text":""},{"location":"api/visualization/#wandas.visualization.plotting-classes","title":"Classes","text":""},{"location":"api/visualization/#wandas.visualization.plotting.PlotStrategy","title":"<code>PlotStrategy</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[TFrame]</code></p> <p>Base class for plotting strategies</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>class PlotStrategy(abc.ABC, Generic[TFrame]):\n    \"\"\"Base class for plotting strategies\"\"\"\n\n    name: ClassVar[str]\n\n    @abc.abstractmethod\n    def channel_plot(self, x: Any, y: Any, ax: \"Axes\") -&gt; None:\n        \"\"\"Implementation of channel plotting\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def plot(\n        self,\n        bf: TFrame,\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = False,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Implementation of plotting\"\"\"\n        pass\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.PlotStrategy-attributes","title":"Attributes","text":""},{"location":"api/visualization/#wandas.visualization.plotting.PlotStrategy.name","title":"<code>name</code>  <code>class-attribute</code>","text":""},{"location":"api/visualization/#wandas.visualization.plotting.PlotStrategy-functions","title":"Functions","text":""},{"location":"api/visualization/#wandas.visualization.plotting.PlotStrategy.channel_plot","title":"<code>channel_plot(x, y, ax)</code>  <code>abstractmethod</code>","text":"<p>Implementation of channel plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>@abc.abstractmethod\ndef channel_plot(self, x: Any, y: Any, ax: \"Axes\") -&gt; None:\n    \"\"\"Implementation of channel plotting\"\"\"\n    pass\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.PlotStrategy.plot","title":"<code>plot(bf, ax=None, title=None, overlay=False, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Implementation of plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>@abc.abstractmethod\ndef plot(\n    self,\n    bf: TFrame,\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = False,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Implementation of plotting\"\"\"\n    pass\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.WaveformPlotStrategy","title":"<code>WaveformPlotStrategy</code>","text":"<p>               Bases: <code>PlotStrategy['ChannelFrame']</code></p> <p>Strategy for waveform plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>class WaveformPlotStrategy(PlotStrategy[\"ChannelFrame\"]):\n    \"\"\"Strategy for waveform plotting\"\"\"\n\n    name = \"waveform\"\n\n    def channel_plot(\n        self,\n        x: Any,\n        y: Any,\n        ax: \"Axes\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Implementation of channel plotting\"\"\"\n        ax.plot(x, y, **kwargs)\n        ax.set_ylabel(\"Amplitude\")\n        ax.grid(True)\n        if \"label\" in kwargs:\n            ax.legend()\n\n    def plot(\n        self,\n        bf: \"ChannelFrame\",\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = False,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Waveform plotting\"\"\"\n        kwargs = kwargs or {}\n        ylabel = kwargs.pop(\"ylabel\", \"Amplitude\")\n        xlabel = kwargs.pop(\"xlabel\", \"Time [s]\")\n        alpha = kwargs.pop(\"alpha\", 1)\n        plot_kwargs = filter_kwargs(\n            Line2D,\n            kwargs,\n            strict_mode=True,\n        )\n        ax_set = filter_kwargs(\n            Axes.set,\n            kwargs,\n            strict_mode=True,\n        )\n        if overlay:\n            if ax is None:\n                fig, ax = plt.subplots(figsize=(10, 4))\n            self.channel_plot(\n                bf.time, bf.data.T, ax, label=bf.labels, alpha=alpha, **plot_kwargs\n            )\n            ax.set(\n                ylabel=ylabel,\n                title=title or bf.label or \"Channel Data\",\n                xlabel=xlabel,\n                **ax_set,\n            )\n            if ax is None:\n                fig.suptitle(title or bf.label or None)\n                plt.tight_layout()\n                plt.show()\n            return ax\n        else:\n            num_channels = bf.n_channels\n            fig, axs = plt.subplots(\n                num_channels, 1, figsize=(10, 4 * num_channels), sharex=True\n            )\n            # Convert axs to list if it is a single Axes object\n            if not isinstance(axs, (list, np.ndarray)):\n                axs = [axs]\n\n            axes_list = list(axs)\n            data = bf.data\n            for ax_i, channel_data, ch_meta in zip(axes_list, data, bf.channels):\n                self.channel_plot(\n                    bf.time, channel_data, ax_i, alpha=alpha, **plot_kwargs\n                )\n                ax_i.set(\n                    ylabel=ylabel,\n                    title=ch_meta.label,\n                    **ax_set,\n                )\n\n            axes_list[-1].set(\n                ylabel=ylabel,\n                xlabel=\"Time [s]\",\n            )\n            fig.suptitle(title or bf.label or \"Channel Data\")\n\n            if ax is None:\n                plt.tight_layout()\n                plt.show()\n\n            return _return_axes_iterator(fig.axes)\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.WaveformPlotStrategy-attributes","title":"Attributes","text":""},{"location":"api/visualization/#wandas.visualization.plotting.WaveformPlotStrategy.name","title":"<code>name = 'waveform'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/visualization/#wandas.visualization.plotting.WaveformPlotStrategy-functions","title":"Functions","text":""},{"location":"api/visualization/#wandas.visualization.plotting.WaveformPlotStrategy.channel_plot","title":"<code>channel_plot(x, y, ax, **kwargs)</code>","text":"<p>Implementation of channel plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def channel_plot(\n    self,\n    x: Any,\n    y: Any,\n    ax: \"Axes\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Implementation of channel plotting\"\"\"\n    ax.plot(x, y, **kwargs)\n    ax.set_ylabel(\"Amplitude\")\n    ax.grid(True)\n    if \"label\" in kwargs:\n        ax.legend()\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.WaveformPlotStrategy.plot","title":"<code>plot(bf, ax=None, title=None, overlay=False, **kwargs)</code>","text":"<p>Waveform plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def plot(\n    self,\n    bf: \"ChannelFrame\",\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = False,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Waveform plotting\"\"\"\n    kwargs = kwargs or {}\n    ylabel = kwargs.pop(\"ylabel\", \"Amplitude\")\n    xlabel = kwargs.pop(\"xlabel\", \"Time [s]\")\n    alpha = kwargs.pop(\"alpha\", 1)\n    plot_kwargs = filter_kwargs(\n        Line2D,\n        kwargs,\n        strict_mode=True,\n    )\n    ax_set = filter_kwargs(\n        Axes.set,\n        kwargs,\n        strict_mode=True,\n    )\n    if overlay:\n        if ax is None:\n            fig, ax = plt.subplots(figsize=(10, 4))\n        self.channel_plot(\n            bf.time, bf.data.T, ax, label=bf.labels, alpha=alpha, **plot_kwargs\n        )\n        ax.set(\n            ylabel=ylabel,\n            title=title or bf.label or \"Channel Data\",\n            xlabel=xlabel,\n            **ax_set,\n        )\n        if ax is None:\n            fig.suptitle(title or bf.label or None)\n            plt.tight_layout()\n            plt.show()\n        return ax\n    else:\n        num_channels = bf.n_channels\n        fig, axs = plt.subplots(\n            num_channels, 1, figsize=(10, 4 * num_channels), sharex=True\n        )\n        # Convert axs to list if it is a single Axes object\n        if not isinstance(axs, (list, np.ndarray)):\n            axs = [axs]\n\n        axes_list = list(axs)\n        data = bf.data\n        for ax_i, channel_data, ch_meta in zip(axes_list, data, bf.channels):\n            self.channel_plot(\n                bf.time, channel_data, ax_i, alpha=alpha, **plot_kwargs\n            )\n            ax_i.set(\n                ylabel=ylabel,\n                title=ch_meta.label,\n                **ax_set,\n            )\n\n        axes_list[-1].set(\n            ylabel=ylabel,\n            xlabel=\"Time [s]\",\n        )\n        fig.suptitle(title or bf.label or \"Channel Data\")\n\n        if ax is None:\n            plt.tight_layout()\n            plt.show()\n\n        return _return_axes_iterator(fig.axes)\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.FrequencyPlotStrategy","title":"<code>FrequencyPlotStrategy</code>","text":"<p>               Bases: <code>PlotStrategy['SpectralFrame']</code></p> <p>Strategy for frequency domain plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>class FrequencyPlotStrategy(PlotStrategy[\"SpectralFrame\"]):\n    \"\"\"Strategy for frequency domain plotting\"\"\"\n\n    name = \"frequency\"\n\n    def channel_plot(\n        self,\n        x: Any,\n        y: Any,\n        ax: \"Axes\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Implementation of channel plotting\"\"\"\n        ax.plot(x, y, **kwargs)\n        ax.grid(True)\n        if \"label\" in kwargs:\n            ax.legend()\n\n    def plot(\n        self,\n        bf: \"SpectralFrame\",\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = False,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Frequency domain plotting\"\"\"\n        kwargs = kwargs or {}\n        is_aw = kwargs.pop(\"Aw\", False)\n        if bf.operation_history[-1][\"operation\"] == \"coherence\":\n            unit = \"\"\n            data = bf.magnitude\n            ylabel = kwargs.pop(\"ylabel\", \"coherence\")\n        else:\n            if is_aw:\n                unit = \"dBA\"\n                data = bf.dBA\n            else:\n                unit = \"dB\"\n                data = bf.dB\n            ylabel = kwargs.pop(\"ylabel\", f\"Spectrum level [{unit}]\")\n        xlabel = kwargs.pop(\"xlabel\", \"Frequency [Hz]\")\n        alpha = kwargs.pop(\"alpha\", 1)\n        plot_kwargs = filter_kwargs(Line2D, kwargs, strict_mode=True)\n        ax_set = filter_kwargs(Axes.set, kwargs, strict_mode=True)\n        if overlay:\n            if ax is None:\n                _, ax = plt.subplots(figsize=(10, 4))\n            self.channel_plot(\n                bf.freqs,\n                data.T,\n                ax,\n                label=bf.labels,\n                alpha=alpha,\n                **plot_kwargs,\n            )\n            ax.set(\n                ylabel=ylabel,\n                xlabel=xlabel,\n                title=title or bf.label or \"Channel Data\",\n                **ax_set,\n            )\n            if ax is None:\n                plt.tight_layout()\n                plt.show()\n            return ax\n        else:\n            num_channels = bf.n_channels\n            fig, axs = plt.subplots(\n                num_channels, 1, figsize=(10, 4 * num_channels), sharex=True\n            )\n            # Convert axs to list if it is a single Axes object\n            if not isinstance(axs, (list, np.ndarray)):\n                axs = [axs]\n\n            axes_list = list(axs)\n            for ax_i, channel_data, ch_meta in zip(axes_list, data, bf.channels):\n                self.channel_plot(\n                    bf.freqs,\n                    channel_data,\n                    ax_i,\n                    label=ch_meta.label,\n                    alpha=alpha,\n                    **plot_kwargs,\n                )\n                ax_i.set(\n                    ylabel=ylabel,\n                    title=ch_meta.label,\n                    xlabel=xlabel,\n                    **ax_set,\n                )\n            axes_list[-1].set(ylabel=ylabel, xlabel=xlabel)\n            fig.suptitle(title or bf.label or \"Channel Data\")\n            if ax is None:\n                plt.tight_layout()\n                plt.show()\n            return _return_axes_iterator(fig.axes)\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.FrequencyPlotStrategy-attributes","title":"Attributes","text":""},{"location":"api/visualization/#wandas.visualization.plotting.FrequencyPlotStrategy.name","title":"<code>name = 'frequency'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/visualization/#wandas.visualization.plotting.FrequencyPlotStrategy-functions","title":"Functions","text":""},{"location":"api/visualization/#wandas.visualization.plotting.FrequencyPlotStrategy.channel_plot","title":"<code>channel_plot(x, y, ax, **kwargs)</code>","text":"<p>Implementation of channel plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def channel_plot(\n    self,\n    x: Any,\n    y: Any,\n    ax: \"Axes\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Implementation of channel plotting\"\"\"\n    ax.plot(x, y, **kwargs)\n    ax.grid(True)\n    if \"label\" in kwargs:\n        ax.legend()\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.FrequencyPlotStrategy.plot","title":"<code>plot(bf, ax=None, title=None, overlay=False, **kwargs)</code>","text":"<p>Frequency domain plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def plot(\n    self,\n    bf: \"SpectralFrame\",\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = False,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Frequency domain plotting\"\"\"\n    kwargs = kwargs or {}\n    is_aw = kwargs.pop(\"Aw\", False)\n    if bf.operation_history[-1][\"operation\"] == \"coherence\":\n        unit = \"\"\n        data = bf.magnitude\n        ylabel = kwargs.pop(\"ylabel\", \"coherence\")\n    else:\n        if is_aw:\n            unit = \"dBA\"\n            data = bf.dBA\n        else:\n            unit = \"dB\"\n            data = bf.dB\n        ylabel = kwargs.pop(\"ylabel\", f\"Spectrum level [{unit}]\")\n    xlabel = kwargs.pop(\"xlabel\", \"Frequency [Hz]\")\n    alpha = kwargs.pop(\"alpha\", 1)\n    plot_kwargs = filter_kwargs(Line2D, kwargs, strict_mode=True)\n    ax_set = filter_kwargs(Axes.set, kwargs, strict_mode=True)\n    if overlay:\n        if ax is None:\n            _, ax = plt.subplots(figsize=(10, 4))\n        self.channel_plot(\n            bf.freqs,\n            data.T,\n            ax,\n            label=bf.labels,\n            alpha=alpha,\n            **plot_kwargs,\n        )\n        ax.set(\n            ylabel=ylabel,\n            xlabel=xlabel,\n            title=title or bf.label or \"Channel Data\",\n            **ax_set,\n        )\n        if ax is None:\n            plt.tight_layout()\n            plt.show()\n        return ax\n    else:\n        num_channels = bf.n_channels\n        fig, axs = plt.subplots(\n            num_channels, 1, figsize=(10, 4 * num_channels), sharex=True\n        )\n        # Convert axs to list if it is a single Axes object\n        if not isinstance(axs, (list, np.ndarray)):\n            axs = [axs]\n\n        axes_list = list(axs)\n        for ax_i, channel_data, ch_meta in zip(axes_list, data, bf.channels):\n            self.channel_plot(\n                bf.freqs,\n                channel_data,\n                ax_i,\n                label=ch_meta.label,\n                alpha=alpha,\n                **plot_kwargs,\n            )\n            ax_i.set(\n                ylabel=ylabel,\n                title=ch_meta.label,\n                xlabel=xlabel,\n                **ax_set,\n            )\n        axes_list[-1].set(ylabel=ylabel, xlabel=xlabel)\n        fig.suptitle(title or bf.label or \"Channel Data\")\n        if ax is None:\n            plt.tight_layout()\n            plt.show()\n        return _return_axes_iterator(fig.axes)\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.NOctPlotStrategy","title":"<code>NOctPlotStrategy</code>","text":"<p>               Bases: <code>PlotStrategy['NOctFrame']</code></p> <p>Strategy for N-octave band analysis plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>class NOctPlotStrategy(PlotStrategy[\"NOctFrame\"]):\n    \"\"\"Strategy for N-octave band analysis plotting\"\"\"\n\n    name = \"noct\"\n\n    def channel_plot(\n        self,\n        x: Any,\n        y: Any,\n        ax: \"Axes\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Implementation of channel plotting\"\"\"\n        ax.step(x, y, **kwargs)\n        ax.grid(True)\n        if \"label\" in kwargs:\n            ax.legend()\n\n    def plot(\n        self,\n        bf: \"NOctFrame\",\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = False,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"N-octave band analysis plotting\"\"\"\n        kwargs = kwargs or {}\n        is_aw = kwargs.pop(\"Aw\", False)\n\n        if is_aw:\n            unit = \"dBrA\"\n            data = bf.dBA\n        else:\n            unit = \"dBr\"\n            data = bf.dB\n        ylabel = kwargs.pop(\"ylabel\", f\"Spectrum level [{unit}]\")\n        xlabel = kwargs.pop(\"xlabel\", \"Center frequency [Hz]\")\n        alpha = kwargs.pop(\"alpha\", 1)\n        plot_kwargs = filter_kwargs(Line2D, kwargs, strict_mode=True)\n        ax_set = filter_kwargs(Axes.set, kwargs, strict_mode=True)\n        if overlay:\n            if ax is None:\n                _, ax = plt.subplots(figsize=(10, 4))\n            self.channel_plot(\n                bf.freqs,\n                data.T,\n                ax,\n                label=bf.labels,\n                alpha=alpha,\n                **plot_kwargs,\n            )\n            ax.set(\n                ylabel=ylabel,\n                xlabel=xlabel,\n                title=title or bf.label or f\"1/{str(bf.n)}-Octave Spectrum\",\n                **ax_set,\n            )\n            if ax is None:\n                plt.tight_layout()\n                plt.show()\n            return ax\n        else:\n            num_channels = bf.n_channels\n            fig, axs = plt.subplots(\n                num_channels, 1, figsize=(10, 4 * num_channels), sharex=True\n            )\n            # Convert axs to list if it is a single Axes object\n            if not isinstance(axs, (list, np.ndarray)):\n                axs = [axs]\n\n            axes_list = list(axs)\n            for ax_i, channel_data, ch_meta in zip(axes_list, data, bf.channels):\n                self.channel_plot(\n                    bf.freqs,\n                    channel_data,\n                    ax_i,\n                    label=ch_meta.label,\n                    alpha=alpha,\n                    **plot_kwargs,\n                )\n                ax_i.set(\n                    ylabel=ylabel,\n                    title=ch_meta.label,\n                    xlabel=xlabel,\n                    **ax_set,\n                )\n            axes_list[-1].set(ylabel=ylabel, xlabel=xlabel)\n            fig.suptitle(title or bf.label or f\"1/{str(bf.n)}-Octave Spectrum\")\n            if ax is None:\n                plt.tight_layout()\n                plt.show()\n            return _return_axes_iterator(fig.axes)\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.NOctPlotStrategy-attributes","title":"Attributes","text":""},{"location":"api/visualization/#wandas.visualization.plotting.NOctPlotStrategy.name","title":"<code>name = 'noct'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/visualization/#wandas.visualization.plotting.NOctPlotStrategy-functions","title":"Functions","text":""},{"location":"api/visualization/#wandas.visualization.plotting.NOctPlotStrategy.channel_plot","title":"<code>channel_plot(x, y, ax, **kwargs)</code>","text":"<p>Implementation of channel plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def channel_plot(\n    self,\n    x: Any,\n    y: Any,\n    ax: \"Axes\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Implementation of channel plotting\"\"\"\n    ax.step(x, y, **kwargs)\n    ax.grid(True)\n    if \"label\" in kwargs:\n        ax.legend()\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.NOctPlotStrategy.plot","title":"<code>plot(bf, ax=None, title=None, overlay=False, **kwargs)</code>","text":"<p>N-octave band analysis plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def plot(\n    self,\n    bf: \"NOctFrame\",\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = False,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"N-octave band analysis plotting\"\"\"\n    kwargs = kwargs or {}\n    is_aw = kwargs.pop(\"Aw\", False)\n\n    if is_aw:\n        unit = \"dBrA\"\n        data = bf.dBA\n    else:\n        unit = \"dBr\"\n        data = bf.dB\n    ylabel = kwargs.pop(\"ylabel\", f\"Spectrum level [{unit}]\")\n    xlabel = kwargs.pop(\"xlabel\", \"Center frequency [Hz]\")\n    alpha = kwargs.pop(\"alpha\", 1)\n    plot_kwargs = filter_kwargs(Line2D, kwargs, strict_mode=True)\n    ax_set = filter_kwargs(Axes.set, kwargs, strict_mode=True)\n    if overlay:\n        if ax is None:\n            _, ax = plt.subplots(figsize=(10, 4))\n        self.channel_plot(\n            bf.freqs,\n            data.T,\n            ax,\n            label=bf.labels,\n            alpha=alpha,\n            **plot_kwargs,\n        )\n        ax.set(\n            ylabel=ylabel,\n            xlabel=xlabel,\n            title=title or bf.label or f\"1/{str(bf.n)}-Octave Spectrum\",\n            **ax_set,\n        )\n        if ax is None:\n            plt.tight_layout()\n            plt.show()\n        return ax\n    else:\n        num_channels = bf.n_channels\n        fig, axs = plt.subplots(\n            num_channels, 1, figsize=(10, 4 * num_channels), sharex=True\n        )\n        # Convert axs to list if it is a single Axes object\n        if not isinstance(axs, (list, np.ndarray)):\n            axs = [axs]\n\n        axes_list = list(axs)\n        for ax_i, channel_data, ch_meta in zip(axes_list, data, bf.channels):\n            self.channel_plot(\n                bf.freqs,\n                channel_data,\n                ax_i,\n                label=ch_meta.label,\n                alpha=alpha,\n                **plot_kwargs,\n            )\n            ax_i.set(\n                ylabel=ylabel,\n                title=ch_meta.label,\n                xlabel=xlabel,\n                **ax_set,\n            )\n        axes_list[-1].set(ylabel=ylabel, xlabel=xlabel)\n        fig.suptitle(title or bf.label or f\"1/{str(bf.n)}-Octave Spectrum\")\n        if ax is None:\n            plt.tight_layout()\n            plt.show()\n        return _return_axes_iterator(fig.axes)\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.SpectrogramPlotStrategy","title":"<code>SpectrogramPlotStrategy</code>","text":"<p>               Bases: <code>PlotStrategy['SpectrogramFrame']</code></p> <p>Strategy for spectrogram plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>class SpectrogramPlotStrategy(PlotStrategy[\"SpectrogramFrame\"]):\n    \"\"\"Strategy for spectrogram plotting\"\"\"\n\n    name = \"spectrogram\"\n\n    def channel_plot(\n        self,\n        x: Any,\n        y: Any,\n        ax: \"Axes\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Implementation of channel plotting\"\"\"\n        pass\n\n    def plot(\n        self,\n        bf: \"SpectrogramFrame\",\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = False,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Spectrogram plotting\"\"\"\n        if overlay:\n            raise ValueError(\"Overlay is not supported for SpectrogramPlotStrategy.\")\n\n        if ax is not None and bf.n_channels &gt; 1:\n            raise ValueError(\"ax must be None when n_channels &gt; 1.\")\n\n        kwargs = kwargs or {}\n\n        is_aw = kwargs.pop(\"Aw\", False)\n        if is_aw:\n            unit = \"dBA\"\n            data = bf.dBA\n        else:\n            unit = \"dB\"\n            data = bf.dB\n\n        specshow_kwargs = filter_kwargs(display.specshow, kwargs, strict_mode=True)\n        ax_set_kwargs = filter_kwargs(Axes.set, kwargs, strict_mode=True)\n\n        cmap = kwargs.pop(\"cmap\", \"jet\")\n        vmin = kwargs.pop(\"vmin\", None)\n        vmax = kwargs.pop(\"vmax\", None)\n\n        if ax is not None:\n            img = display.specshow(\n                data=data[0],\n                sr=bf.sampling_rate,\n                hop_length=bf.hop_length,\n                n_fft=bf.n_fft,\n                win_length=bf.win_length,\n                x_axis=\"time\",\n                y_axis=\"linear\",\n                cmap=cmap,\n                ax=ax,\n                vmin=vmin,\n                vmax=vmax,\n                **specshow_kwargs,\n            )\n            ax.set(\n                title=title or bf.label or \"Spectrogram\",\n                ylabel=\"Frequency [Hz]\",\n                xlabel=\"Time [s]\",\n                **ax_set_kwargs,\n            )\n\n            fig = ax.figure\n            if fig is not None:\n                cbar = fig.colorbar(img, ax=ax)\n                cbar.set_label(f\"Spectrum level [{unit}]\")\n            return ax\n\n        else:\n            # Create a new figure if ax is None\n            num_channels = bf.n_channels\n            fig, axs = plt.subplots(\n                num_channels, 1, figsize=(10, 5 * num_channels), sharex=True\n            )\n            if not isinstance(fig, plt.Figure):\n                raise ValueError(\"fig must be a matplotlib Figure object.\")\n            # Convert axs to array if it is a single Axes object\n            if not isinstance(axs, np.ndarray):\n                axs = np.array([axs])\n\n            for ax_i, channel_data, ch_meta in zip(axs.flatten(), data, bf.channels):\n                img = display.specshow(\n                    data=channel_data,\n                    sr=bf.sampling_rate,\n                    hop_length=bf.hop_length,\n                    n_fft=bf.n_fft,\n                    win_length=bf.win_length,\n                    x_axis=\"time\",\n                    y_axis=\"linear\",\n                    ax=ax_i,\n                    cmap=cmap,\n                    vmin=vmin,\n                    vmax=vmax,\n                    **specshow_kwargs,\n                )\n                ax_i.set(\n                    title=ch_meta.label,\n                    ylabel=\"Frequency [Hz]\",\n                    xlabel=\"Time [s]\",\n                    **ax_set_kwargs,\n                )\n                cbar = ax_i.figure.colorbar(img, ax=ax_i)\n                cbar.set_label(f\"Spectrum level [{unit}]\")\n                fig.suptitle(title or \"Spectrogram Data\")\n            plt.tight_layout()\n            plt.show()\n\n            return _return_axes_iterator(fig.axes)\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.SpectrogramPlotStrategy-attributes","title":"Attributes","text":""},{"location":"api/visualization/#wandas.visualization.plotting.SpectrogramPlotStrategy.name","title":"<code>name = 'spectrogram'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/visualization/#wandas.visualization.plotting.SpectrogramPlotStrategy-functions","title":"Functions","text":""},{"location":"api/visualization/#wandas.visualization.plotting.SpectrogramPlotStrategy.channel_plot","title":"<code>channel_plot(x, y, ax, **kwargs)</code>","text":"<p>Implementation of channel plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def channel_plot(\n    self,\n    x: Any,\n    y: Any,\n    ax: \"Axes\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Implementation of channel plotting\"\"\"\n    pass\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.SpectrogramPlotStrategy.plot","title":"<code>plot(bf, ax=None, title=None, overlay=False, **kwargs)</code>","text":"<p>Spectrogram plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def plot(\n    self,\n    bf: \"SpectrogramFrame\",\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = False,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Spectrogram plotting\"\"\"\n    if overlay:\n        raise ValueError(\"Overlay is not supported for SpectrogramPlotStrategy.\")\n\n    if ax is not None and bf.n_channels &gt; 1:\n        raise ValueError(\"ax must be None when n_channels &gt; 1.\")\n\n    kwargs = kwargs or {}\n\n    is_aw = kwargs.pop(\"Aw\", False)\n    if is_aw:\n        unit = \"dBA\"\n        data = bf.dBA\n    else:\n        unit = \"dB\"\n        data = bf.dB\n\n    specshow_kwargs = filter_kwargs(display.specshow, kwargs, strict_mode=True)\n    ax_set_kwargs = filter_kwargs(Axes.set, kwargs, strict_mode=True)\n\n    cmap = kwargs.pop(\"cmap\", \"jet\")\n    vmin = kwargs.pop(\"vmin\", None)\n    vmax = kwargs.pop(\"vmax\", None)\n\n    if ax is not None:\n        img = display.specshow(\n            data=data[0],\n            sr=bf.sampling_rate,\n            hop_length=bf.hop_length,\n            n_fft=bf.n_fft,\n            win_length=bf.win_length,\n            x_axis=\"time\",\n            y_axis=\"linear\",\n            cmap=cmap,\n            ax=ax,\n            vmin=vmin,\n            vmax=vmax,\n            **specshow_kwargs,\n        )\n        ax.set(\n            title=title or bf.label or \"Spectrogram\",\n            ylabel=\"Frequency [Hz]\",\n            xlabel=\"Time [s]\",\n            **ax_set_kwargs,\n        )\n\n        fig = ax.figure\n        if fig is not None:\n            cbar = fig.colorbar(img, ax=ax)\n            cbar.set_label(f\"Spectrum level [{unit}]\")\n        return ax\n\n    else:\n        # Create a new figure if ax is None\n        num_channels = bf.n_channels\n        fig, axs = plt.subplots(\n            num_channels, 1, figsize=(10, 5 * num_channels), sharex=True\n        )\n        if not isinstance(fig, plt.Figure):\n            raise ValueError(\"fig must be a matplotlib Figure object.\")\n        # Convert axs to array if it is a single Axes object\n        if not isinstance(axs, np.ndarray):\n            axs = np.array([axs])\n\n        for ax_i, channel_data, ch_meta in zip(axs.flatten(), data, bf.channels):\n            img = display.specshow(\n                data=channel_data,\n                sr=bf.sampling_rate,\n                hop_length=bf.hop_length,\n                n_fft=bf.n_fft,\n                win_length=bf.win_length,\n                x_axis=\"time\",\n                y_axis=\"linear\",\n                ax=ax_i,\n                cmap=cmap,\n                vmin=vmin,\n                vmax=vmax,\n                **specshow_kwargs,\n            )\n            ax_i.set(\n                title=ch_meta.label,\n                ylabel=\"Frequency [Hz]\",\n                xlabel=\"Time [s]\",\n                **ax_set_kwargs,\n            )\n            cbar = ax_i.figure.colorbar(img, ax=ax_i)\n            cbar.set_label(f\"Spectrum level [{unit}]\")\n            fig.suptitle(title or \"Spectrogram Data\")\n        plt.tight_layout()\n        plt.show()\n\n        return _return_axes_iterator(fig.axes)\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.DescribePlotStrategy","title":"<code>DescribePlotStrategy</code>","text":"<p>               Bases: <code>PlotStrategy['ChannelFrame']</code></p> <p>Strategy for visualizing ChannelFrame data with describe plot</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>class DescribePlotStrategy(PlotStrategy[\"ChannelFrame\"]):\n    \"\"\"Strategy for visualizing ChannelFrame data with describe plot\"\"\"\n\n    name = \"describe\"\n\n    def channel_plot(self, x: Any, y: Any, ax: \"Axes\", **kwargs: Any) -&gt; None:\n        \"\"\"Implementation of channel plotting\"\"\"\n        pass  # This method is not used for describe plot\n\n    def plot(\n        self,\n        bf: \"ChannelFrame\",\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = False,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        \"\"\"Implementation of describe method for visualizing ChannelFrame data\"\"\"\n\n        fmin = kwargs.pop(\"fmin\", 0)\n        fmax = kwargs.pop(\"fmax\", None)\n        cmap = kwargs.pop(\"cmap\", \"jet\")\n        vmin = kwargs.pop(\"vmin\", None)\n        vmax = kwargs.pop(\"vmax\", None)\n        xlim = kwargs.pop(\"xlim\", None)\n        ylim = kwargs.pop(\"ylim\", None)\n        is_aw = kwargs.pop(\"Aw\", False)\n        waveform = kwargs.pop(\"waveform\", {})\n        spectral = kwargs.pop(\"spectral\", dict(xlim=(vmin, vmax)))\n\n        gs = gridspec.GridSpec(2, 3, height_ratios=[1, 3], width_ratios=[3, 1, 0.1])\n        gs.update(wspace=0.2)\n\n        fig = plt.figure(figsize=(12, 6))\n        fig.subplots_adjust(wspace=0.0001)\n\n        # First subplot (Time Plot)\n        ax_1 = fig.add_subplot(gs[0])\n        bf.plot(plot_type=\"waveform\", ax=ax_1, overlay=True)\n        ax_1.set(**waveform)\n        ax_1.legend().set_visible(False)\n        ax_1.set(xlabel=\"\", title=\"\")\n\n        # Second subplot (STFT Plot)\n        ax_2 = fig.add_subplot(gs[3], sharex=ax_1)\n        stft_ch = bf.stft()\n        if is_aw:\n            unit = \"dBA\"\n            channel_data = stft_ch.dBA[0]\n        else:\n            unit = \"dB\"\n            channel_data = stft_ch.dB[0]\n        # Get the maximum value of the data and round it to a convenient value\n        if vmax is None:\n            data_max = np.nanmax(channel_data)\n            # Round to a convenient number with increments of 10, 5, or 2\n            for step in [10, 5, 2]:\n                rounded_max = np.ceil(data_max / step) * step\n                if rounded_max &gt;= data_max:\n                    vmax = rounded_max\n                    vmin = vmax - 180\n                    break\n        img = display.specshow(\n            data=channel_data,\n            sr=bf.sampling_rate,\n            hop_length=stft_ch.hop_length,\n            n_fft=stft_ch.n_fft,\n            win_length=stft_ch.win_length,\n            x_axis=\"time\",\n            y_axis=\"linear\",\n            ax=ax_2,\n            fmin=fmin,\n            fmax=fmax,\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n        )\n        ax_2.set(xlim=xlim, ylim=ylim)\n\n        # Third subplot\n        ax_3 = fig.add_subplot(gs[1])\n        ax_3.axis(\"off\")\n\n        # Fourth subplot (Welch Plot)\n        ax_4 = fig.add_subplot(gs[4], sharey=ax_2)\n        welch_ch = bf.welch()\n        if is_aw:\n            unit = \"dBA\"\n            data_db = welch_ch.dBA\n        else:\n            unit = \"dB\"\n            data_db = welch_ch.dB\n        ax_4.plot(data_db.T, welch_ch.freqs.T)\n        ax_4.grid(True)\n        ax_4.set(xlabel=f\"Spectrum level [{unit}]\", **spectral)\n\n        cbar = fig.colorbar(img, ax=ax_4, format=\"%+2.0f\")\n        cbar.set_label(unit)\n        fig.suptitle(title or bf.label or \"Channel Data\")\n\n        return _return_axes_iterator(fig.axes)\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.DescribePlotStrategy-attributes","title":"Attributes","text":""},{"location":"api/visualization/#wandas.visualization.plotting.DescribePlotStrategy.name","title":"<code>name = 'describe'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/visualization/#wandas.visualization.plotting.DescribePlotStrategy-functions","title":"Functions","text":""},{"location":"api/visualization/#wandas.visualization.plotting.DescribePlotStrategy.channel_plot","title":"<code>channel_plot(x, y, ax, **kwargs)</code>","text":"<p>Implementation of channel plotting</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def channel_plot(self, x: Any, y: Any, ax: \"Axes\", **kwargs: Any) -&gt; None:\n    \"\"\"Implementation of channel plotting\"\"\"\n    pass  # This method is not used for describe plot\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.DescribePlotStrategy.plot","title":"<code>plot(bf, ax=None, title=None, overlay=False, **kwargs)</code>","text":"<p>Implementation of describe method for visualizing ChannelFrame data</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def plot(\n    self,\n    bf: \"ChannelFrame\",\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = False,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    \"\"\"Implementation of describe method for visualizing ChannelFrame data\"\"\"\n\n    fmin = kwargs.pop(\"fmin\", 0)\n    fmax = kwargs.pop(\"fmax\", None)\n    cmap = kwargs.pop(\"cmap\", \"jet\")\n    vmin = kwargs.pop(\"vmin\", None)\n    vmax = kwargs.pop(\"vmax\", None)\n    xlim = kwargs.pop(\"xlim\", None)\n    ylim = kwargs.pop(\"ylim\", None)\n    is_aw = kwargs.pop(\"Aw\", False)\n    waveform = kwargs.pop(\"waveform\", {})\n    spectral = kwargs.pop(\"spectral\", dict(xlim=(vmin, vmax)))\n\n    gs = gridspec.GridSpec(2, 3, height_ratios=[1, 3], width_ratios=[3, 1, 0.1])\n    gs.update(wspace=0.2)\n\n    fig = plt.figure(figsize=(12, 6))\n    fig.subplots_adjust(wspace=0.0001)\n\n    # First subplot (Time Plot)\n    ax_1 = fig.add_subplot(gs[0])\n    bf.plot(plot_type=\"waveform\", ax=ax_1, overlay=True)\n    ax_1.set(**waveform)\n    ax_1.legend().set_visible(False)\n    ax_1.set(xlabel=\"\", title=\"\")\n\n    # Second subplot (STFT Plot)\n    ax_2 = fig.add_subplot(gs[3], sharex=ax_1)\n    stft_ch = bf.stft()\n    if is_aw:\n        unit = \"dBA\"\n        channel_data = stft_ch.dBA[0]\n    else:\n        unit = \"dB\"\n        channel_data = stft_ch.dB[0]\n    # Get the maximum value of the data and round it to a convenient value\n    if vmax is None:\n        data_max = np.nanmax(channel_data)\n        # Round to a convenient number with increments of 10, 5, or 2\n        for step in [10, 5, 2]:\n            rounded_max = np.ceil(data_max / step) * step\n            if rounded_max &gt;= data_max:\n                vmax = rounded_max\n                vmin = vmax - 180\n                break\n    img = display.specshow(\n        data=channel_data,\n        sr=bf.sampling_rate,\n        hop_length=stft_ch.hop_length,\n        n_fft=stft_ch.n_fft,\n        win_length=stft_ch.win_length,\n        x_axis=\"time\",\n        y_axis=\"linear\",\n        ax=ax_2,\n        fmin=fmin,\n        fmax=fmax,\n        cmap=cmap,\n        vmin=vmin,\n        vmax=vmax,\n    )\n    ax_2.set(xlim=xlim, ylim=ylim)\n\n    # Third subplot\n    ax_3 = fig.add_subplot(gs[1])\n    ax_3.axis(\"off\")\n\n    # Fourth subplot (Welch Plot)\n    ax_4 = fig.add_subplot(gs[4], sharey=ax_2)\n    welch_ch = bf.welch()\n    if is_aw:\n        unit = \"dBA\"\n        data_db = welch_ch.dBA\n    else:\n        unit = \"dB\"\n        data_db = welch_ch.dB\n    ax_4.plot(data_db.T, welch_ch.freqs.T)\n    ax_4.grid(True)\n    ax_4.set(xlabel=f\"Spectrum level [{unit}]\", **spectral)\n\n    cbar = fig.colorbar(img, ax=ax_4, format=\"%+2.0f\")\n    cbar.set_label(unit)\n    fig.suptitle(title or bf.label or \"Channel Data\")\n\n    return _return_axes_iterator(fig.axes)\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.MatrixPlotStrategy","title":"<code>MatrixPlotStrategy</code>","text":"<p>               Bases: <code>PlotStrategy[Union['SpectralFrame']]</code></p> <p>Strategy for displaying relationships between channels in matrix format</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>class MatrixPlotStrategy(PlotStrategy[Union[\"SpectralFrame\"]]):\n    \"\"\"Strategy for displaying relationships between channels in matrix format\"\"\"\n\n    name = \"matrix\"\n\n    def channel_plot(\n        self,\n        x: Any,\n        y: Any,\n        ax: \"Axes\",\n        title: Optional[str] = None,\n        ylabel: str = \"\",\n        xlabel: str = \"Frequency [Hz]\",\n        alpha: float = 0,\n        **kwargs: Any,\n    ) -&gt; None:\n        ax.plot(x, y, **kwargs)\n        ax.grid(True)\n        ax.set_xlabel(xlabel)\n        ax.set_ylabel(ylabel)\n        ax.set_title(title or \"\")\n\n    def plot(\n        self,\n        bf: \"SpectralFrame\",\n        ax: Optional[\"Axes\"] = None,\n        title: Optional[str] = None,\n        overlay: bool = False,\n        **kwargs: Any,\n    ) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n        kwargs = kwargs or {}\n        is_aw = kwargs.pop(\"Aw\", False)\n        if (\n            len(bf.operation_history) &gt; 0\n            and bf.operation_history[-1][\"operation\"] == \"coherence\"\n        ):\n            unit = \"\"\n            data = bf.magnitude\n            ylabel = kwargs.pop(\"ylabel\", \"coherence\")\n        else:\n            if is_aw:\n                unit = \"dBA\"\n                data = bf.dBA\n            else:\n                unit = \"dB\"\n                data = bf.dB\n            ylabel = kwargs.pop(\"ylabel\", f\"Spectrum level [{unit}]\")\n        xlabel = kwargs.pop(\"xlabel\", \"Frequency [Hz]\")\n        alpha = kwargs.pop(\"alpha\", 1)\n        plot_kwargs = filter_kwargs(Line2D, kwargs, strict_mode=True)\n        ax_set = filter_kwargs(Axes.set, kwargs, strict_mode=True)\n        num_channels = bf.n_channels\n        if overlay:\n            if ax is None:\n                fig, ax = plt.subplots(1, 1, figsize=(6, 6))\n            self.channel_plot(\n                bf.freqs,\n                data.T,\n                ax,  # \u3053\u3053\u3067\u5fc5\u305aAxes\u578b\n                title=title or bf.label or \"Spectral Data\",\n                ylabel=ylabel,\n                xlabel=xlabel,\n                alpha=alpha,\n                **plot_kwargs,\n            )\n            if ax is not None:\n                ax.set(**ax_set)\n                fig.suptitle(title or bf.label or \"Spectral Data\")\n                plt.tight_layout()\n                plt.show()\n                return ax\n            # ax\u304cNone\u306e\u30b1\u30fc\u30b9\u306f\u3053\u3053\u3067\u767a\u751f\u3057\u306a\u3044\n        else:\n            num_rows = int(np.ceil(np.sqrt(num_channels)))\n            fig, axs = plt.subplots(\n                num_rows,\n                num_rows,\n                figsize=(3 * num_rows, 3 * num_rows),\n                sharex=True,\n                sharey=True,\n            )\n            if isinstance(axs, np.ndarray):\n                axes_list = axs.flatten().tolist()\n            elif isinstance(axs, list):\n                import itertools\n\n                axes_list = list(itertools.chain.from_iterable(axs))\n            else:\n                axes_list = [axs]\n            for ax_i, channel_data, ch_meta in zip(axes_list, data, bf.channels):\n                self.channel_plot(\n                    bf.freqs,\n                    channel_data,\n                    ax_i,\n                    title=ch_meta.label,\n                    ylabel=ylabel,\n                    xlabel=xlabel,\n                    alpha=alpha,\n                    **plot_kwargs,\n                )\n                ax_i.set(**ax_set)\n            fig.suptitle(title or bf.label or \"Spectral Data\")\n            plt.tight_layout()\n            plt.show()\n            return _return_axes_iterator(fig.axes)\n\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.MatrixPlotStrategy-attributes","title":"Attributes","text":""},{"location":"api/visualization/#wandas.visualization.plotting.MatrixPlotStrategy.name","title":"<code>name = 'matrix'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/visualization/#wandas.visualization.plotting.MatrixPlotStrategy-functions","title":"Functions","text":""},{"location":"api/visualization/#wandas.visualization.plotting.MatrixPlotStrategy.channel_plot","title":"<code>channel_plot(x, y, ax, title=None, ylabel='', xlabel='Frequency [Hz]', alpha=0, **kwargs)</code>","text":"Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def channel_plot(\n    self,\n    x: Any,\n    y: Any,\n    ax: \"Axes\",\n    title: Optional[str] = None,\n    ylabel: str = \"\",\n    xlabel: str = \"Frequency [Hz]\",\n    alpha: float = 0,\n    **kwargs: Any,\n) -&gt; None:\n    ax.plot(x, y, **kwargs)\n    ax.grid(True)\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    ax.set_title(title or \"\")\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.MatrixPlotStrategy.plot","title":"<code>plot(bf, ax=None, title=None, overlay=False, **kwargs)</code>","text":"Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def plot(\n    self,\n    bf: \"SpectralFrame\",\n    ax: Optional[\"Axes\"] = None,\n    title: Optional[str] = None,\n    overlay: bool = False,\n    **kwargs: Any,\n) -&gt; Union[\"Axes\", Iterator[\"Axes\"]]:\n    kwargs = kwargs or {}\n    is_aw = kwargs.pop(\"Aw\", False)\n    if (\n        len(bf.operation_history) &gt; 0\n        and bf.operation_history[-1][\"operation\"] == \"coherence\"\n    ):\n        unit = \"\"\n        data = bf.magnitude\n        ylabel = kwargs.pop(\"ylabel\", \"coherence\")\n    else:\n        if is_aw:\n            unit = \"dBA\"\n            data = bf.dBA\n        else:\n            unit = \"dB\"\n            data = bf.dB\n        ylabel = kwargs.pop(\"ylabel\", f\"Spectrum level [{unit}]\")\n    xlabel = kwargs.pop(\"xlabel\", \"Frequency [Hz]\")\n    alpha = kwargs.pop(\"alpha\", 1)\n    plot_kwargs = filter_kwargs(Line2D, kwargs, strict_mode=True)\n    ax_set = filter_kwargs(Axes.set, kwargs, strict_mode=True)\n    num_channels = bf.n_channels\n    if overlay:\n        if ax is None:\n            fig, ax = plt.subplots(1, 1, figsize=(6, 6))\n        self.channel_plot(\n            bf.freqs,\n            data.T,\n            ax,  # \u3053\u3053\u3067\u5fc5\u305aAxes\u578b\n            title=title or bf.label or \"Spectral Data\",\n            ylabel=ylabel,\n            xlabel=xlabel,\n            alpha=alpha,\n            **plot_kwargs,\n        )\n        if ax is not None:\n            ax.set(**ax_set)\n            fig.suptitle(title or bf.label or \"Spectral Data\")\n            plt.tight_layout()\n            plt.show()\n            return ax\n        # ax\u304cNone\u306e\u30b1\u30fc\u30b9\u306f\u3053\u3053\u3067\u767a\u751f\u3057\u306a\u3044\n    else:\n        num_rows = int(np.ceil(np.sqrt(num_channels)))\n        fig, axs = plt.subplots(\n            num_rows,\n            num_rows,\n            figsize=(3 * num_rows, 3 * num_rows),\n            sharex=True,\n            sharey=True,\n        )\n        if isinstance(axs, np.ndarray):\n            axes_list = axs.flatten().tolist()\n        elif isinstance(axs, list):\n            import itertools\n\n            axes_list = list(itertools.chain.from_iterable(axs))\n        else:\n            axes_list = [axs]\n        for ax_i, channel_data, ch_meta in zip(axes_list, data, bf.channels):\n            self.channel_plot(\n                bf.freqs,\n                channel_data,\n                ax_i,\n                title=ch_meta.label,\n                ylabel=ylabel,\n                xlabel=xlabel,\n                alpha=alpha,\n                **plot_kwargs,\n            )\n            ax_i.set(**ax_set)\n        fig.suptitle(title or bf.label or \"Spectral Data\")\n        plt.tight_layout()\n        plt.show()\n        return _return_axes_iterator(fig.axes)\n\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting-functions","title":"Functions","text":""},{"location":"api/visualization/#wandas.visualization.plotting.register_plot_strategy","title":"<code>register_plot_strategy(strategy_cls)</code>","text":"<p>Register a new plot strategy from a class</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def register_plot_strategy(strategy_cls: type) -&gt; None:\n    \"\"\"Register a new plot strategy from a class\"\"\"\n    if not issubclass(strategy_cls, PlotStrategy):\n        raise TypeError(\"Strategy class must inherit from PlotStrategy.\")\n    if inspect.isabstract(strategy_cls):\n        raise TypeError(\"Cannot register abstract PlotStrategy class.\")\n    _plot_strategies[strategy_cls.name] = strategy_cls\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.get_plot_strategy","title":"<code>get_plot_strategy(name)</code>","text":"<p>Get plot strategy by name</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def get_plot_strategy(name: str) -&gt; type[PlotStrategy[Any]]:\n    \"\"\"Get plot strategy by name\"\"\"\n    if name not in _plot_strategies:\n        raise ValueError(f\"Unknown plot type: {name}\")\n    return _plot_strategies[name]\n</code></pre>"},{"location":"api/visualization/#wandas.visualization.plotting.create_operation","title":"<code>create_operation(name, **params)</code>","text":"<p>Create operation instance from operation name and parameters</p> Source code in <code>wandas/visualization/plotting.py</code> <pre><code>def create_operation(name: str, **params: Any) -&gt; PlotStrategy[Any]:\n    \"\"\"Create operation instance from operation name and parameters\"\"\"\n    operation_class = get_plot_strategy(name)\n    return operation_class(**params)\n</code></pre>"},{"location":"api/wdf_io/","title":"WDF\u30d5\u30a1\u30a4\u30eb\u5165\u51fa\u529b","text":"<p><code>wandas.io.wdf_io</code> \u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u3001<code>ChannelFrame</code> \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092 WDF (Wandas Data File) \u5f62\u5f0f\u3067\u4fdd\u5b58\u30fb\u8aad\u307f\u8fbc\u307f\u3059\u308b\u305f\u3081\u306e\u6a5f\u80fd\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002 WDF\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u306f HDF5 \u3092\u30d9\u30fc\u30b9\u3068\u3057\u3001\u30c7\u30fc\u30bf\u3060\u3051\u3067\u306a\u304f\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8\u3001\u5358\u4f4d\u3001\u30c1\u30e3\u30f3\u30cd\u30eb\u30e9\u30d9\u30eb\u306a\u3069\u306e\u30e1\u30bf\u30c7\u30fc\u30bf\u3082\u5b8c\u5168\u306b\u4fdd\u5b58\u3057\u307e\u3059\u3002</p>"},{"location":"api/wdf_io/#wdf_1","title":"WDF\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u6982\u8981","text":"<p>WDF\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u306f\u4ee5\u4e0b\u306e\u7279\u5fb4\u3092\u6301\u3061\u307e\u3059:</p> <ul> <li>HDF5\u30d9\u30fc\u30b9\u306e\u968e\u5c64\u7684\u306a\u30c7\u30fc\u30bf\u69cb\u9020</li> <li>\u30c1\u30e3\u30f3\u30cd\u30eb\u30c7\u30fc\u30bf\u3068\u30e1\u30bf\u30c7\u30fc\u30bf\u306e\u5b8c\u5168\u306a\u4fdd\u6301</li> <li>\u30c7\u30fc\u30bf\u5727\u7e2e\u3068\u30c1\u30e3\u30f3\u30af\u5316\u306b\u3088\u308b\u30b5\u30a4\u30ba\u6700\u9069\u5316</li> <li>\u5c06\u6765\u306e\u62e1\u5f35\u306b\u5bfe\u5fdc\u3059\u308b\u30d0\u30fc\u30b8\u30e7\u30f3\u7ba1\u7406</li> </ul> <p>\u30d5\u30a1\u30a4\u30eb\u69cb\u9020:</p> <pre><code>/meta           : Frame \u5168\u4f53\u306e\u30e1\u30bf\u30c7\u30fc\u30bf (JSON\u5f62\u5f0f)\n/channels/{i}   : \u500b\u3005\u306e\u30c1\u30e3\u30f3\u30cd\u30eb\u30c7\u30fc\u30bf\u3068\u30e1\u30bf\u30c7\u30fc\u30bf\n    \u251c\u2500 data           : \u6ce2\u5f62\u30c7\u30fc\u30bf (numpy array)\n    \u2514\u2500 attrs          : \u30c1\u30e3\u30f3\u30cd\u30eb\u5c5e\u6027 (\u30e9\u30d9\u30eb\u3001\u5358\u4f4d\u306a\u3069)\n</code></pre>"},{"location":"api/wdf_io/#wdf_2","title":"WDF\u30d5\u30a1\u30a4\u30eb\u4fdd\u5b58","text":""},{"location":"api/wdf_io/#wandas.io.wdf_io.save","title":"<code>wandas.io.wdf_io.save(frame, path, *, format='hdf5', compress='gzip', overwrite=False, dtype=None)</code>","text":"<p>Save a frame to a file.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>BaseFrame[Any]</code> <p>The frame to save.</p> required <code>path</code> <code>Union[str, Path]</code> <p>Path to save the file. '.wdf' extension will be added if not present.</p> required <code>format</code> <code>str</code> <p>Format to use (currently only 'hdf5' is supported)</p> <code>'hdf5'</code> <code>compress</code> <code>Optional[str]</code> <p>Compression method ('gzip' by default, None for no compression)</p> <code>'gzip'</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing file</p> <code>False</code> <code>dtype</code> <code>Optional[Union[str, dtype[Any]]]</code> <p>Optional data type conversion before saving (e.g. 'float32')</p> <code>None</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If the file exists and overwrite=False.</p> <code>NotImplementedError</code> <p>For unsupported formats.</p> Source code in <code>wandas/io/wdf_io.py</code> <pre><code>def save(\n    frame: BaseFrame[Any],\n    path: Union[str, Path],\n    *,\n    format: str = \"hdf5\",\n    compress: Optional[str] = \"gzip\",\n    overwrite: bool = False,\n    dtype: Optional[Union[str, np.dtype[Any]]] = None,\n) -&gt; None:\n    \"\"\"Save a frame to a file.\n\n    Args:\n        frame: The frame to save.\n        path: Path to save the file. '.wdf' extension will be added if not present.\n        format: Format to use (currently only 'hdf5' is supported)\n        compress: Compression method ('gzip' by default, None for no compression)\n        overwrite: Whether to overwrite existing file\n        dtype: Optional data type conversion before saving (e.g. 'float32')\n\n    Raises:\n        FileExistsError: If the file exists and overwrite=False.\n        NotImplementedError: For unsupported formats.\n    \"\"\"\n    # Handle path\n    path = Path(path)\n    if path.suffix != \".wdf\":\n        path = path.with_suffix(\".wdf\")\n\n    # Check if file exists\n    if path.exists() and not overwrite:\n        raise FileExistsError(\n            f\"File {path} already exists. Set overwrite=True to overwrite.\"\n        )\n\n    # Currently only HDF5 is supported\n    if format.lower() != \"hdf5\":\n        raise NotImplementedError(\n            f\"Format {format} not supported. Only 'hdf5' is currently implemented.\"\n        )\n\n    # Compute data arrays (this triggers actual computation)\n    logger.info(\"Computing data arrays for saving...\")\n    computed_data = frame.compute()\n    if dtype is not None:\n        computed_data = computed_data.astype(dtype)\n\n    # Create file\n    logger.info(f\"Creating HDF5 file at {path}...\")\n    with h5py.File(path, \"w\") as f:\n        # Set file version\n        f.attrs[\"version\"] = WDF_FORMAT_VERSION\n\n        # Store frame metadata\n        f.attrs[\"sampling_rate\"] = frame.sampling_rate\n        f.attrs[\"label\"] = frame.label or \"\"\n        f.attrs[\"frame_type\"] = type(frame).__name__\n\n        # Create channels group\n        channels_grp = f.create_group(\"channels\")\n\n        # Store each channel\n        for i, (channel_data, ch_meta) in enumerate(\n            zip(computed_data, frame._channel_metadata)\n        ):\n            ch_grp = channels_grp.create_group(f\"{i}\")\n\n            # Store channel data\n            if compress:\n                ch_grp.create_dataset(\"data\", data=channel_data, compression=compress)\n            else:\n                ch_grp.create_dataset(\"data\", data=channel_data)\n\n            # Store metadata\n            ch_grp.attrs[\"label\"] = ch_meta.label\n            ch_grp.attrs[\"unit\"] = ch_meta.unit\n\n            # Store extra metadata as JSON\n            if ch_meta.extra:\n                ch_grp.attrs[\"metadata_json\"] = json.dumps(ch_meta.extra)\n\n        # Store operation history\n        if frame.operation_history:\n            op_grp = f.create_group(\"operation_history\")\n            for i, op in enumerate(frame.operation_history):\n                op_sub_grp = op_grp.create_group(f\"operation_{i}\")\n                for k, v in op.items():\n                    # Store simple attributes directly\n                    if isinstance(v, (str, int, float, bool, np.number)):\n                        op_sub_grp.attrs[k] = v\n                    else:\n                        # For complex types, serialize to JSON\n                        try:\n                            op_sub_grp.attrs[k] = json.dumps(v)\n                        except (TypeError, OverflowError) as e:\n                            logger.warning(\n                                f\"Could not serialize operation key '{k}': {e}\"\n                            )\n                            op_sub_grp.attrs[k] = str(v)\n\n        # Store frame metadata\n        if frame.metadata:\n            meta_grp = f.create_group(\"meta\")\n            # Store metadata as JSON\n            meta_grp.attrs[\"json\"] = json.dumps(frame.metadata)\n\n            # Also store individual metadata items as attributes for compatibility\n            for k, v in frame.metadata.items():\n                if isinstance(v, (str, int, float, bool, np.number)):\n                    meta_grp.attrs[k] = v\n\n    logger.info(f\"Frame saved to {path}\")\n</code></pre>"},{"location":"api/wdf_io/#wdf_3","title":"WDF\u30d5\u30a1\u30a4\u30eb\u8aad\u307f\u8fbc\u307f","text":""},{"location":"api/wdf_io/#wandas.io.wdf_io.load","title":"<code>wandas.io.wdf_io.load(path, *, format='hdf5')</code>","text":"<p>Load a ChannelFrame object from a WDF (Wandas Data File) file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the WDF file to load.</p> required <code>format</code> <code>str</code> <p>Format of the file. Currently only \"hdf5\" is supported.</p> <code>'hdf5'</code> <p>Returns:</p> Type Description <code>ChannelFrame</code> <p>A new ChannelFrame object with data and metadata loaded from the file.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> <code>NotImplementedError</code> <p>If format is not \"hdf5\".</p> <code>ValueError</code> <p>If the file format is invalid or incompatible.</p> Example <p>cf = ChannelFrame.load(\"audio_data.wdf\")</p> Source code in <code>wandas/io/wdf_io.py</code> <pre><code>def load(path: Union[str, Path], *, format: str = \"hdf5\") -&gt; \"ChannelFrame\":\n    \"\"\"Load a ChannelFrame object from a WDF (Wandas Data File) file.\n\n    Args:\n        path: Path to the WDF file to load.\n        format: Format of the file. Currently only \"hdf5\" is supported.\n\n    Returns:\n        A new ChannelFrame object with data and metadata loaded from the file.\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist.\n        NotImplementedError: If format is not \"hdf5\".\n        ValueError: If the file format is invalid or incompatible.\n\n    Example:\n        &gt;&gt;&gt; cf = ChannelFrame.load(\"audio_data.wdf\")\n    \"\"\"\n    # Ensure ChannelFrame is imported here to avoid circular imports\n    from ..core.metadata import ChannelMetadata\n    from ..frames.channel import ChannelFrame\n\n    if format != \"hdf5\":\n        raise NotImplementedError(f\"Format '{format}' is not supported\")\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    logger.debug(f\"Loading ChannelFrame from {path}\")\n\n    with h5py.File(path, \"r\") as f:\n        # Check format version for compatibility\n        version = f.attrs.get(\"version\", \"unknown\")\n        if version != WDF_FORMAT_VERSION:\n            logger.warning(\n                f\"File format version mismatch: file={version}, current={WDF_FORMAT_VERSION}\"  # noqa: E501\n            )\n\n        # Get global attributes\n        sampling_rate = float(f.attrs[\"sampling_rate\"])\n        frame_label = f.attrs.get(\"label\", \"\")\n\n        # Get frame metadata\n        frame_metadata = {}\n        if \"meta\" in f:\n            meta_json = f[\"meta\"].attrs.get(\"json\", \"{}\")\n            frame_metadata = json.loads(meta_json)\n\n        # Load channel data and metadata\n        all_channel_data = []\n        channel_metadata_list = []\n\n        if \"channels\" in f:\n            channels_group = f[\"channels\"]\n            # Sort channel indices numerically\n            channel_indices = sorted([int(key) for key in channels_group.keys()])\n\n            for idx in channel_indices:\n                ch_group = channels_group[f\"{idx}\"]\n\n                # Load channel data\n                channel_data = ch_group[\"data\"][()]\n\n                # Append to combined array\n                all_channel_data.append(channel_data)\n\n                # Load channel metadata\n                label = ch_group.attrs.get(\"label\", f\"Ch{idx}\")\n                unit = ch_group.attrs.get(\"unit\", \"\")\n\n                # Load additional metadata if present\n                ch_extra = {}\n                if \"metadata_json\" in ch_group.attrs:\n                    ch_extra = json.loads(ch_group.attrs[\"metadata_json\"])\n\n                # Create ChannelMetadata object\n                channel_metadata = ChannelMetadata(\n                    label=label, unit=unit, extra=ch_extra\n                )\n                channel_metadata_list.append(channel_metadata)\n\n        # Stack channel data into a single array\n        if all_channel_data:\n            combined_data = np.stack(all_channel_data, axis=0)\n        else:\n            raise ValueError(\"No channel data found in the file\")\n\n        # Create a new ChannelFrame\n        dask_data = da_from_array(combined_data)\n\n        cf = ChannelFrame(\n            data=dask_data,\n            sampling_rate=sampling_rate,\n            label=frame_label if frame_label else None,\n            metadata=frame_metadata,\n            channel_metadata=channel_metadata_list,\n        )\n\n        logger.debug(\n            f\"ChannelFrame loaded from {path}: {len(cf)} channels, {cf.n_samples} samples\"  # noqa: E501\n        )\n        return cf\n</code></pre>"},{"location":"api/wdf_io/#_1","title":"\u5229\u7528\u4f8b","text":"<pre><code># ChannelFrame \u3092 WDF\u5f62\u5f0f\u3067\u4fdd\u5b58\ncf = wd.read_wav(\"audio.wav\")\ncf.save(\"audio_data.wdf\")\n\n# \u4fdd\u5b58\u6642\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u6307\u5b9a\ncf.save(\n    \"high_quality.wdf\",\n    compress=\"gzip\",  # \u5727\u7e2e\u65b9\u5f0f\n    dtype=\"float64\",  # \u30c7\u30fc\u30bf\u578b\n    overwrite=True    # \u4e0a\u66f8\u304d\u8a31\u53ef\n)\n\n# WDF\u30d5\u30a1\u30a4\u30eb\u304b\u3089 ChannelFrame \u3092\u8aad\u307f\u8fbc\u307f\ncf2 = wd.ChannelFrame.load(\"audio_data.wdf\")\n</code></pre> <p>\u8a73\u7d30\u306a\u4f7f\u7528\u4f8b\u306f \u30d5\u30a1\u30a4\u30eb\u5165\u51fa\u529b\u30ac\u30a4\u30c9 \u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002</p>"},{"location":"explanation/","title":"\u7406\u8ad6\u80cc\u666f\u3068\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3","text":"<p>\u3053\u306e\u30bb\u30af\u30b7\u30e7\u30f3\u3067\u306f\u3001Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u8a2d\u8a08\u601d\u60f3\u3001\u5185\u90e8\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u3001\u304a\u3088\u3073\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u4f7f\u7528\u3055\u308c\u3066\u3044\u308b\u7406\u8ad6\u7684\u80cc\u666f\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002</p>"},{"location":"explanation/#_2","title":"\u8a2d\u8a08\u601d\u60f3","text":"<p>Wandas\u306f\u4ee5\u4e0b\u306e\u8a2d\u8a08\u539f\u5247\u306b\u57fa\u3065\u3044\u3066\u958b\u767a\u3055\u308c\u3066\u3044\u307e\u3059\uff1a</p> <ol> <li>\u76f4\u611f\u7684\u306aAPI\u8a2d\u8a08 - \u30e6\u30fc\u30b6\u30fc\u304c\u7c21\u5358\u306b\u4f7f\u3048\u308b\u4e00\u8cab\u6027\u306e\u3042\u308b\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9</li> <li>\u52b9\u7387\u7684\u306a\u30e1\u30e2\u30ea\u4f7f\u7528 - \u5927\u898f\u6a21\u30c7\u30fc\u30bf\u306e\u51e6\u7406\u306b\u9069\u3057\u305f\u30e1\u30e2\u30ea\u52b9\u7387\u306e\u826f\u3044\u5b9f\u88c5</li> <li>\u62e1\u5f35\u6027 - \u65b0\u3057\u3044\u6a5f\u80fd\u3084\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u8ffd\u52a0\u3057\u3084\u3059\u3044\u62e1\u5f35\u53ef\u80fd\u306a\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3</li> <li>\u79d1\u5b66\u7684\u6b63\u78ba\u6027 - \u97f3\u97ff\u4fe1\u53f7\u51e6\u7406\u306e\u7406\u8ad6\u306b\u57fa\u3065\u304f\u6b63\u78ba\u306a\u5b9f\u88c5</li> </ol>"},{"location":"explanation/#_3","title":"\u30b3\u30a2\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3","text":""},{"location":"explanation/#_4","title":"\u30c7\u30fc\u30bf\u30e2\u30c7\u30eb","text":"<p>Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u4e2d\u5fc3\u3068\u306a\u308b\u30c7\u30fc\u30bf\u30e2\u30c7\u30eb\u306f\u968e\u5c64\u7684\u306b\u69cb\u6210\u3055\u308c\u3066\u3044\u307e\u3059\uff1a</p> <pre><code>BaseChannel (\u57fa\u5e95\u30af\u30e9\u30b9)\n \u251c\u2500\u2500 Channel (\u6642\u9593\u9818\u57df\u4fe1\u53f7)\n \u2502    \u2514\u2500\u2500 FrequencyChannel (\u5468\u6ce2\u6570\u9818\u57df\u4fe1\u53f7)\n \u2502         \u2514\u2500\u2500 TimeFrequencyChannel (\u6642\u9593-\u5468\u6ce2\u6570\u9818\u57df\u4fe1\u53f7)\n \u2514\u2500\u2500 ChannelFrame (\u8907\u6570\u30c1\u30e3\u30f3\u30cd\u30eb\u306e\u30b3\u30f3\u30c6\u30ca)\n      \u251c\u2500\u2500 FileFrame (\u30d5\u30a1\u30a4\u30eb\u30d9\u30fc\u30b9\u306e\u8907\u6570\u30c1\u30e3\u30f3\u30cd\u30eb)\n      \u2514\u2500\u2500 FrequencyChannelFrame (\u5468\u6ce2\u6570\u9818\u57df\u306e\u8907\u6570\u30c1\u30e3\u30f3\u30cd\u30eb)\n</code></pre> <p>\u5404\u30af\u30e9\u30b9\u306e\u8cac\u4efb\uff1a</p> <ul> <li>BaseChannel: \u3059\u3079\u3066\u306e\u30c1\u30e3\u30f3\u30cd\u30eb\u306e\u57fa\u5e95\u30af\u30e9\u30b9\u3002\u30c7\u30fc\u30bf\u30a2\u30af\u30bb\u30b9\u3001\u30e1\u30bf\u30c7\u30fc\u30bf\u7ba1\u7406\u306e\u57fa\u672c\u6a5f\u80fd\u3092\u63d0\u4f9b</li> <li>Channel: \u6642\u9593\u9818\u57df\u306e\u4fe1\u53f7\u30c7\u30fc\u30bf\u3068\u3001\u305d\u308c\u306b\u5bfe\u3059\u308b\u51e6\u7406\u30e1\u30bd\u30c3\u30c9\u3092\u5b9f\u88c5</li> <li>FrequencyChannel: FFT\u30d9\u30fc\u30b9\u306e\u5468\u6ce2\u6570\u9818\u57df\u30c7\u30fc\u30bf\u3068\u51e6\u7406\u3092\u5b9f\u88c5</li> <li>TimeFrequencyChannel: \u77ed\u6642\u9593\u30d5\u30fc\u30ea\u30a8\u5909\u63db\uff08STFT\uff09\u306a\u3069\u306e\u6642\u9593-\u5468\u6ce2\u6570\u9818\u57df\u8868\u73fe\u3092\u5b9f\u88c5</li> <li>ChannelFrame: \u8907\u6570\u306e\u30c1\u30e3\u30f3\u30cd\u30eb\u3092\u7ba1\u7406\u3057\u3001\u4e00\u62ec\u51e6\u7406\u3092\u53ef\u80fd\u306b\u3059\u308b\u30b3\u30f3\u30c6\u30ca</li> </ul>"},{"location":"explanation/#_5","title":"\u30c7\u30fc\u30bf\u51e6\u7406\u30d5\u30ed\u30fc","text":"<ol> <li>\u5165\u529b\u6bb5\u968e: WAV\u3084CSV\u306a\u3069\u306e\u30d5\u30a1\u30a4\u30eb\u304b\u3089<code>Channel</code>\u307e\u305f\u306f<code>ChannelFrame</code>\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210</li> <li>\u51e6\u7406\u6bb5\u968e: \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3001\u30ea\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u306a\u3069\u306e\u51e6\u7406\u3092\u9069\u7528</li> <li>\u5206\u6790\u6bb5\u968e: \u4fe1\u53f7\u306e\u7279\u6027\uff08\u30b9\u30da\u30af\u30c8\u30eb\u3001\u30ec\u30d9\u30eb\u7b49\uff09\u3092\u5206\u6790</li> <li>\u51fa\u529b\u6bb5\u968e: \u51e6\u7406\u7d50\u679c\u3092\u30d5\u30a1\u30a4\u30eb\u306b\u4fdd\u5b58\u307e\u305f\u306f\u30b0\u30e9\u30d5\u3068\u3057\u3066\u53ef\u8996\u5316</li> </ol>"},{"location":"explanation/#_6","title":"\u5b9f\u88c5\u8a73\u7d30","text":""},{"location":"explanation/#_7","title":"\u30e1\u30e2\u30ea\u52b9\u7387","text":"<p>Wandas\u306f\u5927\u898f\u6a21\u306a\u30aa\u30fc\u30c7\u30a3\u30aa\u30c7\u30fc\u30bf\u3092\u6271\u3046\u305f\u3081\u306b\u3001\u4ee5\u4e0b\u306e\u65b9\u6cd5\u3067\u30e1\u30e2\u30ea\u52b9\u7387\u3092\u78ba\u4fdd\u3057\u3066\u3044\u307e\u3059\uff1a</p> <ul> <li>\u9045\u5ef6\u8a55\u4fa1: \u5fc5\u8981\u306b\u306a\u308b\u307e\u3067\u8a08\u7b97\u3092\u9045\u5ef6\u3055\u305b\u308b\u4ed5\u7d44\u307f</li> <li>\u30e1\u30e2\u30ea\u30de\u30c3\u30d4\u30f3\u30b0: \u5927\u304d\u306a\u30d5\u30a1\u30a4\u30eb\u3067\u3082\u30e1\u30e2\u30ea\u306b\u5168\u3066\u8aad\u307f\u8fbc\u307e\u305a\u306b\u30a2\u30af\u30bb\u30b9</li> <li>dask\u3068H5PY: \u5927\u898f\u6a21\u30c7\u30fc\u30bf\u306e\u51e6\u7406\u306b\u9069\u3057\u305f\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u6d3b\u7528</li> </ul>"},{"location":"explanation/#_8","title":"\u4fe1\u53f7\u51e6\u7406\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0","text":"<p>Wandas\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u4fe1\u53f7\u51e6\u7406\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u5b9f\u88c5\u3057\u3066\u3044\u307e\u3059\uff1a</p> <ul> <li>\u30c7\u30b8\u30bf\u30eb\u30d5\u30a3\u30eb\u30bf: \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf\u306a\u3069\u306eIIR/FIR\u30d5\u30a3\u30eb\u30bf</li> <li>\u30b9\u30da\u30af\u30c8\u30eb\u5206\u6790: \u9ad8\u901f\u30d5\u30fc\u30ea\u30a8\u5909\u63db\uff08FFT\uff09\u306b\u57fa\u3065\u304f\u5468\u6ce2\u6570\u5206\u6790</li> <li>\u6642\u9593-\u5468\u6ce2\u6570\u5206\u6790: \u77ed\u6642\u9593\u30d5\u30fc\u30ea\u30a8\u5909\u63db\uff08STFT\uff09\u3001\u30b9\u30da\u30af\u30c8\u30ed\u30b0\u30e9\u30e0</li> <li>\u7d71\u8a08\u7684\u5206\u6790: RMS\u3001\u30d4\u30fc\u30af\u5024\u3001\u30af\u30ec\u30b9\u30c8\u30d5\u30a1\u30af\u30bf\u30fc\u306a\u3069\u306e\u4fe1\u53f7\u7279\u6027\u306e\u8a08\u7b97</li> </ul>"},{"location":"explanation/#_9","title":"\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u306e\u8003\u616e\u4e8b\u9805","text":"<p>Wandas\u3092\u4f7f\u7528\u3059\u308b\u969b\u306e\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u306b\u95a2\u3059\u308b\u8003\u616e\u4e8b\u9805\uff1a</p> <ul> <li>\u5927\u91cf\u306e\u30c7\u30fc\u30bf\u3092\u51e6\u7406\u3059\u308b\u5834\u5408\u306f\u3001\u51e6\u7406\u3092\u30c1\u30e3\u30f3\u30af\u5358\u4f4d\u3067\u884c\u3046\u3053\u3068\u3092\u691c\u8a0e</li> <li>\u8907\u96d1\u306a\u51e6\u7406\u30c1\u30a7\u30fc\u30f3\u3092\u69cb\u7bc9\u3059\u308b\u5834\u5408\u306f\u3001\u4e2d\u9593\u7d50\u679c\u3092\u30ad\u30e3\u30c3\u30b7\u30e5\u3059\u308b\u3053\u3068\u3067\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u3092\u5411\u4e0a</li> <li>\u30de\u30eb\u30c1\u30c1\u30e3\u30f3\u30cd\u30eb\u51e6\u7406\u306f\u30de\u30eb\u30c1\u30b3\u30a2\u30d7\u30ed\u30bb\u30c3\u30b5\u3092\u52b9\u7387\u7684\u306b\u6d3b\u7528</li> </ul>"},{"location":"explanation/#_10","title":"\u53c2\u8003\u6587\u732e","text":"<ol> <li>Smith, J. O. (2011). Spectral Audio Signal Processing. W3K Publishing.</li> <li>M\u00fcller, M. (2015). Fundamentals of Music Processing: Audio, Analysis, Algorithms, Applications. Springer.</li> <li>Z\u00f6lzer, U. (2008). Digital Audio Signal Processing. Wiley.</li> </ol>"},{"location":"tutorial/","title":"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb","text":"<p>\u3053\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3067\u306f\u3001Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u57fa\u672c\u7684\u306a\u4f7f\u3044\u65b9\u30925\u5206\u3067\u5b66\u3079\u307e\u3059\u3002</p>"},{"location":"tutorial/#_2","title":"\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb","text":"<pre><code>pip install git+https://github.com/endolith/waveform-analysis.git@master\npip install wandas\n</code></pre>"},{"location":"tutorial/#_3","title":"\u57fa\u672c\u7684\u306a\u4f7f\u3044\u65b9","text":""},{"location":"tutorial/#1","title":"1. \u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u30a4\u30f3\u30dd\u30fc\u30c8","text":"<pre><code>import wandas as wd\n</code></pre>"},{"location":"tutorial/#2","title":"2. \u97f3\u58f0\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f","text":"<pre><code># URL\u304b\u3089\u30c7\u30fc\u30bf\u3092\u53d6\u5f97\nurl = \"https://github.com/kasahart/wandas/raw/main/examples/data/summer_streets1.wav\"\n\naudio = wd.read_wav(url)\nprint(f\"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8: {audio.sampling_rate} Hz\")\nprint(f\"\u30c1\u30e3\u30f3\u30cd\u30eb\u6570: {audio.n_channels}\")\nprint(f\"\u9577\u3055: {audio.duration} s\")\n</code></pre> <p>\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u30ec\u30fc\u30c8: 44100 Hz \u30c1\u30e3\u30f3\u30cd\u30eb\u6570: 2 \u9577\u3055: 15.0 s  </p>"},{"location":"tutorial/#3","title":"3. \u4fe1\u53f7\u306e\u53ef\u8996\u5316","text":"<pre><code># \u6ce2\u5f62\u3092\u8868\u793a\naudio.describe()\n</code></pre> 2025-05-20T17:59:45.849816 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/"},{"location":"tutorial/#4","title":"4. \u57fa\u672c\u7684\u306a\u4fe1\u53f7\u51e6\u7406","text":"<pre><code># \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3092\u9069\u7528\uff081kHz\u4ee5\u4e0b\u306e\u5468\u6ce2\u6570\u3092\u901a\u904e\uff09\nfiltered = audio.low_pass_filter(cutoff=1000)\n\n# \u7d50\u679c\u3092\u53ef\u8996\u5316\u3057\u3066\u6bd4\u8f03\nfiltered.previous.plot(title=\"Original\")\nfiltered.plot(title=\"filtered\")\n</code></pre> 2025-05-20T17:59:47.076614 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/ 2025-05-20T17:59:47.808131 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/"},{"location":"tutorial/#_4","title":"\u6b21\u306e\u30b9\u30c6\u30c3\u30d7","text":"<ul> <li>API\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9 \u3067\u8a73\u7d30\u306a\u6a5f\u80fd\u3092\u8abf\u3079\u308b</li> <li>\u7406\u8ad6\u80cc\u666f \u3067\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u8a2d\u8a08\u601d\u60f3\u3092\u7406\u89e3\u3059\u308b</li> </ul>"},{"location":"tutorial/#_5","title":"\u30e6\u30fc\u30b9\u30b1\u30fc\u30b9\u5225\u30ec\u30b7\u30d4","text":"<p>\u3053\u306e\u30bb\u30af\u30b7\u30e7\u30f3\u3067\u306f\u3001Wandas\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u3088\u308a\u8a73\u7d30\u306a\u6a5f\u80fd\u3084\u5fdc\u7528\u4f8b\u3092\u3001\u4ee5\u4e0b\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30ce\u30fc\u30c8\u30d6\u30c3\u30af\u3092\u901a\u3058\u3066\u5b66\u3076\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002</p> <ul> <li>00_setup.ipynb: \u30bb\u30c3\u30c8\u30a2\u30c3\u30d7\u3068\u57fa\u672c\u7684\u306a\u8a2d\u5b9a</li> <li>01_io_basics.ipynb: \u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u66f8\u304d\u3068\u57fa\u672c\u7684\u306a\u64cd\u4f5c</li> <li>02_signal_processing_basics.ipynb:\u57fa\u672c\u7684\u306a\u4fe1\u53f7\u51e6\u7406</li> <li>03_visualization.ipynb: \u30c7\u30fc\u30bf\u306e\u53ef\u8996\u5316</li> <li>04_time_frequency.ipynb: \u6642\u9593\u5468\u6ce2\u6570\u5206\u6790</li> <li>05_lazy_and_dask.ipynb: \u9045\u5ef6\u8a55\u4fa1\u3068Dask\u306b\u3088\u308b\u5927\u898f\u6a21\u30c7\u30fc\u30bf\u51e6\u7406</li> <li>06_metadata_history.ipynb: \u30e1\u30bf\u30c7\u30fc\u30bf\u3068\u51e6\u7406\u5c65\u6b74\u306e\u6d3b\u7528</li> <li>07_batch_processing.ipynb: \u8907\u6570\u30d5\u30a1\u30a4\u30eb\u3078\u306e\u4e00\u62ec\u51e6\u7406</li> <li>08_extending_api.ipynb: \u30ab\u30b9\u30bf\u30e0\u95a2\u6570\u306e\u8ffd\u52a0\u3068API\u306e\u62e1\u5f35</li> <li>08_interoperability.ipynb: \u4ed6\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u3068\u306e\u9023\u643a</li> <li>09_case_studies.ipynb: \u5b9f\u8df5\u7684\u306a\u30e6\u30fc\u30b9\u30b1\u30fc\u30b9\u30b9\u30bf\u30c7\u30a3</li> </ul> <p>\u30d2\u30f3\u30c8</p> <p>\u5404\u30ce\u30fc\u30c8\u30d6\u30c3\u30af\u306f\u7279\u5b9a\u306e\u30c8\u30d4\u30c3\u30af\u306b\u7126\u70b9\u3092\u5f53\u3066\u3066\u3044\u307e\u3059\u3002\u8208\u5473\u306e\u3042\u308b\u3082\u306e\u304b\u3089\u9806\u306b\u3001\u307e\u305f\u306f\u5fc5\u8981\u306b\u5fdc\u3058\u3066\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002Wandas\u306e\u57fa\u672c\u7684\u306a\u4f7f\u3044\u65b9\u306b\u3064\u3044\u3066\u306f\u3001\u3053\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u306e\u5192\u982d\u90e8\u5206\u3082\u5408\u308f\u305b\u3066\u3054\u89a7\u304f\u3060\u3055\u3044\u3002</p>"},{"location":"en/","title":"Wandas: Waveform Analysis Data Structures","text":"<p>Wandas is an open-source library for efficient signal analysis in Python. Wandas provides comprehensive functionality for signal processing and seamless integration with Matplotlib.</p>"},{"location":"en/#features","title":"Features","text":"<ul> <li>Comprehensive Signal Processing Functions: Easily perform basic signal processing operations including filtering, Fourier transforms, and STFT</li> <li>Integration with Visualization Libraries: Seamlessly integrate with Matplotlib for easy data visualization</li> <li>Lazy Evaluation: Efficiently process large data using dask</li> <li>Various Analysis Tools: Frequency analysis, octave band analysis, time-frequency analysis, and more</li> </ul>"},{"location":"en/#usage-examples","title":"Usage Examples","text":""},{"location":"en/#loading-and-visualizing-audio-files","title":"Loading and Visualizing Audio Files","text":"<pre><code>import wandas as wd\n\ncf = wd.read_wav(\"data/sample.wav\")\ncf.describe()\n</code></pre>"},{"location":"en/#filtering","title":"Filtering","text":"<pre><code>signal = wd.generate_sin(freqs=[5000, 1000], duration=1)\n# Apply low pass filter\nsignal.low_pass_filter(cutoff=1000).fft().plot()\n</code></pre> <p>For detailed documentation and usage examples, see the Tutorial.</p>"},{"location":"en/#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Tutorial - 5-minute getting started guide and recipe collection for common tasks</li> <li>API Reference - Detailed API specifications</li> <li>Theory &amp; Architecture - Design philosophy and algorithm explanations</li> <li>Contributing Guide - Rules and methods for contribution</li> </ul>"},{"location":"en/#next-steps","title":"Next Steps","text":"<ul> <li>Explore detailed features in the API Reference</li> <li>Understand the library's design philosophy in the Explanation</li> <li>See Contributing Guidelines if you want to contribute.</li> </ul>"},{"location":"en/#for-more-information","title":"For More Information","text":"<ul> <li>Visit the Wandas GitHub Repository for source code and issues</li> <li>Check the Wandas Documentation for hosted documentation</li> <li>Join the Wandas Discussion Forum for community support and discussions</li> </ul>"},{"location":"en/api/","title":"API Reference","text":"<p>API reference for the main components and functions of the Wandas library.</p>"},{"location":"en/api/#core-module","title":"Core Module","text":"<p>The core module provides the basic functionality of Wandas.</p>"},{"location":"en/api/#frames-module","title":"Frames Module","text":"<p>The frames module defines different types of data frames.</p>"},{"location":"en/api/#processing-module","title":"Processing Module","text":"<p>The processing module provides various processing functions for audio data.</p>"},{"location":"en/api/#io-module","title":"IO Module","text":"<p>The IO module provides file reading and writing functions.</p>"},{"location":"en/api/#utilities-module","title":"Utilities Module","text":"<p>The utilities module provides auxiliary functions.</p>"},{"location":"en/api/#visualization-module","title":"Visualization Module","text":"<p>The visualization module provides data visualization functions.</p>"},{"location":"en/api/#datasets-module","title":"Datasets Module","text":"<p>The datasets module provides sample data and dataset functions.</p>"},{"location":"en/api/core/","title":"Core Module","text":"<p>The <code>wandas.core</code> module provides the foundation components of the Wandas library.</p>"},{"location":"en/api/core/#baseframe","title":"BaseFrame","text":"<p>BaseFrame is the base class for all Wandas frames. It defines the basic data structure and operations.</p>"},{"location":"en/api/core/#channelmetadata","title":"ChannelMetadata","text":"<p>The ChannelMetadata class manages metadata related to audio channels.</p>"},{"location":"en/api/datasets/","title":"Datasets Module","text":"<p>The <code>wandas.datasets</code> module provides sample data that can be used for testing and demonstrations.</p>"},{"location":"en/api/datasets/#sample-data","title":"Sample Data","text":"<p>Provides sample audio data that can be used for testing and demonstrations.</p>"},{"location":"en/api/frames/","title":"Frames Module","text":"<p>The <code>wandas.frames</code> module provides various data frame classes for manipulating and representing audio data.</p>"},{"location":"en/api/frames/#channelframe","title":"ChannelFrame","text":"<p>ChannelFrame is the basic frame for handling time-domain waveform data.</p>"},{"location":"en/api/frames/#spectralframe","title":"SpectralFrame","text":"<p>SpectralFrame is a frame for handling frequency-domain data.</p>"},{"location":"en/api/frames/#spectrogramframe","title":"SpectrogramFrame","text":"<p>SpectrogramFrame is a frame for handling time-frequency domain (spectrogram) data.</p>"},{"location":"en/api/frames/#noctframe","title":"NOctFrame","text":"<p>NOctFrame is a frame class for octave-band analysis.</p>"},{"location":"en/api/frames/#mixins","title":"Mixins","text":"<p>Mixins for extending frame functionality.</p>"},{"location":"en/api/io/","title":"IO Module","text":"<p>The <code>wandas.io</code> module provides reading and writing capabilities for various file formats.</p>"},{"location":"en/api/io/#file-readers","title":"File Readers","text":"<p>Provides functionality to read data from various file formats.</p>"},{"location":"en/api/io/#wav-file-io","title":"WAV File IO","text":"<p>Provides functions for reading and writing WAV files.</p>"},{"location":"en/api/io/#wdf-file-io","title":"WDF File IO","text":"<p>Provides functions for reading and writing WDF (Wandas Data File) format, which enables complete preservation including metadata.</p>"},{"location":"en/api/processing/","title":"Processing Module","text":"<p>The <code>wandas.processing</code> module provides various processing capabilities for audio data.</p>"},{"location":"en/api/processing/#base-processing","title":"Base Processing","text":"<p>Provides basic processing operations.</p>"},{"location":"en/api/processing/#effects","title":"Effects","text":"<p>Provides audio effect processing.</p>"},{"location":"en/api/processing/#filters","title":"Filters","text":"<p>Provides various audio filter processing.</p>"},{"location":"en/api/processing/#spectral-processing","title":"Spectral Processing","text":"<p>Provides spectral analysis and processing capabilities.</p>"},{"location":"en/api/processing/#statistical-processing","title":"Statistical Processing","text":"<p>Provides statistical analysis functions for audio data.</p>"},{"location":"en/api/processing/#temporal-processing","title":"Temporal Processing","text":"<p>Provides time-domain processing capabilities.</p>"},{"location":"en/api/utils/","title":"Utilities Module","text":"<p>The <code>wandas.utils</code> module provides various utility functions used in the Wandas library.</p>"},{"location":"en/api/utils/#frame-dataset","title":"Frame Dataset","text":"<p>Provides dataset utilities for managing multiple data frames.</p>"},{"location":"en/api/utils/#sample-generation","title":"Sample Generation","text":"<p>Provides functions for generating sample data for testing.</p>"},{"location":"en/api/utils/#type-definitions","title":"Type Definitions","text":"<p>Provides type definitions used in Wandas.</p>"},{"location":"en/api/utils/#general-utilities","title":"General Utilities","text":"<p>Provides other general utility functions.</p>"},{"location":"en/api/visualization/","title":"Visualization Module","text":"<p>The <code>wandas.visualization</code> module provides functionality for visually representing audio data.</p>"},{"location":"en/api/visualization/#plotting","title":"Plotting","text":"<p>Provides plotting functions for visualizing audio data.</p>"},{"location":"en/api/wdf_io/","title":"WDF File I/O","text":"<p>The <code>wandas.io.wdf_io</code> module provides functionality for saving and loading <code>ChannelFrame</code> objects in the WDF (Wandas Data File) format. The WDF format is based on HDF5 and preserves not only the data but also all metadata such as sampling rate, units, and channel labels.</p>"},{"location":"en/api/wdf_io/#wdf-format-overview","title":"WDF Format Overview","text":"<p>The WDF format has the following features:</p> <ul> <li>HDF5-based hierarchical data structure</li> <li>Complete preservation of channel data and metadata</li> <li>Size optimization through data compression and chunking</li> <li>Version management for future extensions</li> </ul> <p>File structure:</p> <pre><code>/meta           : Frame-level metadata (JSON format)\n/channels/{i}   : Individual channel data and metadata\n    \u251c\u2500 data           : Waveform data (numpy array)\n    \u2514\u2500 attrs          : Channel attributes (labels, units, etc.)\n</code></pre>"},{"location":"en/api/wdf_io/#saving-wdf-files","title":"Saving WDF Files","text":""},{"location":"en/api/wdf_io/#loading-wdf-files","title":"Loading WDF Files","text":""},{"location":"en/api/wdf_io/#usage-examples","title":"Usage Examples","text":"<pre><code># Save a ChannelFrame in WDF format\ncf = wd.read_wav(\"audio.wav\")\ncf.save(\"audio_data.wdf\")\n\n# Specifying options when saving\ncf.save(\n    \"high_quality.wdf\",\n    compress=\"gzip\",  # Compression method\n    dtype=\"float64\",  # Data type\n    overwrite=True    # Allow overwriting\n)\n\n# Load a ChannelFrame from a WDF file\ncf2 = wd.ChannelFrame.load(\"audio_data.wdf\")\n</code></pre> <p>For detailed usage examples, see the File I/O Guide.</p>"},{"location":"en/explanation/","title":"Theory Background and Architecture","text":"<p>This section explains the design philosophy, internal architecture, and theoretical background used in the Wandas library.</p>"},{"location":"en/explanation/#design-philosophy","title":"Design Philosophy","text":"<p>Wandas is developed based on the following design principles:</p> <ol> <li>Intuitive API Design - Consistent interface that users can easily use</li> <li>Efficient Memory Usage - Memory-efficient implementation suitable for processing large-scale data</li> <li>Extensibility - Expandable architecture that makes it easy to add new features and algorithms</li> <li>Scientific Accuracy - Accurate implementation based on acoustic signal processing theory</li> </ol>"},{"location":"en/explanation/#core-architecture","title":"Core Architecture","text":""},{"location":"en/explanation/#data-model","title":"Data Model","text":"<p>The central data model of the Wandas library is hierarchically structured:</p> <pre><code>BaseChannel (base class)\n \u251c\u2500\u2500 Channel (time-domain signal)\n \u2502    \u2514\u2500\u2500 FrequencyChannel (frequency-domain signal)\n \u2502         \u2514\u2500\u2500 TimeFrequencyChannel (time-frequency domain signal)\n \u2514\u2500\u2500 ChannelFrame (container for multiple channels)\n      \u251c\u2500\u2500 FileFrame (file-based multiple channels)\n      \u2514\u2500\u2500 FrequencyChannelFrame (multiple channels in frequency domain)\n</code></pre> <p>Responsibilities of each class:</p> <ul> <li>BaseChannel: Base class for all channels. Provides basic functionality for data access and metadata management</li> <li>Channel: Implements time-domain signal data and processing methods</li> <li>FrequencyChannel: Implements FFT-based frequency-domain data and processing</li> <li>TimeFrequencyChannel: Implements time-frequency domain representations such as Short-Time Fourier Transform (STFT)</li> <li>ChannelFrame: Manages multiple channels and enables batch processing</li> </ul>"},{"location":"en/explanation/#data-processing-flow","title":"Data Processing Flow","text":"<ol> <li>Input Stage: Generate <code>Channel</code> or <code>ChannelFrame</code> objects from files such as WAV and CSV</li> <li>Processing Stage: Apply processing such as filtering and resampling</li> <li>Analysis Stage: Analyze signal characteristics (spectrum, level, etc.)</li> <li>Output Stage: Save processing results to files or visualize as graphs</li> </ol>"},{"location":"en/explanation/#implementation-details","title":"Implementation Details","text":""},{"location":"en/explanation/#memory-efficiency","title":"Memory Efficiency","text":"<p>Wandas ensures memory efficiency for handling large audio data through the following methods:</p> <ul> <li>Lazy Evaluation: A mechanism that delays calculations until needed</li> <li>Memory Mapping: Access to large files without loading them entirely into memory</li> <li>Dask and H5PY: Utilizing libraries suitable for large-scale data processing</li> </ul>"},{"location":"en/explanation/#signal-processing-algorithms","title":"Signal Processing Algorithms","text":"<p>Wandas implements signal processing algorithms such as:</p> <ul> <li>Digital Filters: IIR/FIR filters such as Butterworth filters</li> <li>Spectral Analysis: Frequency analysis based on Fast Fourier Transform (FFT)</li> <li>Time-Frequency Analysis: Short-Time Fourier Transform (STFT), spectrograms</li> <li>Statistical Analysis: Calculation of signal characteristics such as RMS, peak values, crest factor</li> </ul>"},{"location":"en/explanation/#performance-considerations","title":"Performance Considerations","text":"<p>Performance considerations when using Wandas:</p> <ul> <li>When processing large amounts of data, consider processing in chunks</li> <li>When building complex processing chains, improve performance by caching intermediate results</li> <li>Multi-channel processing efficiently utilizes multi-core processors</li> </ul>"},{"location":"en/explanation/#references","title":"References","text":"<ol> <li>Smith, J. O. (2011). Spectral Audio Signal Processing. W3K Publishing.</li> <li>M\u00fcller, M. (2015). Fundamentals of Music Processing: Audio, Analysis, Algorithms, Applications. Springer.</li> <li>Z\u00f6lzer, U. (2008). Digital Audio Signal Processing. Wiley.</li> </ol>"},{"location":"en/tutorial/","title":"Tutorial","text":"<p>This tutorial will teach you the basics of the Wandas library in 5 minutes.</p>"},{"location":"en/tutorial/#installation","title":"Installation","text":"<pre><code>pip install git+https://github.com/endolith/waveform-analysis.git@master\npip install wandas\n</code></pre>"},{"location":"en/tutorial/#basic-usage","title":"Basic Usage","text":""},{"location":"en/tutorial/#1-import-the-library","title":"1. Import the Library","text":"<pre><code>import wandas as wd\n</code></pre>"},{"location":"en/tutorial/#2-load-audio-files","title":"2. Load Audio Files","text":"<pre><code># Load a WAV file\nurl = \"https://github.com/kasahart/wandas/raw/main/examples/data/summer_streets1.wav\"\n\naudio = wd.read_wav(url)\nprint(f\"Sampling rate: {audio.sampling_rate} Hz\")\nprint(f\"Number of channels: {len(audio)}\")\nprint(f\"Duration: {audio.duration} s\")\n</code></pre> <p>Sampling rate: 44100 Hz Number of channels: 2 Duration: 15.0 s  </p>"},{"location":"en/tutorial/#3-visualize-signals","title":"3. Visualize Signals","text":"<pre><code># Display waveform\naudio.describe()\n</code></pre> 2025-05-20T17:59:59.304604 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/"},{"location":"en/tutorial/#4-basic-signal-processing","title":"4. Basic Signal Processing","text":"<pre><code># Apply a low-pass filter (passing frequencies below 1kHz)\nfiltered = audio.low_pass_filter(cutoff=1000)\n\n# Visualize and compare results\nfiltered.previous.plot(title=\"Original\")\nfiltered.plot(title=\"filtered\")\n</code></pre> 2025-05-20T18:00:00.514292 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/ 2025-05-20T18:00:01.167465 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/"},{"location":"en/tutorial/#next-steps","title":"Next Steps","text":"<ul> <li>Check out various applications in the Cookbook</li> <li>Look up detailed functions in the API Reference</li> <li>Understand the library's design philosophy in the Theory Background</li> </ul>"},{"location":"en/tutorial/#recipes-by-use-case","title":"Recipes by Use Case","text":"<p>This section provides links to tutorial notebooks that demonstrate more detailed features and application examples of the Wandas library.</p> <ul> <li>00_setup.ipynb: Setup and basic configuration</li> <li>01_io_basics.ipynb: File reading/writing and basic operations</li> <li>02_signal_processing_basics.ipynb: Basic signal processing</li> <li>03_visualization.ipynb: Data visualization</li> <li>04_time_frequency.ipynb: Time-frequency analysis</li> <li>05_lazy_and_dask.ipynb: Lazy evaluation and large-scale data processing with Dask</li> <li>06_metadata_history.ipynb: Utilizing metadata and processing history</li> <li>07_batch_processing.ipynb: Batch processing for multiple files</li> <li>08_extending_api.ipynb: Adding custom functions and extending the API</li> <li>08_interoperability.ipynb: Integration with other libraries</li> <li>09_case_studies.ipynb: Practical use case studies</li> </ul> <p>Hint</p> <p>Each notebook focuses on a specific topic. Refer to them sequentially or as needed based on your interests. For basic usage of Wandas, please also see the \"Basic Usage\" section at the beginning of this document.</p>"}]}